---
categories: ["SQL engine"]
tags: ["SQL parser"]
title: "03.统计计数"
# linkTitle: ""
weight: 10
description: >

---



# 背景

统计计数是一个非常常见场景。除了通常的计数，统计不重复元素个数的需求也非常常见，这种统计称为**基数统计**。分布式SQL引擎，计数的实现原理值得深入研究，特别是基数统计。关于普通计数和基数计数，最典型的例子莫过于PV/UV。

# 主要方法

在SQL语法里面，基数统计对应到count(distinct  field)或者aprox_distinct()。通常做精确计数统计需要用到Set这种数据结构。Set不仅可以获得数量信息，还能不重不漏地获取每一个元素。

Set内部有两种实现实现原理：Hash和Tree。

在海量数据的前提下，Hash和Tree有一个致命的问题：内存消耗，而且随着数据量级的增长，内存消耗也是线性增长。

面对Set内存消耗的问题，通常有两种思路：

* 选取其他内存占用更小的数据结构，例如bitmap；
* 放弃精确，从数学上寻求近似解，典型的算法有Linear Count和HyperLogLog。
## Bitmap

在数据库领域Bitmap并不是新事物，一般用作索引，称为位图索引。所谓位图索引，就是用一个bit位向量来记录某个字段值是否存在于对应的记录。它有一个前置条件：记录要有永久的编号，类似于从1开始的自增主键。

### 位图向量的构建

对于数据表的一个字段，如果记录数为n且字段的取值基数为m，那么会得到一个m*n的位图。

多个字段即得到多个这样的位图。

### 位图向量的应用

单个条件：

直接取该字段m*n的位图，统计其中 1 的个数。

多个条件：

取对应多个字段的位图，多个向量进行交集运算，然后统计 1 的个数。

### 优缺点

优点：

* 节省内存（数据分布密集压缩空间更大）
* 二进制位操作，执行效率高
缺点：

* 非数值型字段，需要额外转换处理
## Linear Count

Linear Count简称LC算法（利用数学的概率和统计学知识）。 

算法描述如下：

* 初始化：给定m个房间，房间存储数字，初始化为0。
* 迭代执行：对于要进行基数统计的集合，用一个哈希函数处理集合中的每一个元素。通过哈希函数处理后，元素就可以放置到一个房间中。
* 收尾：统计m个房间中空房间的数量U。
* 结论：集合中不重复元素的个数估计值可以通过如下公式计算：n=-m*log(U/m)。
随着m和n的增大，m大约为n的十分之一。

## HyperLogLog

HyperLogLog简称HLL算法，它有如下的特点：

1. 可以实现由极小的内存开销统计出巨量的数据。在 Redis中实现的HyperLogLog，只需要12K内存就能统计2^64个数据。
2. 可以方便实现分布式扩展。(对算法在业务系统中落地非常关键)
## 基础理论

### 伯努利实验

如抛硬币，随着次数地增多，对应的值也就越趋近一个值。这样将统计问题转换成概率论中参数估计的问题。

### 调和平均数

概率中的极值问题导致最后得到的值不稳定。对于极值的处理策略是多实验几轮，通过平均值来消除极值的影响。

数学上其实有许多的平均数计算方式：算术平均数、几何平均数、平方平均数。选用调和平均数主要是消除极值的影响。

# 核心流程

MapReduce的核心流程：

* Input
* Splitting
* Mapping
* Shuffling
* Reducing
* Final result
Presto核心流程也是类似的，先分组聚合，然后汇总聚合。

# 方案实现

## **count distinct**

以id为主key, 对数据进行hash分发，进行部分聚合，最终整体聚合。依然是map-reduce的思路，只不过数据按id进行了分发。

## **aprox_distinct**

免去了基于id的hash分发策略，减少了一个stage。以Presto为例，基础框架airlift中封装了HyperLogLog算法的实现，采用的函数是MurMurHash3算法，生成64位散列值。前6位用于计算当前散列值所在分组m。实现过程中还有一个很有意思的细节：基于待统计的数据量，实现中同时采用了Linear Count算法和HyperLogLog算法。

# 小结

基数统计是一个非常消耗内存的操作，特别是在分布式系统背景下，不仅消耗内存，而且涉及大量网络数据传输。

分析对应的业务场景，如果可以提供近似值而非精确值，能大幅度降低系统消耗和响应时间，提升用户体验。或者在设计产品时，对于一些场景的计数，可以优先提供近似估计，如果确实需要精确计数，在管理好响应时间预期下，再提供查询精确值的接口。

