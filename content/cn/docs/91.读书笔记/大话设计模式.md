---
categories: [""] 
tags: [""] 
title: "大话设计模式"
# linkTitle: ""
weight: 5
description: >
  
---

2019-11-05 

# 第一章：简单工厂模式 

加减乘除实现计算接口，计算接口有两个属性，一个计算方法。工厂类case判断计算类型，实例化出具体的实现类。 

UML类图 

1、矩形代表一个类，类图分三层，第一层：类的名称（抽象类使用斜体）；第二层：类的特性（字段和属性）；第三层：类的操作（方法或行为）。“+”表示public，“-”表示private，“#”表示protected。 

2、接口，与类的区别主要是顶端有<<interface>>显示，第一层：接口名称；第二层：接口方法。（棒棒糖表示法：圆圈旁为接口方法）。 

3、继承关系，空心三角形+实线。 

4、实现接口关系，空心三角形+虚线。 

5、关联关系，实线箭头。当一个类“知道”另一个类时，可以用关联（association）。如“企鹅”关联“气候”。 

6、聚合关系，空心的菱形+实线箭头。表示一种弱的“拥有”关系，提现的是A对象可以包含B对象，但B对象不是A对象的一部分，如“雁群”与“大雁”。 

7、合成（组合）关系，实心的菱形+实线箭头。合成（composition）是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。如“鸟”与“翅膀”。 

8、依赖关系，虚线箭头。如“动物”与“氧气”、“动物”与“水”。 

# 第二章：商场促销——策略模式 

“面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类”——不要滥用子类！ 

策略模式——将不同类型算法分别封装起来，可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。 

Context，维护对Strategy对象的引用。抽象算法类：正常算法A；打折算法B；满减算法B。 

```java
//简单工厂模式
CashSuper cashSpuer = CashFactory.createCashAccept(item.toString());
… = cashSpuer.getResult();
 
//策略模式
CashContext cashContext = new CashContext(new CashXXX(,,));
… = cashContext.getResult(,);
 
//策略模式与简单工厂结合的方法
CashContext cashContext = new CashContext(item.toString());
… = cashContext.getResult(,); 
```
简单工厂需要让客户端认识两个类CashSuper和CashFactory，而策略模式与简单工厂结合的用法，客户端只需要认识一个雷CashContext就可以。耦合更加降低。 
优点：简化了单元测试。 

2019-11-06 

# 第三章：拍摄UFO——单一职责原则 

 

# 第四章：考研求职两不误——开放-封闭原则 

开放-封闭原则：软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。 

# 第五章：会修电脑不会修收音机？——依赖倒转原则 

依赖倒转原则： 

A. 高层模块不应该依赖底层模块 

B. 抽象不应该依赖细节。细节应该依赖抽象。 

里氏代换原则——子类型必须能够替换掉它们的父类型。 

“只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。” 

# 第六章：穿什么有这么重要？——装饰模式 

装饰模式——动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。 

# 第七章：为别人做嫁衣——代理模式 

# 第八章：雷锋依然在人间——工厂方法模式 

工厂方法模式（Factory Method）——定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 

简单工厂违背了“开放——封闭原则” 

```java
//简单工厂模式
LeiFeng studentA = SimpleFactory.createLeiFeng(“学雷锋的大学生”);
studentA.buyRice();
LeiFeng studentB = SimpleFactory.createLeiFeng(“学雷锋的大学生”);
studentB.sweep();
LeiFeng studentC = SimpleFactory.createLeiFeng(“学雷锋的大学生”);
studentC.wash();
 
 
// 工厂方法模式
IFactory factory = new UndergraduateFactory();
Leifeng student = factory.createLeifeng();
 
student.BuyRice();
student.Sweep();
student.Wash(); 
```


2019-11-08 

# 第九章：简历复印——原型模式 

浅复制与深复制 

# 第十章：考题抄错会做也白搭——模板方法模式 

模板方法——当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。 

# 第十一章：无熟人难办事？——迪米特法则 

迪米特法则——也叫最少知识原则。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某个方法的话，可以通过第三者转发这个调用。 

# 第十二章：牛市股票还会亏钱？——外观模式（Facade） 

外观模式——为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 

# 第十三章：好菜每回味不同——建造者模式 

# 第十四章：老板回来，我不知道——观察者模式 

# 第十五章：就不能不换DB吗？——抽象工厂模式 

抽象工厂模式（Abstract Factory）——提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。 

抽象工厂需要更改的工厂类太多，简单工厂switch case太多，反射加抽象工厂的数据访问程序。 

# 第十六章：无尽加班何时休——状态模式 

状态模式（State）——当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。 

“状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。” 

状态模式好处与用处 

“装填模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。” 

“将特定状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。” 

“状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖。” 

“当一个对象的行为取决于他的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。” 

# 第十七章：在NBA中我需要翻译——适配器模式 

适配器模式——将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 

# 第十八章：备忘录模式 

备忘录（Memento）——在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 

# 第十九章：分公司=一部门——组合模式 

# 第二十章：想走？可以！先买票——迭代器模式 

迭代器模式（Iterator）——提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。 

# 第二十一章：有些类也需计划生育——单例模式 

# 第二十二章：手机软件何时统一——桥接模式 

合成/聚合复用原则——尽量使用合成/聚合，尽量不要使用类继承。 

桥接模式——将抽象部分与它的实现部分分离，使它们都可以独立地变化。 

“手机品牌”与“手机软件”是弱的聚合关系，像一座桥。 

# 第二十三章：烤羊肉串引来的思考——命令模式 

# 第二十四章：加薪非要老总批？——职责链模式 

职责链模式——使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 

# 第二十五章：世界需要和平——中介者模式 

中介者模式（Mediator）——用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 

# 第二十六章：项目多也别傻做——享元模式 

享元模式（Flyweight）——运用共享技术有效地支持大量细粒度的对象。 

# 第二十七章：其实你不懂老板的心——解释器模式 

解释器模式——给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 

# 第二十八章：男人和女人——访问者模式 

访问者模式（Visitor）——表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 
