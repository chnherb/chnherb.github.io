---
categories: ["distributed"] 
tags: ["lock"] 
title: "分布式锁实现及方案比较"
# linkTitle: ""
weight: 10
description: >

---

# 背景

单机中可以利用语言自身提供的能力或者借助第三方包来实现对资源的安全并发访问。随着微服务的流行，各种服务都慢慢演变成了分布式架构，部署在不同机器上。这样会使得一些资源在共享上也需要保证安全性问题，需要用到特殊的锁——分布式锁。

# 实现方案

## 数据库方案

### **数据表简单分布式锁**

基于数据库来实现分布式锁需要依赖一张数据表，表结构如下：

```sql
CREATE TABLE `methodLock` (
`id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'Primary Key',
`method_name` varchar(64) NOT NULL DEFAULT '' COMMENT 'Locked Method Name',
`desc` varchar(1024) NOT NULL DEFAULT 'Note Information',
`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'save data time, automatic generation',
PRIMARY KEY (`id`),
UNIQUE KEY `uidx_method_name`(`method_name`) USING BTREE) ENGINE = InnoDB DEFAULT CHARSET = utf8 COMMENT='method in lock';
```
对方法“method_A”添加锁时，可以采用下面的SQL语句往上表中插入一条记录
```sql
insert into methodLock(method_name,desc) values (‘method_A',‘desc')
```
因为数据表在method_name字段上创建了唯一索引，如果同时有多个插入请求提交，数据库会保证只会有一条记录插入成功。这样就可以认为插入记录成功的这个线程获取到了分布式锁，它可以执行后续的方法逻辑。
当方法执行完成后，需要执行下面的SQL语句来释放锁

```sql
delete from methodLock where method_name ='method_A'
```
上面利用数据库表简单实现了分布式锁的获取和释放，但是其存在多方面的问题：
* **对数据库是强依赖，存在单点问题，一旦数据库挂起，业务系统将不可用**
* **没有失效时间，一旦释放锁操作失败，将会一直持有锁，导致其他线程无法获取到锁**
* **非阻塞式，因为插入操作一旦失败数据库会直接返回错误信息，线程未获取到锁也不会进入等待重试队列，要再次获取锁，需要再次触发插入操作**
* **非可重入锁，同一线程在未释放锁前无法再次获取该锁，因为数据表中的数据已经存在了**
* **非公平锁，所有等待锁的线程会同时争抢锁，最终谁能够获取到锁，就要看谁比较幸运数据能够插入成功**
当然，上述几个问题也有相应的解决方案

* **数据库单点？可以建立数据库集群，在集群间进行数据同步，一旦主库挂掉，可以快速切到备库，保证分布式锁服务可用**
* **没有失效时间？只需要额外建立一个定时任务，定时清理超时数据**
* **非阻塞？可以通过while循环，在代码中添加重试逻辑，直到获取锁成功**
* **不可重入？在数据库中添加一个字段，记录当前获取到锁的主机和线程信息，下一次在获取锁前，先查询这个字段的信息，如果与当前获取锁的线程信息一致，则可以直接为该线程返回锁**
* **不公平？我们可以创建一张中间表来记录所有获取锁的线程，这张表就充当了队列的作用，按照插入时间排序，只有排在第一位的线程有机会获取锁**
### **数据库排他锁分布式锁**

除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式锁。

仍然借助上面创建的数据表，在MySQL数据库的InnoDB引擎模式下，可以通过下面的方法来实现分布式锁操作，伪代码如下：

```java
public boolean lock(){
  connection.setAutoCommit(false);
  while(true){
    try{
      result = select * from methodLock where method_name=xxx for update;
      if(result==null){
        return true;
      }
    }catch(Exception e){
    }
    sleep(1000);
  }
  return false;
}
```
在查询语句后面添加“for update”语句，数据库会在查询过程中向数据库表添加独占锁，其他线程就无法再对这行记录加锁了。
我们可以假定一个线程获取了独占锁就获取了分布式锁，获取到锁以后，就可以执行后续业务逻辑。使用这种方式要注意进行事务的手动管理，在事务提交前执行业务逻辑，执行完成后手动提交事务来释放锁。

```java
public void unlock(){ connection.commit(); }
```
通过上面的这种方式可以高效解决上面提到的解锁和阻塞锁的问题。
针对解锁问题，在获取锁以后，如果服务突然宕机，不用担心锁不会释放，数据库连接会在在服务宕机后自动断开并释放锁。

针对阻塞问题，采用for update语句，其会保持阻塞状态，在成功执行或者执行失败后立即返回。

上述方案虽然解决了阻塞和解锁问题，但是数据库的单点、可重入、公平锁等问题仍需要进行额外处理。

### **小结**

基于数据库实现分布式锁都依赖于一个数据库表。一种是通过表中记录的存在来确定当前是否存在锁，另一种是通过数据库的排他锁来实现分布式锁。

优点就是简单明了，容易理解；缺点也很明显，为了实现一个功能完善的分布式锁，需要一堆额外的优化措施，使得整个方案变得愈加复杂，同时操作数据库需要一定的开销，性能问题不容忽视。

## redis方案

setnx对应api有诸如setIfAbsent(key)

可能存在死锁，如果处理的线程抛出异常无法释放锁

setnx expire增加超时时间

redis实现分布式锁主要使用setnx这个命令实现，该命令的语义为如果该键不存在就设置该键的值，保证只有一个客户端能设置成功。

### **实现1**

加锁：

```shell
setnx key value；
expire key expireTime;
```
解锁：
```shell
delete key
```
问题：setnx执行成功，而expire失败后机器宕机，会导致锁永远无法被释放。该方案基本不会被使用。
### **实现2**

redis从2.6.12版本开始，SET命令开始支持超时参数，并且保证整个操作是原子的。

加锁:

```shell
SET key value NX PX expireMillSeconds
```
解锁:
```shell
delete key
```
问题:
1、持有锁的线程挂掉后，其他线程必须等待锁超时失效后才能重新争抢；

2、不能保证删除锁的线程是锁的拥有者。

### **实现3**

加锁:

```java
public boolean tryLock(){
  if (SET key expireTime NX PX expireMillSeconds 是否成功) {
    return true;
  } else {
    Date expireTime = get(key);
    if (expireTime < currentTime) {
      cas (key,expireTime,currentExpireTime 是否成功) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
}
```
解锁:
```shell
delete key
```
问题:不能保证删除锁的线程是锁的拥有者。
### **实现4（防盗抢）**

加锁:

```shell
SET key value NX PX expireMillSeconds
```
value设置为一个独特的token。
解锁:

```shell
compareAndDelete(key, token)
```
### **小结**

redis实现的原理是通过一致性哈希将不同key的散列到不同的机器进行处理，最终也是由master处理写。

redis实现的分布式锁性能最优，缺点是超时时间的设定比较困难。

如果需要保证只有锁的持有者才能释放锁，建议使用方案实现4，否则使用方案实现3，实现3可以减少锁持有者宕机后其他线程的等待时间。

## redisson方案

### 背景

redis实现分布式锁存在的问题, 为了解决redis单点问题, 我们会部署redis集群, 在Sentinel集群中, 主节点突然挂掉了。同时主节点中有把锁还没有来得及同步到从节点。这样就会导致系统中同样一把锁被两个客户端同时持有, 不安全性由此产生。redis官方为了解决这个问题, 推出了Redlock算法解决这个问题。但是带来的网络消耗较大。

### 简介

Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。

### 实现

分布式锁的redisson实现: 

```xml
<dependency> 
  <groupId>org.redisson</groupId> 
  <artifactId>redisson</artifactId> 
  <version>3.6.5</version> 
</dependency>
```

获取锁释放锁

```java
// 程序化配置
Config config = new config(); 
config.useSingleServer().setAddress(" redis://127.0.0.1:6379").setDatabase(0); 
Redisson redisson= (Redisson)Redisson.create(config); 
RLockmylock = redisson.getLock(key); 
// 获取锁mylock.TockC; …资源操作
// 释放锁mylock.unlock(); 
// 文件方式配置
Config config = Config.fromJSON(new File("config-file.json"));
RedissonClient redisson = Redisson.create(config);
// yaml配置
Config config = Config.fromYAML(new File("config-file.yaml"));
RedissonClient redisson = Redisson.create(config);
```
集群模式
```java
Config config = new Config();
config.useClusterServers()
   .setScanInterval(2000) // 集群状态扫描间隔时间，单位是毫秒
   //可以用"rediss://"来启用SSL连接
   .addNodeAddress("redis://127.0.0.1:7000", "redis://127.0.0.1:7001")
   .addNodeAddress("redis://127.0.0.1:7002");
	
RedissonClient redisson = Redisson.create(config);
```

主从模式

```java
Config config = new Config();
config.useMasterSlaveServers()
   //可以用"rediss://"来启用SSL连接
   .setMasterAddress("redis://127.0.0.1:6379")
   .addSlaveAddress("redis://127.0.0.1:6389", "redis://127.0.0.1:6332", "redis://127.0.0.1:6419")
   .addSlaveAddress("redis://127.0.0.1:6399");

RedissonClient redisson = Redisson.create(config);
```

使用：

```java
public class RedissonLock {
  private static RedissonClient redissonClient;
  static{
    Config config = new Config();
    config.useSingleServer().setAddress("redis://127.0.0.1:6379").setPassword(null);
    //			config.useSingleServer().setAddress("redis://192.168.188.4:6380").setPassword("ty3foGTrNiKi");
    redissonClient = Redisson.create(config);
  }
  
  public static RedissonClient getRedisson(){
    return redissonClient;
  }
  
  public static void main(String[] args) throws InterruptedException{
  
  	RLock fairLock = getRedisson().getLock("TEST_KEY");
  	System.out.println(fairLock.toString());
  //		fairLock.lock(); 
  	// 尝试加锁，最多等待10秒，上锁以后10秒自动解锁
  	boolean res = fairLock.tryLock(10, 10, TimeUnit.SECONDS);
  	System.out.println(res);
  	fairLock.unlock();
  	
  	//有界阻塞队列
  	RBoundedBlockingQueue<JSONObject> queue = getRedisson().getBoundedBlockingQueue("anyQueue");
  	// 如果初始容量（边界）设定成功则返回`真（true）`，
  	// 如果初始容量（边界）已近存在则返回`假（false）`。
  	System.out.println(queue.trySetCapacity(10));
  	JSONObject o=new JSONObject();
  	o.put("name", 1);
  	if(!queue.contains(o)){
  		queue.offer(o);
  	}
  	
  	JSONObject o2=new JSONObject();
  	o2.put("name", 2);
  	// 此时容量已满，下面代码将会被阻塞，直到有空闲为止。
  	
  	if(!queue.contains(o2)){
  		queue.offer(o2);
  	}
  	
  	//  获取但不移除此队列的头；如果此队列为空，则返回 null。
  	JSONObject obj = queue.peek();
  	//获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。
  	JSONObject ob = queue.poll(10, TimeUnit.MINUTES);                                                    
  	
  	//获取并移除此队列的头，如果此队列为空，则返回 null。
  	 Iterator<JSONObject> iterator=queue.iterator();
  	 while (iterator.hasNext()){
  		  JSONObject i =iterator.next();
  	      System.out.println(i.toJSONString());
  	      iterator.remove();
  	    
  	  }
  		while(queue.size()>0){
  			JSONObject obs = queue.poll();     
  			System.out.println(obs.toJSONString());
  		}
  	
  	JSONObject someObj = queue.poll();
  	System.out.println(someObj.toJSONString());
  }
}
```

## zookeeper方案

### 基础知识

基于ZooKeeper，是使用它的临时有序节点来实现的分布式锁。

节点类型：

1、**持久节点**：创建后一直存在，直到主动删除；

2、**临时节点**：临时节点的生命周期和客户端会话绑定，客户端节点失效后，这个节点会自动被清除；

3、**持久顺序节点**：基本特性和持久节点一致，只是在创建节点时路径名后面增加一个自增的数字后缀；数字后缀的值记录在父节点的一个4bytes的字段中。

4、**临时顺序节点**：基本特性同临时节点，同样节点路径名带有自增数字。

### 实现原理

加锁流程:

1、创建永久节点如 resourcex 代表争抢的资源；

2、所有想获取锁的客户端都到 resourcex 目录下创建临时顺序节点；

3、客户端获取当前目录下所有子节点，判断自己的节点是否位于子节点第一个；

4、如果是第一个，则获取到锁，返回成功；

5、如果不是第一个，则说明前面已经有客户端获取到锁了，那么需要获取自己节点的前一个节点，并监听前一个节点的状态，当监听到前一个节点被删除后返回步骤3。

解锁的流程:

删除当前客户端注册的临时节点即可。

锁超时：

Zookeeper不需要配置锁超时，创建临时节点的客户端维护着一个和服务端的session，服务端通过session判断客户端是否在线，当客户端机器宕机时，服务端会删除对应的临时节点。

### 原生使用

```java
package com.huangbo;
import org.apache.zookeeper.*;
import org.apache.zookeeper.data.Stat;
import java.util.List;
import java.util.TreeSet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
public class ZkLock implements Lock {
    private ZooKeeper zk;
    private String root = "/locks";
    private String lockName;
    // 当前线程创建的序列node
    private ThreadLocal<String> nodeId = new ThreadLocal<String>();
    // 用来同步等待zkclient连接到了服务端
    private CountDownLatch connectedSignal = new CountDownLatch(1);
    private final static int sessionTimeout = 3000;
    private final static byte[] data = new byte[0];
    public ZkLock(String config, String lockName) {
        this.lockName = lockName;
        try {
            zk = new ZooKeeper(config, sessionTimeout, new Watcher() {
                @Override
                public void process(WatchedEvent event) {
                    //建立连接
                    if (event.getState() == Event.KeeperState.SyncConnected) {
                        connectedSignal.countDown();
                    }
                }
            });
            connectedSignal.await();
            Stat stat = zk.exists(root, false);
            if (null == stat) {
                zk.create(root, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    // 添加watch监听临时顺序节点的删除
    class LockWatcher implements Watcher {
        private CountDownLatch latch = null;
        public LockWatcher(CountDownLatch latch) {
            this.latch = latch;
        }
        @Override
        public void process(WatchedEvent event) {
        }
    }
    @Override
    public void lock() {
        try {
            // 创建临时节点
            String myNode = zk.create(root + "/" + lockName, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
            System.out.println(Thread.currentThread().getName() + myNode + "created");
            // 取出所有子节点
            List<String> subNodes = zk.getChildren(root, false);
            TreeSet<String> sortedNodes = new TreeSet<>();
            for (String node : subNodes) {
                sortedNodes.add(root + "/" + node);
            }
            String smallNode = sortedNodes.first();
            if (myNode.equals(smallNode)) {
                // 如果是最小的节点，则表示取得锁
                System.out.println(Thread.currentThread().getName() + myNode + "get lock");
                this.nodeId.set(myNode);
                return;
            }
            String preNode = sortedNodes.lower(myNode);
            CountDownLatch latch = new CountDownLatch(1);
            Stat stat = zk.exists(preNode, new LockWatcher(latch)); // 同时注册监听
            // 判断比自己小一个数的节点是否存在，如果不存在则无需等待锁，同时注册监听
            if (stat != null) {
                System.out.println(Thread.currentThread().getName() + myNode + " waiting for " +
                        root + "/" + preNode + " released lock");
                latch.wait(); // 等待，这里应该一直等待其他线程释放锁
                nodeId.set(myNode);
                latch = null;
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    @Override
    public void lockInterruptibly() throws InterruptedException {
    }
    @Override
    public boolean tryLock() {
        return false;
    }
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return false;
    }
    @Override
    public void unlock() {
        try {
            System.out.println(Thread.currentThread().getName() + "unlock ");
            if (null != nodeId) {
                zk.delete(nodeId.get(), -1);
            }
            nodeId.remove();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (KeeperException e) {
            e.printStackTrace();
        }
    }
    @Override
    public Condition newCondition() {
        return null;
    }
}
```
### **小结**

zk实现的原理主要是ZAB协议控制所有写请求都转发到leader节点执行，以保证新建节点的唯一性。zk实现的分布式锁可用性较高，实现简单，自动锁释放，缺点是创建和删除节点的性能较差。zk分布式锁对于锁的qps和锁数量都有一定的要求，在锁QPS超过100或者锁的数量超过50万，建议不要使用基于ZK的分布式锁，应寻求其他分布式锁方案。

# 方案比较

|    |mysql|redis|redisson|zookeeper|
|:----|:----|:----|:----|:----|
|实现复杂度|复杂|简单|简单|简单|
|性能|3|1|1|2|
|可用性|3|2|2|1|
|可重入性|需要额外增加字段支持|支持|支持|支持|
|锁超时|需要额外增加字段支持|支持，超时后失效|支持，超时后失效|支持，宕机后节点自动失效|

## 总结

1. mysql方案看起来最简单，但实现过程中的细节较多，性能一般，适用于特别简单或者没有其他方案可选的场景，一般不建议使用该方法。
2. redis 性能是最高的，使用场景最多，但可能存在单点问题，要么业务上自己处理，要么使用官方推荐的 RedLock，实际生产中需要注意 redis 多机房带来的锁问题。
3. zookeeper 的性能不如 redis，当 qps 高于 100 或锁数量大于 50 万时建议使用redis（性能数据来源于参考文档）。
# Reference

[https://redis.io/commands/set](https://redis.io/commands/set)

[Apache zookeeper](https://zookeeper.apache.org/doc/r3.1.2/zookeeperOver.html)

[Redis实现分布式锁的正确姿势](https://www.cnblogs.com/zhili/p/redisdistributelock.html)

[小米-分布式锁的实现之redis篇](https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock)

[知乎-基于Redis的分布式锁详解](https://zhuanlan.zhihu.com/p/100140241)

[掘金-基于Redis的分布式锁实现](https://juejin.cn/post/6844903830442737671)

[Redisson 分布式锁实战与watch dog机制解读](https://mp.weixin.qq.com/s/64bYwgsb9h87SLQ-aiPvhA)

