<!doctype html><html lang=zh-cn class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.101.0"><link rel=canonical type=text/html href=/docs/30.%E6%95%B0%E6%8D%AE%E5%BA%93/><link rel=alternate type=application/rss+xml href=/docs/30.%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>数据库 | Herbdocs</title><meta name=description content="Introduction
数据库相关，如MySQL、Redis或其他类型db
"><meta property="og:title" content="数据库"><meta property="og:description" content="Herb's blog"><meta property="og:type" content="website"><meta property="og:url" content="/docs/30.%E6%95%B0%E6%8D%AE%E5%BA%93/"><meta property="og:site_name" content="Herbdocs"><meta itemprop=name content="数据库"><meta itemprop=description content="Herb's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据库"><meta name=twitter:description content="Herb's blog"><link rel=preload href=/scss/main.min.dcab2c3dae6e6fefb7672f19e4b612cc4e75ca208740f642aa2f1fe378478a8f.css as=style><link href=/scss/main.min.dcab2c3dae6e6fefb7672f19e4b612cc4e75ca208740f642aa2f1fe378478a8f.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-00000000-0","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><img width=6% style=margin-bottom:1% src=/favicons/favicon.ico></span><span class=font-weight-bold>&nbsp;Herbdocs</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/about/><span>About</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class="nav-link active" href=/docs/><span class=active>Documentation</span></a></li><li class="nav-item dropdown mr-4 d-none d-lg-block"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Chinese</a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/en/>English</a></div></li></ul></div><div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/docs/30.%E6%95%B0%E6%8D%AE%E5%BA%93/>返回本页常规视图</a>.</p></div><h1 class=title>数据库</h1><ul><li>1: <a href=#pg-fcf9dd34ad477515f7d2f71d14194557>分布式数据库理论概述</a></li><li>2: <a href=#pg-ca77ecfe7055a64123f8d65e4aa98106>MySQL</a></li><ul><li>2.1: <a href=#pg-3507a2142af71f2e761a63c984092b20>01.SQL查询流程</a></li><li>2.2: <a href=#pg-3d3ec131c01cea7acbeed218bf2383b1>02.日志</a></li><li>2.3: <a href=#pg-57b43e076e15600ed34422d1ac7278e3>02.日志扩展-主从架构</a></li><li>2.4: <a href=#pg-bf80de10001d03d00650fdeb67ce469b>03.表</a></li><li>2.5: <a href=#pg-89e2569382d1c8d44b11a57d472b32e5>04.索引</a></li><li>2.6: <a href=#pg-ad92d6c116d2b87e6f117464895446b9>05.锁</a></li><li>2.7: <a href=#pg-2d169502965da79dfedf0b7ae28eb3a0>06.事务隔离</a></li><li>2.8: <a href=#pg-0cacbe2389748a5d32062a1f0c3659cc>MySQL技术内幕-InnoDB</a></li></ul><li>3: <a href=#pg-3543749e44f03a87413d5435c686d875>Redis</a></li><ul><li>3.1: <a href=#pg-7c5bf47b0f395e37baa104838561cd81>Redis开发与运维</a></li></ul><li>4: <a href=#pg-dbad5e56ec419875a875e1ae622d097c>TiDB</a></li><ul><li>4.1: <a href=#pg-8efec6d6843be08756a1666c851838b7>TiDB初探</a></li></ul><li>5: <a href=#pg-9e167dd3abe5e966a867e1608aa6eca0>SQL引擎</a></li><ul><li>5.1: <a href=#pg-57913b8619c14271e28f8fb18439d412>01.SQL解析器介绍</a></li><li>5.2: <a href=#pg-1f3b4428a1c3ce6dcce34a27b1a096d7>02.Join操作</a></li><li>5.3: <a href=#pg-a69378d24d0e96b77d18b4cd0bae055d>03.统计计数</a></li><li>5.4: <a href=#pg-58e370dcab589bd0cfd3917819e042ca>Presto简介</a></li></ul><li>6: <a href=#pg-25d0fe449057e0f0f6bfe7f9d5f135fb>PostgreSQL</a></li><ul><li>6.1: <a href=#pg-0d82a348ae5eecde6b38ed1859d66c02>PostgreSQL基础使用入门</a></li></ul><li>7: <a href=#pg-807cfd58d53ca9f5ebe339e2098feffc>图</a></li><ul><li>7.1: <a href=#pg-e4b76c76c83e7d334295b0cf83d00cba>图数据库基本介绍</a></li></ul><li>8: <a href=#pg-e45f3f93acd03eb19581a69d28cdebd2>LevelDB</a></li><ul><li>8.1: <a href=#pg-618d30a5d90efc2d9c3168dfb863e4f4>LevelDB-01基本介绍</a></li><li>8.2: <a href=#pg-69cc4c260e3e001ff652a81d39c0f9cf>LevelDB-02基础数据结构</a></li><li>8.3: <a href=#pg-0508025ca5882f41d7056dc7b99a92ba>LevelDB-03Log</a></li><li>8.4: <a href=#pg-eb58a0144226b02120405fa607fe5c26>LevelDB-04数据读写</a></li><li>8.5: <a href=#pg-0fbcf3acb82df1e77d1d85e0d7e0bead>LevelDB-05Cache</a></li><li>8.6: <a href=#pg-de0e0325e2b6d74aef3411cef8176277>LevelDB-06Compaction</a></li></ul><li>9: <a href=#pg-90eb8f9f061ff2dabeca8888b56b5a78>ClickHouse</a></li><ul><li>9.1: <a href=#pg-035c4e69a1451d145c4d6de85264c30f>01.ClickHouse基本介绍</a></li></ul></ul><div class=content><h1 id=introduction>Introduction</h1><p>数据库相关，如MySQL、Redis或其他类型db</p></div></div><div class=td-content><h1 id=pg-fcf9dd34ad477515f7d2f71d14194557>1 - 分布式数据库理论概述</h1><h1 id=简介>简介</h1><h2 id=对比单体数据库>对比单体数据库</h2><p>这里主要针对关系型数据，像 MongoDB 这样的 NoSQL 产品不是这里的重点。</p><p>传统的单体数据需要做好 查询、事务、存储、复制和其它 等五个方面，分布式数据库在单体数据库的基础上还需要增加对 分片 的处理。并且难点重点在 查询、事务、复制和分片 这四个方面。</p><p>单体数据库：</p><ul><li>查询</li><li>事务</li><li>存储</li><li>复制</li><li>其它</li></ul><p>分布式数据库：</p><ul><li>查询<ul><li>计算下推</li><li>多表关联</li></ul></li><li>事务<ul><li>隔离性</li><li>原子性</li></ul></li><li>分片<ul><li>分片元数据存储</li><li>合并拆分</li><li>调度</li></ul></li><li>存储<ul><li>写入效率</li><li>读取效率</li><li>存储成本</li></ul></li><li>复制<ul><li>主从复制</li><li>Quorum</li></ul></li><li>其它<ul><li>客户端接入</li><li>权限管理</li><li>元数据存储</li></ul></li></ul><h2 id=定义>定义</h2><h3 id=外部视角>外部视角</h3><p>业务应用系统可以按照交易类型分为联机交易（OLTP）场景和联机分析（OLAP）场景两大类。OLTP 是面向交易的处理过程，单笔交易的数据量小，但要在短时间内响应，典型场景包括电商、转账等；而 OLAP 场景通常是基于大数据集的运算，典型场景包括生成年度账单和财务报表等。</p><p>从外部视角可以有如下定义：</p><ul><li><p>OLTP 关系型数据库
写多读少；低延迟；高并发</p></li><li><p>海量并发</p></li><li><p>高可靠</p></li><li><p>海量存储
所以从外部视角最终定义可以是：分布式数据库是服务于写多读少、低延时、海量并发 OLTP 场景的，具备海量数据存储能力和高可靠性的关系型数据库。</p></li></ul><h3 id=内部视角>内部视角</h3><ul><li><p>客户端组件 + 单体数据库
典型的客户端组件就是 Sharding-JDBC。</p></li><li><p>代理中间件 + 单体数据库
典型的就是中间件产品就是 MyCat。</p></li><li><p>单元化架构 + 单体数据库
单元化架构对业务应用系统需要彻底重构，应用系统被拆分成若干实例，配置独立的单体数据库，让每个实例管理一定范围的数据。当出现跨实例事务时通过分布式事务组件保证，不同的分布式事务模型，应用系统都需要配合改造。该方案改造量最大，实施难度最高。</p></li></ul><p>总结：</p><p>传统的单体数据库仍然能够被应用系统感知到。而分布式数据库对外单体数据库是透明的，将技术细节收敛到产品内部，以一个整体面对业务应用。</p><h1 id=一致性>一致性</h1><p>分布式数据库的一致性，一般是指数据一致性和事务一致性两个方面。</p><h2 id=数据一致性>数据一致性</h2><p>数据一致性可分为：</p><ul><li><p>状态一致性（State Consistency）
数据所处的客观、实际状态所体现的一致性。</p></li><li><p>操作一致性（Operation Consistency）
外部用户通过协议约定的操作，能够读取到的数据一致性。</p></li></ul><h3 id=状态一致性>状态一致性</h3><h4 id=强一致性>强一致性</h4><p>如 MySQL 全同步复制。</p><p>问题：</p><ul><li>性能差：主库必须等多个从库均返回成功后，才向客户端返回成功。主库的响应时间取决于多个从库中延时最长的那个。</li><li>可用性问题：全同步复制模式下，多个节点被串联，如果单机可用性 99%，那么集群可用性为 99%*99%*99%，比单机更低。</li></ul><h4 id=弱一致性>弱一致性</h4><p>如 NoSQL 最终一致性。也就是 BASE 理论中的 E 代表的最终一致性（Eventually Consistency）。</p><p>最终一致性可以理解为：主副本执行写操作成功后直接响应客户端，不要求其他副本与主副本实时保持一致，经过一段时间，其它副本会逐渐追赶上主副本。</p><h3 id=操作一致性>操作一致性</h3><h3 id=读写一致性>读写一致性</h3><p>写后读一致性（Read after Write Consistency），它也称为 读写一致性 或 读自己写一致性（Read My Writes Consistency）。表示自己写入的数据，下一刻一定能够读取。</p><h4 id=单调读一致性>单调读一致性</h4><p>之前能读到，刷新了之后依然能够读到。避免出现上一刻读副本A，下一刻读副本B，导致前后数据不一致。避免这种问题就需要实现 单调读一致性。</p><h4 id=前缀一致性>前缀一致性</h4><p>保持因果关系的一致性，被称为前缀读或前缀一致性（Consistent Prefix）。举例出现时间上的扭曲：评论A在评论B之前，避免出现时间上的乱序。</p><h4 id=线性一致性>线性一致性</h4><p>分布式数据库无法要求应用系统每次变更操作都附带显式声明，如变更是因为读取哪些数据导致。更可靠的方式是将自然语义的因果关系转变为事件发生的先后顺序。</p><p>线性一致性（Linearizability）就是建立在事件的先后顺序之上。整个系统的所有操作被记录在一条时间线下且被原子化，表现得就像只有一个副本。</p><p>因为各个节点都是各自的时间线，所以做到全局线性一致性需要一个<strong>全局时钟</strong>。主流数据大多以实现线性一致性为目标，在设计之初就引入了全局时钟（如 Spanner、TiDB、OceanBase、GoldenDB 和巨杉），多数采用单点授时（TSO）。</p><p>对于线性一致性，当然也有一些争议，反对者认为没有绝对时间，时间都是相对的，自然不存在全序的事件顺序，不同的观察者对于事件的发生顺序无法达成一致（相对论）。</p><h4 id=因果一致性>因果一致性</h4><p>线性一致性存在争议，那可以不依赖绝对时间。</p><p>因果一致性的基础是偏序关系，即部分事件顺序可以比较。如一个节点内的事件可以排序，仅依靠节点的本地时钟，如果节点发生通讯，则按照接收方事件晚于调用方事件来处理。</p><p>基于这种偏序关系，Leslie Lamport 在论文“Time, Clocks, and the Ordering of Events in a Distributed System”中提出了<strong>逻辑时钟</strong>的概念。</p><p>借助逻辑时钟也可以建立全序关系，只不过这个全序关系不够精确，如两个事件没有相关性，逻辑时钟给出的大小就没有意义。</p><p>因果一致性弱于线性一致性，但在并发性能上具有优势，也足以处理多数的异常现象，所以因果一致性也在工业界得到了应用。CockroachDB 和 YugabyteDB 都在设计中采用了逻辑混合时钟（Hybrid Logical Clocks）。</p><h2 id=事务一致性>事务一致性</h2><p>（事务一致性在 MySQL 章节已详细介绍，这里简单介绍）</p><p>事务的 ACID 四大特性，将广义上的事务一致性具化到了：</p><ul><li>原子性：事务中的所有变更要么全部发生，要么一个也不发生。</li><li>一致性：事务要保持数据的完整性。</li><li>隔离性：多事务并行执行所得到的结果，与串行执行（一个接一个）完全相同。</li><li>持久性：一旦事务提交，它对数据的改变将被永久保留，不应受到任何系统故障的影响。</li></ul><h3 id=隔离性>隔离性</h3><p>隔离级别：</p><ul><li>未提交读（RU）</li><li>以提交读（RC）</li><li>可重复读（RR）</li><li>可串行化（Serializable）
隔离性是事务的核心。降低隔离级别就是在正确性上做妥协，将一些异常现象交给业务去处理，从而获得更好的性能。除 串行化 以外的隔离级别，都有无法处理的异常现象。</li></ul><h1 id=原子性>原子性</h1><h2 id=事务原子性>事务原子性</h2><p>原子性要求事务只有两种状态：</p><ul><li><p>成功，所有操作全部成功；</p></li><li><p>失败，任何操作都没有被执行，即使过程中执行了部分操作，也要保证回滚这些操作。
原子性提交协议有不少，按照其作用范围可以分为面向应用层和面向资源层。下面介绍两种协议：</p></li><li><p>面向应用层的 TCC</p></li><li><p>数据库领域常用的 2PC</p></li></ul><h2 id=tcc>TCC</h2><p>TCC 是 Try、Confirm 和 Cancel 三个单词的缩写，是事务过程中的三个操作。</p><h2 id=2pc>2PC</h2><p>两阶段提交协议（Two-Phase Commit，2PC），这也是面向资源层的典型协议。</p><p>2PC 的首次正式提出是在 Jim Gray 1977 年发表的一份文稿中，文稿的题目是“<a href=https://cs.nyu.edu/courses/fall18/CSCI-GA.3033-002/papers/Gray1978.pdf>Notes on Data Base Operating Systems</a>”，对当时数据库系统研究成果和实践进行了总结，而 2PC 在工程中的应用还要再早上几年。</p><p>2PC 的处理过程也分为准备和提交两个阶段，每个阶段都由事务管理器与资源管理器共同完成。其中，事务管理器作为事务的协调者只有一个，而资源管理器作为参与者执行具体操作允许有多个。</p><h3 id=问题>问题</h3><p>相比于 TCC，2PC 的优点是借助了数据库的提交和回滚操作，不侵入业务逻辑。但是，它也存在一些明显的问题：</p><ul><li><p>同步阻塞
执行过程中，数据库要锁定对应的数据行。如果其他事务刚好也要操作这些数据行，那就只能等待。其实同步阻塞只是设计方式，真正的问题在于这种设计会导致分布式事务出现高延迟和性能的显著下降。</p></li><li><p>单点故障
事务管理器非常重要，一旦发生故障，数据库会一直阻塞下去。尤其是在第二阶段发生故障的话，所有数据库还都处于锁定事务资源的状态中，从而无法继续完成事务操作。</p></li><li><p>数据不一致
在第二阶段，当事务管理器向参与者发送 Commit 请求之后，发生了局部网络异常，导致只有部分数据库接收到请求，但是其他数据库未接到请求所以无法提交事务，整个系统就会出现数据不一致性的现象。比如转账余额已经能够扣减，但另一方余额没有增加，就不符合原子性的要求。</p></li></ul><h2 id=两个2pc改进模型>两个2PC改进模型</h2><h3 id=newsql阵营-percolator>NewSQL阵营：Percolator</h3><p>Percolator 来自 Google 的论文“<a href=https://www.cs.princeton.edu/courses/archive/fall10/cos597B/papers/percolator-osdi10.pdf>Large-scale Incremental Processing Using Distributed Transactions and Notifications</a>”，因为它是基于分布式存储系统 BigTable 建立的模型，所以可以和 NewSQL 无缝链接。</p><p>Percolator 模型同时涉及了隔离性和原子性的处理，本节仅介绍原子性的部分。</p><p>改进：</p><ul><li><p>数据不一致
2PC 的一致性问题主要缘自第二阶段，不能确保事务管理器与多个参与者的通讯始终正常。但在 Percolator 的第二阶段，事务管理器只需要与一个分片通讯，这个 Commit 操作本身就是原子的。所以，事务的状态自然也是原子的，一致性问题被完美解决了。</p></li><li><p>单点故障
Percolator 通过日志和异步线程的方式弱化了该问题。</p><ul><li>Percolator 引入的异步线程可以在事务管理器宕机后，回滚各个分片上的事务，提供了善后手段，不会让分片上被占用的资源无法释放。</li><li>事务管理器可以用记录日志的方式使自身无状态化，日志通过共识算法同时保存在系统的多个节点上。事务管理器宕机后，可以在其他节点启动新的事务管理器，基于日志恢复事务操作。</li></ul></li></ul><h3 id=proxy阵营-goldendb一阶段提交>Proxy阵营：GoldenDB一阶段提交</h3><p>GoldenDB 展现了另外一种改良思路，称之为“一阶段提交”。GoldenDB 遵循 Proxy 架构，包含了四种角色：协调节点、数据节点、全局事务器和管理节点，其中协调节点和数据节点均有多个。GoldenDB 的数据节点由 MySQL 担任，后者是独立的单体数据库。</p><p><img src alt=图片></p><p>虽然叫做“一阶段提交”，但流程仍可以分为两个阶段：</p><p>第一阶段，GoldenDB 的协调节点接到事务后，在全局事务管理器（GTM）的全局事务列表中将事务标记成活跃的状态。这个标记过程是 GoldenDB 的主要改进点，实质是通过全局事务列表来申请资源，规避可能存在的事务竞争。</p><blockquote><p>好处是避免了与所有参与者的通讯，也减少了很多无效的资源锁定动作。</p></blockquote><p>第二阶段，协调节点把一个全局事务分拆成若干子事务，分配给对应的 MySQL 去执行。如果所有操作成功，协调者节点会将全局事务列表中的事务标记为结束，整个事务处理完成。如果失败，子事务在单机上自动回滚，而后反馈给协调者节点，后者向所有数据节点下发回滚指令。</p><p>本质上是改变了资源的申请方式，更准确的说法是，并发控制手段从锁调度变为时间戳排序（Timestamp Ordering）。在正常情况下协调节点与数据节点只通讯一次，降低了网络不确定性的影响，数据库的整体性能有明显提升。因为第一阶段不涉及数据节点的操作，也就弱化了数据一致性和单点故障的问题。</p><h2 id=事务延迟>事务延迟</h2><p>优化方法如下</p><h3 id=缓存写提交>缓存写提交</h3><p>第一个办法是将所有写操作缓存起来，直到 commit 语句时一起执行，这种方式称为 Buffering Writes until Commit，这里称为“缓存写提交”。</p><h3 id=管道>管道</h3><p>Pipe 既能缩短延迟，又能保持交互事务。CockroachDB 就是采用这种方式，具体过程就是在准备阶段是按照顺序将 SQL 转换为 K/V 操作并执行，但是并不等待返回结果，直接执行下一个 K/V 操作。</p><h3 id=并行提交>并行提交</h3><p>（Parallel Commits）</p><p>在执行意向写的同时，写入事务标志，这时不能确定事务是否提交成功，要引入一个新的状态“Staging”，表示事务正在进行。</p><p>客户端得到所有意向写的成功反馈后，可以直接返回调用方事务提交成功。注意：这个地方是关键，客户端只在当前进程内判断事务提交成功后，不维护事务状态，而直接返回调用方；事后由异步线程根据事务表中的线索，再次确认事务的状态，并落盘维护状态记录。这样事务操作中就减少了一轮共识算法开销。</p><h1 id=隔离性-1>隔离性</h1><p>多版本并发控制（Multi-Version Concurrency Control，MVCC）就是通过记录数据项历史版本的方式，来提升系统应对多事务访问的并发处理能力。</p><h2 id=单体数据库的mvcc>单体数据库的MVCC</h2><h3 id=mvcc存储方式>MVCC存储方式</h3><p>MVCC 有三类存储方式，一类是将历史版本直接存在数据表中的，称为 Append-Only，典型代表是 PostgreSQL。另外两类都是在独立的表空间存储历史版本，它们区别在于存储的方式是全量还是增量。增量存储就是只存储与版本间变更的部分，这种方式称为 Delta，也就是数学中常作为增量符号的那个 Delta，典型代表是 MySQL 和 Oracle。全量存储则是将每个版本的数据全部存储下来，这种方式称为 Time-Travle，典型代表是 HANA。</p><h4 id=append-only方式>Append-Only方式</h4><p>优点：</p><ul><li><p>在事务包含大量更新操作时也能保持较高效率。因为更新操作被转换为 Delete + Insert，数据并未被迁移，只是有当前版本被标记为历史版本，磁盘操作的开销较小。</p></li><li><p>可以追溯更多的历史版本，不必担心回滚段被用完。</p></li><li><p>因为执行更新操作时，历史版本仍然留在数据表中，所以如果出现问题，事务能够快速完成回滚操作。
缺点：</p></li><li><p>新老数据放在一起，会增加磁盘寻址的开销，随着历史版本增多，会导致查询速度变慢。</p></li></ul><h4 id=delta方式>Delta方式</h4><p>优点：</p><ul><li><p>因为历史版本独立存储，所以不会影响当前读的执行效率。</p></li><li><p>因为存储的只是变化的增量部分，所以占用存储空间较小。
缺点：</p></li><li><p>历史版本存储在回滚段中，而回滚段由所有事务共享，并且还是循环使用的。如果一个事务执行持续的时间较长，历史版本可能会被其他数据覆盖，无法查询。</p></li><li><p>这个模式下读取的历史版本，实际上是基于当前版本和多个增量版本计算追溯回来的，那么计算开销自然就比较大。
Oracle 早期版本中经常会出现的 ORA-01555 “快照过旧”（Snapshot Too Old），就是回滚段中的历史版本被覆盖造成的。一般设置更大的回滚段和缩短事务执行时间可以解决这个问题。随着 Oracle 后续版本采用自动管理回滚段的设计该问题也得到缓解。</p></li></ul><h4 id=time-travel方式>Time-Travel方式</h4><p>优点：</p><ul><li><p>将历史版本独立存储，不会影响当前读的执行效率。</p></li><li><p>相对 Delta 方式，历史版本是全量独立存储的，直接访问即可，计算开销小。
缺点：</p></li><li><p>相对 Delta 方式，需要占用更大的存储空间。</p></li></ul><h2 id=mvcc工作过程>MVCC工作过程</h2><p>最低可接受的隔离级别就是“已提交读”（Read Committed，RC）。RC隔离级别下 MVCC 的工作过程：</p><ol><li>当前事务的更新所产生的数据。</li><li>当前事务启动前，已经提交事务更新的数据。</li></ol><h3 id=快照工作原理>快照工作原理</h3><p>快照是基于 MVCC 实现的一个重要功能，用“快照”来实现 RR 是很方便的。</p><p>RC 与 RR 的区别在于 RC 下每个 SQL 语句会有一个自己的快照，所以看到的数据库是不同的，而 RR 下，所有 SQL 语句使用同一个快照，所以会看到同样的数据库。</p><p>为了提升效率，快照不是单纯的事务 ID 列表，它会统计最小活动事务 ID 和最大已提交事务 ID。因此多数事务 ID 通过比较边界值就能被快速排除掉，如果事务 ID 恰好在边界范围内，再进一步查找是否与活跃事务 ID 匹配。</p><p>快照在 MySQL 中称为 ReadView，在 PostgreSQL 中称为 SnapshotData，组织方式都是类似的。</p><h3 id=proxy读写冲突处理>Proxy读写冲突处理</h3><p>Proxy 架构实现 RR 时遇到的两个挑战，也就是实现快照的两个挑战：</p><ul><li>如何保证产生单调递增事务 ID。每个数据节点自行处理显然不行，这就需要由一个集中点来统一生成。</li><li>如何提供全局快照。每个事务要把自己的状态发送给一个集中点，由它维护一个全局事务列表，并向所有事务提供快照。
Proxy 架构的分布式数据库都有一个集中点，通常称为全局事务管理器（GTM）。又因为事务 ID 是单调递增的，用来衡量事务发生的先后顺序，和时间戳作用相近，所以全局事务管理器也被称为“全局时钟”。</li></ul><h3 id=newsql读写冲突处理>NewSQL读写冲突处理</h3><p>没有普遍采用快照解决读写冲突问题，其中 TiDB 是由于权衡全局事务列表的代价，CockroachDB 则是因为要实现更高的隔离级别。无论哪种原因都造成了读写并行能力的下降。</p><h2 id=隐式读写冲突>隐式读写冲突</h2><h3 id=不确定时间窗口>不确定时间窗口</h3><p>当两个时间窗口时重叠时，无法判断时间先后关系。只有通过避免时间窗口出现重叠来解决，而避免重叠只能是等待（waiting out the uncertainty”，用等待来消除不确定性）。</p><h3 id=写等待-spanner>写等待：Spanner</h3><p>Spanner 选择了写等待方式，更准确地说是用提交等待（commit-wait）来消除不确定性。</p><p>Spanner 是直接将时间误差暴露出来的，所以调用当前时间函数 TT.now() 时，会获得的是一个区间对象 TTinterval。它的两个边界值 earliest 和 latest 分别代表了最早可能时间和最晚可能时间，而绝对时间就在这两者之间。另外，Spanner 还提供了 TT.before() 和 TT.after() 作为辅助函数，其中 TT.after() 用于判断当前时间是否晚于指定时间。</p><h3 id=理论等待时间>理论等待时间</h3><p><img src=../imgs/20230202_distributed_database_1.png alt=20230202_distributed_database_1.png></p><p>写等待的处理方式是：</p><p>事务 Ta 在获得“提交时间戳”S 后，再等待ɛ时间后才写盘并提交事务。真正的提交时间是晚于“提交时间戳”的，中间这段时间就是等待。这样 Tb 事务启动后，能够得到的最早时间 TT2.earliet 肯定不会早于 S 时刻，所以 Tb 就一定能够读取到 Ta。这样就符合线性一致性的要求了。</p><p>事务获得“提交时间戳”后必须等待ɛ时间才能写入磁盘，即 commit-wait。</p><h3 id=实际等待时间>实际等待时间</h3><p><img src=../imgs/20230202_distributed_database_2.png alt=20230202_distributed_database_2.png></p><p>针对同一个数据项，事务 T8 和 T9 分别对进行写入和读取操作。T8 在绝对时间 100ms 的时候，调用 TT.now() 函数，得到一个时间区间[99,103]，选择最大值 103 作为提交时间戳，而后等待 8 毫秒（即 2ɛ）后提交。</p><p>无论如何 T9 事务启动时间都晚于 T8 的“提交时间戳”，也就能读取到 T8 的更新。</p><p>回顾一下这个过程，第一个时间差是 2PC 带来的，如果换成其他事务模型也许可以避免，而第二个时间差是真正的 commit-wait，来自时间的不确定性，是不能避免的。</p><p>TrueTime 的平均误差是 4 毫秒，commit-wait 需要等待两个周期，那 Spanner 读写事务的平均延迟必然大于等于 8 毫秒。为啥有人会说 Spanner 的 TPS 是 125 呢？原因就是这个。其实，这只是事务操作数据出现重叠时的吞吐量，而无关的读写事务是可以并行处理的。</p><p>对数据库来说 8 毫秒的延迟虽然不能说短，但对多数场景来说还是能接受的。可是，TrueTime 是 Google 的独门招式，其他分布式数据库的时间误差远大于 8 毫秒，难道也用 commit-wait 可不太行，所以要用到第二种方式：读等待。</p><h3 id=读等待-cockroachdb>读等待：CockroachDB</h3><p>读等待的代表产品是 CockroachDB。</p><p>CockroachDB 采用混合逻辑时钟（HLC），对于没有直接关联的事务，只能用物理时钟比较先后关系。CockroachDB 各节点的物理时钟使用 NTP 机制同步，误差在几十至几百毫秒之间，用户可以基于网络情况通过参数”maximum clock offset”设置这个误差，默认配置是 250 毫秒。</p><p>写等待模式下，所有包含写操作的事务都受到影响，要延后提交；而读等待只在特殊条件下才被触发，影响的范围要小得多。</p><p><img src=../imgs/20230202_distributed_database_3.png alt=20230202_distributed_database_3.png></p><p>这时，CockroachDB 的办法是重启（Restart）读操作的事务，就是让 T6 获得一个更晚的时间戳 T6-S2，使得 T6-S2 与 T2-C 的间隔大于 offset，那么就能读取 T2 的写入了。</p><p><img src=../imgs/20230202_distributed_database_4.png alt=20230202_distributed_database_4.png></p><p>不过，接下来又出现更复杂的情况， T6-S2 与 T3 的提交时间戳 T3-C 间隔太近，又落入了 T3 的不确定时间窗口，所以 T6 事务还需要再次重启。而 T3 之后，T6 还要重启越过 T4 的不确定时间窗口。</p><p><img src=../imgs/20230202_distributed_database_5.png alt=20230202_distributed_database_5.png></p><p>最后，当 T6 拿到时间戳 T6-S4 后，终于跳过了所有不确定时间窗口，读等待过程到此结束，T6 可以正式开始它的工作了。</p><p>在这个过程中，可以看到读等待的两个特点：一是偶发，只有当读操作与已提交事务间隔小于设置的时间误差时才会发生；二是等待时间的更长，因为事务在重启后可能落入下一个不确定时间窗口，所以也许需要经过多次重启。</p><h2 id=并发控制技术>并发控制技术</h2><p>并发控制技术的分类：</p><ul><li>乐观协议</li><li>悲观协议
悲观协议是使用锁的，而乐观协议是不使用锁的。</li></ul><h3 id=乐观锁-tidb>乐观锁：TiDB</h3><p>TiDB 的乐观锁基本上就是 Percolator 模型，运行过程分为三个阶段：</p><ol><li><p>选择Primary Row
收集所有参与修改的行，从中随机选择一行，作为这个事务的 Primary Row，这一行是拥有锁的，称为 Primary Lock，而且这个锁会负责标记整个事务的完成状态。所有其他修改行也有锁，称为 Secondary Lock，都会保留指向 Primary Row 的指针。</p></li><li><p>写入阶段
按照两阶段提交的顺序，执行第一阶段。每个修改行都会执行上锁并执行“prewrite”，prewrite 就是将数据写入私有版本，其他事务不可见。注意这时候每个修改行都可能碰到锁冲突的情况，如果冲突就终止事务，返回给 TiDB，整个事务也就终止。如果所有修改行都顺利上锁，完成 prewrite，第一阶段结束。</p></li><li><p>提交阶段
这是两阶段提交的第二阶段，提交 Primary Row，也就是写入新版本的提交记录并清除 Primary Lock，如果顺利完成，那么这个事务整体也就完成了，反之就是失败。而 Secondary Rows 上的锁，则会交给异步线程根据 Primary Lock 的状态去清理。</p></li></ol><h3 id=并发控制阶段>并发控制阶段</h3><ol><li>读阶段
每个事务对数据项的局部拷贝进行更新。</li></ol><p>注意此时的更新结果对于其他事务不可见。这个阶段的命名容易让人误解，明明做了写操作，却叫做“读阶段”。大意为后面要写入的内容，先要暂时加载到一个仅自己可见的临时空间内。</p><ol start=2><li>有效性确认阶段
验证准备提交的事务。检查这些更新是否可以保证数据库的一致性，如果检查通过进入下一个阶段，否则取消事务。</li></ol><p>首先这里提到的检查与隔离性目标有直接联系；其次就是检查可以有不同的手段，也就是不同的并发控制技术，比如可以是基于锁的检查，也可以是基于时间戳排序。</p><ol start=3><li>写阶段
将读阶段的更新结果写入到数据库中，接受事务的提交结果。</li></ol><p>还有一种关于乐观与悲观的表述，也与三阶段的顺序相呼应。<strong>乐观重在事后检测</strong>，在事务提交时检查是否满足隔离级别，如果满足则提交，否则回滚并自动重新执行。<strong>悲观重在事前预防</strong>，在事务执行时检查是否满足隔离级别，如果满足则继续执行，否则等待或回滚。</p><p>回到 TiDB 的乐观锁。虽然对于每一个修改行来说，TiDB 都做了有效性验证，而且顺序是 VRW，可以说是悲观的，但这只是局部的有效性验证；从整体看，TiDB 没有做全局有效性验证，不符合 VRW 顺序，所以还是相对乐观的。</p><h3 id=狭义乐观并发控制-occ>狭义乐观并发控制（OCC）</h3><p>“<a href=http://www.gbv.de/dms/weimar/toc/647210940_toc.pdf>Transactional Information Systems : Theory, Algorithms, and the Practice of Concurrency Control and Recovery</a>”给出了一个专用于 RVW 的三阶段定义，专门描述乐观协议的。其中主要差别在“有效性确认阶段”，是针对可串行化的检查，检查采用基于时间戳的特定算法。</p><p>这个定义是一个更加具体的乐观协议，严格符合 RVW 顺序，所以我把它称为狭义上的乐观并发控制（Optimistic Concurrency Control），也称为基于有效性确认的并发控制（Validation-Based Concurrency Control）。很多学术论文中的 OCC 就是指这个。在工业界真正生产级的分布式数据库还很少使用狭义 OCC 进行并发控制，唯一的例外就是 FoundationDB。与之相对应的，则是 TiDB 这种广义上的乐观并发控制，说它乐观是因为它没有严格遵循 VRW 顺序。</p><h3 id=乐观协议的挑战>乐观协议的挑战</h3><p>主要两方面：</p><ul><li>事务冲突少是使用乐观协议的前提，但这个前提是否普遍成立？</li><li>现有应用系统使用的单体数据库多是悲观协议，兼容性上的挑战。</li></ul><h4 id=事务频繁冲突>事务频繁冲突</h4><p>金融业务频繁冲突，很可能一直在重试、回滚，永远无法执行完成，而使用悲观锁就很容易解决。</p><h4 id=兼容性要求>兼容性要求</h4><p>保证对遗留应用系统的兼容性。单体数据库都是悲观协议，甚至多数都是基于锁的悲观协议，所以在 SQL 运行效果上与乐观协议有直接的区别。一个非常典型的例子就是 select for update。这是一个显式的加锁操作，或者说是显式的方式进行有效性确认，广义的乐观协议都不提供严格的 RVW，所以也就无法支持这个操作。</p><h3 id=乐观锁的改变>乐观锁的改变</h3><p>基于上面这些挑战，TiDB 的并发控制机制也做出了改变，增加了“悲观锁”并作为默认选项。TiDB 悲观锁的理论基础很简单，就是在原有的局部有效性确认前，增加一轮全局有效性确认。这样就是严格的 VRW，自然就是标准的悲观协议了。具体采用的方式就是增加了悲观锁，这个锁是实际存在的，表现为一个占位符，随着 SQL 的执行即时向存储系统（TiKV）发出，这样事务就可以在第一时间发现是否有其他事务与自己冲突。</p><p>悲观锁还触发了一个变化。TiDB 原有的事务模型并不是一个交互事务，它会把所有的写 SQL 都攒在一起，在 commit 阶段一起提交，所以有很大的并行度，锁的时间较短，死锁的概率也就较低。因为增加了悲观锁的加锁动作，变回了一个可交互事务，TiDB 还要增加一个死锁检测机制。</p><h2 id=悲观锁>悲观锁</h2><h3 id=分类>分类</h3><p>悲观协议又分为基于锁和非锁两大类，其中基于锁的协议是数量最多的。</p><h3 id=两阶段封锁>两阶段封锁</h3><p>Two-Phase Locking，2PL。就是事务具备两阶段特点的并发控制协议，两阶段指加锁阶段和释放锁阶段，并且加锁阶段严格区别于紧接着的释放锁阶段。</p><p>保守两阶段封锁协议（Conservative 2PL，C2PL），事务在开始时设置它需要的所有锁。</p><p>严格两阶段封锁协议（Strict 2PL，S2PL），事务一直持有已经获得的所有写锁，直到事务终止。</p><p>强两阶段封锁协议（Strong Strict 2PL，SS2PL），事务一直持有已经获得的所有锁，包括写锁和读锁，直到事务终止。SS2PL 与 S2PL 差别只在于一直持有的锁的类型，所以它们的图形是相同的。</p><h3 id=串行化图检测-sgt>串行化图检测（SGT）</h3><p>SSI 是一种隔离级别的命名，最早来自 PostgreSQL，CockroachDB 沿用了这个名称。它是在 SI 基础上实现的可串行化隔离。作为 SSI 核心的 SGT 也不是 CockroachDB 首创，学术界早就提出了这个理论，真正的工程化实现要晚得多。</p><h4 id=理论来源-postgresql>理论来源：PostgreSQL</h4><p>事务之间的边又分为三类情况：</p><ul><li>写读依赖（WR-Dependencies），第二个操作读取了第一个操作写入的值。</li><li>写写依赖（WW-Dependencies），第二个操作覆盖了第一个操作写入的值。</li><li>读写反依赖（RW-Antidependencies），第二个操作覆盖了第一个操作读取的值，可能导致读取值过期。</li></ul><h4 id=工程实现-cockroachdb>工程实现：CockroachDB</h4><p>RW 反向依赖是一个非常特别的存在，而特别之处就在于传统的锁机制无法记录这种情况。因此在论文“<a href=http://vldb.org/pvldb/vol5/p1850_danrkports_vldb2012.pdf>Serializable Snapshot Isolation in PostgreSQL</a>”中提出，增加一种锁 SIREAD，用来记录快照隔离（SI）上所有执行过的读操作（Read），从而识别 RW 反向依赖。本质上，SIREAD 并不是锁，只是一种标识。但这个方案面临的困境是，读操作涉及到的数据范围实在太大，跟踪标识带来的成本可能比 S2PL 还要高，也就无法达到最初的目标。</p><p>针对这个问题，CockroachDB 做了一个关键设计，读时间戳缓存（Read Timestamp Cache），简称 RTC。</p><p>基于 RTC 的新方案是这样的，当执行任何的读取操作时，操作的时间戳都会被记录在所访问节点的本地 RTC 中。当任何写操作访问这个节点时，都会以将要访问的 Key 为输入，向 RTC 查询最大的读时间戳（MRT），如果 MRT 大于这个写入操作的时间戳，那继续写入就会形成 RW 依赖。这时就必须终止并重启写入事务，让写入事务拿到一个更大的时间戳重新尝试。</p><p>具体来说，RTC 是以 Key 的范围来组织读时间戳的。这样，当读取操作携带了谓词条件，比如 where 子句，对应的操作就是一个范围读取，会覆盖若干个 Key，那么整个 Key 的范围也可以被记录在 RTC 中。这样处理的好处是，可以兼容一种特殊情况。</p><h1 id=架构演进>架构演进</h1><p>单体数据往分布式数据库演进主要有两种方式，一种是通过增加中间件如 MyCat 来分库分表，实际就是在多个单体数据库之前增加代理节点，这里称作 Proxy 吧。另一种是提供一个完整的分布式数据库。</p><h2 id=proxy>Proxy</h2><p>在多个单体数据库之前增加代理节点，本质上是增加 SQL 的路由功能。随着分布式事务和跨节点等功能的加入，代理节点不再仅仅承担路由功能，还会承担分布式事务管理，可以成为协调节点。主要实现以下功能：</p><ul><li>客户端接入</li><li>简单的查询处理器</li><li>进程管理中的访问控制</li><li>分布式事务管理
<img src=../imgs/20230202_distributed_database_6.png alt=20230202_distributed_database_6.png></li></ul><h2 id=newsql>NewSQL</h2><p>NewSQL 也叫原生分布式数据，在架构上更加先进，每个层次的设计都是以分布式为目标，是从分布式键值对系统演进而来。在 NoSQL 的基础上增加了数据库事务处理能力。主要的工作负载由计算节点和存储节点承担，另外由管理节点承担全局时钟和分片信息管理功能。存储引擎层使用 LSM-Tree 模型替换 B+ Tree 模型，大幅提升了写入性能。</p><p><img src=../imgs/20230202_distributed_database_7.png alt=20230202_distributed_database_7.png></p><p>Spanner 是 NewSQL 的开山鼻祖，其它的知名度较高的还有 CockroachDB、TiDB 和 YugabyteDB。</p><h1 id=全局时钟>全局时钟</h1><p>分布式数据库的很多设计都和时间有关，更确切地说是和全局时钟有关。比如前面提到的线性一致性，其基础就是全局时钟，还有多版本并发控制（MVCC）、快照、乐观协议与悲观协议，都和时间有关。</p><h2 id=常见授时方案>常见授时方案</h2><p>授时机制三要素：</p><ul><li>时间源：单个还是多个</li><li>时钟类型：物理时钟还是混合逻辑时钟</li><li>授时点：一个还是多个
排列组合一共 8 种可能性，其中 NTP（Network Time Protocol）误差大，也不能保证递增，基本没有使用其的产品。还有一些方案在实际中不适用（N/A），因此常见方案只有 4 类。</li></ul><p><img src=../imgs/20230202_distributed_database_8.png alt=20230202_distributed_database_8.png></p><h2 id=truetime>TrueTime</h2><p>Spanner 采用的方案是 TrueTime，其时间源是 GPS 和原子钟，属于多时间源和物理时钟，同时它也采用了多点授时机制，就是说集群内有多个时间服务器都可以提供授时服务。Truetime 是 Google 的独门绝技，依赖于特定硬件设备的思路，不适用于开源软件。</p><p>TrueTime 会出现时光倒流，不只是 TrueTime，任何物理时钟都会存在时钟偏移甚至回拨。</p><p>单个物理时钟会产生误差，多点授时又会带来整体性的误差。</p><p>TrueTime 的优势：</p><ul><li>高可靠高性能，多时间源和多授时点实现了完全的去中心化设计，不存在单点问题</li><li>支持全球化部署，客户端和时间服务器的距离可控，不会因为二者通讯延迟过长导致时钟失效</li></ul><h2 id=hlc>HLC</h2><p>CockroachDB 和 YugabyteDB 也是以高性能高可靠和全球化部署为目标，因为 TrueTime 的限制，其使用了混合逻辑时钟（Hybrid Logical Clock，HLC）。同样是多时间源、多点授时，但时钟采用了物理时钟与逻辑时钟混合的方式。HLC 在实现机制上较复杂的，且和 TrueTime 同样有整体性的时间误差。</p><h3 id=实现-cockroachdb>实现（CockroachDB）</h3><p><img src=../imgs/20230202_distributed_database_9.png alt=20230202_distributed_database_9.png></p><p>方框是节点上发生的事件，方框内的三个数字依次是节点的本地物理时间（简称本地时间，Pt）、HLC 的高位（简称 L 值）和 HLC 的低位（简称 C 值）。</p><p>分析一：</p><p>事件 D2 发生时，首先取上一个事件 D1 的 L 值和本地时间比较。L 值等于 0，本地时间已经递增变为 1，取最大值，那么用本地时间作为 D2 的 L 值。高位变更了，低位要归零，所以 D2 的 HLC 就是 (1,0)。</p><p>分析二：</p><p>如果节点间有调用关系，计时逻辑会更复杂一点。我们看事件 B2，要先判断 B2 的 L 值，就有三个备选：本节点上前一个事件 B1 的 L 值当前本地时间调用事件 A1 的 L 值，A1 的 HLC 是随着函数调用传给 B 节点的。</p><p>这三个值分别是 0、1 和 10。按照规则取最大值，所以 B2 的 L 值是 10，也就是 A1 的 L 值，而 C 值就在 A1 的 C 值上加 1，最终 B2 的 HLC 就是 (10,1)。</p><p>分析三：</p><p>B3 事件发生时，发现当前本地时间比 B2 的 L 值还要小，所以沿用了 B2 的 L 值，而 C 值是在 B2 的 C 值上加一，最终 B3 的 HLC 就是 (10,2)。</p><h2 id=tso>TSO</h2><p>在 NewSQL 架构中使用单时间源、单点授时的方式往往被称为 TSO（Timestamp Oracle），在 Proxy 架构风格中被称为全局事务管理器（Golobal Transcation Manager，GTM）。也就是一个单点递增的时间戳和全局事务号基本等效。</p><p>优点是实现简便，能够保证时钟单调递增，可以简化事务冲突时的设计。缺点是集群不能大范围部署，性能有上限。</p><p>TiDB、OceanBase、GoldenDB 和 TBase 等选择使用 TSO。</p><h3 id=实现-tidb>实现（TiDB）</h3><p>中心化授时。</p><p>TiDB 的全局时钟是一个数值，由两部分构成，其中高位是物理时间，也就是操作系统的毫秒时间；低位是逻辑时间，是一个 18 位的数值。从存储空间看，1 毫秒最多可以产生 262,144 个时间戳（2^18），这个数字很大一般来说足够使用。</p><p>单点授时首先需要解决单点故障问题。TiDB 中提供授时服务的节点被称为 PD（Placement Driver）。多个 PD 节点构成一个 Raft 组，通过共识算法可以保证主节点宕机后马上选出新主，在短时间内恢复授时服务。</p><p>问题是如何保证新主产生的时间戳一定大于旧主。必须将旧主的时间戳持久化存储，存储必须高可靠，TiDB 使用了 etcd。不是每产生一个时间戳都要保存的，那样时间戳的产生速度直接与磁盘 I/O 能力相关存在瓶颈。TiDB 采用预申请时间窗口的方式，如下过程：</p><p><img src=../imgs/20230202_distributed_database_10.png alt=20230202_distributed_database_10.png></p><p>PD（主节点）系统时间是 103 毫秒，PD 向 etcd 申请了一个 可分配的时间窗口（可以通过参数指定，默认配置是 3 毫秒），所以该窗口起点是 PD 当前时间 103，时间窗口的终点就在 106 毫秒。写入 etcd 成功后，PD 将得到一个从 103 到 106 的 可分配时间窗口，这个时间窗口内 PD 可以使用系统的物理时间作为高位，拼接其在内存中累加的逻辑时间，对外分配时间戳。</p><p>这种设计意味着所有 PD 已分配时间戳的高位，即物理时间，永远小于 etcd 存储的最大值。如果 PD 主节点宕机，新主可以读取 etcd 中存储的最大值，在这个基础上申请新的 可分配时间窗口，这样新主分配的时间戳肯定大于旧主。</p><p>其次，客户端可以一次申请多个时间戳，但如果客户端缓存，多个客户端之间就不是严格单调递增的。</p><h2 id=stp>STP</h2><p>这是一个小众的方案，如 巨杉的 STP(SequoiaDB Time Protoco)，采用了单时间源、多点授时的方式，优缺点介于 HLC 和 TSO 之间。</p><p>STP 是独立于分布式数据库的授时方案，与巨杉其他角色没有必然联系。</p><p>STP 下的所有角色统称为 STP Node，分为两类：</p><ul><li>STP Server：STP 是独立于分布式数据库的授时方案。</li><li>STP Client：按照固定的时间间隔，从 Primary Server 同步时间。
巨杉数据库的其他角色节点，如编目节点（CATALOG）、协调节点（COORD）和数据节点（DATA）等，都从本地的 STP Node 节点获得时间。</li></ul><h1 id=分片机制>分片机制</h1><h2 id=分片策略>分片策略</h2><p>主要是：</p><ul><li>Hash（哈希）</li><li>Range（范围）</li></ul><blockquote><p>Key 和 List 可以看做 Hash 和 Range 的特殊情况。其机制类似。</p></blockquote><h2 id=分片调度机制>分片调度机制</h2><p>分为两种：</p><ul><li>静态：分片在节点上的分布基本固定，移动需要人工介入</li><li>动态：通过调度管理器基于算法在各节点之间自动地移动分片
分片机制与架构风格对应关系：</li></ul><table><thead><tr><th style=text-align:left></th><th style=text-align:left>静态</th><th style=text-align:left>动态</th></tr></thead><tbody><tr><td style=text-align:left>Hash</td><td style=text-align:left>Proxy / NewSQL</td><td style=text-align:left>N/A</td></tr><tr><td style=text-align:left>Range</td><td style=text-align:left>Proxy</td><td style=text-align:left>NewSQL</td></tr></tbody></table><h2 id=hash分片>Hash分片</h2><p>就是按照数据记录中指定关键字的 Hash 值将数据记录映射到不同的分片中。</p><p>Hash 计算会过滤掉数据原有的业务特性，可以保证数据非常均匀地分布到多个分片上，这是 其最大优势，且实现也很简洁。如果直接用节点数作为模，当系统节点数量变动时模也随之改变，就要重新 Hash 计算，会带来大规模的数据迁移，对于扩展性非常不友好。</p><p>于是引入了一致性 Hash。工业实践中应用一致性 Hash 算法，会引入虚拟节点，每个虚拟节点就是一个分片。一开始设定的分片数量决定了集群的最大规模，通常远大于初始集群节点。</p><p><strong>节点和数据都通过 Hash 函数映射到 Hash 环上，数据按照顺时针找到最近的节点。</strong></p><h2 id=range静态分片>Range静态分片</h2><p>Range 分片的特点恰恰是能够加入对于业务的预估，比如数据较多时可以更细分，数据较少时可以使用较粗的分类。</p><p>Range 分片的适用范围更加广泛。主要因为 Range 分片可以更高效地扫描数据记录，而 Hash 分片由于数据被打散，扫描操作的 I/O 开销更大。</p><h2 id=range动态分片>Range动态分片</h2><p>多数是用主键作为关键字来分片的，当然主键可以是系统自动生成的，也可以是用户指定的。</p><p>一般来说动态分片可以自动分裂和合并、根据访问压力调度分片，即<strong>存储均衡</strong>和<strong>访问压力均衡</strong>。</p><p>分片调度还应具有两项能力：</p><ul><li>减少分布式事务：将频繁跨副本的事务数据转移到同一个节点，从而转换成本地事务。</li><li>缩短服务延时：调度到较近的数据中心。</li></ul><h1 id=数据复制协议>数据复制协议</h1><p>动态分片，满足高可靠的同时还要考虑元数据的多副本一致性，必须选择合适的复制协议。</p><p>如果搭建独立的、小规模元数据集群，则可以使用 Paxos 或 Raft 等协议，传播特点是广播。如果元数据存在工作节点上，数量较多则可以考虑 Gossip 协议，传播特点是谣言传播。</p><p>复制协议的选择和数据副本数量有很大关系：如果副本少，参与节点少，可以采用广播方式，也就是 Paxos、Raft 等协议；如果副本多，节点多，更适合采用 Gossip 协议。</p><h2 id=gossip协议>Gossip协议</h2><p>CockroachDB 采用了 P2P 架构，每个节点都要保存完整的元数据，这样节点规模就非常大，不适用广播机制。而 Gossip 协议的原理是谣言传播机制，每一次谣言都在几个人的小范围内传播，但最终会成为众人皆知的谣言。这种方式达成的数据一致性是 “最终一致性”，即执行数据更新操作后，经过一定的时间，集群内各个节点所存储的数据最终会达成一致。</p><p>虽然 Gossip 是最终一致性，但通过一些寻址过程中的巧妙设计，基于“最终一致性”的元数据也可以实现强一致性。</p><h3 id=实现强一致性>实现强一致性</h3><p><img src=../imgs/20230202_distributed_database_11.png alt=20230202_distributed_database_11.png></p><ol><li>节点 A 接到客户端的 SQL 请求，要查询数据表 T1 的记录，根据主键范围确定记录可能在分片 R1 上，而本地元数据显示 R1 存储在节点 B 上。</li><li>节点 A 向节点 B 发送请求。很不幸，节点 A 的元数据已经过时，R1 已经重新分配到节点 C。</li><li>此时节点 B 会回复给节点 A 一个非常重要的信息，R1 存储在节点 C。</li><li>节点 A 得到该信息后，向节点 C 再次发起查询请求，这次运气很好 R1 确实在节点 C。</li><li>节点 A 收到节点 C 返回的 R1。节点 A 向客户端返回 R1 上的记录，同时会更新本地元数据。
CockroachDB 在寻址过程中会不断地更新分片元数据，促成各节点元数据达成一致。</li></ol><h2 id=raft协议>Raft协议</h2><p>Raft 日志复制过程：</p><ol><li>Leader 收到客户端的请求。</li><li>Leader 将请求内容（Log Entry）追加（Append）到本地 Log。</li><li>Leader 将 Log Entry 发送给其他的 Follower。</li><li>Leader 等待 Follower 的结果，如果大多数节点提交了该 Log，那么该 Log Entry 就是 Committed Entry，Leader 就可以将它应用（Apply）到本地的状态机。</li><li>Leader 返回客户端提交成功。</li><li>Leader 继续处理下一次请求。</li></ol><h3 id=顺序投票阻塞问题>顺序投票阻塞问题</h3><p>当多事务并行操作时，由于前面的事务没有超过半数的响应，Leader 必须等待一个明确的失败信号，如通讯超时等，才能结束这次操作。因为有顺序投票的规则，会阻塞后续事务的进行。</p><h3 id=优化方法-tidb>优化方法（TiDB）</h3><p>可以借鉴下 TiDB 的优化点：</p><ul><li>批操作（Batch）：Leader 缓存多个客户端请求，将一批日志批量发送给 Follower。减少通讯成本。</li><li>流水线（Pipeline）：Leader 本地增加一个变量（称为 NextIndex），每次发送一个 Batch 后，更新 NextIndex 记录下一个 Batch 的位置，不等待 Follower 返回立刻发送下一个 Batch。当出现网络问题，Leader 重新调整 NextIndex 再次发送 Batch。</li><li>并行追加日志（Append Log Parallelly）：Leader 将 Batch 发送给 Follower 的同时，并发执行本地的 Append 操作，可以减少部分开销。同时可以调整 Committed Entry 的判断规则，并行操作下，即使 Leader 没有 Append 成功，只要有半数以上的 Follower 节点 Append 成功，那就依然可以视为一个 Committed Entry，Entry 可以被 Apply。</li><li>异步应用日志（Asynchronous Apply）：任何处于 Committed 状态的 Log Entry 都确保是不会丢失的。Apply 仅仅是为了保证状态能够在下次被正确地读取到，一般提交数据后不会马上读取，可以将 Apply 修改异步执行，同时改造读操作。</li></ul><h1 id=自增主键>自增主键</h1><h2 id=特性>特性</h2><p>自增主键给开发人员提供了很大的便利。主键必须要保证唯一，且多数设计规范都会要求，主键不带有业务属性。如果数据库没有内置这个特性，应用开发人员就必须自己设计一套主键的生成逻辑，数据库原生提供的自增主键免去了这些工作量。</p><h2 id=单体数据库自增主键>单体数据库自增主键</h2><h3 id=无法连续递增>无法连续递增</h3><p>事务发生冲突时，主键就会跳跃留下空洞。可以参考 MySQL 章节。</p><h3 id=无法单调递增>无法单调递增</h3><p>当主键生成的速度能够满足应用系统的并发需求时，自增主键确实可以做到单调自增。但在高并发场景下，如果自增主键称为瓶颈，那么需要优化。</p><p>Oracle 数据库常见的优化方式就是由 Sequence 负责生成主键的高位，由应用服务器负责生成低位数字，拼接起来形成完整的主键。</p><p>这样只能保证全局唯一，但数据表中最终保存的主键不再是单调递增。</p><p>因此，在一个海量并发场景下，即使借助单体数据库的自增主键特性，也不能实现单调递增的主键。</p><h2 id=自增主键的问题>自增主键的问题</h2><p>分布式数据库中自增主键的问题更多，如：</p><ul><li>在自增主键的产生环节</li><li>在自增主键的使用环节
可以发现自增主键的单调递增和全局时钟中的 TSO 很相似。</li></ul><h3 id=尾部热点>尾部热点</h3><blockquote><p>参考：<a href=https://www.cockroachlabs.com/blog/unpacking-competitive-benchmarks/>https://www.cockroachlabs.com/blog/unpacking-competitive-benchmarks/</a></p></blockquote><p>性能问题的根因是同时使用自增主键和 Range 分片。Range 分片有很多优势，使得其成为一个不能轻易放弃的选择。因此主流产品的默认方案是保持 Range 分片，放弃自增主键，转而用随机主键来代替。</p><h2 id=随机主键>随机主键</h2><h3 id=内置uuid>内置UUID</h3><p>UUID 是由 32 个的 16 进制数字组成，长度是 128 位（16^32 = 2^128）。UUID 作为一种广泛使用标准，有多个实现版本，影响它的因素包括时间、网卡 MAC 地址、自定义 Namesapce 等等。</p><p>缺点是键值长度过长（128 位），存储和计算的代价都会增加。</p><h3 id=内置random-id>内置Random ID</h3><p>TiDB 默认是支持自增主键的，对未声明主键的表会提供了一个隐式主键 _tidb_rowid。因为这个主键大体上是单调递增的，所以也会出现尾部热点问题。</p><p>TiDB 除了提供了 UUID 函数，在 4.0 版本中还提供了一种解决方案 AutoRandom。TiDB 模仿 MySQL 的 AutoIncrement，提供了 AutoRandom 关键字用于生成一个随机 ID 填充指定列。</p><p>这个随机 ID 是一个 64 位整型，分为三个部分。</p><ul><li>第一部分的符号位没有实际作用。</li><li>第二部分是事务开始时间，默认为 5 位，可以理解成事务时间戳的一种映射。</li><li>第三部分则是自增的序列号，使用其余位。</li></ul><h3 id=外置snowflake>外置Snowflake</h3><p>雪花算法（Snowflake）是 Twitter 公司分布式项目采用的 ID 生成算法。</p><p>生成的 ID 是一个 64 位的长整型，由四个部分构成：</p><ul><li>第一部分是 1 位的符号位，并没有实际用处，主要为了兼容长整型的格式。</li><li>第二部分是 41 位的时间戳用来记录本地的毫秒时间。</li><li>第三部分是机器 ID，这里说的机器就是生成 ID 的节点，用 10 位长度给机器做编码，那意味着最大规模可以达到 1024 个节点（2^10）。</li><li>最后是 12 位序列，序列的长度直接决定了一个节点 1 毫秒能够产生的 ID 数量，12 位就是 4096（2^12）。
注意时钟回拨导致产生的 ID 重复，需要特殊处理。</li></ul><h1 id=关联查询>关联查询</h1><p>查询中的多表关联，也就是 join 操作，在分布式数据库中如何优化呢。</p><h2 id=关联算法>关联算法</h2><p>常见的关联算法有三大类，分别是嵌套循环（Nested Loop Join）、排序归并（Sort-Merge Join）和哈希（Hash Join）。</p><h3 id=嵌套循环连接算法>嵌套循环连接算法</h3><p>所有的嵌套循环算法都由内外两个循环构成，分别从两张表中顺序取数据。其中，外层循环表称为外表（Outer 表），内层循环表则称为内表（Inner 表）。算法过程是由遍历 Outer 表开始，Outer 表也称为驱动表。在最终得到的结果集中，记录的排列顺序与 Outer 表的记录顺序是一致的。</p><p>根据在处理环节上的不同，嵌套循环算法又可以细分为三种，分别是 Simple Nested-Loop Join（SNLJ）、Block Nested-Loop Join（BNJ）和 Index Lookup Join（ILJ）。</p><h4 id=simple-nested-loop-join>Simple Nested-Loop Join</h4><p>SNLJ 是最简单粗暴的算法，有些资料会用 NLJ 指代 SNLJ。</p><p>SNLJ 执行过程：</p><ol><li>遍历 Outer 表，取一条记录 r1；</li><li>遍历 Inner 表，对于 Inner 表中的每条记录，与 r1 做 join 操作并输出结果；</li><li>重复步骤 1 和 2，直至遍历完 Outer 表中的所有数据，就得到了最后的结果集。
性能问题：每次为了匹配 Outer 表的一条记录，都要对 Inner 表做一次全表扫描操作。而全表扫描的磁盘 I/O 开销很大。</li></ol><h4 id=block-nested-loop-join>Block Nested-Loop Join</h4><p>BNJ 是对 SNLJ 的一种优化，改进点是减少 Inner 表的全表扫描次数。BNJ 的变化主要在于步骤 1，读取 Outer 表时不再只取一条记录，而是读取一个批次的 x 条记录加载到内存中。这样执行一次 Inner 表的全表扫描就可以比较 x 条记录。MySQL 中这个 x 对应一个叫做 Join Buffer 的设置项，直接影响了 BNJ 的执行效率。</p><p>与 SNLJ 相比，BNJ 虽然在时间复杂度都是 O(m*n)（m 和 n 分别是 Outer 表和 Inner 表的记录行数），但磁盘 I/O 的开销却明显降低了，所以效果优于 SNLJ</p><h4 id=index-lookup-join>Index Lookup Join</h4><p>SNLJ 和 BNJ 都是直接在数据行上扫描，并没有使用索引。所以这两种算法的磁盘 I/O 开销比较大。</p><p>Index Lookup Join（ILJ）在 BNJ 的基础上使用了索引，执行过程：</p><ol><li>遍历 Outer 表，取一个批次的记录 ri；</li><li>通过连接键（Join Key）和 ri 可以确定对 Inner 表索引的扫描范围，再通过索引得到对应的若干条数据记录，记为 sj；</li><li>将 ri 的每一条记录与 sj 的每一条记录做 Join 操作并输出结果；</li><li>重复前三步，直到遍历完 Outer 表中的所有数据，就得到了最后结果集。
ILJ 的主要优化点很明显就是对 Inner 表进行索引扫描。BNJ 在 Inner 表上要做多次全表扫描成本最高，所以 Inner 表上使用索引的效果最显著，也就成为了算法的重点，而 Outer 表因为扫描结果集要放入内存中暂存，意味着它的记录数比较有限，索引带来的效果也就没有 Inner 表那么显著。</li></ol><h3 id=排序归并链接算法>排序归并链接算法</h3><p>排序归并算法就是 Sort-Merge Join（SMJ），也被称为 Merge Join。</p><p>SMJ 可以分为排序和归并两个阶段：</p><ol><li>对 Outer 表和 Inner 表进行排序，排序的依据就是每条记录在连接键上的数值。</li><li>归并，两张表已经按照同样的顺序排列，Outer 表和 Inner 表各一次循环遍历就能完成比对工作。
SMJ 就是先要把两个数据集合变成两个数据序列（有序的数据单元），然后再做循环比对。计算成本是两次排序再加两次循环。所以选择 SMJ 的前提是表的记录本身就是有序的，否则成本较高。而索引天然有序，如果表的连接键刚好是索引列，那么 SMJ 就是三种嵌套循环算法中成本最低的，它的时间复杂度只有 O(m+n)。</li></ol><h3 id=哈希连接算法>哈希连接算法</h3><p>哈希连接是一种分治思想，基本思想是取关联表的记录，计算连接键上数据项的哈希值，再根据哈希值映射为若干组，然后分组进行匹配。</p><p>常见的哈希连接算法有三种，分别是 Simple Hash Join、Grace Hash Join 和 Hybrid Hash Join。</p><h4 id=simple-hash-join>Simple Hash Join</h4><p>执行过程:</p><ol><li><p>建立阶段（Build Phase）
选择一张表作为 Inner 表，对其中每条记录上的连接属性（Join Attribute）使用哈希函数得到哈希值，从而建立一个哈希表。在计算逻辑允许的情况下，建立阶段选择数据量较小的表作为 Inner 表，以减少生成哈希表的时间和空间开销。</p></li><li><p>探测阶段（Probe Phase）
另一个表作为 Outer 表，扫描它的每一行并计算连接属性的哈希值，与建立阶段生成的哈希表进行对比。当然哈希值相等不代表连接属性相等，需要再做一次判断，返回最终满足条件的记录。</p></li></ol><p>这里做了非常理想化的假设，即 Inner 表形成的哈希表小到能够放入内存中。但实际上哈希表也有可能超过内存容量。所以引入了 Grace Hash Join 算法。</p><h4 id=grace-hash-join>Grace Hash Join</h4><p>GHJ 中的 Grace 并不是指某项技术，而是首个采用该算法的数据库名称。Grace 将哈希表分块缓存在磁盘上。</p><p>执行过程：</p><ol><li>Inner 表的记录会根据哈希值分成若干个块（Bucket）写入磁盘，每个 Bucket 必须小于内存容量。Outer 表也按照同样的方法被分为若干 Bucket 写入磁盘，但大小并不受到内存容量限制。</li><li>和 SHJ 类似，先将 Inner 表的 Bucket 加载到内存，再读取 Outer 表对应 Bucket 的记录进行匹配，所有 Inner 表和 Outer 表的 Bucket 都读取完毕后，就得到了最终的结果集。</li></ol><h4 id=hybrid-hash-join>Hybrid Hash Join</h4><p>也就是混合哈希，字面上是指 Simple Hash Join 和 Grace Hash Join 的混合。实际上主要是针对 Grace Hash Join 的优化，内存够用下，可以将 Inner 表的第一个 Bucket 和 Outer 表的第一个 Bucket 都保留在内存中，这样建立阶段一结束就可以进行匹配，节省了先写入磁盘再读取的两次 I/O 操作。</p><p>总体来说，哈希连接的核心思想和排序归并很相似，都是对内外表的记录分别只做一次循环。哈希连接算法不仅能够处理大小表关联，对提升大表之间关联的效率也有明显效果，但限制条件就是适用于等值连接。</p><h2 id=并行框架>并行框架</h2><h3 id=大小表关联-复制表>大小表关联（复制表）</h3><p>大小表关联时，可以把小表复制到相关存储节点，这样全局关联就被转换为一系列的本地关联，再汇总起来就得到了最终结果。</p><p>具体实现有静态和动态两种方式。</p><h4 id=静态方式>静态方式</h4><p>创建表时直接使用关键字将表声明为复制表，每个节点上都会保留一份数据副本。当与大表关联时，计算节点就可以将关联操作下推到每个存储节点进行。很多分布式数据库，比如 TBase、TDSQL 等，都支持定义复制表。</p><h4 id=动态方式>动态方式</h4><p>动态方式也称为“小表广播”，不需要人工预先定义，在关联发生时系统自行处理。当关联的某张表足够小时，在整个集群中分发不会带来太大的网络开销，系统就将其即时地复制到相关的数据节点上，实现本地关联。</p><h3 id=大表关联-重分布>大表关联（重分布）</h3><p>复制表解决了大小表关联的问题，还剩下最棘手的大表间关联，它的解决方案通常就是重分布。</p><p>例如，A、B 两张大表，c 作为关联字段。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>A</span>,<span style=color:#000>B</span> <span style=color:#a90d91>where</span> <span style=color:#000>A</span>.<span style=color:#a90d91>c</span> <span style=color:#000>=</span> <span style=color:#000>B</span>.<span style=color:#a90d91>c</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>那么可能引起两种不同的重分布操作：</p><ul><li>c 是 A 表的分区键，但不是 B 表的分区键，则 B 表按照 c 做重分布，推送到 A 的各个分片上，实现本地关联。</li><li>两张表的分区键都不是 c，则两张表都要按照 c 做重分布，然后在多个节点上再做本地关联。（执行代价很高）
重分布的思想和 MapReduce、Spark 等并行计算引擎一致，基本等同于 Shuffle 操作：</li></ul><ol><li>shuffle 阶段：分别将两个表按照连接键进行分区，将相同连接键的记录重分布到同一节点，数据就会被分配到尽量多的节点上，增大并行度。</li><li>hash join 阶段：每个分区节点上的数据单独执行单机 hash join 算法。</li></ol><h1 id=查询执行引擎>查询执行引擎</h1><h2 id=火山模型>火山模型</h2><p>火山模型（Volcano Model）也称为迭代模型（Iterator Model），是最著名的查询执行模型。1990 年提出，长期流行的查询执行模型，主流的 OLTP 数据库 Oracle、MySQL 都采用了这种模型。但面对海量数据时，火山模型有 CPU 使用率低的问题，性能有待提升。</p><p>火山模型中，一个查询计划会被分解为多个代数运算符（Operator）。每个 Operator 就是一个迭代器，都要实现一个 next() 接口，通常包括三个步骤：</p><ol><li>调用子节点 Operator 的 next() 接口，获取一个元组（Tuple）；</li><li>对元组执行 Operator 特定的处理；</li><li>返回处理后的元组。</li></ol><h3 id=优缺点>优缺点</h3><p>火山模型的优点是处理逻辑清晰，每个 Operator 只要关心自己的处理逻辑即可，耦合性低。但是它的缺点也非常明显，主要是两点：</p><ul><li>虚函数调用次数过多，造成 CPU 资源的浪费。</li><li>数据以行为单位进行处理，不利于发挥现代 CPU 的特性。</li></ul><h3 id=运算符融合>运算符融合</h3><p>最简单的方法就是减少执行过程中 Operator 的函数调用。通常来说 Project 和 Filter 都是常见的 Operator，在很多查询计划中都会出现。OceanBase1.0 就将两个 Operator 融合到了其它的 Operator 中。这样做有两个好处：</p><ul><li>降低了整个查询计划中 Operator 的数量，也就简化了 Operator 间的嵌套调用关系，最终减少了虚函数调用次数。</li><li>单个 Operator 的处理逻辑更集中，增强了代码局部性能力，更容易发挥 CPU 的分支预测能力。
火山模型仍有一些优化空间，比如运算符融合，可以适度减少虚函数调用，但提升空间有限。学术界提出的两种优化方案是向量化和代码生成。</li></ul><h3 id=分支预测能力>分支预测能力</h3><p>分支预测是指 CPU 执行跳转指令时的一种优化技术。当出现程序分支时 CPU 需要执行跳转指令，在跳转的目的地址之前无法确定下一条指令，就只能让流水线等待，这就降低了 CPU 效率。为了提高效率，设计者在 CPU 中引入了一组寄存器，用来专门记录最近几次某个地址的跳转指令。</p><p>当下次执行到这个跳转指令时，就可以直接取出上次保存的指令，放入流水线。等到真正获取到指令时，如果证明取错了则推翻当前流水线中的指令，执行真正的指令。</p><h2 id=向量化模型>向量化模型</h2><p>向量化模型就是一系列向量化运算符组成的执行模型。向量化模型首先在 OLAP 数据库和大数据领域广泛使用，配合列式存储取得很好的效果。虽然 OLTP 数据库的场景不适于列式存储，但将其与行式存储结合也取得了明显的性能提升。</p><p>向量化模型与火山模型的最大差异就是，其中的 Operator 是向量化运算符，是基于列来重写查询处理算法的。简单来说向量化模型是由一系列支持向量化运算的 Operator 组成的执行模型。</p><p>向量化模型依然采用了拉取式模型。和火山模型的唯一区别就是 Operator 的 next() 函数每次返回的是一个向量块，而不是一个元组。向量块是访问数据的基本单元，由固定的一组向量组成，这些向量和列 / 字段一一对应。</p><p>向量处理背后的主要思想是，按列组织数据和计算，充分利用 CPU，把从多列到元组的转化推迟到较晚的时候执行。这种方法在不同的操作符间平摊了函数调用的开销。</p><p>向量化模型首先在 OLAP 数据库中采用，与列式存储搭配使用可以获得更好的效果，例如 ClickHouse。</p><p>这里的分布式数据库都是面向 OLTP 场景的，不能直接使用列式存储。但是可以采用折中的方式来实现向量化模型，即在底层的 Operator 中完成多行到向量块的转化，上层的 Operator 都是以向量块作为输入。这样改造后即使是与行式存储结合，仍然能够显著提升性能。在 TiDB 和 CockroachDB 的实践中，性能提升可以达到数倍甚至数十倍。</p><h2 id=代码生成>代码生成</h2><p>与向量化模型并列的另一种高效查询执行引擎就是 代码生成。代码生成的全称是以数据为中心的代码生成（Data-Centric Code Generation），也被称为编译执行（Compilation）。</p><p>代码生成消除了火山模型中的大量虚函数调用，让大部分指令可以直接从寄存器取数，极大地提高了 CPU 的执行效率。</p><p>代码生成是现代编译器与 CPU 结合的产物，也可以大幅提升查询执行效率。代码生成的基础逻辑是，针对性的代码在执行效率上必然优于通用运算符嵌套。代码生成根据算法会被划分成多个在 Pipeline 执行的单元，提升 CPU 效率。代码生成有不同的粒度，包括整体代码生成和表达式代码生成，粒度越大实现难度越大。</p><h1 id=reference>Reference</h1><p><a href=https://www.cs.princeton.edu/courses/archive/fall10/cos597B/papers/percolator-osdi10.pdf>https://www.cs.princeton.edu/courses/archive/fall10/cos597B/papers/percolator-osdi10.pdf</a></p><p><a href=https://cse.buffalo.edu/~demirbas/publications/hlc.pdf>https://cse.buffalo.edu/~demirbas/publications/hlc.pdf</a></p><p><a href=http://cs.brown.edu/courses/cs296-2/papers/consistent.pdf>http://cs.brown.edu/courses/cs296-2/papers/consistent.pdf</a></p><p><a href=https://core.ac.uk/download/pdf/54846488.pdf>https://core.ac.uk/download/pdf/54846488.pdf</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca77ecfe7055a64123f8d65e4aa98106>2 - MySQL</h1><h1 id=introduction>Introduction</h1><p>MySQL</p></div><div class=td-content><h1 id=pg-3507a2142af71f2e761a63c984092b20>2.1 - 01.SQL查询流程</h1><blockquote><p>本文介绍 MySQL 的逻辑架构。如一条 SQL 查询语句的执行过程等。</p></blockquote><h1 id=逻辑架构>逻辑架构</h1><p>MySQL 的逻辑架构图</p><p><img src=../imgs/sql_process_20220409_1.png alt=sql_process_20220409_1.png></p><p>大体来说，MySQL 可以分为<strong>Server 层</strong>和<strong>存储引擎层</strong>两部分。</p><h2 id=server层>Server层</h2><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><h2 id=存储引擎层>存储引擎层</h2><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。</p><p>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。创建表时如果不指定引擎类型，默认使用的就是 InnoDB。指定引擎：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#000>engine</span><span style=color:#000>=</span>memory  <span style=color:#177500># 指定使用内存引擎创建表</span>
</span></span></code></pre></td></tr></table></div></div></div><p>不同存储引擎的表数据存取方式不同，支持的功能也不同。</p><h1 id=连接器>连接器</h1><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般写法：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql -h<span style=color:#000>$ip</span> -P<span style=color:#000>$port</span> -u<span style=color:#000>$user</span> -p
</span></span></code></pre></td></tr></table></div></div></div><p>连接命令 mysql 是客户端命令，完成 TCP 握手后，连接器会验证身份。如果身份不对会返回“Access denied for user”的错误。身份通过后，该连接的权限判断都依赖此时读取的权限（不会热更新权限）。
创建 2 个连接，如果都是空闲，使用其中一个连接 <code>show processlist</code></p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; show processlist;
</span></span><span style=display:flex><span>+----+------+-----------+------+---------+------+----------+------------------+
</span></span><span style=display:flex><span>| Id | User | Host      | db   | Command | Time | State    | Info             |
</span></span><span style=display:flex><span>+----+------+-----------+------+---------+------+----------+------------------+
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>4</span> | root | localhost | NULL | Sleep   |   <span style=color:#1c01ce>20</span> |          | NULL             |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>5</span> | root | localhost | NULL | Query   |    <span style=color:#1c01ce>0</span> | starting | show processlist |
</span></span><span style=display:flex><span>+----+------+-----------+------+---------+------+----------+------------------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>2</span> rows in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></div><p>可以看到 Command 列显示“Sleep”的行是一个空闲的连接。</p><h2 id=自动断开>自动断开</h2><p>客户端长时间没有动静，连接器会自动断开。由参数 wait_timeout 控制，默认 8 小时。</p><h2 id=长连接>长连接</h2><p>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，建议使用中尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p><p>解决方案：</p><p>1、定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p><p>2、使用 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p><h1 id=查询缓存>查询缓存</h1><p>连接建立完成后，就可以执行 select 语句。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，这个 value 就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。如果查询命中缓存，MySQL 不需要执行后面的复杂操作，直接返回结果，效率会很高。</p><p>但是建议不要使用查询缓存，往往弊大于利。</p><p>1、缓存需要语句完全相等，包括参数。</p><p>2、表更新后就会失效 因此，只有在表更新频率不高，查询语句完全一致的情况下，可以手动开启缓存，其他一律关闭。</p><p>( 注意：mysql8之后，取消了缓存功能。)</p><p>MySQL 也提供了这种“按需使用”的方式。将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; <span style=color:#a90d91>select</span> SQL_CACHE * from T where <span style=color:#000>ID</span><span style=color:#000>=</span>10；
</span></span></code></pre></td></tr></table></div></div></div><h1 id=分析器>分析器</h1><p>如果没有命中查询缓存，就要开始真正执行语句了。首先需要对 SQL 语句做解析。</p><h2 id=词法分析>词法分析</h2><p>分析器先会做“词法分析”。解析字符串分别是什么，代表什么。</p><p>词法分析的特征：</p><table><thead><tr><th style=text-align:left>词性</th><th style=text-align:left>内容</th></tr></thead><tbody><tr><td style=text-align:left>关键字</td><td style=text-align:left>select、from、where</td></tr><tr><td style=text-align:left>标志符</td><td style=text-align:left>id、name、age</td></tr><tr><td style=text-align:left>操作符</td><td style=text-align:left>=、>、&lt;</td></tr><tr><td style=text-align:left>常量</td><td style=text-align:left>1、2</td></tr></tbody></table><h2 id=语法分析>语法分析</h2><p>然后做“语法分析”。语法分析会根据词法分析获得的词来匹配语法规则，最终生成一个抽象语法树，每个词作为语法树的叶子节点出现。</p><p>根据语法规则，判断 SQL 语句是否满足语法。如果语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。</p><h2 id=语义分析>语义分析</h2><p>对语法树进行有效性检查，检查语法树中对应的表、列、函数、表达式是否有对应的元数据，将抽象语法树转换为逻辑执行计划（关系代数表达式）。</p><p>抽象语法树表达的寓意还仅仅限制在能够保证应用的 SQL 语句符合 SQL 标准的规范，但是对于 SQL 语句的内在含义还需要做有效性检查。</p><h1 id=优化器>优化器</h1><p>经过了分析器，MySQL 就知道要做什么。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定<strong>使用哪个索引</strong>；或者在一个语句有多表关联（join）的时候，决定<strong>各个表的连接顺序</strong>。</p><h1 id=执行器>执行器</h1><p>MySQL 通过分析器知道要做什么，通过优化器知道该怎么做，就进入了执行器阶段，开始执行语句。</p><p>首先判断执行权限。</p><p>然后继续执行。</p><p>如果没有索引，慢查询日志会有一个 <strong>row_examined 的字段，表示执行器获取到的数据行数，不是真正的扫描行数</strong>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3d3ec131c01cea7acbeed218bf2383b1>2.2 - 02.日志</h1><blockquote><p>本文介绍 MySQL 的日志，同时会介绍一个 SQL 更新语句的执行过程。</p></blockquote><h1 id=背景>背景</h1><p>SQL 更新语句和查询语句的大致流程类似，首先通过连接器连接数据库，然后分析器会通过词法和语法解析知道这是更新语句（跟这个表有关的查询缓存会失效）。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）</p><h1 id=名词介绍>名词介绍</h1><p><strong>物理/逻辑日志</strong></p><p>物理日志记录的是修改页的的详情，逻辑日志记录的是操作语句。物理日志恢复的速度快于逻辑日志。</p><h1 id=redo-log>redo log</h1><p>redo log 是<strong>事务日志、物理机日志</strong></p><p>先写日志再写磁盘的过程就是 WAL 技术（Write-Ahead Logging）。</p><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，此时更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><p>InnoDB 的 redo log 是固定大小的。如果 redo log 满了，就会将 redo log 中一部分的记录更新到磁盘，然后将这些记录从 redo log 中删除腾出空间。</p><p>redo log 大小固定，从头开始写，写到末尾会重头开始写。</p><p><img src=../imgs/mysql_log_20220409_1.png alt=mysql_log_20220409_1.png></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。</p><h2 id=redo-log作用>redo log作用</h2><p>保证事务的原子性和持久性。</p><p>redo log 是重做日记，属于 InnoDB 引擎的日志。</p><p>前滚操作：具备 crash-safe 能力，提供断电重启时解决事务丢失数据问题。</p><p>提高性能：先写 redo log记录更新。当等到有空闲线程、内存不足、redo log 满了时刷脏。写 redo log 是顺序写入，刷脏是随机写，节省的是随机写磁盘的 IO 消耗（转成顺序写），所以性能得到提升。此技术称为 WAL 技术：Write-Ahead Logging，它的关键点就是先写日记磁盘，再写数据磁盘。</p><h2 id=redo-log写入机制>redo log写入机制</h2><p>redo log 可能存在的三种状态，对应下图中的三个颜色块：</p><p><img src=../imgs/mysql_log_20220409_2.png alt=mysql_log_20220409_2.png></p><p>[MySQL redo log 存储状态]</p><p>这三种状态分别是：</p><p>1、存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中的红色部分；</p><p>2、写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面，也就是图中的黄色部分；</p><p>3、持久化到磁盘，对应的是 hard disk，也就是图中的绿色部分。</p><p>日志写到 redo log buffer 是很快的，wirte 到 page cache 也差不多，但是持久化到磁盘的速度就慢多了。</p><h3 id=redo-log持久化>redo log持久化</h3><p>为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值（默认为1）：</p><p>0 表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</p><p>1 表示每次事务提交时都将 redo log 直接持久化到磁盘；</p><p>2 表示每次事务提交时都只是把 redo log 写到 page cache。</p><p>InnoDB 有一个后台线程，每隔 1 秒就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</p><p>注意，事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。也就是一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。</p><p>实际除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中：</p><p>1、<strong>redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘</strong>。</p><p>注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。</p><p>2、<strong>并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘</strong>。</p><p>假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。</p><p>两阶段提交时序上 redo log 先 prepare， 再写 binlog，最后再把 redo log commit。如果把 innodb_flush_log_at_trx_commit 设置成 1，那么 redo log 在 prepare 阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于 prepare 的 redo log，再加上 binlog 来恢复的。</p><p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB 就认为 redo log 在 commit 时就不需要 fsync 了，只会 write 到文件系统的 page cache 中就够了。</p><p>通常 MySQL 的“双 1”配置，指 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p><h3 id=组提交-group-commit>组提交(group commit)</h3><p>MySQL 看到的 TPS 是每秒两万的话，每秒就会写四万次磁盘。但用工具测试，磁盘能力也就两万左右，怎么能实现两万的 TPS？</p><p>日志逻辑序列号（log sequence number，LSN）是单调递增的，用来对应 redo log 的一个个写入点。每次写入长度为 length 的 redo log， LSN 的值就会加上 length。</p><p>LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log。</p><p><img src=../imgs/mysql_log_20220409_3.png alt=mysql_log_20220409_3.png></p><p>[redo log组提交]</p><p>上图所示，三个并发事务 (trx1, trx2, trx3) 在 prepare 阶段，都写完 redo log buffer，持久化到磁盘的过程，对应的 LSN 分别是 50、120 和 160。</p><p>由图得到：</p><p>1、trx1 是第一个到达的，会被选为这组的 leader；</p><p>2、等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160；</p><p>3、trx1 去写盘的时候，带的就是 LSN=160，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘；</p><p>4、此时 trx2 和 trx3 就可以直接返回了。</p><p>所以一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p><p>在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。</p><p>为了让一次 fsync 带的组员更多，MySQL 有一个很有趣的优化：拖时间。</p><p>两阶段提交的过程：</p><p>1、写入 redo log，处于 prepare 阶段</p><p>2、写 binlog</p><p>3、提交事务，处于 commit 阶段</p><p>实际上，第 2 步写 binlog 是分为两步的：</p><p>1）先把 binlog 从 binlog cache 中写到磁盘上的 binlog 文件；</p><p>2）调用 fsync 持久化。</p><p>MySQL 为了让组提交的效果更好，把 redo log 做 fsync 的时间拖到了步骤 1 之后。也就是两阶段提交的细化过程：</p><p>1、redo log prepare; write</p><p>2、binlog; write</p><p>3、redo log prepare; fsync</p><p>4、binlog; fsync</p><p>5、redo log commit; write</p><p>不过通常情况下上面第 3 步执行得会很快，所以 binlog 的 write 和 fsync 间的间隔时间短，导致能集合到一起持久化的 binlog 比较少，因此 binlog 的组提交的效果通常不如 redo log 的效果那么好。</p><p>如果想提升 binlog 组提交的效果，可以通过设置 binlog_group_commit_sync_delay 或 binlog_group_commit_sync_no_delay_count 来实现。</p><p>1、binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</p><p>2、binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</p><p>每次提交事务都要写 redo log 和 binlog，WAL 机制主要得益于两个方面：</p><p>1、redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快；</p><p>2、组提交机制，可以大幅度降低磁盘的 IOPS 消耗。</p><p>如果出现了 IO 性能瓶颈，可以考虑以下几种方法：</p><p>1、设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</p><p>2、将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。风险：主机掉电会丢 binlog 日志。</p><p>3、将 innodb_flush_log_at_trx_commit 设置为 2。风险：主机掉电的时候会丢数据。</p><p>（不建议把 innodb_flush_log_at_trx_commit 设置成 0。因为这表示 redo log 只保存在内存，MySQL 本身异常重启也会丢数据风险太大。而 redo log 写到文件系统的 page cache 的速度也是很快的，所以将这个参数设置成 2 跟设置成 0 其实性能差不多，但这样做 MySQL 异常重启时就不会丢数据，相比之下风险更小。）</p><p>FAQ</p><p>1、执行 update 语句以后，再去执行 hexdump 命令直接查看 ibd 文件内容，没有看到数据有改变？</p><p>可能是因为 WAL 机制的原因。update 语句执行完成后，InnoDB 只保证写完了 redo log、内存，可能还没来得及将数据写到磁盘。</p><p>2、为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</p><p>这么设计的主要原因是，binlog 是不能“被打断的”。一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。</p><p>而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中。redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p><p>3、事务执行期间，没到提交阶段，如果发生 crash，redo log 丢了会不会导致主备不一致？</p><p>不会。因为这时候 binlog 也还在 binlog cache 里，没发给备库。crash 以后 redo log 和 binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。</p><p>4、binlog 写完盘后发生 crash，这时还没给客户端答复就重启。等客户端再重连进来，发现事务已经提交成功了，是 bug？</p><p>不是 bug。实际上数据库的 crash-safe 保证的是：</p><p>1、如果客户端收到事务成功的消息，事务一定持久化了；</p><p>2、如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了；</p><p>3、如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以。</p><p>联想更极端的情况，如果整个事务都提交了，从库也收到 binlog 并执行了，但主库和客户端网络断开，导致事务成功的包无法返回，那么这种也算事务成功执行的。</p><h2 id=flush>flush</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p><p>将脏页数据写到磁盘中。称作刷脏页（flush）。</p><h3 id=触发flush>触发flush</h3><p>1、redo log 空间满了。</p><p>2、系统内存不足。</p><p>需要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，需要先将脏页写到磁盘</p><p>3、系统“空闲”时。</p><p>4、MySQL正常关闭时。</p><p>下次启动时可以直接从磁盘读数据，启动速度更快。</p><p>针对第 1 种情况，要尽量避免，对性能影响较大。</p><p>针对第 2 种情况是常态。InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</p><p>1、还没有使用的；</p><p>2、使用了并且是干净页；</p><p>3、使用了并且是脏页。</p><p>InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</p><p>但是出现以下两种情况，会明显影响性能。</p><p>1、一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</p><p>2、日志写满，更新全部堵住，写性能跌为 0。</p><p>所以，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p><h3 id=flush控制策略>flush控制策略</h3><p>1、设置磁盘 IO 能力</p><p>通过 innodb_io_capacity 参数设置磁盘的 IO 能力，建议设置成磁盘的 IOPS。</p><p>fio 工具可以测试磁盘的 IOPS</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>fio -filename<span style=color:#000>=</span><span style=color:#000>$filename</span> -direct<span style=color:#000>=</span><span style=color:#1c01ce>1</span> -iodepth <span style=color:#1c01ce>1</span> -thread -rw<span style=color:#000>=</span>randrw -ioengine<span style=color:#000>=</span>psync -bs<span style=color:#000>=</span>16k -size<span style=color:#000>=</span>500M -numjobs<span style=color:#000>=</span><span style=color:#1c01ce>10</span> -runtime<span style=color:#000>=</span><span style=color:#1c01ce>10</span> -group_reporting -name<span style=color:#000>=</span>mytest 
</span></span></code></pre></td></tr></table></div></div></div><p>2、脏页比例</p><p>参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%。</p><p><strong>脏页比例</strong>是通过 Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total 得到的，命令参考：</p><p>从mysql5.7.6开始information_schema.global_status已经开始被舍弃，为了兼容性，此时需要打开 show_compatibility_56</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>show</span> <span style=color:#000>variables</span> <span style=color:#a90d91>like</span> <span style=color:#c41a16>&#39;%show_compatibility_56%&#39;</span>; <span style=color:#000>#</span> <span style=color:#000>查看状态</span>
</span></span><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#000>方法</span><span style=color:#1c01ce>1</span><span style=color:#000>：临时打开</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#a90d91>global</span> <span style=color:#000>show_compatibility_56</span><span style=color:#000>=</span><span style=color:#a90d91>on</span>;
</span></span><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#000>方法</span><span style=color:#1c01ce>2</span><span style=color:#000>：永久打开</span>
</span></span><span style=display:flex><span><span style=color:#000>vim</span> <span style=color:#000>/</span><span style=color:#000>etc</span><span style=color:#000>/</span><span style=color:#000>my</span>.<span style=color:#000>cnf</span>
</span></span><span style=display:flex><span><span style=color:#000>show_compatibility_56</span> <span style=color:#000>=</span> <span style=color:#1c01ce>1</span>  <span style=color:#000>#</span> <span style=color:#000>添加该行</span>
</span></span></code></pre></td></tr></table></div></div></div><p>查看脏页比例命令：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>use</span> <span style=color:#000>information_schema</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>VARIABLE_VALUE</span> <span style=color:#a90d91>into</span> <span style=color:#000>@</span><span style=color:#000>a</span> <span style=color:#a90d91>from</span> <span style=color:#000>global_status</span> <span style=color:#a90d91>where</span> <span style=color:#000>VARIABLE_NAME</span> <span style=color:#000>=</span> <span style=color:#c41a16>&#39;Innodb_buffer_pool_pages_dirty&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>VARIABLE_VALUE</span> <span style=color:#a90d91>into</span> <span style=color:#000>@</span><span style=color:#000>b</span> <span style=color:#a90d91>from</span> <span style=color:#000>global_status</span> <span style=color:#a90d91>where</span> <span style=color:#000>VARIABLE_NAME</span> <span style=color:#000>=</span> <span style=color:#c41a16>&#39;Innodb_buffer_pool_pages_total&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>@</span><span style=color:#000>a</span><span style=color:#000>/@</span><span style=color:#000>b</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><p>3、刷脏页速度</p><p>InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字 F1(M)，计算这个数字的伪代码类似这样：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>F1</span>(<span style=color:#000>M</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a90d91>if</span> <span style=color:#000>M</span><span style=color:#000>&gt;=</span><span style=color:#000>innodb_max_dirty_pages_pct</span> <span style=color:#000>then</span>
</span></span><span style=display:flex><span>      <span style=color:#a90d91>return</span> <span style=color:#1c01ce>100</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>return</span> <span style=color:#1c01ce>100</span><span style=color:#000>*</span><span style=color:#000>M</span><span style=color:#000>/</span><span style=color:#000>innodb_max_dirty_pages_pct</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></div><p>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，假设为 N。InnoDB 根据 N 算出一个范围在 0 到 100 之间的数字，计算公式可以 F2(N)。这个算法比较复杂， N 越大值越大。</p><p>根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。</p><p>4、刷新相邻页面策略</p><p>一旦一个查询请求需要在执行过程中先 flush 掉一个脏页时，该查询可能比平时慢。</p><p>而 MySQL 中的一个机制，可能会让查询更慢：</p><p>在准备刷一个脏页时，如果该数据页旁边的数据页刚好是脏页，就会把这个“邻居”一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，即对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</p><p>InnoDB 中，innodb_flush_neighbors 参数用来控制该行为，值为 1 时会有上述的“连坐”机制，开启脏页相邻淘汰，值为 0 时表示关闭脏页相邻淘汰。（MySQL 8.0中，默认 0）</p><p>找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机 IO。机械硬盘的随机 IOPS 一般只有几百，相同的逻辑操作减少随机 IO 就意味着系统性能的大幅度提升。</p><p>SSD IOPS 值有上千，建议设置该参数为 0。</p><h1 id=binlog>binlog</h1><p>MySQL 整体来看分为两块：Server 层主要做的是功能层面的事情；引擎层负责存储相关的具体事宜。redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><h2 id=为什么会有两份日志>为什么会有两份日志</h2><p>最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p><h2 id=binlog写入机制>binlog写入机制</h2><p>写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p><p>一个事务的 binlog 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。涉及到 binlog cache 的保存问题。</p><p>系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><p>事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。</p><p><img src=../imgs/mysql_log_20220409_4.png alt=mysql_log_20220409_4.png></p><p>[binlog写盘状态]</p><p>可以看到，每个线程有自己的 binlog cache，但是共用同一份 binlog 文件。上图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下认为 fsync 才占磁盘的 IOPS。</p><h3 id=binlog持久化>binlog持久化</h3><p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p><p>1、sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</p><p>2、sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</p><p>3、sync_binlog=N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</p><p>出现 IO 瓶颈时，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，常见将其设置为 100~1000 中的某个数值。</p><p>将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。</p><h2 id=binlog日志格式>binlog日志格式</h2><p>statement：记录执行的 SQL 语句。</p><p>row：会记录行的内容（包括 id），记两条，更新前和更新后都有。</p><p>mixed：以上两种混合，可以利用 statment 格式的优点，同时又避免了数据不一致的风险。</p><p>mixed 格式存在的场景：</p><p>1、有些 statement 格式的 binlog 可能会导致主备不一致，所以要使用 row 格式。原因：如果 where 条件中有多个索引，主备库在执行这条语句时，选择的索引可能不同执行结果也就不同。</p><p>2、row 格式的缺点是很占空间。比如一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式就要把这 10 万条记录都写到 binlog 中。这样不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</p><p>3、折中方案，MySQL 会判断 SQL 语句是否可能引起主备不一致，如果可能就用 row 格式，否则就用 statement 格式。</p><p>现在越来越多的场景要求把 MySQL 的 binlog 格式设置成 row。比如恢复数据。row 格式记录了操作前后的数据，可以直接恢复。</p><p>由 delete、insert 或者 update 语句导致的数据操作错误，需要恢复到操作之前状态的情况，也时有发生。MariaDB 的 <a href=https://mariadb.com/kb/en/library/flashback>Flashback</a> 工具就是基于这种原理来回滚数据的。</p><p>mix 格式举例：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>10</span>,<span style=color:#1c01ce>10</span>, <span style=color:#000>now</span>());
</span></span></code></pre></td></tr></table></div></div></div><p>查看 binlog 日志是 statement 格式。
mysqlbinlog 工具查看，原来 binlog 在记录 event 的时候，多记了一条命令：SET TIMESTAMP=1546103491。它用 SET TIMESTAMP 命令约定了接下来的 now() 函数的返回时间。</p><p>因此，得出结论：重放 binlog 数据，将 statement 语句直接拷贝出来执行有很大风险。</p><p>标准做法：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysqlbinlog master.000001  --start-position<span style=color:#000>=</span><span style=color:#1c01ce>2738</span> --stop-position<span style=color:#000>=</span><span style=color:#1c01ce>2973</span> | mysql -h127.0.0.1 -P13000 -u<span style=color:#000>$user</span> -p<span style=color:#000>$pwd</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>(将 master.000001 文件里面从第 2738 字节到第 2973 字节中间这段内容解析出来，放到 MySQL 去执行。)</p><h1 id=undo-log>undo log</h1><p>(逻辑日志)——记录相反的sql语句</p><p>1、保证事务的一致性</p><p>2、InnoDB的MVCC</p><h2 id=存储结构>存储结构</h2><h3 id=回滚段与undo页>回滚段与undo页</h3><p>undo日志的结构由<strong>回滚段</strong>和<strong>undo页</strong>组成</p><ul><li>undo日志中的空间划分为一个个的段，称为回滚段（rollback segment），共有128个段，每个段中有1024个undo页</li><li>undo页可以重复使用，如果当前事务写入的记录小于页空间的3/4，那其他事务可以继续写入。</li></ul><h3 id=回滚段与事务>回滚段与事务</h3><ul><li>每个事务只能用一个回滚段，一个回滚段可以在同一时刻服务于多个事务</li><li>事务开始时会制定一个回滚段，事务进行中当数据被修改时，原始数据会比复制到回滚段</li></ul><h3 id=undo页重用>undo页重用</h3><p>开启的事务需要写 undo log 时，先去 undo log segment 中申请 undo 页（MySQL中默认一页是16k），如果每个事务分配一个页非常浪费（除非事务写数据非常大），TPS为1000，每秒需要 1000*16k=16M 的空间，每分钟需要 1G，很多空间都被浪费了。所以undo页被设计成<strong>重用</strong>的。</p><p>事务提交时并不会立刻删除undo页，因为重用使得该undo页中可能混杂着其它事务的undo log，undo log在commit后会被放到一个链表中，undo页使用空间如果小于3/4，表示可以重用而不会被回收，其它事务的undo log可以记录在当前undo页之后。</p><p>undo log是离散的，因此清理对应的磁盘空间效率不高。</p><h2 id=类型>类型</h2><p><strong>插入页</strong>：在进行insert操作时产生的日志记录，由于insert只有事务本身可见，其他事务不可见，所以事务提交后insert日志页可以直接删除，不需要purge操作。</p><p><strong>更新页</strong>：在进行删除或更新时产生的日志记录。更新页需要参与多版本机制（MVCC）,所以事务提交后一般不会删除，会放入链表，等待purge线程清除。</p><h2 id=数据更新流程>数据更新流程</h2><p>Buffer Pool、Redo、Undo日志的情况下，更新一次数据流程：</p><ol><li>发起更新数据请求</li><li>Buffer Pool中没有数据则从磁盘中加载</li><li>记录undo log</li><li>执行器更新数据</li><li>写入 redo log Buffer</li><li>写入 redo log 到文件</li><li>写入 binlog 到文件</li></ol><h1 id=日志对比>日志对比</h1><h2 id=redo-log与binlog对比>redo log与binlog对比</h2><table><thead><tr><th style=text-align:left></th><th style=text-align:left>redo log</th><th style=text-align:left>binlog</th></tr></thead><tbody><tr><td style=text-align:left>日志类型</td><td style=text-align:left>物理日志</td><td style=text-align:left>逻辑日志</td></tr><tr><td style=text-align:left>文件大小</td><td style=text-align:left>大小固定</td><td style=text-align:left>可通过参数max_binlog_size设置每个binlog文件的大小</td></tr><tr><td style=text-align:left>实现方式</td><td style=text-align:left>由innodb引擎层实现，不是所有引擎都有</td><td style=text-align:left>由service层实现，所有引擎都可以使用</td></tr><tr><td style=text-align:left>记录</td><td style=text-align:left>采用循环写的方式记录，当写到结尾时，会回到开头循坏写日志</td><td style=text-align:left>通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td></tr><tr><td style=text-align:left>适用场景</td><td style=text-align:left>适用于崩溃恢复（crash-safe）</td><td style=text-align:left>适用于主从复制和数据恢复</td></tr></tbody></table><h1 id=update语句执行流程>update语句执行流程</h1><p>update 语句：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; update T <span style=color:#a90d91>set</span> <span style=color:#000>c</span><span style=color:#000>=</span>c+1 where <span style=color:#000>ID</span><span style=color:#000>=</span>2;
</span></span></code></pre></td></tr></table></div></div></div><p>1、执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2、执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p><p>3、引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</p><p>4、执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</p><p>5、执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</p><p>update 语句执行流程图</p><p><img src=../imgs/mysql_log_20220409_5.png alt=mysql_log_20220409_5.png>
<img src=../imgs/mysql_log_20220409_6.png alt=mysql_log_20220409_6.png></p><h1 id=两阶段提交>两阶段提交</h1><p>更新内存后引擎层写 Redo log 将状态改成 prepare 为预提交第一阶段，Server 层写 Binlog，将状态改成 commit为提交第二阶段。两阶段提交可以确保 Binlog 和 Redo log 数据一致性。</p><h2 id=数据备份同步>数据备份同步</h2><p>1、找到最近时间的全量备份；</p><p>2、基于备份的时间点重放 binlog。</p><h2 id=容灾恢复过程>容灾恢复过程</h2><p>1、判断 redo log 是否完整，如果判断是完整（commit）的，直接用 Redo log 恢复</p><p>2、如果 redo log 只是预提交 prepare 但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 Redo log，用 redo log 恢复，不完整就回滚事务，丢弃数据。</p><p><strong>只有在 redo log 状态为 prepare 时，才会去检查 binlog 是否存在，否则只校验 redo log 是否是 commit 就可以啦。</strong></p><p>怎么检查 binlog：一个完整事务 binlog 结尾有固定的格式。</p><p>1、statement 格式的 binlog，最后会有 COMMIT；</p><p>2、row 格式的 binlog，最后会有一个 XID event。</p><p>另外，在 MySQL 5.6.2 版本以后，还引入了 binlog-checksum 参数，用来验证 binlog 内容的正确性。</p><h2 id=两阶段提交分析>两阶段提交分析</h2><p>1、先写 redo log 后写 binlog。</p><p>假设 redo log 写完，binlog 还没写完。系统异常重启，那么系统仍然可以根据 redo log 将数据恢复。</p><p>但是 binlog 没有写完就 crash 了，没有该更新记录。因此之后备份数据恢复的时候，自然也没有该更新记录。使用 binlog 恢复临时库就会发生与原库数据不同的问题。</p><p>2、先写 binlog 后写 redo log</p><p>假设 binlog 写完，redo log 还没写完。系统异常重启，因为 redo log 中没有该更新记录，库中的记录还是原来的值。但是 binlog 已经存在更新记录，所以之后用 binlog 恢复临时库该记录就是新的值，与原库数据不同。</p><p>鉴此，两阶段提交可以保证 redo log 和 binlog 数据的一致性。即两个日志都可以表示事物的提交状态。</p><h1 id=change-buffer>change buffer</h1><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作直接缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页再更新了。</p><p><strong>「change buffer 主要节省的则是随机读磁盘的 IO 消耗」</strong>，下次查询读取数据页时用上 change buffer 中的记录即可。</p><p>change buffer 可以持久化，在内存中有拷贝，也会被写入到磁盘上。</p><p>将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会明显提升。而且，数据读入内存是需要占用 buffer pool 的，所以还能够避免占用内存，提高内存利用率。</p><h2 id=merge>merge</h2><p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p><h2 id=cb使用条件>cb使用条件</h2><p>唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</p><p>因为对于唯一索引来说，所有的更新操作都要先判断操作是否违反唯一性约束。必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p><h2 id=cb限制>cb限制</h2><p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。</p><p>change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p><h2 id=cb插入数据流程>cb插入数据流程</h2><h3 id=目标页在内存中>目标页在内存中</h3><ul><li>对于唯一索引，目标页在内存中，直接判断唯一索引值是否冲突，然后插入数据，语句执行结束</li><li>对于普通索引，找到目标页中插入数据的位置，插入该记录，语句执行结束</li></ul><h3 id=目标页不在内存中>目标页不在内存中</h3><ul><li>对于唯一索引，需要将数据页读入内存，判断是否冲突，然后插入数据，语句执行结束</li><li>对于普通索引，将记录插入 change buffer，语句执行结束</li></ul><h2 id=cb使用场景>cb使用场景</h2><p>首先，change buffer 只限于用在普通索引的场景下，而不适用于唯一索引。</p><p>其次，因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p><p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>相反，如果一个业务是写入数据后立即查询，会触发 merge 过程，随机访问 IO 的次数不会减少，且会增加 change buffer 的维护代价。这种业务下 change buffer 反而起到了副作用。</p><h1 id=日志延伸>日志延伸</h1><h2 id=change-buffer-和-redo-log><strong>change buffer 和 redo log</strong></h2><p>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</p><p>redo log 与 change buffer (含磁盘持久化) 这 2 个机制，不同之处在于优化了整个变更流程的不同阶段。</p><p>先不考虑这二者机制，简化抽象一个更新 (insert、update、delete) 流程：</p><p>1、从磁盘读取待变更的行所在的数据页，读入内存页中</p><p>2、对内存页中的行，执行变更操作</p><p>3、将变更后的数据页，写入至数据磁盘中</p><p>其中，流程中的步骤 1 涉及随机读磁盘 IO；步骤 3 涉及随机写磁盘 IO；刚好对应 change buffer 和 redo log。</p><p>根据以上流程得出结论：</p><p>1、change buffer 机制，优化了步骤 1——避免了随机读磁盘 IO ，将不在内存中的数据页的操作写入 change buffer 中，而不是将数据页从磁盘读入内存页中</p><p>2、redo log 机制， 优化了步骤 3——避免了随机写磁盘 IO，将随机写磁盘，优化为了顺序写磁盘(写 redo log，确保 crash-safe)</p><p>change buffer 机制不是一直会被应用到，仅当待操作的数据页当前不在内存中，需要先读磁盘加载数据页时，change buffer 才有用武之地。而 redo log 机制，为了保证 crash-safe 会一直被用到。</p><h2 id=checkpoint>checkpoint</h2><p>redo log中带有checkpoint,用来高效的恢复数据.</p><h1 id=最佳实践>最佳实践</h1><h2 id=flush案例>flush案例</h2><p>一个内存配置为 128GB、innodb_io_capacity 设置为 20000 的大规格实例，正常会建议将 redo log 设置成 4 个 1GB 的文件。</p><p>如果配置时不慎将 redo log 设置成了 1 个 100M 的文件，会发生的情况及原因？</p><p>每次事务提交都要写 redo log，如果设置太小很快就会被写满，write pos 一直追着 checkpoint。</p><p>此时系统不得不停止所有更新去推进 checkpoint。</p><p>现象：磁盘压力很小，数据库出现间歇性的性能下跌。</p><h2 id=生产库非双1场景>生产库非双1场景</h2><p>通常 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p><p>非双1场景有如下：</p><p>1、业务高峰期。一般如果有预知的高峰期，DBA 会有预案，把主库设置成“非双 1”。</p><p>2、备库延迟，为了让备库尽快赶上主库。</p><p>3、用备份恢复主库的副本，应用 binlog 的过程，跟第 2 个场景类似。</p><p>4、批量导入数据的时候。</p><p>一般情况下，把生产库改成“非双 1”配置，是设置 innodb_flush_logs_at_trx_commit=2、sync_binlog=1000。</p><h1 id=日志faq>日志FAQ</h1><h2 id=red-log和binlog关联>red log和binlog关联</h2><p>它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p><p>1、如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</p><p>2、如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</p><h2 id=两阶段提交的必要性>两阶段提交的必要性</h2><p>处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，为什么还要两阶段提交？</p><p>两阶段提交是经典的分布式系统问题，并不是 MySQL 独有的。</p><p>两阶段提交的必要性，是事务的持久性问题。</p><p>对于 InnoDB 引擎来说，如果 redo log 提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果 redo log 直接提交，然后 binlog 写入的时候失败，InnoDB 又回滚不了，数据和 binlog 日志又不一致了。两阶段提交就是为了进可攻退可守。</p><h2 id=redo-log一般设置多大>redo log一般设置多大</h2><p>redo log 太小会导致很快就被写满，不得不强行刷 redo log，这样 WAL 机制的能力就发挥不出来。</p><p>现在常见的几个 TB 的磁盘的话，可以直接将 redo log 设置为 4 个文件、每个文件 1GB 。</p><h2 id=redo-log最终落盘>redo log最终落盘</h2><p>正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？</p><p>涉及 redo log 里面是什么。</p><p>redo log 记录了"在某个数据页上做了什么修改"，而不是"这个数据修改后最新的值"。因此是需要先把磁盘的数据读入内存再执行 redo log 中的内容。</p><p>1、正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系；</p><p>2、崩溃恢复场景中，InnoDB 如果判断一个数据页可能在崩溃恢复时丢失了更新，会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第 1 种情况的状态。</p><h2 id=redo-log-buffer是什么>redo log buffer是什么</h2><p>先修改内存，还是先写 redo log 文件？</p><p>插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到 redo log 文件里。</p><p>所以 redo log buffer 就是一块内存，用来先存 redo 日志。即在执行更新操作时（未 commit），数据的内存被修改了，redo log buffer 也写入了日志。</p><p>但是，真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的。</p><h1 id=reference>Reference</h1><p><a href=https://bbs.huaweicloud.com/blogs/200758>https://bbs.huaweicloud.com/blogs/200758</a></p><p><a href=https://mp.weixin.qq.com/s/e082trAojq6wu_SvTVPrsg>https://mp.weixin.qq.com/s/e082trAojq6wu_SvTVPrsg</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-57b43e076e15600ed34422d1ac7278e3>2.3 - 02.日志扩展-主从架构</h1><blockquote><p>本文介绍基于 MySQL 的日志的主从架构</p></blockquote><h1 id=主从同步>主从同步</h1><p>从库和备库在概念上其实差不多。有的地方会把在 HA 过程中被选成新主库的，称为备库，其他的称为从库。</p><h2 id=从库readonly>从库readonly</h2><p>建议把从库设置成只读（readonly）模式。有以下几个考虑：</p><p>1、一些运营类查询语句可能会被放到从库上去查，设置为只读可以防止误操作；</p><p>2、防止切换逻辑有 bug，比如切换过程中出现双写，造成主从不一致；</p><p>3、可以用 readonly 状态，来判断节点的角色。</p><p>把从库设置成只读了，如何跟主库保持同步更新？readonly 设置对超级 (super) 权限用户是无效的，而用于同步更新的线程拥有超级权限。</p><h2 id=主从同步流程>主从同步流程</h2><p><img src=../imgs/master_slave_20220409_1.png alt=master_slave_20220409_1.png></p><p>[主从同步流程图]</p><p>从库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务从库 B 的这个长连接。一个事务日志同步的完整过程是这样的：</p><p>1、在从库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</p><p>2、在从库 B 上执行 start slave 命令，这时候从库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</p><p>3、主库 A 校验完用户名、密码后，开始按照从库 B 传过来的位置，从本地读取 binlog，发给 B。</p><p>4、从库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</p><p>5、sql_thread 读取中转日志，解析出日志里的命令，并执行。</p><p>由于多线程复制方案的引入，sql_thread 后来演化成为了多个线程。</p><h2 id=循环复制问题>循环复制问题</h2><p>（建议把参数 log_slave_updates 设置为 on，表示从库执行 relay log 后生成 binlog）</p><p>双节点双主库可能存在循环使用 binlog 同步数据的情况，可以通过 server id 解决，有如下规定：</p><p>1、规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主从关系；</p><p>2、一个从库接到 binlog 并在重放过程中，生成与原 binlog 的 server id 相同的新的 binlog；</p><p>3、每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</p><p>但这个机制其实并不完备，在某些场景下还是有可能出现死循环。比如：</p><p>1、在一个主库更新事务后，用命令 set global server_id=x 修改了 server_id。等日志再传回来的时候，发现 server_id 跟自己的 server_id 不同就只能执行了。</p><p>2、三个节点复制的场景，如 server id 是 B 节点产生的，binlog 传给 A 执行，然后 A 又和 A1 形成双 M 结构，就会出现循环复制。</p><p>数据迁移时会遇到这种三节点循环复制的问题，可以临时在迁移后的节点上（比如上面的 A 或 A1 ）执行：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>stop</span> <span style=color:#000>slave</span><span style=color:#000>；</span>
</span></span><span style=display:flex><span><span style=color:#000>CHANGE</span> <span style=color:#000>MASTER</span> <span style=color:#a90d91>TO</span> <span style=color:#000>IGNORE_SERVER_IDS</span><span style=color:#000>=</span>(<span style=color:#000>server_id_of_B</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>start</span> <span style=color:#000>slave</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>这样这个节点收到日志后就不会再执行。数据迁移完后，再执行下面的命令把改回来：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>stop</span> <span style=color:#000>slave</span><span style=color:#000>；</span>
</span></span><span style=display:flex><span><span style=color:#000>CHANGE</span> <span style=color:#000>MASTER</span> <span style=color:#a90d91>TO</span> <span style=color:#000>IGNORE_SERVER_IDS</span><span style=color:#000>=</span>();
</span></span><span style=display:flex><span><span style=color:#a90d91>start</span> <span style=color:#000>slave</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><h1 id=主从延迟>主从延迟</h1><p>MySQL 要提供高可用能力，只有最终一致性是不够的。</p><p>主从切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电。</p><h2 id=延迟时间计算>延迟时间计算</h2><p>与数据同步有关的时间点主要包括以下三个：</p><p>1、主库 A 执行完成一个事务，写入 binlog，我们把这个时刻记为 T1；</p><p>2、之后传给从库 B，我们把从库 B 接收完这个 binlog 的时刻记为 T2；</p><p>3、从库 B 执行完成这个事务，我们把这个时刻记为 T3。</p><p>主从延迟就是同一个事务，在从库执行完成的时间和主库执行完成的时间之间的差值，也就是 T3-T1。</p><p>在从库上执行 <code>show slave status</code> 命令，返回结果里面会显示 seconds_behind_master，用于表示当前从库延迟了多少秒。seconds_behind_master 的计算方法是这样的：</p><p>1、每个事务的 binlog 里面都有一个时间字段，用于记录主库上写入的时间；</p><p>2、从库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 seconds_behind_master。</p><p>主从库机器的系统时间设置不一致，不会影响该值。因为，从库连接到主库时，会通过执行 SELECT UNIX_TIMESTAMP() 函数来获得当前主库的系统时间。如果发现主库的系统时间与自己不一致，从库在执行 seconds_behind_master 计算的时候会自动扣掉这个差值。</p><h2 id=主从延迟原因>主从延迟原因</h2><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即 T2-T1 的值是非常小的。也就是说，网络正常情况下，主从延迟的主要来源是从库接收完 binlog 和执行完这个事务之间的时间差。</p><p>主从延迟最直接的表现是，从库消费中转日志（relay log）的速度，比主库生产 binlog 的速度要慢。可能是由以下原因导致的。</p><h3 id=从库机器性能差>从库机器性能差</h3><p>比如将众多从库都放在同一台机器上。</p><p>更新请求对 IOPS 的压力，在主库和从库上是无差别的。做这种部署时，一般都会将从库设置为“非双 1”的模式。</p><p>但实际上更新过程中也会触发大量的读操作。所以，当从库主机上的多个从库都在争抢资源的时候，就可能会导致主从延迟了。</p><p>一般比较常见是主从库机器相同，因为主从可能发生切换，从库随时可能变成主库，所以主从库选用相同规格的机器，并且做对称部署。</p><h3 id=从库压力大>从库压力大</h3><p>由于主库直接影响业务，使用起来会比较克制，反而忽视了从库的压力控制。结果就是，从库上的查询耗费了大量的 CPU 资源，影响了同步速度，造成主从延迟。如一些运营后台需要的分析语句。</p><p>处理方法：</p><p>1、一主多从。除了从库外，可以多接几个从库，让这些从库来分担读的压力。</p><p>2、通过 binlog 输出到外部系统，比如 Hadoop 这类系统，让外部系统提供统计类查询的能力。</p><h3 id=大事务>大事务</h3><p>主库上必须等事务执行完成才会写入 binlog，再传给从库。所以如果一个主库上的语句执行 10 分钟，那这个事务很可能就会导致从库延迟 10 分钟。比如一个典型的大事务场景：不要一次性地用 delete 语句删除太多数据。</p><h3 id=大表ddl>大表DDL</h3><p>处理方案就是计划内的 DDL，建议使用 gh-ost 方案</p><h3 id=从库并行复制能力>从库并行复制能力</h3><h2 id=应对策略>应对策略</h2><p><img src=../imgs/master_slave_20220409_2.png alt=master_slave_20220409_2.png></p><p>[主从切换流程-双 M 结构]</p><h3 id=可靠性优先策略>可靠性优先策略</h3><p>在 [主从切换流程-双 M 结构] 下，从状态 1 到状态 2 切换的详细过程是这样的：</p><p>1、判断从库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；</p><p>2、把主库 A 改成只读状态，即把 readonly 设置为 true；</p><p>3、判断从库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止；</p><p>4、把从库 B 改成可读写状态，也就是把 readonly 设置为 false；</p><p>5、把业务请求切到从库 B。</p><p>这个切换流程，一般是由专门的 HA 系统来完成的，暂时称之为可靠性优先流程。</p><p><img src=../imgs/master_slave_20220409_3.png alt=master_slave_20220409_3.png></p><p>[可靠性优先主从切换流程]</p><p>这个切换流程中是有不可用时间的。因为在步骤 2 之后，主库 A 和从库 B 都处于 readonly 状态，也就是说这时系统处于不可写状态，直到步骤 5 完成后才能恢复。</p><h3 id=可用性优先策略>可用性优先策略</h3><p>如果强行把步骤 4、5 调整到最开始执行，也就是说不等主从数据同步，直接把连接切到从库 B，并且让从库 B 可以读写，那么系统几乎就没有不可用时间了。</p><p>这个切换流程暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。分析如下：</p><p>表：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#000>unsigned</span> <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span> <span style=color:#000>AUTO_INCREMENT</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#000>unsigned</span> <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t</span>(<span style=color:#a90d91>c</span>) <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>1</span>),(<span style=color:#1c01ce>2</span>),(<span style=color:#1c01ce>3</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>这个表定义了一个自增主键 id，初始化数据后，主库和从库上都是 3 行数据。接下来继续在表 t 上执行两条插入语句的命令，依次是：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t</span>(<span style=color:#a90d91>c</span>) <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>4</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t</span>(<span style=color:#a90d91>c</span>) <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>5</span>);
</span></span></code></pre></td></tr></table></div></div></div></p><p>假设现在主库上其他的数据表有大量的更新，导致主从延迟达到 5 秒。在插入一条 c=4 的语句后，发起了主从切换。
<strong>binlog 为 mixed 格式流程</strong></p><p><img src=../imgs/master_slave_20220409_4.png alt=master_slave_20220409_4.png></p><p>[可用性优先策略流程] （binlog_format=mixed）</p><p>切换流程：</p><p>1、步骤 2 中，主库 A 执行完 insert 语句，插入了一行数据（4,4），之后开始进行主从切换。</p><p>2、步骤 3 中，由于主从之间有 5 秒的延迟，所以从库 B 还没来得及应用“插入 c=4”这个中转日志，就开始接收客户端“插入 c=5”的命令。</p><p>3、步骤 4 中，从库 B 插入了一行数据（4,5），并且把这个 binlog 发给主库 A。</p><p>4、步骤 5 中，从库 B 执行“插入 c=4”这个中转日志，插入了一行数据（5,4）。而直接在从库 B 执行的“插入 c=5”这个语句，传到主库 A，就插入了一行新数据（5,5）。</p><p>最后的结果就是，主库 A 和从库 B 上出现了两行不一致的数据。可以看到，这个数据不一致，是由可用性优先流程导致的。</p><p>binlog 为 row 格式流程：</p><p><img src=../imgs/master_slave_20220409_5.png alt=master_slave_20220409_5.png></p><p>[可用性优先策略流程] （binlog_format=row）</p><p>因为 row 格式在记录 binlog 的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。而且，两边的主从同步的应用线程会报错 duplicate key error 并停止。也就是说，这种情况下，从库 B 的 (5,4) 和主库 A 的 (5,5) 这两行数据，都不会被对方执行。</p><p>结论：</p><p>1、使用 row 格式的 binlog 时，数据不一致的问题更容易被发现。而使用 mixed 或者 statement 格式的 binlog 时，数据不一致很难发现且随着时间推移可能会造成更多数据逻辑不一致。</p><p>2、主从切换的可用性优先策略会导致数据不一致。大多数情况下建议使用可靠性优先策略。一般对数据服务来说，数据的可靠性一般优于可用性的。</p><p>可用性优先级更高的场景：</p><p>有个库的作用是记录操作日志。如果数据不一致可以通过 binlog 来修补，而这个短暂的不一致也不会引发业务问题。同时，业务系统依赖于这个日志写入逻辑，如果库不可写会导致线上的业务操作无法执行。</p><p>MySQL 的高可用性，依赖于主从延迟。主从延迟的时间越小，出现故障的时候，服务需要恢复的时间就越短，可用性就越高。</p><h1 id=从库并行复制>从库并行复制</h1><p><img src=../imgs/master_slave_20220409_6.png alt=master_slave_20220409_6.png></p><p>[主从同步流程图]</p><p>谈到主从的并行复制能力，要关注上图中黑色的两个箭头。一个箭头代表了客户端写入主库，另一箭头代表的是从库上 sql_thread 执行中转日志（relay log）。如果用箭头的粗细来代表并行度的话，那么真实情况就如图所示，第一个箭头要明显粗于第二个箭头。</p><p>主库影响并发度就是各种锁。由于 InnoDB 引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，对业务并发度的支持还是很友好。</p><p>而日志在从库执行，就是图中从库上 sql_thread 更新数据的逻辑。如果用单线程就会导致从库应用日志不够快，造成主从延迟。</p><h2 id=sql-thread多线程>sql_thread多线程</h2><p>在官方的 5.6 版本之前，MySQL 只支持单线程复制，由此在主库并发高、TPS 高时就会出现严重的主从延迟问题。MySQL 多线程复制的演进过程经历了好几个版本。</p><p>多线程复制机制，都是要把 [主从同步流程图] 中只有一个线程的 sql_thread，拆成多个线程，基本都符合下面的模型：</p><p><img src=../imgs/master_slave_20220409_7.png alt=master_slave_20220409_7.png></p><p>[sql_thread多线程模型]</p><p>coordinator 就是原来的 sql_thread，它不再直接更新数据，只负责读取中转日志和分发事务。真正更新日志的变成了 worker 线程。而 work 线程的个数，就是由参数 slave_parallel_workers 决定。根据经验把参数设置为 8~16 之间最好（32 核物理机），毕竟从库还有可能要提供读查询，不要占用过多 CPU。</p><p>事务能不能按照轮询的方式分发给各个 worker，否则 workder 独立执行速度快慢不一。同一个事物的多个 SQL 语句也不能分配给多个 worker 执行，否则破坏事务的隔离性（查询可能看到事务执行一半的结果）。</p><p>所以coordinator 在分发时，需要满足以下两个基本要求：</p><p>1、不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个 worker 中。</p><p>2、同一个事务不能被拆开，必须放到同一个 worker 中。</p><p>各个版本的多线程复制，都遵循了这两条基本原则。</p><h2 id=通用并行复制策略>通用并行复制策略</h2><p>官方 MySQL 5.5 版本是不支持并行复制的，第三方开发了按表分发策略和按行分发策略。</p><h3 id=按表分发策略>按表分发策略</h3><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行，如果有跨表的事务，要把两张表放在一起考虑。</p><p><img src=../imgs/master_slave_20220409_8.png alt=master_slave_20220409_8.png></p><p>[按表并行复制程模型]</p><p>每个 worker 线程对应一个 hash 表，用于保存当前正在这个 worker 的“执行队列”里的事务所涉及的表。hash 表的 key 是“库名. 表名”，value 是一个数字，表示队列中有多少个事务修改这个表。</p><p>在有事务分配给 worker 时，事务里面涉及的表会被加到对应的 hash 表中。worker 执行完成后，这个表会被从 hash 表中去掉。</p><p>每个事务在分发的时候，跟所有 worker 的冲突关系包括以下三种情况：</p><p>1、如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker；</p><p>2、如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个；</p><p>3、如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker。</p><p>这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</p><h3 id=按行分发策略>按行分发策略</h3><p>要解决热点表的并行复制问题，需要按行并行复制的方案。核心思路是：如果两个事务没有更新相同的行，它们在从库上可以并行执行。显然这个模式要求 binlog 格式必须是 row。</p><p>判断一个事务 T 和 worker 是否冲突，用的就规则就不是“修改同一个表”，而是“修改同一行”。</p><p>key，就必须是“库名 + 表名 + 唯一键的值”，考虑到唯一索引，基于行的策略，事务 hash 表中还需要考虑唯一键，即 key 应该是“库名 + 表名 + 索引名字 + 索引值”。</p><p>举例：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t6</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>a</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>b</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>UNIQUE</span> <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#000>a</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#000>a</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t6</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>1</span>),(<span style=color:#1c01ce>2</span>,<span style=color:#1c01ce>2</span>,<span style=color:#1c01ce>2</span>),(<span style=color:#1c01ce>3</span>,<span style=color:#1c01ce>3</span>,<span style=color:#1c01ce>3</span>),(<span style=color:#1c01ce>4</span>,<span style=color:#1c01ce>4</span>,<span style=color:#1c01ce>4</span>),(<span style=color:#1c01ce>5</span>,<span style=color:#1c01ce>5</span>,<span style=color:#1c01ce>5</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>SQL 语句：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>update t6 set a=6 where id=1;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t6 set a=1 where id=2;</td></tr></tbody></table><p>这两个事务要更新的行的主键值不同，但是如果它们被分到不同的 worker，就有可能 Session B 的语句先执行。此时 id=1 的行的 a 的值还是 1，就会报唯一键冲突。</p><p>表 t1 上执行 update t1 set a=1 where id=2 语句，binlog 里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。</p><p>因此，coordinator 在解析这个语句的 binlog 的时候，这个事务的 hash 表就有三个项:</p><p>1、key=hash_func(db1+t1+"PRIMARY"+2), value=2; 这里 value=2 是因为修改前后的行 id 值不变，出现了两次。</p><p>2、key=hash_func(db1+t1+"a"+2), value=1，表示会影响到这个表 a=2 的行。（修改前 a=2）</p><p>3、key=hash_func(db1+t1+"a"+1), value=1，表示会影响到这个表 a=1 的行。（修改后 a=1）</p><p>相比于按表并行分发策略，按行并行策略在决定线程分发时，需要消耗更多的计算资源。两个方案其实都有一些约束条件：</p><p>1、要能够从 binlog 里面解析出表名、主键值和唯一索引的值。也就是说，主库的 binlog 格式必须是 row；</p><p>2、表必须有主键；不能有外键。表上如果有外键，级联更新的行不会记录在 binlog 中，这样冲突检测就不准确。</p><p>按行分发的策略有两个问题：</p><p>1、耗费内存。比如一个语句要删除 100 万行数据，这时 hash 表就要记录 100 万个项。</p><p>2、耗费 CPU。解析 binlog，然后计算 hash 值，对于大事务成本很高。</p><p>因此实现这个策略时会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过 10 万行），就暂时退化为单线程模式，退化过程的逻辑如下：</p><p>1、coordinator 暂时先 hold 住这个事务；</p><p>2、等待所有 worker 都执行完成，变成空队列；</p><p>3、coordinator 直接执行这个事务；</p><p>4、恢复并行模式。</p><h2 id=官方并行复制策略>官方并行复制策略</h2><h3 id=mysql5-6并行复制策略>MySQL5.6并行复制策略</h3><p>只是支持的粒度是按库并行，用于决定分发策略的 hash 表里，key 就是数据库名。</p><p>这个策略的并行效果，取决于压力模型。如果在主库上有多个 DB，并且各个 DB 的压力均衡，使用这个策略的效果会很好。相比于按表和按行分发，这个策略有两个优势：</p><p>1、构造 hash 值的时候很快，只需要库名；而且一个实例上 DB 数也不会很多，不会出现需要构造 100 万个项这种情况。</p><p>2、不要求 binlog 的格式。因为 statement 格式的 binlog 也可以很容易拿到库名。</p><p>但是，如果主库上的表都放在同一个 DB 里面，这个策略就没有效果；或者如果不同 DB 的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。</p><h3 id=mariadb并行复制策略>MariaDB并行复制策略</h3><p>MariaDB 的并行复制策略利用了 redo log 组提交 (group commit) 优化的特性 ：</p><p>1、能够在同一组里提交的事务，一定不会修改同一行；</p><p>2、主库上可以并行执行的事务，从库上也一定是可以并行执行的。</p><p>实现上的流程：</p><p>1、在一组里面一起提交的事务，有一个相同的 commit_id，下一组就是 commit_id+1；</p><p>2、commit_id 直接写到 binlog 里面；</p><p>3、传到从库应用的时候，相同 commit_id 的事务分发到多个 worker 执行；</p><p>4、这一组全部执行完成后，coordinator 再去取下一批。</p><p>这个策略出来的时候相当惊艳。因为之前业界的思路都是在“分析 binlog，并拆分到 worker”上。而 MariaDB 的这个策略，目标是“模拟主库的并行模式”。</p><p>但是这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。主库一组事务 commit 时，下一组事务是同时处于“执行中”状态的。从库上执行时，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。</p><p>另外，这个方案很容易被大事务拖后腿。假设 trx2 是一个超大事务，那么在从库应用的时候，trx1 和 trx3 执行完成后，就只能等 trx2 完全执行完成，下一组才能开始执行。这段时间只有一个 worker 线程在工作，是对资源的浪费。</p><p>该策略仍然是一个很好的创新，对原系统的改造非常少，实现很优雅。</p><h3 id=mysql5-7并行复制策略>MySQL5.7并行复制策略</h3><p>参数 slave-parallel-type （ <code>show variables like 'slave_parallel_type</code> ）来控制并行复制策略：</p><p>1、配置为 DATABASE，表示使用 MySQL 5.6 版本的按库并行策略；</p><p>2、配置为 LOGICAL_CLOCK，表示类似 MariaDB 的策略。不过 MySQL 5.7 这个策略，针对并行度做了优化。</p><p>首先，同时处于“执行状态”的所有事务，不能并行执行。因为里面可能有由于锁冲突而处于锁等待状态的事务。MariaDB 策略的核心是“所有处于 commit”状态的事务可以并行。事务处于 commit 状态，表示已经通过了锁冲突的检验了。</p><p>两阶段提交过程中，其实不用等到 commit 阶段，只要能够到达 redo log prepare 阶段，就表示事务已经通过锁冲突的检验了。</p><p>因此，MySQL 5.7 并行复制策略的思想是：</p><p>1、同时处于 prepare 状态的事务，在从库执行时是可以并行的；</p><p>2、处于 prepare 状态的事务，与处于 commit 状态的事务之间，在从库执行时也是可以并行的。</p><p>binlog 的组提交有两个参数：</p><p>1、binlog_group_commit_sync_delay 表示延迟多少微秒后才调用 fsync；</p><p>2、binlog_group_commit_sync_no_delay_count 表示累积多少次以后才调用 fsync。</p><p>这两个参数是用于故意拉长 binlog 从 write 到 fsync 的时间，以此减少 binlog 的写盘次数。在 MySQL 5.7 的并行复制策略里，它们可以用来制造更多的“同时处于 prepare 阶段的事务”。这样可以从库复制的并行度。</p><p>即这两个参数，既可以“故意”让主库提交得慢些，又可以让从库执行得快些。在 MySQL 5.7 处理从库延迟时，可以考虑调整这两个参数值，来达到提升从库复制并发度的目的。</p><h3 id=mysql5-7-22并行复制策略>MySQL5.7.22并行复制策略</h3><p>这个版本增加了一个新的并行复制策略，基于 WRITESET 的并行复制。新增了一个参数 binlog-transaction-dependency-tracking，用来控制是否启用这个新策略，参数值：</p><p>1、COMMIT_ORDER 表示根据同时进入 prepare 和 commit 来判断是否可以并行的策略。</p><p>2、WRITESET 表示对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。</p><p>3、WRITESET_SESSION 表示在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在从库执行的时候，要保证相同的先后顺序。</p><p>为了唯一标识，这个 hash 值是通过“库名 + 表名 + 索引名 + 值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert 语句对应的 writeset 就要多增加一个 hash 值。</p><p>跟前面介绍的基于 MySQL 5.5 版本的按行分发的策略差不多。不过 MySQL 官方的实现还是有很大的优势：</p><p>1、writeset 是在主库生成后直接写入到 binlog 里面的，这样在从库执行的时候，不需要解析 binlog 内容（event 里的行数据），节省了很多计算量；</p><p>2、不需要把整个事务的 binlog 都扫一遍才能决定分发到哪个 worker，更省内存；</p><p>3、由于从库的分发策略不依赖于 binlog 内容，所以 binlog 是 statement 格式也是可以的。</p><p>因此，MySQL 5.7.22 的并行复制策略在通用性上还是有保证的。当然对于“表上没主键”和“外键约束”的场景，WRITESET 策略也是没法并行的，也会暂时退化为单线程模型。</p><h1 id=主备切换>主备切换</h1><p>一主多从的架构下，假设 A 为主库，A1 为从库，B、C、D 为从库，当 A 断电后，A1 会成为新的主库，从库 B、C、D 也要重新指向 A1。</p><h2 id=基于位点的主备切换>基于位点的主备切换</h2><p>把节点 B 设置成节点 A’的从库的时候，需要执行一条 change master 命令：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>CHANGE</span> <span style=color:#000>MASTER</span> <span style=color:#a90d91>TO</span> 
</span></span><span style=display:flex><span><span style=color:#000>MASTER_HOST</span><span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>host_name</span> 
</span></span><span style=display:flex><span><span style=color:#000>MASTER_PORT</span><span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>port</span> 
</span></span><span style=display:flex><span><span style=color:#000>MASTER_USER</span><span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>user_name</span> 
</span></span><span style=display:flex><span><span style=color:#000>MASTER_PASSWORD</span><span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>password</span> 
</span></span><span style=display:flex><span><span style=color:#000>MASTER_LOG_FILE</span><span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>master_log_name</span> 
</span></span><span style=display:flex><span><span style=color:#000>MASTER_LOG_POS</span><span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>master_log_pos</span>  
</span></span></code></pre></td></tr></table></div></div></div><p>参数：
1、MASTER_HOST、MASTER_PORT、MASTER_USER 和 MASTER_PASSWORD 四个参数，分别代表了主库 A’的 IP、端口、用户名和密码。</p><p>2、最后两个参数 MASTER_LOG_FILE 和 MASTER_LOG_POS 表示，要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。这个位置就是同步位点，也就是主库对应的文件名和日志偏移量。</p><h3 id=同步位点>同步位点</h3><p>原来节点 B 是 A 的从库，本地记录的也是 A 的位点。但是相同的日志，A 的位点和 A’的位点是不同的。因此从库 B 切换时，需要先“找同步位点”。</p><p>本质是重放binlog，如果太靠后可能会丢记录，稍微往前点的可以经过判断跳过已经执行的。</p><p>一种取同步位点的方法是这样的：</p><p>1、等待新主库 A’把中转日志（relay log）全部同步完成；</p><p>2、在 A’上执行 show master status 命令，得到当前 A’上最新的 File 和 Position；</p><p>3、取原主库 A 故障的时刻 T；</p><p>4、用 mysqlbinlog 工具解析 A’的 File，得到 T 时刻的位点。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysqlbinlog File --stop-datetime<span style=color:#000>=</span>T --start-datetime<span style=color:#000>=</span>T
</span></span></code></pre></td></tr></table></div></div></div><p><img src=../imgs/master_slave_20220409_9.png alt=master_slave_20220409_9.png></p><p>[mysqlbinlog 部分输出结果]</p><p>图中 end_log_pos 后面的值“123”，表示的就是 A1 这个实例，在 T 时刻写入新的 binlog 的位置。然后，我们就可以把 123 这个值作为 $master_log_pos ，用在节点 B 的 change master 命令里。</p><p>该值不准确的原因：</p><p>假设 T 时刻主库 A 已经执行完成了一个 insert 语句插入了一行数据 R，并且已经将 binlog 传给了 A1 和 B，然后在传完的瞬间主库 A 主机掉电。</p><p>此时系统状态是：</p><p>1、在从库 B 上，由于同步了 binlog， R 这一行已经存在；</p><p>2、在新主库 A1上， R 这一行也已经存在，日志是写在 123 这个位置之后的；</p><p>3、在从库 B 上执行 change master 命令，指向 A1 的 File 文件的 123 位置，就会把插入 R 这一行数据的 binlog 又同步到从库 B 去执行。</p><p>从库 B 的同步线程就会提示主键冲突，然后停止同步。</p><h3 id=主动跳过错误>主动跳过错误</h3><p>通常情况下，在切换任务时，要先主动跳过这些错误，有两种常用的方法。一种做法是：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#a90d91>global</span> <span style=color:#000>sql_slave_skip_counter</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>start</span> <span style=color:#000>slave</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>切换过程中，可能会不止重复执行一个事务，需要在从库 B 刚开始接到新主库 A1 时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。
另一种方式是：设置 slave_skip_errors 参数，直接设置跳过指定的错误。</p><p>执行主备切换时，有两类错误经常遇到：</p><p>1、1062 错误是插入数据时唯一键冲突；</p><p>2、1032 错误是删除数据时找不到行。</p><p>因此可以把 slave_skip_errors 设置为 “1032,1062”。</p><p>注意：主备间的同步关系建立完成，并稳定执行一段时间之后，需要把这个参数设置为空，以免之后真的出现了主从数据不一致也跳过。</p><h2 id=gtid>GTID</h2><p>虽然上面的方法最终可以建立从库 B 和新主库 A1 的主从关系，但操作都很复杂，而且容易出错。MySQL 5.6 版本引入了 GTID，彻底解决了这个困难。</p><p>GTID 的全称是 Global Transaction Identifier，即全局事务 ID，是一个事务在提交的时候生成的唯一标识。由两部分组成，格式是：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>GTID=server_uuid:gno
</span></span></code></pre></td></tr></table></div></div></div><p>1、server_uuid 是一个实例第一次启动时自动生成的，是一个全局唯一的值；
2、gno 是一个整数，初始值是 1，每次提交事务的时候分配给这个事务，并加 1。</p><p>官方定义格式：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>GTID=source_id:transaction_id
</span></span></code></pre></td></tr></table></div></div></div><p>source_id 就是 server_uuid，transaction_id 容易造成误解，两个都是递增，不同点是事务 id 自增但不一定连续，因为会被回滚，而 gno 在提交时分配，所以是连续递增的。
在 GTID 模式下，每个事务都会跟一个 GTID 一一对应。这个 GTID 有两种生成方式，而使用哪种方式取决于 session 变量 gtid_next 的值：</p><p>1、默认值 automatic，MySQL 就会把 server_uuid:gno 分配给这个事务。</p><p>1）记录 binlog 时，先记录一行 SET @@SESSION.GTID_NEXT=‘server_uuid:gno’；</p><p>2）把这个 GTID 加入本实例的 GTID 集合。</p><p>2、gtid_next 是一个指定的 GTID 的值，比如通过 set gtid_next='current_gtid’指定为 current_gtid，有两种可能：</p><p>1）如果 current_gtid 已经存在于实例的 GTID 集合中，接下来执行的这个事务会直接被系统忽略；</p><p>2）如果 current_gtid 没有存在于实例的 GTID 集合中，就将这个 current_gtid 分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的 GTID，因此 gno 也不用加 1。</p><p>注意，一个 current_gtid 只能给一个事务使用。事务提交后要执行下一个事务，就要执行 set 命令，把 gtid_next 设置成另外一个 gtid 或者 automatic。这样每个 MySQL 实例都维护了一个 GTID 集合，用来对应“这个实例执行过的所有事务”。</p><p>举例说明：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>1</span>);
</span></span></code></pre></td></tr></table></div></div></div><p><img src=../imgs/master_slave_20220409_10.png alt=master_slave_20220409_10.png></p><p>[初始化数据的binlog]</p><p>查看 binlog，事务的 BEGIN 之前有一条 SET @@SESSION.GTID_NEXT 命令。这时，如果实例 X 有从库，那么将 CREATE TABLE 和 insert 语句的 binlog 同步过去执行的话，执行事务之前就会先执行这两个 SET 命令， 这样被加入从库的 GTID 集合的，就是上图的这两个 GTID。</p><p>如果从库主键冲突，可以执行：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>gtid_next</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>begin</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>commit</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>gtid_next</span><span style=color:#000>=</span><span style=color:#000>automatic</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>start</span> <span style=color:#000>slave</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>前三条语句的作用，是通过提交一个空事务，把这个 GTID 加到实例 X 的 GTID 集合中。然后 <code>show master status</code> 可以看到 Executed_Gtid_set 已经加入了这个 GTID。
再执行 <code>start slave</code> 命令让同步线程执行起来时，虽然实例 X 上还是会继续执行实例 Y 传过来的事务，但是由于“xxxx:10”已经存在于实例的 GTID 集合中了，就会直接跳过这个事务，也就不会再出现主键冲突的错误。</p><p><code>set gtid_next=automatic</code> 的作用是“恢复 GTID 的默认分配行为”，如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配 gno=3。</p><h2 id=基于gtid的主备切换>基于GTID的主备切换</h2><p>GTID 模式下，从库 B 要设置为新主库 A1 的从库的语法如下：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>CHANGE</span> <span style=color:#000>MASTER</span> <span style=color:#a90d91>TO</span> 
</span></span><span style=display:flex><span><span style=color:#000>MASTER_HOST</span><span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>host_name</span> 
</span></span><span style=display:flex><span><span style=color:#000>MASTER_PORT</span><span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>port</span> 
</span></span><span style=display:flex><span><span style=color:#000>MASTER_USER</span><span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>user_name</span> 
</span></span><span style=display:flex><span><span style=color:#000>MASTER_PASSWORD</span><span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>password</span> 
</span></span><span style=display:flex><span><span style=color:#000>master_auto_position</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span> 
</span></span></code></pre></td></tr></table></div></div></div><p>master_auto_position=1 就表示这个主备关系使用的是 GTID 协议。可以看到难以指定的 MASTER_LOG_FILE 和 MASTER_LOG_POS 参数，已经不需要指定了。
实例 A1 的 GTID 集合记为 set_a，实例 B 的 GTID 集合记为 set_b。</p><p>实例 B 上执行 start slave 命令，取 binlog 的逻辑：</p><p>1、实例 B 指定主库 A1，基于主备协议建立连接。</p><p>2、实例 B 把 set_b 发给主库 A1。</p><p>3、实例 A1 算出 set_a 与 set_b 的差集，也就是所有存在于 set_a 但不存在于 set_b 的 GTID 集合，判断 A1 本地是否包含了这个差集需要的所有 binlog 事务。</p><p>1）如果不包含，表示 A1 已经把实例 B 需要的 binlog 给删掉了，直接返回错误；</p><p>2）如果确认全部包含，A1 从自己的 binlog 文件中找出第一个不在 set_b 的事务，发给 B；</p><p>4、之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行。</p><p>主备切换，若选择 A1 作为新的主库，必须要包含从库 B 的全部内容；如果存在事务 B 中有，A1 没有，则 A1 不能成为新的主库。</p><p>主备切换的流程：</p><p>由于不需要找位点了，从库 B、C、D 只需要分别执行 change master 命令指向实例 A1 即可。（找位点在 A1 内部完成了）</p><p>之后系统就由新主库 A1 写入，主库 A1 生成的 binlog 中的 GTID 集合格式是：server_uuid_of_A1:1-M。</p><h2 id=gtid和在线ddl>GTID和在线DDL</h2><p>假设两个互为主备关系的库是实例 X 和实例 Y，且当前主库是 X，并且都打开了 GTID 模式。这时的主备切换流程可以变成下面这样：</p><p>1、在实例 X 上执行 stop slave。</p><p>2、在实例 Y 上执行 DDL 语句。注意，这里并不需要关闭 binlog。</p><p>3、执行完成后，查出这个 DDL 语句对应的 GTID，并记为 server_uuid_of_Y:gno。</p><p>4、到实例 X 上执行以下语句序列：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>GTID_NEXT</span><span style=color:#000>=</span><span style=color:#c41a16>&#34;server_uuid_of_Y:gno&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>begin</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>commit</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>gtid_next</span><span style=color:#000>=</span><span style=color:#000>automatic</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>start</span> <span style=color:#000>slave</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>目的：既可以让实例 Y 的更新有 binlog 记录，同时也可以确保不会在实例 X 上执行这条更新。
5、按照之前的流程继续执行。</p><h1 id=读写分离>读写分离</h1><p>读写分离的主要目标就是分摊主库的压力。一般有两种架构：</p><p>1、客户端直连方案</p><p>需要了解后端部署细节，在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发。</p><p>2、Proxy</p><p>客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。对后端维护团队的要求会更高。Proxy 需要有高可用架构。整体相对比较复杂。</p><p>不论使用哪种架构，都会碰到由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库，就有可能读到刚刚的事务更新之前的状态。本文称作“过期读”。</p><p>主从延迟不能 100% 避免的。下面介绍一下处理“过期读”的方案</p><h2 id=强制走主库方案>强制走主库方案</h2><p>强制走主库方案其实就是，将查询请求做分类：</p><p>1、对于必须要拿到最新结果的请求，强制将其发到主库上。</p><p>2、对于可以读到旧数据的请求，才将其发到从库上。</p><h2 id=sleep方案>sleep方案</h2><p>主库更新后，读从库之前先 sleep 一下。</p><p>具体的方案就是，类似于执行一条 select sleep(1) 命令。这个方案的假设是：大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据。</p><p>更靠谱的方案</p><p>客户端将用户数据的数据直接展示在页面上，而不是真正的去请求后端数据库。等到卖家再刷新页面去查询时，已经过了一段时间，相当于 sleep 了。</p><h2 id=判断无延迟方案>判断无延迟方案</h2><p>确保从库无延迟，通常有三种做法：</p><p>1、 <code>show slave status</code> 结果里的 seconds_behind_master 参数的值（秒级），可以用来衡量主备延迟时间的长短。</p><p>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果不等于，就必须等到为 0 才能执行查询请求。</p><p>2、对比位点确保主从无延迟</p><p>1）Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；</p><p>2）Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是从库执行的最新位点。</p><p>如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。</p><p>3、对比 GTID 集合确保主备无延迟</p><p>1）Auto_Position=1 ，表示这对主从关系使用了 GTID 协议。</p><p>2）Retrieved_Gtid_Set，是从库收到的所有日志的 GTID 集合</p><p>3）Executed_Gtid_Set，是从库所有已经执行完成的 GTID 集合。</p><p>如果这两个集合相同，也表示从库接收到的日志都已经同步完成。</p><p>对比位点和对比 GTID 这两种方法，都要比判断 seconds_behind_master 是否为 0 更准确。</p><h2 id=配合semi-sync方案>配合semi-sync方案</h2><p>引入半同步复制，也就是 semi-sync replication。semi-sync 做了这样的设计：</p><p>1、事务提交的时候，主库把 binlog 发给从库；</p><p>2、从库收到 binlog 后，发回给主库一个 ack，表示收到了；</p><p>3、主库收到 ack 后，才能给客户端返回“事务完成”的确认。</p><p>如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了从库已经收到了这个日志。</p><p>semi-sync 配合前面关于位点的判断，能够确定在从库上执行的查询请求，可以避免过期读。</p><p>但是，semi-sync+ 位点判断的方案，只对一主一从的场景是成立的。在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。</p><p>判断同步位点的方案还有另外一个潜在问题，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p><p>semi-sync 配合判断主备无延迟的方案，存在两个问题：</p><p>1、一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</p><p>2、在持续延迟的情况下，可能出现过度等待的问题。</p><p>扩展延伸</p><p>如果主库掉电时，有些 binlog 还来不及发给从库，会不会导致系统数据丢失？</p><p>如果使用的是普通的异步复制模式，就可能会丢失，但 semi-sync 就可以解决这个问题。</p><h2 id=等主库位点方案>等主库位点方案</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>master_pos_wait</span>(<span style=color:#000>file</span>, <span style=color:#000>pos</span>[, <span style=color:#000>timeout</span>]);
</span></span></code></pre></td></tr></table></div></div></div><p>这条命令的逻辑：
1、它是在从库执行的；</p><p>2、参数 file 和 pos 指的是主库上的文件名和位置；</p><p>3、timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。</p><p>这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。</p><p>还会返回一些其他结果，包括：</p><p>1、如果执行期间，从库同步线程发生异常则返回 NULL；</p><p>2、如果等待超过 N 秒，就返回 -1；</p><p>3、如果刚开始执行时，发现已经执行过这个位置则返回 0。</p><p>如果主库频繁写入事务，并不需要获取当前事务对应的pos，执行完事务之后，获取的pos肯定是要比当前事务的pos的位置要大，只要在从库上面执行，master_pos_wait 返回大于等于 0 的值就说明事务已经在从库执行了。查询的结果就是正确的。</p><p>等位点执行流程如下：</p><p>1、trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的 File 和 Position；</p><p>2、选定一个从库执行查询语句；</p><p>3、在从库上执行 select master_pos_wait(File, Position, 1)；</p><p>4、如果返回值是 >=0 的正整数，则在这个从库执行查询语句；</p><p>5、否则，到主库执行查询语句。</p><h2 id=等gtid方案>等GTID方案</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>wait_for_executed_gtid_set</span>(<span style=color:#000>gtid_set</span>, <span style=color:#1c01ce>1</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>这条命令的逻辑是：
1、等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；</p><p>2、超时返回 1。</p><p>等位点的方案中，执行完事务后要主动去主库执行 show master status。而 MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询。</p><p>等 GTID 执行流程如下：</p><p>1、trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；</p><p>2、选定一个从库执行查询语句；</p><p>3、在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</p><p>4、如果返回值是 0，则在这个从库执行查询语句；</p><p>5、否则，到主库执行查询语句。</p><p>将参数 session_track_gtids 设置为 OWN_GTID，MySQL 在执行事务后，就会在返回包中带上 GTID，然后通过 API 接口 mysql_session_track_get_first 从返回包解析出 GTID 的值即可。<a href=https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html>API 接口</a></p><h1 id=最佳实践>最佳实践</h1><h2 id=从库45度延迟>从库45度延迟</h2><p>一般现在的数据库运维系统都有从库延迟监控，其实就是在从库上执行 show slave status，采集 seconds_behind_master 的值。</p><p>假设维护的一个从库，它的延迟监控的图像类似下图，是一个 45°斜向上的线段，可能是什么原因导致呢？如何确认？</p><p><img src=../imgs/master_slave_20220409_11.png alt=master_slave_20220409_11.png></p><p>从库的同步在这段时间完全被堵住了。产生这种现象典型的场景主要包括两种：</p><p>1、大事务（包括大表 DDL、一个事务操作很多行）；</p><p>2、从库起了一个长事务，比如</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>begin</span>; 
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>然后就不动了。这时候主库对表 t 做了一个加字段操作，即使这个表很小，这个 DDL 在从库应用的时候也会被堵住，也不能看到这个现象。
注意：从库跟不上主库的更新速度（并行复制）会导致主从延迟，但不会表现为这种标准的呈 45 度的直线。</p><h2 id=从库并行复制策略选择>从库并行复制策略选择</h2><p>如果主库都是单线程压力模式，在从库追主库的过程中，binlog-transaction-dependency-tracking 应该选用什么参数？</p><p>应该将这个参数设置为 WRITESET。</p><p>由于主库是单线程压力模式，所以每个事务的 commit_id 都不同，那么设置为 COMMIT_ORDER 模式的话，从库也只能单线程执行。</p><p>同样地，由于 WRITESET_SESSION 模式要求在从库应用日志的时候，同一个线程的日志必须与主库上执行的先后顺序相同，也会导致主库单线程压力模式下退化成单线程复制。所以，应该将 binlog-transaction-dependency-tracking 设置为 WRITESET。</p><h2 id=gtid下主库binlog丢失>GTID下主库binlog丢失</h2><p>GTID 模式下，从库执行 start slave 命令后，主库发现需要的 binlog 已经被没了，导致主备创建不成功，如何处理？</p><p>1、如果业务允许主从不一致的情况，那么可以在主库上先执行 show global variables like ‘gtid_purged’，得到主库已经删除的 GTID 集合，假设是 gtid_purged1；然后先在从库上执行 reset master，再执行 set global gtid_purged =‘gtid_purged1’；最后执行 start slave，就会从主库现存的 binlog 开始同步。binlog 缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。</p><p>2、如果需要主从数据一致，最好还是通过重新搭建从库来做。</p><p>3、如果有其他的从库保留有全量的 binlog ，可以把新的从库先接到这个保留了全量 binlog 的从库，追上日志后，如果有需要再接回主库。</p><p>4、如果 binlog 有备份的情况，可以先在从库上应用缺失的 binlog，然后再执行 start slave。</p><h2 id=gtid等位点读写分离做ddl>GTID等位点读写分离做DDL</h2><p>如果使用 GTID 等位点的方案做读写分离，在对大表做 DDL 的时候会怎么样？</p><p>假设，这条语句在主库上要执行 10 分钟，提交后传到从库就要 10 分钟（典型的大事务）。那么，在主库 DDL 之后再提交的事务的 GTID，去从库查的时候，就会等 10 分钟才出现。这样，这个读写分离机制在这 10 分钟之内都会超时，然后走主库。</p><p>这种预期内的操作，应该在业务低峰期的时候，确保主库能够支持所有业务查询，然后把读请求都切到主库，再在主库上做 DDL。等从库延迟追上以后，再把读请求切回从库。</p><p>需要关注大事务对等位点方案的影响。另外使用 gh-ost 方案来解决这个问题也是不错的选择。</p><h2 id=判断主库故障>判断主库故障</h2><p>主从切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换往往是因为主库出问题了，由 HA 系统发起的。</p><p>判断主库故障的方法：</p><h3 id=select-1-判断>select 1 判断</h3><p>select 1 成功返回，只能说明这个库的进程还在，并不能说明主库没问题。</p><p>可以通过设置 innodb_thread_concurrency 参数控制 InnoDB 的并发线程上限，使用多个语句如 <code>select sleep(100) from t;</code> 占用查询，新建会话发现 select 1 可以返回，但是其他 SQL 语句却因为分配不到连接线程被阻塞。</p><p>该参数默认为 0，表示不限制并发线程数量。建议设置为 64~128。</p><p>注意并发连接和并发查询，并不是同一个概念。show processlist 中看到的几千个连接，指的就是并发连接。而“当前正在执行”的语句，才是并发查询。并发连接数达到几千个影响并不大，就是多占一些内存而已。并发查询太高才是 CPU 杀手。</p><p>线程进入锁等待以后，并发线程的计数会减一，也就是等行锁（也包括间隙锁）的线程是不算在这个参数里面的。</p><h3 id=查表判断>查表判断</h3><p>为了能够检测 InnoDB 并发线程数过多导致的系统不可用情况，我们需要找一个访问 InnoDB 的场景。一般做法是在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>mysql</span>.<span style=color:#000>health_check</span>; 
</span></span></code></pre></td></tr></table></div></div></div><p>问题：更新事务要写 binlog，而一旦 binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p><h3 id=更新判断>更新判断</h3><p>既然要更新，就要放个有意义的字段，常见做法是放一个 timestamp 字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>update</span> <span style=color:#000>mysql</span>.<span style=color:#000>health_check</span> <span style=color:#a90d91>set</span> <span style=color:#000>t_modified</span><span style=color:#000>=</span><span style=color:#000>now</span>();
</span></span></code></pre></td></tr></table></div></div></div><p>节点可用性的检测都应该包含主库和从库。如果用更新来检测主库的话，那么从库也要进行更新检测。
但从库的检测也是要写 binlog 的。因为一般会把数据库 A 和 B 的主备关系设计为双 M 结构，所以在备库 B 上执行的检测命令，也要发回给主库 A。</p><p>但是如果主库 A 和备库 B 都用相同的更新命令，就可能出现行冲突，也就是可能会导致主备同步停止。所以现在看来 mysql.health_check 这个表就不能只有一行数据了。</p><p>为了让主备之间的更新不产生冲突，可以在 mysql.health_check 表上存入多行数据，并用 A、B 的 server_id 做主键。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>health_check</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>t_modified</span><span style=color:#000>`</span> <span style=color:#a90d91>timestamp</span> <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span> <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>CURRENT_TIMESTAMP</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>/* 检测命令 */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>mysql</span>.<span style=color:#000>health_check</span>(<span style=color:#000>id</span>, <span style=color:#000>t_modified</span>) <span style=color:#a90d91>values</span> (<span style=color:#000>@@</span><span style=color:#000>server_id</span>, <span style=color:#000>now</span>()) <span style=color:#a90d91>on</span> <span style=color:#000>duplicate</span> <span style=color:#a90d91>key</span> <span style=color:#a90d91>update</span> <span style=color:#000>t_modified</span><span style=color:#000>=</span><span style=color:#000>now</span>();
</span></span></code></pre></td></tr></table></div></div></div><p>由于 MySQL 规定了主库和备库的 server_id 必须不同（否则创建主备关系的时候就会报错），这样就可以保证主从库各自的检测命令不会发生冲突。
但是更新判断还是有“判定慢”的问题。根本原因是上面说的所有方法，都是基于外部检测的，有一个随机性的天然问题。外部检测都需要定时轮询，可能需要等到下一个检测发起执行语句时，才有可能发现问题。</p><p>比如 IO 利用率 100% 表示系统的 IO 是在工作的，每个请求都有机会获得 IO 资源，执行自己的任务。而检测使用的 update 命令，需要的资源很少，所以可能在拿到 IO 资源的时候就可以提交成功，并且在超时时间 N 秒未到达之前就返回给了检测系统。</p><h3 id=内部统计>内部统计</h3><p>针对磁盘利用率，如果 MySQL 可以告诉我们内部每一次 IO 请求的时间，那判断数据库是否出问题的方法就很可靠。</p><p>MySQL 5.6 版本以后提供的 performance_schema 库，就在 file_summary_by_event_name 表里统计了每次 IO 请求的时间。</p><p>file_summary_by_event_name 表里有很多行数据，先看看 event_name='wait/io/file/innodb/innodb_log_file’这一行。</p><p><img src=../imgs/master_slave_20220409_12.png alt=master_slave_20220409_12.png></p><p>这一行表示统计的是 redo log 的写入时间，第一列 EVENT_NAME 表示统计的类型。</p><p>接下来的三组数据，显示的是 redo log 操作的时间统计。</p><p>第一组五列，是所有 IO 类型的统计。其中，COUNT_STAR 是所有 IO 的总次数，接下来四列是具体的统计项， 单位是皮秒；前缀 SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、平均值和最大值。</p><p>第二组六列，是读操作的统计。最后一列 SUM_NUMBER_OF_BYTES_READ 统计的是，总共从 redo log 里读了多少个字节。</p><p>第三组六列，统计的是写操作。</p><p>最后的第四组数据，是对其他类型数据的统计。在 redo log 里，可以认为就是对 fsync 的统计。</p><p>在 performance_schema 库的 file_summary_by_event_name 表里，binlog 对应的是 event_name = "wait/io/file/sql/binlog"这一行。各个字段的统计逻辑，与 redo log 的各个字段完全相同。</p><p>如果打开所有的 performance_schema 项，性能大概会下降 10% 左右。</p><p>如果要打开 redo log 的时间监控，可以执行这个语句：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>update</span> <span style=color:#000>setup_instruments</span> <span style=color:#a90d91>set</span> <span style=color:#000>ENABLED</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;YES&#39;</span>, <span style=color:#000>Timed</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;YES&#39;</span> <span style=color:#a90d91>where</span> <span style=color:#000>name</span> <span style=color:#a90d91>like</span> <span style=color:#c41a16>&#39;%wait/io/file/innodb/innodb_log_file%&#39;</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>可以通过 MAX_TIMER 的值来判断数据库是否出问题。比如可以设定阈值，单次 IO 请求时间超过 200 毫秒属于异常，然后使用类似下面这条语句作为检测逻辑：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>event_name</span>,<span style=color:#000>MAX_TIMER_WAIT</span>  <span style=color:#a90d91>FROM</span> <span style=color:#000>performance_schema</span>.<span style=color:#000>file_summary_by_event_name</span> <span style=color:#a90d91>where</span> <span style=color:#000>event_name</span> <span style=color:#a90d91>in</span> (<span style=color:#c41a16>&#39;wait/io/file/innodb/innodb_log_file&#39;</span>,<span style=color:#c41a16>&#39;wait/io/file/sql/binlog&#39;</span>) <span style=color:#a90d91>and</span> <span style=color:#000>MAX_TIMER_WAIT</span><span style=color:#000>&gt;</span><span style=color:#1c01ce>200</span><span style=color:#000>*</span><span style=color:#1c01ce>1000000000</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>发现异常后获取到需要的信息。可通过下面这条语句把之前的统计信息清空：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>truncate</span> <span style=color:#a90d91>table</span> <span style=color:#000>performance_schema</span>.<span style=color:#000>file_summary_by_event_name</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><h3 id=判断主库故障小结>判断主库故障小结</h3><p>使用非常广泛的 MHA（Master High Availability），默认使用 select 1 方法。</p><p>MHA 中的另一个可选方法是只做连接，就是 “如果连接成功就认为主库没问题”。但选择这个方法的很少。</p><p>建议是优先考虑 update 系统表，然后再配合增加检测 performance_schema 的信息。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bf80de10001d03d00650fdeb67ce469b>2.4 - 03.表</h1><h1 id=表>表</h1><h2 id=表的组成>表的组成</h2><p>一个 InnoDB 表包含两部分，即：表结构定义和数据。</p><p>在 MySQL 8.0 版本以前，表结构是存在以.frm 为后缀的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。表结构定义占用的空间很小。</p><h2 id=表数据>表数据</h2><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：</p><p>1、设置为 OFF 表示：表的数据放在系统共享表空间，也就是跟数据字典放在一起；</p><p>2、设置为 ON 表示：每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</p><p>从 MySQL 5.6.6 版本开始，默认值就是 ON 。</p><p>建议无论哪个版本都将这个值设置为 ON。因为一个表单独存储为一个文件更容易管理，而且不需要这个表时，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><h2 id=数据删除流程>数据删除流程</h2><p>InnoDB 里的数据都是用 B+ 树的结构组织的。</p><p><img src=../imgs/table_20220409_1.png alt=table_20220409_1.png></p><p>[B+ 树索引示意图]</p><p>假设删除 R4 记录，InnoDB 引擎只会把 R4 记录标记为删除。如果之后要插入一个 ID 在 300 和 600 之间的记录时，可能会复用该位置。但是，磁盘文件的大小并不会缩小。</p><p>InnoDB 的数据是按页存储的，如果删除了一个数据页上的所有记录，那么整个数据页就可以被复用了。</p><p>注意：<strong>数据页的复用和记录的复用是不同的！</strong></p><p>记录的复用，只限于符合范围条件的数据。而整个页从 B+ 树里面摘掉以后，可以复用到任何位置。</p><p>如果相邻的两个数据页利用率都很小，系统就会把两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</p><p>如果用 delete 命令将整个表的数据删除，所有的数据页都会被标记为可复用。但是磁盘上文件不会变小。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p><p>实际上，插入数据也会造成这种“空洞”。</p><p>比如上图中的 page A 已满，插入一条数据（如 ID 为 550）会造成页分类，page A 和新增的 page B 都会留下“空洞”。</p><p>以此类推，更新索引上的值，可以理解为删除一个旧的值，再插入一个新的值，也是会造成空洞的。</p><p>因此，重建表可以达到去掉空洞、收缩表空间的目的。</p><h2 id=重建表>重建表</h2><p>把表 B 作为临时表，数据从表 A 导入表 B 的操作完成后，用表 B 替换 A，从效果上看，就起到了收缩表 A 空间的作用。</p><p>可以使用 <code>alter table A engine=InnoDB</code> 命令来重建表，MySQL 会自动完成转存数据、交换表名、删除旧表的操作。</p><p>在整个 DDL 过程中，表 A 中不能有更新。即这个 DDL 不是 Online 的。</p><p>MySQL 5.6 版本开始引入的 Online DDL，对该操作流程做了优化。</p><p>引入了 Online DDL 之后，重建表的流程：</p><p>1、建立一个临时文件，扫描表 A 主键的所有数据页；</p><p>2、用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</p><p>3、生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中；</p><p>4、临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件；</p><p>5、用临时文件替换表 A 的数据文件。</p><p>总结不同之处在于，由于日志文件记录和重放操作功能的存在，方案在重建表的过程中，允许对表 A 做增删改操作。这也就是 Online DDL 名字的来源。</p><p>（关于获取写锁，然后降级成读锁不阻塞更新过程，可参考“锁”章节 Online DDL）</p><p>Online DDL 可以考虑在业务低峰期使用，线上服务如果想要更安全的操作的话，建议使用 GitHub 开源的 gh-ost 来操作。</p><h2 id=online和inplace>Online和inplace</h2><p>DDL 中把表 A 中的数据导出来的存放位置叫作 tmp_table。这是一个临时表，在 server 层创建。</p><p>Online DDL 中根据表 A 重建出来的数据是放在“tmp_file”里的，这个临时文件是 InnoDB 在内部创建出来的。整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</p><p>所以 inplace 的 DDL 受到磁盘空间约束，如果额外的空间不够 tmp_file 使用，则无法执行。</p><p>重建表的语句 <code>alter table A engine=InnoDB</code> ，隐含的意思就是：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>A</span> <span style=color:#000>engine</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>,<span style=color:#000>ALGORITHM</span><span style=color:#000>=</span><span style=color:#000>inplace</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>跟 inplace 对应的就是拷贝表的方式，用法是：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>A</span> <span style=color:#000>engine</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>,<span style=color:#000>ALGORITHM</span><span style=color:#000>=</span><span style=color:#a90d91>copy</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><p>当使用 ALGORITHM=copy 时表示强制拷贝表，对应的流程就是 非 Online 的 DDL。
上面的逻辑看起来 inplace 跟 Online 是一个意思？其实并不是。</p><p>比如，给 InnoDB 表的一个字段加全文索引：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>t</span> <span style=color:#a90d91>add</span> <span style=color:#000>FULLTEXT</span>(<span style=color:#000>field_name</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>该过程是 inplace 的，但是会阻塞 增删改 操作，是非 Online 的。
二者之间的关系概括：</p><p>1、DDL 过程如果是 Online 的，那么一定是 inplace 的；</p><p>2、反之不一定，inplace 的 DDL 有可能不是 Online 的。</p><p>（MySQL 8.0 添加全文索引（FULLTEXT index）和空间索引（SPATIAL index）就属于这种情况。</p><p><strong>optimize table、analyze table 和 alter table 区别</strong></p><p>1、从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）默认的 Online DDL</p><p>2、analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；</p><p>3、optimize table t 等于 recreate+analyze。</p><p><strong>表重建后占用空间更大是什么原因？</strong></p><p>本身已经没有“空洞”了，DDL 期间，刚好有外部的 DML 正在执行，可能引入一些“空洞”。</p><p>更深层次的，在重建表的时候，InnoDB 不会把整张表占满，每个页留了 1/16 给后续的更新用。也就是说，其实重建表之后不是最紧凑的。</p><h1 id=临时表>临时表</h1><h2 id=内存临时表>内存临时表</h2><p>如 MEMORY 内存临时表，当使用 order by rand() 查询语句时会自动生成。或者 <code>create table … engine=memory</code></p><h2 id=磁盘临时表>磁盘临时表</h2><p>mp_table_size 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表。</p><p>磁盘临时表使用的引擎默认是 InnoDB，是由参数 internal_tmp_disk_storage_engine 控制的。</p><h3 id=排序过程>排序过程</h3><p>当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程。</p><p>验证过程，将 tmp_table_size 设置成 1024，把 sort_buffer_size 设置成 32768, 把 max_length_for_sort_data 设置成 16。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>tmp_table_size</span><span style=color:#000>=</span><span style=color:#1c01ce>1024</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>sort_buffer_size</span><span style=color:#000>=</span><span style=color:#1c01ce>32768</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>max_length_for_sort_data</span><span style=color:#000>=</span><span style=color:#1c01ce>16</span>;
</span></span><span style=display:flex><span><span style=color:#177500>/* 打开 optimizer_trace，只对本线程有效 */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>SET</span> <span style=color:#000>optimizer_trace</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;enabled=on&#39;</span>; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>/* 执行语句 */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>word</span> <span style=color:#a90d91>from</span> <span style=color:#000>words</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>rand</span>() <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>/* 查看 OPTIMIZER_TRACE 输出 */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>SELECT</span> <span style=color:#000>*</span> <span style=color:#a90d91>FROM</span> <span style=color:#000>`</span><span style=color:#000>information_schema</span><span style=color:#000>`</span>.<span style=color:#000>`</span><span style=color:#000>OPTIMIZER_TRACE</span><span style=color:#000>`</span><span style=color:#000>\</span><span style=color:#a90d91>G</span>
</span></span></code></pre></td></tr></table></div></div></div><p><img src=../imgs/table_20220409_2.png alt=table_20220409_2.png></p><p>[OPTIMIZER_TRACE 部分结果]</p><p>因为将 max_length_for_sort_data 设置成 16，小于 word 字段的长度定义，所以 sort_mode 里面显示的是 rowid 排序。</p><p>rand 字段存放的随机值就 8 个字节，rowid 是 6 个字节，数据总行数是 10000，有 140000 字节，超过了 sort_buffer_size 定义的 32768 字节。但是，number_of_tmp_files 的值是 0。因为这里没有用到临时文件，采用是 MySQL 5.6 版本引入的优先队列排序而不是归并排序（不需要将所有数据都排序）。</p><p>优先队列算法可以精确地只得到三个最小值，执行流程如下：</p><p>1、对于这 10000 个准备排序的 (rand,rowid)，先取前三行，构造成一个堆；</p><p>2、取下一个行 (rand’,rowid’)，跟当前堆里面最大的 rand 比较，如果 rand’小于 rand，把这个 (rand,rowid) 从堆中去掉，换成 (rand’,rowid’)；</p><p>3、重复第 2 步，直到第 10000 个 (rand’,rowid’) 完成比较。</p><h2 id=临时表特性>临时表特性</h2><p>1、建表语法是 create temporary table …。</p><p>2、<strong>临时表只能被创建它的 session 访问，对其他线程不可见</strong>。</p><p>3、临时表可以与普通表同名。</p><p>4、session 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</p><p>5、show tables 命令不显示临时表。</p><p>由于临时表只能被创建它的 session 访问，所以 session 结束时会自动删除临时表。也正是由于这个特性，临时表就特别适合 join 优化场景。原因主要包括以下两个方面：</p><p>1、不同 session 的临时表是可以重名的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题。</p><p>2、不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。</p><h2 id=临时表应用>临时表应用</h2><p>由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分表系统的跨库查询就是一个典型的使用场景。</p><h2 id=临时表数据>临时表数据</h2><p>frm 文件放在临时文件目录下，文件名的后缀是.frm，前缀是进程id_线程id_序列号，每个线程的线程 id 不同，所以不同线程可以创建同名的临时表。可以使用 select @@tmpdir 命令，来显示实例的临时文件目录。</p><p>临时表中数据的存放方式，在不同的 MySQL 版本中有着不同的处理方式：</p><p>1、在 5.6 以及之前的版本里，MySQL 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件，用来存放数据文件；</p><p>2、从 5.7 版本开始，MySQL 引入了一个临时文件表空间，专门用来存放临时文件的数据。因此不需要再创建 ibd 文件。</p><p>MySQL 维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个 table_def_key。</p><p>1、一个普通表的 table_def_key 的值是由“库名 + 表名”得到，所以如果要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了。</p><p>2、而对于临时表，table_def_key 在“库名 + 表名”基础上，又加入了“server_id+thread_id”。</p><h2 id=临时表与主从同步>临时表与主从同步</h2><p>如果当前的 binlog_format=row，那么跟临时表有关的语句，不会记录到 binlog 里。也就是只在 binlog_format=statment/mixed 的时候，binlog 中才会记录临时表的操作。</p><p>这种情况下，创建临时表的语句会传到从库执行，因此从库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是从库同步线程是持续在运行的。所以这时候就需要在主库上再写一个 DROP TEMPORARY TABLE 传给从库执行。</p><p>MySQL 在记录 binlog 的时候，不论是 create table 还是 alter table 语句都是原样记录，甚至于连空格都不变。但是如果执行 drop table t_normal，系统记录 binlog 就会改成了标准的格式：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>DROP</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t_normal</span><span style=color:#000>`</span> <span style=color:#177500>/* generated by server */</span>
</span></span></code></pre></td></tr></table></div></div></div><p>drop table 命令是可以一次删除多个表的。比如设置 binlog_format=row，如果主库上执行 "drop table t_normal, temp_t"这个命令，那么 binlog 中就只能记录上面改写的语句。因为从库上并没有表 temp_t，将这个命令重写后再传到从库执行，才不会导致从库同步线程停止。</p><p>主库上不同的线程创建同名的临时表是没关系的，传到从库执行要把这两个同名的临时表当做两个不同的临时表来处理。MySQL 记录 binlog 时，会把主库执行语句的线程 id 写到 binlog 中。这样从库的应用线程就能够知道执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key（库名 + 表名 + serverid + thread_id）。</p><h2 id=临时表faq>临时表FAQ</h2><p><strong>MySQL 什么时候使用内部临时表？</strong></p><p>1、如果语句执行过程可以一边读数据，一边直接得到结果，不需要额外内存，否则就需要额外的内存，来保存中间结果；</p><p>2、join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；</p><p>三者的区别</p><p>joinBuffer: 用于在join语句中对驱动表进行暂存用，是无序数组；所以为什么BKA算法在用了JoinBuffer后不能原地排序只好借由MRR算法排序；</p><p>sortBuffer: order by 语句时，会将排序列进行暂存。sortBuffer不够的情况下，则是分段排序最后整合；</p><p>临时表：一种二维表结构，有主键，有field。所以如果中间数据需要用到二维表特性，那么就需要使用临时表，且内存临时表不够的前提下，会转为使用磁盘临时表</p><p>3、如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。</p><p>排序，分组，去重等可能会使用内存临时表。</p><p><strong>为什么不能用 rename 修改临时表的改名？</strong></p><p>在实现上执行 rename table 语句时，要求按照“库名 / 表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的 frm 文件是放在 tmpdir 目录下的，并且文件名的规则是“#sql{进程 id}<em>{线程 id}</em> 序列号.frm”，因此会报“找不到文件名”的错误。</p><h1 id=内存表>内存表</h1><p>两个 group by 语句都用了 order by null，使用内存临时表得到的语句结果里，0 在最后一行；而使用磁盘临时表得到的结果里，0 在第一行。这与内存的数据组织结构有关。</p><h2 id=内存表数据组织结构>内存表数据组织结构</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>create</span> <span style=color:#a90d91>table</span> <span style=color:#000>t21</span>(<span style=color:#000>id</span> <span style=color:#a90d91>int</span> <span style=color:#a90d91>primary</span> <span style=color:#a90d91>key</span>, <span style=color:#a90d91>c</span> <span style=color:#a90d91>int</span>) <span style=color:#000>engine</span><span style=color:#000>=</span><span style=color:#000>Memory</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>create</span> <span style=color:#a90d91>table</span> <span style=color:#000>t22</span>(<span style=color:#000>id</span> <span style=color:#a90d91>int</span> <span style=color:#a90d91>primary</span> <span style=color:#a90d91>key</span>, <span style=color:#a90d91>c</span> <span style=color:#a90d91>int</span>) <span style=color:#000>engine</span><span style=color:#000>=</span><span style=color:#000>innodb</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t21</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>1</span>),(<span style=color:#1c01ce>2</span>,<span style=color:#1c01ce>2</span>),(<span style=color:#1c01ce>3</span>,<span style=color:#1c01ce>3</span>),(<span style=color:#1c01ce>4</span>,<span style=color:#1c01ce>4</span>),(<span style=color:#1c01ce>5</span>,<span style=color:#1c01ce>5</span>),(<span style=color:#1c01ce>6</span>,<span style=color:#1c01ce>6</span>),(<span style=color:#1c01ce>7</span>,<span style=color:#1c01ce>7</span>),(<span style=color:#1c01ce>8</span>,<span style=color:#1c01ce>8</span>),(<span style=color:#1c01ce>9</span>,<span style=color:#1c01ce>9</span>),(<span style=color:#1c01ce>0</span>,<span style=color:#1c01ce>0</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t22</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>1</span>),(<span style=color:#1c01ce>2</span>,<span style=color:#1c01ce>2</span>),(<span style=color:#1c01ce>3</span>,<span style=color:#1c01ce>3</span>),(<span style=color:#1c01ce>4</span>,<span style=color:#1c01ce>4</span>),(<span style=color:#1c01ce>5</span>,<span style=color:#1c01ce>5</span>),(<span style=color:#1c01ce>6</span>,<span style=color:#1c01ce>6</span>),(<span style=color:#1c01ce>7</span>,<span style=color:#1c01ce>7</span>),(<span style=color:#1c01ce>8</span>,<span style=color:#1c01ce>8</span>),(<span style=color:#1c01ce>9</span>,<span style=color:#1c01ce>9</span>),(<span style=color:#1c01ce>0</span>,<span style=color:#1c01ce>0</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>分别执行：<style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; <span style=color:#a90d91>select</span> * from t21;
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>| id | c    |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>1</span> |    <span style=color:#1c01ce>1</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>2</span> |    <span style=color:#1c01ce>2</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>3</span> |    <span style=color:#1c01ce>3</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>4</span> |    <span style=color:#1c01ce>4</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>5</span> |    <span style=color:#1c01ce>5</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>6</span> |    <span style=color:#1c01ce>6</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>7</span> |    <span style=color:#1c01ce>7</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>8</span> |    <span style=color:#1c01ce>8</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>9</span> |    <span style=color:#1c01ce>9</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>0</span> |    <span style=color:#1c01ce>0</span> |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>10</span> rows in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.02 sec<span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql&gt; <span style=color:#a90d91>select</span> * from t22;
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>| id | c    |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>0</span> |    <span style=color:#1c01ce>0</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>1</span> |    <span style=color:#1c01ce>1</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>2</span> |    <span style=color:#1c01ce>2</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>3</span> |    <span style=color:#1c01ce>3</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>4</span> |    <span style=color:#1c01ce>4</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>5</span> |    <span style=color:#1c01ce>5</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>6</span> |    <span style=color:#1c01ce>6</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>7</span> |    <span style=color:#1c01ce>7</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>8</span> |    <span style=color:#1c01ce>8</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>9</span> |    <span style=color:#1c01ce>9</span> |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>10</span> rows in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></details><br></p><p>可以看到，内存表 t21 的返回结果里面 0 在最后一行，而 InnoDB 表 t22 的返回结果里 0 在第一行。
InnoDB 表的数据就放在主键索引树上，主键索引是 B+ 树。主键索引上的值是有序存储的。在执行 select * 的时候，就会按照叶子节点从左到右扫描，所以得到的结果里，0 就出现在第一行。</p><p><img src=../imgs/table_20220409_3.png alt=table_20220409_3.png></p><p>[t22 表的组织结构]</p><p>与 InnoDB 引擎不同，Memory 引擎的数据和索引是分开的。下图可以看到，内存表的数据部分以数组的方式单独存放，而主键 id 索引里，存的是每个数据的位置。主键 id 是 hash 索引，索引上的 key 并不是有序的。在内存表 t21 中执行 select * 的时候，走的是全表扫描，也就是顺序扫描这个数组。因此 0 就是最后一个被读到，并放入结果集的数据。</p><p><img src=../imgs/table_20220409_4.png alt=table_20220409_4.png></p><p>[t21 表的组织结构]</p><p>InnoDB 和 Memory 引擎的数据组织方式是不同的：</p><p>1、InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式称之为索引组织表（Index Organizied Table）。</p><p>2、而 Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，称之为堆组织表（Heap Organizied Table）。</p><p>两个引擎的一些典型不同：</p><p>1、InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</p><p>2、当数据文件有空洞时，InnoDB 表在插入新数据为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</p><p>3、数据位置发生变化时，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；</p><p>4、InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</p><p>5、InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</p><p>由于内存表的这些特性，每个数据行被删除以后，空出的这个位置都可以被接下来要插入的数据复用。比如，在表 t21 中执行：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>delete</span> <span style=color:#a90d91>from</span> <span style=color:#000>t21</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>5</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t21</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>10</span>,<span style=color:#1c01ce>10</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t21</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>就会看到返回结果里，id=10 这一行出现在 id=4 之后，也就是原来 id=5 这行数据的位置。
表 t21 的这个主键索引是哈希索引，因此如果执行范围查询，如 <code>select * from t1 where id&lt;5;</code> ，是用不上索引的，需要走全表扫描。</p><h2 id=hash索引和b-tree索引>hash索引和B-Tree索引</h2><p>内存表也是支持 B-Tree 索引的。在 id 列上创建一个 B-Tree 索引，SQL 语句可以这么写：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>t21</span> <span style=color:#a90d91>add</span> <span style=color:#a90d91>index</span> <span style=color:#000>a_btree_index</span> <span style=color:#a90d91>using</span> <span style=color:#000>btree</span> (<span style=color:#000>id</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>表 t1 的数据组织形式就变成了下图，跟 InnoDB 的 b+ 树索引组织形式类似：
<img src=../imgs/table_20220409_5.png alt=table_20220409_5.png></p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; <span style=color:#a90d91>select</span> * from t21 where id&lt;5;
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>| id | c    |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>0</span> |    <span style=color:#1c01ce>0</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>1</span> |    <span style=color:#1c01ce>1</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>2</span> |    <span style=color:#1c01ce>2</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>3</span> |    <span style=color:#1c01ce>3</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>4</span> |    <span style=color:#1c01ce>4</span> |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>5</span> rows in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.01 sec<span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql&gt; <span style=color:#a90d91>select</span> * from t21 force index<span style=color:#000>(</span>primary<span style=color:#000>)</span> where id&lt;5;
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>| id | c    |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>1</span> |    <span style=color:#1c01ce>1</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>2</span> |    <span style=color:#1c01ce>2</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>3</span> |    <span style=color:#1c01ce>3</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>4</span> |    <span style=color:#1c01ce>4</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>0</span> |    <span style=color:#1c01ce>0</span> |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>5</span> rows in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></details><br><p>可以看到，执行 <code>select * from t21 where id&lt;5</code> 的时候，优化器会选择 B-Tree 索引，所以返回结果是 0 到 4。 使用 force index 强行使用主键 id 这个索引，id=0 这一行就在结果集的最末尾了。
不建议在生产环境上使用内存表。原因主要包括两个方面：</p><p>1、锁粒度问题；</p><p>2、数据持久化问题。</p><h2 id=内存表的锁>内存表的锁</h2><p>内存表的锁粒度：内存表不支持行锁，只支持表锁。一张表只要有更新，就会堵住其他所有在这张表上的读写操作。</p><p>需要注意的是，这里的表锁跟之前介绍过的 MDL 锁不同，但都是表级的锁。</p><p>模拟内存表的表级锁</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>update t21 set id=sleep(50) where id=1;</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>select * from t21 where id=2;<br>(wait 50s)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>show processlist;</td></tr></tbody></table><p>在这个执行序列里，Session A 的 update 语句要执行 50 秒，在这个语句执行期间 Session B 的查询会进入锁等待状态。Session C 的 show processlist 结果输出如下：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>+----+------+-----------------+--------------------+---------+------+------------------------------+----------------------------------------+
</span></span><span style=display:flex><span>| Id | User | Host            | db                 | Command | Time | State                        | Info                                   |
</span></span><span style=display:flex><span>+----+------+-----------------+--------------------+---------+------+------------------------------+----------------------------------------+
</span></span><span style=display:flex><span>| <span style=color:#1c01ce>41</span> | root | localhost       | <span style=color:#a90d91>test</span>               | Query   |   <span style=color:#1c01ce>21</span> | User sleep                   | update t21 <span style=color:#a90d91>set</span> <span style=color:#000>id</span><span style=color:#000>=</span>sleep<span style=color:#000>(</span>50<span style=color:#000>)</span> where <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span> |
</span></span><span style=display:flex><span>| <span style=color:#1c01ce>43</span> | root | localhost       | <span style=color:#a90d91>test</span>               | Query   |    <span style=color:#1c01ce>6</span> | Waiting <span style=color:#a90d91>for</span> table level lock | <span style=color:#a90d91>select</span> * from t21 where <span style=color:#000>id</span><span style=color:#000>=</span>2           |
</span></span><span style=display:flex><span>| <span style=color:#1c01ce>45</span> | root | localhost       | <span style=color:#a90d91>test</span>               | Query   |    <span style=color:#1c01ce>0</span> | starting                     | show processlist                       |
</span></span><span style=display:flex><span>+----+------+-----------------+--------------------+---------+------+------------------------------+----------------------------------------+
</span></span></code></pre></td></tr></table></div></div></div><h2 id=内存表数据持久性>内存表数据持久性</h2><p>数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。</p><p>从库重启，内存表数据会被清空，接收客户端 update 语句后会执行失败，这样就会导致主备同步停止。如果这时候发生主备切换的话，客户端会看到表中数据“丢失”了。</p><p>MySQL 在实现上做了这样一件事儿：在数据库重启之后，（主库）往 binlog 里面写入一行 DELETE FROM t1。</p><p>由于重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个备库是双 M 架构，还可能导致主库的内存表数据被删掉。</p><p>建议把普通内存表都用 InnoDB 表来代替。有一个场景例外，就是临时表。</p><p>内存临时表刚好可以无视内存表的两个不足，主要是下面的三个原因：</p><p>1、临时表不会被其他线程访问，没有并发性的问题；</p><p>2、临时表重启后也是需要删除的，清空数据这个问题不存在；</p><p>3、备库的临时表也不会影响主库的用户线程。</p><p>扩展延伸</p><p>从库重启之后肯定是会导致从库的内存表数据被清空，进而导致主从同步停止。最好的做法是将它修改成 InnoDB 引擎表。如果业务场景暂时不允许修改引擎如何处理从库重启？</p><p>假设的是主库暂时不能修改引擎，那么就把从库的内存表引擎先都改成 InnoDB。对于每个内存表，执行</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>sql_log_bin</span><span style=color:#000>=</span><span style=color:#a90d91>off</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>tbl_name</span> <span style=color:#000>engine</span><span style=color:#000>=</span><span style=color:#000>innodb</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>这样就能避免从库重启时数据丢失的问题。
由于主库重启后，会往 binlog 里面写“delete from tbl_name”，这个命令传到从库，从库的同名的表数据也会被清空。因此，就不会出现主从同步停止的问题。</p><p>如果由于主库异常重启触发了 HA，这时之前修改过引擎的备库变成了主库。而原来的主库变成了新备库，在新备库上把所有的内存表（这时候表里没数据因为重启了）都改成 InnoDB 表。所以如果不能直接修改主库上的表引擎，可以配置一个自动巡检的工具，在备库上发现内存表就把引擎改了。</p><h1 id=union>union</h1><p>sort buffer、内存临时表和 join buffer 这三个数据结构都是用来存放语句执行过程中的中间数据，以辅助 SQL 语句的执行的。其中，排序时用到了 sort buffer，在使用 join 语句的时候用到了 join buffer。</p><h2 id=union执行流程>union执行流程</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; explain  <span style=color:#000>(</span><span style=color:#a90d91>select</span> <span style=color:#1c01ce>1000</span> as f<span style=color:#000>)</span> union <span style=color:#000>(</span><span style=color:#a90d91>select</span> id from t11 order by id desc limit 2<span style=color:#000>)</span>;
</span></span><span style=display:flex><span>+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+
</span></span><span style=display:flex><span>| id | select_type  | table      | partitions | <span style=color:#a90d91>type</span>  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |
</span></span><span style=display:flex><span>+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>1</span> | PRIMARY      | NULL       | NULL       | NULL  | NULL          | NULL    | NULL    | NULL | NULL |     NULL | No tables used  |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>2</span> | UNION        | t11        | NULL       | index | NULL          | PRIMARY | 4       | NULL |    <span style=color:#1c01ce>2</span> |   100.00 | Using index     |
</span></span><span style=display:flex><span>| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |
</span></span><span style=display:flex><span>+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>3</span> rows in set, <span style=color:#1c01ce>1</span> warning <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></div><p>第三行的 Extra 字段，表示在对子查询的结果集做 union 的时候，使用了临时表 (Using temporary)。
这条语句的执行流程：</p><p>1、创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段。</p><p>2、执行第一个子查询，得到 1000 这个值，并存入临时表中。</p><p>3、执行第二个子查询：</p><p>1）拿到第一行 id=1000，试图插入临时表中。但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</p><p>2）取到第二行 id=999，插入临时表成功。</p><p>4、从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是 1000 和 999。</p><p><img src=../imgs/table_20220409_6.png alt=table_20220409_6.png></p><p>[union 执行流程]</p><p>这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键 id 的唯一性约束，实现了 union 的语义。如果把上面这个语句中的 union 改成 union all 的话，就没有了“去重”的语义。这样执行时就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; explain  <span style=color:#000>(</span><span style=color:#a90d91>select</span> <span style=color:#1c01ce>1000</span> as f<span style=color:#000>)</span> union all <span style=color:#000>(</span><span style=color:#a90d91>select</span> id from t11 order by id desc limit 2<span style=color:#000>)</span>;
</span></span><span style=display:flex><span>+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------+
</span></span><span style=display:flex><span>| id | select_type | table | partitions | <span style=color:#a90d91>type</span>  | possible_keys | key     | key_len | ref  | rows | filtered | Extra          |
</span></span><span style=display:flex><span>+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------+
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>1</span> | PRIMARY     | NULL  | NULL       | NULL  | NULL          | NULL    | NULL    | NULL | NULL |     NULL | No tables used |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>2</span> | UNION       | t1    | NULL       | index | NULL          | PRIMARY | 4       | NULL |    <span style=color:#1c01ce>2</span> |   100.00 | Using index    |
</span></span><span style=display:flex><span>+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>2</span> rows in set, <span style=color:#1c01ce>1</span> warning <span style=color:#000>(</span>0.01 sec<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></div><p>可以看到，第二行的 Extra 字段显示的是 Using index，表示只使用了覆盖索引，没有用临时表了。</p><h2 id=group-by执行流程>group by执行流程</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>explain</span>  <span style=color:#a90d91>select</span> <span style=color:#000>id</span><span style=color:#000>%</span><span style=color:#1c01ce>10</span> <span style=color:#a90d91>as</span> <span style=color:#000>m</span>, <span style=color:#a90d91>count</span>(<span style=color:#000>*</span>) <span style=color:#a90d91>as</span> <span style=color:#a90d91>c</span> <span style=color:#a90d91>from</span> <span style=color:#000>t11</span> <span style=color:#a90d91>group</span> <span style=color:#a90d91>by</span> <span style=color:#000>m</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span> <span style=color:#000>id</span> <span style=color:#000>|</span> <span style=color:#000>select_type</span> <span style=color:#000>|</span> <span style=color:#a90d91>table</span> <span style=color:#000>|</span> <span style=color:#000>partitions</span> <span style=color:#000>|</span> <span style=color:#a90d91>type</span>  <span style=color:#000>|</span> <span style=color:#000>possible_keys</span> <span style=color:#000>|</span> <span style=color:#a90d91>key</span>  <span style=color:#000>|</span> <span style=color:#000>key_len</span> <span style=color:#000>|</span> <span style=color:#a90d91>ref</span>  <span style=color:#000>|</span> <span style=color:#a90d91>rows</span> <span style=color:#000>|</span> <span style=color:#000>filtered</span> <span style=color:#000>|</span> <span style=color:#000>Extra</span>                                        <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span>  <span style=color:#1c01ce>1</span> <span style=color:#000>|</span> <span style=color:#a90d91>SIMPLE</span>      <span style=color:#000>|</span> <span style=color:#000>t1</span>    <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span>       <span style=color:#000>|</span> <span style=color:#a90d91>index</span> <span style=color:#000>|</span> <span style=color:#a90d91>PRIMARY</span>,<span style=color:#000>a</span>     <span style=color:#000>|</span> <span style=color:#000>a</span>    <span style=color:#000>|</span> <span style=color:#1c01ce>5</span>       <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span> <span style=color:#000>|</span>  <span style=color:#1c01ce>100</span> <span style=color:#000>|</span>   <span style=color:#1c01ce>100</span>.<span style=color:#1c01ce>00</span> <span style=color:#000>|</span> <span style=color:#a90d91>Using</span> <span style=color:#a90d91>index</span>; <span style=color:#a90d91>Using</span> <span style=color:#a90d91>temporary</span>; <span style=color:#a90d91>Using</span> <span style=color:#000>filesort</span> <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#1c01ce>1</span> <span style=color:#a90d91>row</span> <span style=color:#a90d91>in</span> <span style=color:#a90d91>set</span>, <span style=color:#1c01ce>1</span> <span style=color:#000>warning</span> (<span style=color:#1c01ce>0</span>.<span style=color:#1c01ce>00</span> <span style=color:#000>sec</span>)
</span></span></code></pre></td></tr></table></div></div></div><p>在 Extra 字段里面，可以看到三个信息：
1、Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；</p><p>2、Using temporary，表示使用了临时表；</p><p>3、Using filesort，表示需要排序。</p><p>语句的执行流程：</p><p>1、创建内存临时表，表里有两个字段 m 和 c，主键是 m；</p><p>2、扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；</p><p>1）如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);</p><p>2）如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；</p><p>3、遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。</p><p>如果并不需要对结果进行排序，那可以在 SQL 语句末尾增加 order by null，也就是改成：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>id</span><span style=color:#000>%</span><span style=color:#1c01ce>10</span> <span style=color:#a90d91>as</span> <span style=color:#000>m</span>, <span style=color:#a90d91>count</span>(<span style=color:#000>*</span>) <span style=color:#a90d91>as</span> <span style=color:#a90d91>c</span> <span style=color:#a90d91>from</span> <span style=color:#000>t11</span> <span style=color:#a90d91>group</span> <span style=color:#a90d91>by</span> <span style=color:#000>m</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#a90d91>null</span>; <span style=color:#000>//</span> <span style=color:#000>Q11</span>
</span></span></code></pre></td></tr></table></div></div></div><p>这样就跳过了最后排序的阶段，直接从临时表中取数据返回。
内存临时表的大小是有限制的，参数 tmp_table_size 就是控制这个内存大小的，默认是 16M。</p><p>如果把内存临时表的大小限制为最大 1024 字节，并把语句改成 id % 100，这样返回结果里有 100 行数据。但是，这时的内存临时表大小不够存下这 100 行数据，也就是说，执行过程中会发现内存临时表大小到达了上限（1024 字节）。</p><p>这时候就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是 InnoDB。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; <span style=color:#a90d91>set</span> <span style=color:#000>tmp_table_size</span><span style=color:#000>=</span>1024;
</span></span><span style=display:flex><span>mysql&gt; <span style=color:#a90d91>select</span> id%100 as m, count<span style=color:#000>(</span>*<span style=color:#000>)</span> as c from t11 group by m order by null limit 10; // Q12
</span></span><span style=display:flex><span>+------+----+
</span></span><span style=display:flex><span>| m    | c  |
</span></span><span style=display:flex><span>+------+----+
</span></span><span style=display:flex><span>|    <span style=color:#1c01ce>0</span> | <span style=color:#1c01ce>10</span> |
</span></span><span style=display:flex><span>|    <span style=color:#1c01ce>1</span> | <span style=color:#1c01ce>10</span> |
</span></span><span style=display:flex><span>|    <span style=color:#1c01ce>2</span> | <span style=color:#1c01ce>10</span> |
</span></span><span style=display:flex><span>|    <span style=color:#1c01ce>3</span> | <span style=color:#1c01ce>10</span> |
</span></span><span style=display:flex><span>|    <span style=color:#1c01ce>4</span> | <span style=color:#1c01ce>10</span> |
</span></span><span style=display:flex><span>|    <span style=color:#1c01ce>5</span> | <span style=color:#1c01ce>10</span> |
</span></span><span style=display:flex><span>|    <span style=color:#1c01ce>6</span> | <span style=color:#1c01ce>10</span> |
</span></span><span style=display:flex><span>|    <span style=color:#1c01ce>7</span> | <span style=color:#1c01ce>10</span> |
</span></span><span style=display:flex><span>|    <span style=color:#1c01ce>8</span> | <span style=color:#1c01ce>10</span> |
</span></span><span style=display:flex><span>|    <span style=color:#1c01ce>9</span> | <span style=color:#1c01ce>10</span> |
</span></span><span style=display:flex><span>+------+----+
</span></span><span style=display:flex><span><span style=color:#1c01ce>10</span> rows in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.01 sec<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></div><p>如果这个表 t1 的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。
扩展：</p><p>Q11 和 Q12 都是 order by null，但是 m 的排序不一样，一个是 9-0 另一个是 0-9</p><p>因为 Q11 使用的是内存临时表，使用的引擎是 Memory，哈希索引按插入的顺序读取数据；Q12 使用的磁盘临时表，使用的引擎是innodb，innodb是索引组织表，按主键顺序存储数据，所以是按照m字段有序的。</p><h3 id=group-by索引优化>group by索引优化</h3><p>上面可以看到，不论是使用内存临时表还是磁盘临时表，group by 逻辑都需要构造一个带唯一索引的表，执行代价比较高。如果表的数据量比较大，上面这个 group by 语句执行起来就会很慢。</p><p>group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以就需要有一个临时表，来记录并统计结果。如果扫描过程中可以保证出现的数据是有序的，那么计算 group by 的时候，就只需要从左到右，顺序扫描，依次累加。也就是下面这个过程：</p><p>1、当碰到第一个 1 的时候，已经知道累积了 X 个 0，结果集里的第一行就是 (0,X)；</p><p>2、当碰到第一个 2 的时候，已经知道累积了 Y 个 1，结果集里的第二行就是 (1,Y);</p><p>就可以拿到 group by 的结果，不需要临时表，也不需要再额外排序。</p><p>InnoDB 的索引，就可以满足这个输入有序的条件！</p><p>在 MySQL 5.7 版本支持了 generated column 机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引（如果是 MySQL 5.6 及之前的版本，也可以创建普通列和索引，来解决这个问题）</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>t11</span> <span style=color:#a90d91>add</span> <span style=color:#a90d91>column</span> <span style=color:#000>z</span> <span style=color:#a90d91>int</span> <span style=color:#a90d91>generated</span> <span style=color:#000>always</span> <span style=color:#a90d91>as</span>(<span style=color:#000>id</span> <span style=color:#000>%</span> <span style=color:#1c01ce>100</span>), <span style=color:#a90d91>add</span> <span style=color:#a90d91>index</span>(<span style=color:#000>z</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>这样索引 z 上的数据就是有序了。上面的 group by 语句就可以改成：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>select</span> <span style=color:#000>z</span>, <span style=color:#a90d91>count</span>(<span style=color:#000>*</span>) <span style=color:#a90d91>as</span> <span style=color:#a90d91>c</span> <span style=color:#a90d91>from</span> <span style=color:#000>t11</span> <span style=color:#a90d91>group</span> <span style=color:#a90d91>by</span> <span style=color:#000>z</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span> <span style=color:#000>id</span> <span style=color:#000>|</span> <span style=color:#000>select_type</span> <span style=color:#000>|</span> <span style=color:#a90d91>table</span> <span style=color:#000>|</span> <span style=color:#000>partitions</span> <span style=color:#000>|</span> <span style=color:#a90d91>type</span>  <span style=color:#000>|</span> <span style=color:#000>possible_keys</span> <span style=color:#000>|</span> <span style=color:#a90d91>key</span>  <span style=color:#000>|</span> <span style=color:#000>key_len</span> <span style=color:#000>|</span> <span style=color:#a90d91>ref</span>  <span style=color:#000>|</span> <span style=color:#a90d91>rows</span> <span style=color:#000>|</span> <span style=color:#000>filtered</span> <span style=color:#000>|</span> <span style=color:#000>Extra</span>       <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span>  <span style=color:#1c01ce>1</span> <span style=color:#000>|</span> <span style=color:#a90d91>SIMPLE</span>      <span style=color:#000>|</span> <span style=color:#000>t11</span>   <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span>       <span style=color:#000>|</span> <span style=color:#a90d91>index</span> <span style=color:#000>|</span> <span style=color:#000>z</span>             <span style=color:#000>|</span> <span style=color:#000>z</span>    <span style=color:#000>|</span> <span style=color:#1c01ce>5</span>       <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span> <span style=color:#000>|</span> <span style=color:#1c01ce>1000</span> <span style=color:#000>|</span>   <span style=color:#1c01ce>100</span>.<span style=color:#1c01ce>00</span> <span style=color:#000>|</span> <span style=color:#a90d91>Using</span> <span style=color:#a90d91>index</span> <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#1c01ce>1</span> <span style=color:#a90d91>row</span> <span style=color:#a90d91>in</span> <span style=color:#a90d91>set</span>, <span style=color:#1c01ce>1</span> <span style=color:#000>warning</span> (<span style=color:#1c01ce>0</span>.<span style=color:#1c01ce>00</span> <span style=color:#000>sec</span>)
</span></span></code></pre></td></tr></table></div></div></div></p><p>从 Extra 字段可以看到，这个语句的执行不再需要临时表，也不需要排序了。</p><h3 id=group-by直接排序优化>group by直接排序优化</h3><p>碰上不适合创建索引的场景就没办法使用索引优化了。</p><p>一个 group by 语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”不太好。可以直接走磁盘临时表。</p><p>在 group by 语句中加入 SQL_BIG_RESULT 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p><p>MySQL 的优化器看磁盘临时表是 B+ 树存储，存储效率不如数组高，从磁盘空间考虑直接用数组。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>SQL_BIG_RESULT</span> <span style=color:#000>id</span><span style=color:#000>%</span><span style=color:#1c01ce>100</span> <span style=color:#a90d91>as</span> <span style=color:#000>m</span>, <span style=color:#a90d91>count</span>(<span style=color:#000>*</span>) <span style=color:#a90d91>as</span> <span style=color:#a90d91>c</span> <span style=color:#a90d91>from</span> <span style=color:#000>t11</span> <span style=color:#a90d91>group</span> <span style=color:#a90d91>by</span> <span style=color:#000>m</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>流程如下：
1、初始化 sort_buffer，确定放入一个整型字段，记为 m；</p><p>2、扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；</p><p>3、扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；</p><p>4、排序完成后，就得到了一个有序数组。</p><p><img src=../imgs/table_20220409_7.png alt=table_20220409_7.png></p><p>[使用 SQL_BIG_RESULT 的执行流程图]</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>t11</span> <span style=color:#a90d91>drop</span> <span style=color:#a90d91>column</span> <span style=color:#000>z</span>;  <span style=color:#000>#</span> <span style=color:#000>删除索引</span> <span style=color:#000>z</span>
</span></span><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#a90d91>desc</span> <span style=color:#000>t11</span>;  <span style=color:#000>#</span> <span style=color:#000>查看表结构</span>
</span></span><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>explain</span> <span style=color:#a90d91>select</span> <span style=color:#000>SQL_BIG_RESULT</span> <span style=color:#000>id</span><span style=color:#000>%</span><span style=color:#1c01ce>100</span> <span style=color:#a90d91>as</span> <span style=color:#000>m</span>, <span style=color:#a90d91>count</span>(<span style=color:#000>*</span>) <span style=color:#a90d91>as</span> <span style=color:#a90d91>c</span> <span style=color:#a90d91>from</span> <span style=color:#000>t11</span> <span style=color:#a90d91>group</span> <span style=color:#a90d91>by</span> <span style=color:#000>m</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span> <span style=color:#000>id</span> <span style=color:#000>|</span> <span style=color:#000>select_type</span> <span style=color:#000>|</span> <span style=color:#a90d91>table</span> <span style=color:#000>|</span> <span style=color:#000>partitions</span> <span style=color:#000>|</span> <span style=color:#a90d91>type</span>  <span style=color:#000>|</span> <span style=color:#000>possible_keys</span> <span style=color:#000>|</span> <span style=color:#a90d91>key</span>  <span style=color:#000>|</span> <span style=color:#000>key_len</span> <span style=color:#000>|</span> <span style=color:#a90d91>ref</span>  <span style=color:#000>|</span> <span style=color:#a90d91>rows</span> <span style=color:#000>|</span> <span style=color:#000>filtered</span> <span style=color:#000>|</span> <span style=color:#000>Extra</span>                       <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span>  <span style=color:#1c01ce>1</span> <span style=color:#000>|</span> <span style=color:#a90d91>SIMPLE</span>      <span style=color:#000>|</span> <span style=color:#000>t11</span>   <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span>       <span style=color:#000>|</span> <span style=color:#a90d91>index</span> <span style=color:#000>|</span> <span style=color:#a90d91>PRIMARY</span>,<span style=color:#000>a</span>     <span style=color:#000>|</span> <span style=color:#000>a</span>    <span style=color:#000>|</span> <span style=color:#1c01ce>5</span>       <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span> <span style=color:#000>|</span> <span style=color:#1c01ce>1000</span> <span style=color:#000>|</span>   <span style=color:#1c01ce>100</span>.<span style=color:#1c01ce>00</span> <span style=color:#000>|</span> <span style=color:#a90d91>Using</span> <span style=color:#a90d91>index</span>; <span style=color:#a90d91>Using</span> <span style=color:#000>filesort</span> <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#1c01ce>1</span> <span style=color:#a90d91>row</span> <span style=color:#a90d91>in</span> <span style=color:#a90d91>set</span>, <span style=color:#1c01ce>1</span> <span style=color:#000>warning</span> (<span style=color:#1c01ce>0</span>.<span style=color:#1c01ce>00</span> <span style=color:#000>sec</span>)
</span></span></code></pre></td></tr></table></div></div></div><p>从 Extra 字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。</p><h3 id=group-by小结>group by小结</h3><p>group by 使用指导原则：</p><p>1、如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；</p><p>2、尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；</p><p>3、如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；</p><p>4、如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。</p><h1 id=排序>排序</h1><h2 id=全字段排序>全字段排序</h2><p>全字段排序流程：</p><p>这个语句执行流程如下所示 ：</p><p>1、初始化 sort_buffer，确定放入查询的所有字段；</p><p>2、从二级索引中找到第一个满足条件的主键 id；</p><p>3、到主键 id 索引取出整行，取 查询的所有字段 的值，存入 sort_buffer 中；</p><p>4、从二级索引中取下一个记录的主键 id；</p><p>5、重复步骤 3、4 直到 where 查询条件不满足为止；</p><p>6、对 sort_buffer 中的数据按照 order 字段做<strong>快速排序</strong>；</p><p>7、按照排序结果取前 limit 行返回给客户端。</p><p>按照 order 字段排序，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。</p><p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p><p>可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#177500>/* 打开optimizer_trace，只对本线程有效 */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>SET</span> <span style=color:#000>optimizer_trace</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;enabled=on&#39;</span>; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>/* @a保存Innodb_rows_read的初始值 */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>VARIABLE_VALUE</span> <span style=color:#a90d91>into</span> <span style=color:#000>@</span><span style=color:#000>a</span> <span style=color:#a90d91>from</span>  <span style=color:#000>performance_schema</span>.<span style=color:#000>session_status</span> <span style=color:#a90d91>where</span> <span style=color:#000>variable_name</span> <span style=color:#000>=</span> <span style=color:#c41a16>&#39;Innodb_rows_read&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>/* 执行语句，查询的 SQL 语句 */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>xxx</span> <span style=color:#a90d91>from</span> <span style=color:#000>tx</span> <span style=color:#a90d91>where</span> <span style=color:#000>xx</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>xx</span> <span style=color:#a90d91>limit</span> <span style=color:#000>xx</span>; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>/* 查看 OPTIMIZER_TRACE 输出 */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>SELECT</span> <span style=color:#000>*</span> <span style=color:#a90d91>FROM</span> <span style=color:#000>`</span><span style=color:#000>information_schema</span><span style=color:#000>`</span>.<span style=color:#000>`</span><span style=color:#000>OPTIMIZER_TRACE</span><span style=color:#000>`</span><span style=color:#000>\</span><span style=color:#a90d91>G</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>/* @b保存Innodb_rows_read的当前值 */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>VARIABLE_VALUE</span> <span style=color:#a90d91>into</span> <span style=color:#000>@</span><span style=color:#000>b</span> <span style=color:#a90d91>from</span> <span style=color:#000>performance_schema</span>.<span style=color:#000>session_status</span> <span style=color:#a90d91>where</span> <span style=color:#000>variable_name</span> <span style=color:#000>=</span> <span style=color:#c41a16>&#39;Innodb_rows_read&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>/* 计算Innodb_rows_read差值 */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>@</span><span style=color:#000>b</span><span style=color:#000>-@</span><span style=color:#000>a</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>通过查看 OPTIMIZER_TRACE 的结果来确认的，可以从 number_of_tmp_files 中看到是否使用临时文件。</p><p><img src=../imgs/table_20220409_8.png alt=table_20220409_8.png></p><p>number_of_tmp_files 表示排序过程中使用的临时文件数。</p><p>内存放不下需要排序的数据时，就会用外部排序，一般使用归并排序。这里临时文件数就是归并排序将数据分成的份数，最后再合并成一个文件。</p><p>如果 sort_buffer_size 超过了需要排序的数据量大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。</p><p>examined_rows 表示参与排序的行数</p><p>sort_mode 里面的 packed_additional_fields 的意思是，排序过程对字符串做了“紧凑”处理。即使字段的定义是 varchar(xx)，在排序过程中还是要按照实际长度来分配空间。</p><p>注意：因为查询 OPTIMIZER_TRACE 表时，需要用到临时表，而 internal_tmp_disk_storage_engine 的默认值是 InnoDB。如果使用的是 InnoDB 引擎的话，把数据从临时表取出来的时候，会让 Innodb_rows_read 的值加 1，可以设置成 MyISAM。</p><p>举例：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>city</span><span style=color:#000>`</span> <span style=color:#a90d91>varchar</span>(<span style=color:#1c01ce>16</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>name</span><span style=color:#000>`</span> <span style=color:#a90d91>varchar</span>(<span style=color:#1c01ce>16</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>age</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>addr</span><span style=color:#000>`</span> <span style=color:#a90d91>varchar</span>(<span style=color:#1c01ce>128</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#000>city</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#000>city</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>查询语句：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>city</span>,<span style=color:#000>name</span>,<span style=color:#000>age</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>city</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;杭州&#39;</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>name</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1000</span>  ;
</span></span></code></pre></td></tr></table></div></div></div></p><p>这里需要在 city 字段加上索引（略）。
explain SQL 查询语句，Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。</p><h2 id=rowid排序>rowid排序</h2><p>如果 MySQL 认为排序的单行长度太大，会采用另外一种 rowid 排序算法（如果没有主键 id，那么会自动生成一个长度为 6 字节的rowid 来作为主键）。</p><p>可以通过下列参数设置用于排序的行数据的长度的一个参数。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>SET max_length_for_sort_data = 16;
</span></span></code></pre></td></tr></table></div></div></div><p>新的算法会根据行数据的长度计算放入 sort_buffer 的字段，如只要排序的列和主键 id。整体流程如下：</p><p>1、初始化 sort_buffer，确定放入两个字段，即 排序字段 和主键 id；</p><p>2、从二级索引中找到第一个满足条件的主键 id；</p><p>3、到主键 id 索引取出整行，取 条件、id 字段，存入 sort_buffer 中；</p><p>4、从二级索引中取下一个记录的主键 id；</p><p>5、重复步骤 3、4 直到不满足条件为止；</p><p>6、对 sort_buffer 中的数据按照排序字段进行排序；</p><p>7、遍历排序结果，取前 limit 行，并按照 id 的值回到原表中取出其它所需字段返回给客户端。</p><h2 id=排序对比>排序对比</h2><p>MySQL 认为内存太小，会影响排序效率，就会采用 rowid 排序算法，排序过程中一次可以排序更多航，但是需要再回到原表去取数据。</p><p>如果认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，排序后可以直接从内存中返回查询结果，不用再回到原表中去取数据。</p><p>排序的操作成本较高，排序的根本原因在于原来的数据都是无序的，如果要避免排序操作，那么保证原来的数据有序即可。这里自然联想到使用索引，具体来说是联合索引，可以通过 explain 的 Extra 字段来验证。进一步还可以结合覆盖索引，避免回表的操作。</p><h1 id=全表扫描>全表扫描</h1><h2 id=客户端连接>客户端连接</h2><p>如果库里面的表特别多，连接就会很慢。其实这并不是连接慢也不是服务端慢，而是客户端慢，因为要执行哈希操作构建一个本地的哈希表。</p><p>比如有些线上的库，会包含很多表如 6 万个表。会发现每次用客户端连接都会卡在下面这个连接上：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span> <span style=color:#000>-</span><span style=color:#000>h127</span>.<span style=color:#1c01ce>0</span>.<span style=color:#1c01ce>0</span>.<span style=color:#1c01ce>1</span> <span style=color:#000>-</span><span style=color:#000>uroot</span> <span style=color:#000>-</span><span style=color:#000>pxxx</span> <span style=color:#000>db123</span>
</span></span></code></pre></td></tr></table></div></div></div><p>并且终端还提示使用 -A 参数可以关掉自动补全功能，然后客户端就可以快速返回了。
除了加 -A 以外，加 –quick(简写为 -q) 参数，也可以跳过这个阶段。但是需要注意设置这个参数可能会降低服务端的性能。</p><p>因为 MySQL 客户端发送请求后，接收服务端返回结果的方式有两种：</p><p>1、一种是本地缓存，也就是在本地开一片内存，先把结果存起来。API 开发对应的就是 mysql_store_result 方法。</p><p>2、另一种是不缓存，读一个处理一个。API 开发对应的就是 mysql_use_result 方法。</p><p>MySQL 客户端默认采用第一种方式，而如果加上–quick 参数，就会使用第二种不缓存的方式。</p><p>采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。</p><h2 id=server层>server层</h2><p>对一个 200G 的 InnoDB 表 db1. t，执行一个全表扫描。把扫描结果保存在客户端，会使用类似这样的命令：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span> <span style=color:#000>-</span><span style=color:#000>h$host</span> <span style=color:#000>-</span><span style=color:#000>P$port</span> <span style=color:#000>-</span><span style=color:#000>u$user</span> <span style=color:#000>-</span><span style=color:#000>p$pwd</span> <span style=color:#000>-</span><span style=color:#000>e</span> <span style=color:#c41a16>&#34;select * from db1.t&#34;</span> <span style=color:#000>&gt;</span> <span style=color:#000>$</span><span style=color:#000>target_file</span>
</span></span></code></pre></td></tr></table></div></div></div><p>服务端查询数据并不需要保存一个完整的结果集。取数据和发数据的流程：
1、获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。</p><p>2、重复获取行，直到 net_buffer 写满，调用网络接口发出去。</p><p>3、如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer。</p><p>4、如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</p><p>从这个流程可以知道：</p><p>1、一个查询在发送过程中，占用的 MySQL 内部的内存最大就是 net_buffer_length 这么大，全表扫描时并不会达到表的大小；</p><p>2、socket send buffer 在全表扫描时也不可能达到表的大小（默认定义 /proc/sys/net/core/wmem_default），如果 socket send buffer 被写满，就会暂停读数据的流程。</p><p>所以 MySQL 是“边读边发”，就意味着如果客户端接收得慢，会导致 MySQL 服务端由于结果发不出去，事务的执行时间变长。</p><h2 id=innodb引擎层>InnoDB引擎层</h2><h3 id=buffer-pool>Buffer Pool</h3><p>介绍 WAL 机制时，分析了 InnoDB 内存的一个作用是保存更新的结果，再配合 redo log，就避免了随机写盘。</p><p>内存的数据页是在 Buffer Pool (BP) 中管理的，在 WAL 里 Buffer Pool 起到了加速更新的作用。而实际上，Buffer Pool 还有一个更重要的作用是加速查询。</p><p>由于有 WAL 机制，当事务提交的时候，磁盘上的数据页是旧的，如果这时马上有一个查询要来读这个数据页，并不需要立即把 redo log 应用到数据页。因为这时候内存数据页的结果是最新的，直接读内存页就可以了。（注意这里跟 change buffer 和 redo log 不矛盾）</p><p>InnoDB Buffer Pool 的大小是由参数 innodb_buffer_pool_size 确定的，一般建议设置成可用物理内存的 60%~80%。</p><h3 id=内存命中率>内存命中率</h3><p>Buffer Pool 对查询的加速效果，依赖于内存命中率这个重要指标。</p><p>一般一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在 99% 以上。查看系统当前 BP 命中率，可以通过 show engine innodb status，“Buffer pool hit rate”字样显示的就是当前的命中率。</p><h3 id=lru算法改进>LRU算法改进</h3><p>InnoDB 内存管理用的是最近最少使用 (Least Recently Used, LRU) 算法，这个算法的核心就是淘汰最久未使用的数据。</p><p>但是全表扫描就会把当前的 Buffer Pool 里的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。也就是说 Buffer Pool 里面主要放的是这个历史数据表的数据。会使内存命令率急剧下降，磁盘压力增加，SQL 语句响应变慢。因此对 LRU 算法进行了改进。</p><p>在 InnoDB 实现上，按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。靠近链表头部的 5/8 是 young 区域，靠近链表尾部的 3/8 是 old 区域。</p><p>改进后的 LRU 算法逻辑：</p><p>1、扫描过程中，需要新插入的数据页，都被放到 old 区域 ;</p><p>2、一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过 1 秒，因此还是会被保留在 old 区域；</p><p>3、再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部（也就是 young 区域），很快就会被淘汰出去。</p><p>这个策略最大的收益就是在扫描这个大表的过程中，虽然也用到了 Buffer Pool，但是对 young 区域完全没有影响，从而保证了 Buffer Pool 响应正常业务的查询命中率。</p><h1 id=自增id>自增id</h1><h2 id=自增主键>自增主键</h2><p>自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，索引更紧凑。</p><p>但自增主键不能保证连续递增。</p><h3 id=自增值保存策略>自增值保存策略</h3><p>实际上，表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。</p><p>不同的引擎对于自增值的保存策略不同。</p><p>1、MyISAM 引擎的自增值保存在数据文件中。</p><p>2、InnoDB 引擎的自增值，其实是保存在了内存里，并且到了 MySQL 8.0 版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为 MySQL 重启前的值”，具体情况是：</p><p>1）在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。﻿</p><p>举例：如果一个表当前数据行里最大的 id 是 10，AUTO_INCREMENT=11。这时删除 id=10 的行，AUTO_INCREMENT 还是 11。但如果马上重启实例，重启后这个表的 AUTO_INCREMENT 就会变成 10。﻿也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。</p><p>2）在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值。</p><h3 id=自增值修改机制>自增值修改机制</h3><p>MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><p>1、如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</p><p>2、如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</p><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是 X，当前的自增值是 Y。</p><p>1、如果 X&lt;Y，那么这个表的自增值不变；</p><p>2、如果 X≥Y，就需要把当前自增值修改为新的自增值。</p><p>新的自增值生成算法是：从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值。（两个系统参数默认都为1）</p><h3 id=自增值修改时机>自增值修改时机</h3><p>自增值改成插入的值，是在真正执行插入数据的操作之前。</p><p>自增值不连续的原因：</p><p>1、唯一键冲突</p><p>2、事务回滚</p><p>3、批量插入（申请id是上一次的 2 倍）</p><p><strong>自增值不能回退的原因</strong></p><p>假设有两个并行执行的事务，在申请自增值时，为了避免两个事务申请到相同的自增 id，肯定要加锁然后顺序申请。</p><p>1、假设事务 A 申请到了 id=2， 事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行。</p><p>2、事务 B 正确提交了，但事务 A 出现了唯一键冲突。</p><p>3、如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现：表里面已经有 id=3 的行，而当前的自增 id 值是 2。</p><p>4、接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”。</p><p>为了解决这个主键冲突，有两种方法：</p><p>1、每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。</p><p>2、把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</p><p>这两个方法都会导致性能问题。因此 InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。</p><h3 id=自增锁的优化>自增锁的优化</h3><p>自增 id 锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。（在 MySQL 5.1 版本之前，并不是这样的）</p><p>在 MySQL 5.0 版本，自增锁的范围是语句级别。如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。这样设计会影响并发度。</p><p>MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode，默认值是 1。</p><p>1、参数值为 0 时，表示采用之前 MySQL 5.0 版本的策略，即语句执行结束后才释放锁；</p><p>2、参数值为 1 时：普通 insert 语句，自增锁在申请之后就马上释放；类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</p><p>2、参数值为 2 时，所有的申请自增主键的动作都是申请后就释放锁。</p><p>默认设置下 insert … select 要使用语句级锁 和 默认值不为 2 都是为了数据的一致性。</p><p>举例：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>insert into t31 values(null, 1, 1);<br>insert into t31 values(null, 2, 2);<br>insert into t31 values(null, 3, 3);<br>insert into t31 values(null, 4, 4);</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>create table t32 like t31;</td></tr><tr><td style=text-align:left>insert into t32 values(null, 5, 5);</td><td style=text-align:left>insert into t32(c,d) select c,d from t31;</td></tr></tbody></table><p>如果 Session B 是申请了自增值以后马上就释放自增锁，那么可能出现：</p><p>1、Session B 先插入了两个记录，(1,1,1)、(2,2,2)；</p><p>2、然后 Session A 来申请自增 id 得到 id=3，往 t32 插入了（3,5,5)；</p><p>3、之后 Session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</p><p>如果 binlog_format=statement，由于两个 session 是同时执行插入数据命令的，所以 binlog 里面对表 t32 的更新日志只有两种情况：要么先记 Session A 要么先记 Session B 。</p><p>但不论是哪一种，binlog 去从库执行或者用来恢复临时实例，从库和临时实例里面，Session B 语句执行出来生成的结果里面，id 都是连续的。这时，这个库就发生了数据不一致。</p><p>出现这个问题是因为原库 Session B 的 insert 语句，生成的 id 不连续。这个不连续的 id，用 statement 格式的 binlog 来串行执行，是执行不出来的。</p><p>要解决这个问题有两种思路：</p><p>1、让原库的批量插入数据语句，固定生成连续的 id 值。自增锁直到语句执行结束才释放就是为了这个目的。</p><p>2、在 binlog 里面把插入数据的操作都如实记录进来，到从库执行的时候，不再依赖于自增主键去生成。其实就是 innodb_autoinc_lock_mode 设置为 2，同时 binlog_format 设置为 row。</p><p>生产上尤其是有 insert … select 这种批量插入数据（insert … select、replace … select 和 load data 语句）的场景时，从并发插入数据性能的角度考虑，建议这样设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row. 这样既能提升并发性又不会出现数据一致性问题。</p><p>在普通的 insert 语句里面包含多个 value 值的情况下，即使 innodb_autoinc_lock_mode 设置为 1，也不会等语句执行完成才释放锁。因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，一次性申请完成后锁就可以释放了。所以只有针对不知道预先需要申请多少个 id 的场景需要注意。</p><h3 id=批量插入申请id策略>批量插入申请id策略</h3><p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p><p>1、语句执行过程中，第一次申请自增 id，会分配 1 个；</p><p>2、1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</p><p>3、2 个用完以后，这个语句第三次申请自增 id，会分配 4 个；</p><p>4、依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</p><p>举例：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t31</span> <span style=color:#a90d91>values</span>(<span style=color:#a90d91>null</span>, <span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>1</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t31</span> <span style=color:#a90d91>values</span>(<span style=color:#a90d91>null</span>, <span style=color:#1c01ce>2</span>,<span style=color:#1c01ce>2</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t31</span> <span style=color:#a90d91>values</span>(<span style=color:#a90d91>null</span>, <span style=color:#1c01ce>3</span>,<span style=color:#1c01ce>3</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t31</span> <span style=color:#a90d91>values</span>(<span style=color:#a90d91>null</span>, <span style=color:#1c01ce>4</span>,<span style=color:#1c01ce>4</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>create</span> <span style=color:#a90d91>table</span> <span style=color:#000>t32</span> <span style=color:#a90d91>like</span> <span style=color:#000>t31</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t32</span>(<span style=color:#a90d91>c</span>,<span style=color:#000>d</span>) <span style=color:#a90d91>select</span> <span style=color:#a90d91>c</span>,<span style=color:#000>d</span> <span style=color:#a90d91>from</span> <span style=color:#000>t31</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t32</span> <span style=color:#a90d91>values</span>(<span style=color:#a90d91>null</span>, <span style=color:#1c01ce>5</span>,<span style=color:#1c01ce>5</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>insert…select，实际上往表 t32 中插入了 4 行数据。但是，这四行数据是分三次申请的自增 id，第一次申请到了 id=1，第二次被分配了 id=2 和 id=3， 第三次被分配到 id=4 到 id=7。由于这条语句实际只用上了 4 个 id，所以 id=5 到 id=7 就被浪费掉了。之后，再执行
insert into t32 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p><p>这是主键 id 出现自增 id 不连续的第三种原因。</p><h3 id=自增主键主从同步>自增主键主从同步</h3><p>binlog_format=statement下，即使两个 INSERT 语句在主备库的执行顺序不同，自增主键字段的值也不会不一致。因为会通过 <code>SET INSERT_ID</code> 设置主键：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>SET</span> <span style=color:#000>INSERT_ID</span><span style=color:#000>=</span><span style=color:#1c01ce>2</span>;
</span></span><span style=display:flex><span><span style=color:#000>语句</span><span style=color:#000>B</span><span style=color:#000>；</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>SET</span> <span style=color:#000>INSERT_ID</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span><span style=color:#000>语句</span><span style=color:#000>A</span><span style=color:#000>；</span>
</span></span></code></pre></td></tr></table></div></div></div><h2 id=自增id上限>自增id上限</h2><p>无符号整型 (unsigned int) 是 4 个字节，上限就是 2^32-1。</p><h3 id=表定义自增值id>表定义自增值id</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>create</span> <span style=color:#a90d91>table</span> <span style=color:#000>te</span>(<span style=color:#000>id</span> <span style=color:#a90d91>int</span> <span style=color:#000>unsigned</span> <span style=color:#000>auto_increment</span> <span style=color:#a90d91>primary</span> <span style=color:#a90d91>key</span>) <span style=color:#000>auto_increment</span><span style=color:#000>=</span><span style=color:#1c01ce>4294967295</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>te</span> <span style=color:#a90d91>values</span>(<span style=color:#a90d91>null</span>);
</span></span><span style=display:flex><span><span style=color:#000>//</span><span style=color:#000>成功插入一行</span> <span style=color:#1c01ce>4294967295</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>show</span> <span style=color:#a90d91>create</span> <span style=color:#a90d91>table</span> <span style=color:#000>t</span>;
</span></span><span style=display:flex><span><span style=color:#177500>/* CREATE TABLE `t` (
</span></span></span><span style=display:flex><span><span style=color:#177500>  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
</span></span></span><span style=display:flex><span><span style=color:#177500>  PRIMARY KEY (`id`)
</span></span></span><span style=display:flex><span><span style=color:#177500>) ENGINE=InnoDB AUTO_INCREMENT=4294967295;
</span></span></span><span style=display:flex><span><span style=color:#177500>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t</span> <span style=color:#a90d91>values</span>(<span style=color:#a90d91>null</span>);
</span></span><span style=display:flex><span><span style=color:#000>//</span><span style=color:#000>Duplicate</span> <span style=color:#000>entry</span> <span style=color:#c41a16>&#39;4294967295&#39;</span> <span style=color:#a90d91>for</span> <span style=color:#a90d91>key</span> <span style=color:#c41a16>&#39;PRIMARY&#39;</span>
</span></span></code></pre></td></tr></table></div></div></div><p>2^32-1（4294967295）不是一个特别大的数，对于一个频繁插入删除数据的表来说，是可能会被用完的。因此在建表时需要考察表是否有可能达到这个上限，如果有可能，就应该创建成 8 个字节的 bigint unsigned。</p><h3 id=innodb自增row-id>InnoDB自增row_id</h3><p>如果创建的 InnoDB 表没有指定主键，那么 InnoDB 会给你创建一个不可见的，长度为 6 个字节的 row_id。InnoDB 维护了一个全局的 dict_sys.row_id 值，所有无主键的 InnoDB 表，每插入一行数据，都将当前的 dict_sys.row_id 值作为要插入数据的 row_id，然后把 dict_sys.row_id 的值加 1。</p><p>实际上，在代码实现时 row_id 是一个长度为 8 字节的无符号长整型 (bigint unsigned)。但是，InnoDB 在设计时，给 row_id 留的只是 6 个字节的长度，这样写到数据表中时只放了最后 6 个字节，所以 row_id 能写到数据表中的值，就有两个特征：</p><p>1、row_id 写入表中的值范围，是从 0 到 2^48-1；</p><p>2、当 dict_sys.row_id=2^48时，如果再有插入数据的行为要来申请 row_id，拿到以后再取最后 6 个字节的话就是 0。</p><p>验证（使用 gdb 修改系统的自增 row_id 来实现）：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; create table tem<span style=color:#000>(</span>a int<span style=color:#000>)</span><span style=color:#000>engine</span><span style=color:#000>=</span>innodb;
</span></span><span style=display:flex><span>gdb -p &lt;pid of mysqld&gt; -ex <span style=color:#c41a16>&#39;p dict_sys.row_id=1&#39;</span> --batch
</span></span><span style=display:flex><span>mysql&gt; insert into tem values<span style=color:#000>(</span>1<span style=color:#000>)</span>;
</span></span><span style=display:flex><span>gdb -p &lt;pid of mysqld&gt; -ex <span style=color:#c41a16>&#39;p dict_sys.row_id=281474976710656&#39;</span> --batch
</span></span><span style=display:flex><span>mysql&gt; insert into tem values<span style=color:#000>(</span>2<span style=color:#000>)</span>;
</span></span><span style=display:flex><span>mysql&gt; insert into tem values<span style=color:#000>(</span>3<span style=color:#000>)</span>;
</span></span><span style=display:flex><span>mysql&gt; <span style=color:#a90d91>select</span> * from tem;
</span></span></code></pre></td></tr></table></div></div></div><p><img src=../imgs/table_20220409_9.png alt=table_20220409_9.png></p><p>图中可以看到，a=1 的数据被覆盖了。</p><p>从这个角度看，我们还是应该在 InnoDB 表中主动创建自增主键。因为，表自增 id 到达上限后，再插入数据时报主键冲突错误，是更能被接受的。</p><p>毕竟覆盖数据，就意味着数据丢失，影响的是数据可靠性；报主键冲突，是插入失败，影响的是可用性。而一般情况下，可靠性优先于可用性。</p><h3 id=xid>Xid</h3><p>redo log 和 binlog 相配合的时候，提到了它们有一个共同的字段叫作 Xid。它在 MySQL 中是用来对应事务的。</p><p>MySQL 内部维护了一个全局变量 global_query_id，每次执行语句的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。</p><p>而 global_query_id 是一个纯内存变量，重启之后就清零了。所以在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。</p><p>但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，同一个 binlog 文件里，Xid 一定是惟一的。</p><p>如果 global_query_id 达到上限后，就会继续从 0 开始计数。从理论上讲，还是就会出现同一个 binlog 里面出现相同 Xid 的场景。2^64-1 太大了，这个可能性仅存在理论上。</p><h3 id=innodb-trx-id>innodb trx_id</h3><p>Xid 是由 server 层维护的。InnoDB 内部使用 Xid 是为了能够在 InnoDB 事务和 server 之间做关联。trx_id 就是MVCC的版本号，是InnoDB内部自己维护的，每次事务开启时都会向InnoDB事务系统申请，是严格顺序递增的。</p><p>InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。</p><p>InnoDB 数据可见性的核心思想是：每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比。</p><p>对于正在执行的事务，你可以从 information_schema.innodb_trx 表中看到事务的 trx_id。如：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>use</span> <span style=color:#000>information_schema</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>trx_id</span>, <span style=color:#000>trx_mysql_thread_id</span> <span style=color:#a90d91>from</span> <span style=color:#000>information_schema</span>.<span style=color:#000>innodb_trx</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>trx_id 实验的时候发现不止加 1，原因如下：</p><p>1、update 和 delete 语句除了事务本身，还涉及到标记删除旧数据，也就是要把数据放到 purge 队列里等待后续物理删除，这个操作也会把 max_trx_id+1， 因此在一个事务中至少加 2；</p><p>2、InnoDB 的后台操作，比如表的索引信息统计这类操作，也是会启动内部事务的，因此你可能看到，trx_id 值并不是按照加 1 递增的。</p><p>对于只读事务（select 后面加上 for update 不是只读事务），InnoDB 并不会分配 trx_id。会话没有执行到更新语句也是只读事务，等执行到更新语句才不是只读事务，才开始分配 trx_id。</p><p>只读事务分配的 trx_id 仅用作展示，值看起来很大。这个数字是每次查询的时候由系统临时计算出来的。算法是：把当前事务的 trx 变量的指针地址转成整数，再加上 2^48。可以保证如下：</p><p>1、为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在 innodb_trx 还是在 innodb_locks 表里，同一个只读事务查出来的 trx_id 就会是一样的。</p><p>2、如果有并行的多个只读事务，每个事务的 trx 变量的指针地址肯定不同。这样，不同的并发只读事务，查出来的 trx_id 就是不同的。</p><p>在显示值里面加上 2^48，目的是要保证只读事务显示的 trx_id 值比较大，正常情况下就会区别于读写事务的 id。但是，trx_id 跟 row_id 的逻辑类似，定义长度也是 8 个字节。因此，在理论上还是可能出现一个读写事务与一个只读事务显示的 trx_id 相同的情况。不过这个概率很低，并且也没有什么实质危害，可以忽略。</p><p>只读事务不分配 trx_id 的好处：</p><p>1、可以减小事务视图里面活跃事务数组的大小。因为当前正在运行的只读事务，是不影响数据的可见性判断的。所以在创建事务的一致性视图时，InnoDB 就只需要拷贝读写事务的 trx_id。</p><p>2、可以减少 trx_id 的申请次数。在 InnoDB 里，即使只是执行一个普通的 select 语句，在执行过程中，也是要对应一个只读事务的。所以只读事务优化后，普通的查询语句不需要申请 trx_id，就大大减少了并发事务申请 trx_id 的锁冲突。</p><p>max_trx_id 会持久化存储，重启也不会重置为 0，理论上只要一个 MySQL 服务跑得足够久，就可能出现 max_trx_id 达到 248-1 的上限，然后从 0 开始的情况。当达到这个状态后，MySQL 就会持续出现一个脏读的 bug。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; create table tem<span style=color:#000>(</span>id int primary key, c int<span style=color:#000>)</span><span style=color:#000>engine</span><span style=color:#000>=</span>innodb;
</span></span><span style=display:flex><span>mysql&gt; insert into tem values<span style=color:#000>(</span>1,1<span style=color:#000>)</span>;
</span></span><span style=display:flex><span>gdb -p &lt;pid of mysqld&gt; -ex <span style=color:#c41a16>&#39;p trx_sys-&gt;max_trx_id=281474976710655&#39;</span> --batch
</span></span></code></pre></td></tr></table></div></div></div><table><thead><tr><th style=text-align:left></th><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>T1</td><td style=text-align:left>begin;<br>select * from tem;<br>(1,1)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>update tem set c=2 where id=1;<br>begin;<br>update tem set c=3 where id=1;</td></tr><tr><td style=text-align:left></td><td style=text-align:left>select * from tem;<br>(1,3) // 脏读</td><td style=text-align:left></td></tr></tbody></table><p>由于已经把系统的 max_trx_id 设置成了 2^48-1，所以在 Session A 启动的事务 TA 的低水位就是 2^48-1。</p><p>T2 时刻，Session B 执行第一条 update 语句的事务 id 就是 2^48-1，而第二条 update 语句的事务 id 就是 0，即 trx_id 就是 0。</p><p>T3 时刻，Session A 执行 select 语句时，判断可见性发现 c=3 的 trx_id 小于事务 TA 的低水位，因此认为这个数据可见。</p><p>这就导致了脏读。且MySQL 重启时 max_trx_id 也不会清 0，也就是说重启 MySQL，这个 bug 仍然存在。这个 bug 是只要 MySQL 实例服务时间够长，就会必然出现的。</p><h3 id=thread-id>thread_id</h3><p>thread_id 就是系统保存了一个全局变量 thread_id_counter，每新建一个连接就将 thread_id_counter 赋值给这个新连接的线程变量。</p><p>show processlist 里的第一列就是 thread_id。</p><p>thread_id_counter 定义的大小是 4 个字节，达到 2^32-1 后就会重置为 0，然后继续增加。不会在 show processlist 里看到两个相同的 thread_id。因为 MySQL 设计了一个唯一数组的逻辑，给新线程分配 thread_id 的时候，逻辑代码会判断：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>do</span> {
</span></span><span style=display:flex><span>  <span style=color:#000>new_id</span><span style=color:#000>=</span> <span style=color:#000>thread_id_counter</span><span style=color:#000>++</span>;
</span></span><span style=display:flex><span>} <span style=color:#a90d91>while</span> (<span style=color:#000>!</span><span style=color:#000>thread_ids</span>.<span style=color:#000>insert_unique</span>(<span style=color:#000>new_id</span>).<span style=color:#000>second</span>);
</span></span></code></pre></td></tr></table></div></div></div><h3 id=自增id上限小结>自增id上限小结</h3><p>每种自增 id 有各自的应用场景，在达到上限后的表现也不同：</p><p>1、表的自增 id 达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误。</p><p>2、row_id 达到上限后，则会归 0 再重新递增，如果出现相同的 row_id，后写的数据会覆盖之前的数据。</p><p>3、Xid 只需要不在同一个 binlog 文件中出现重复值即可。虽然理论上会出现重复值，但是概率极小，可以忽略不计。</p><p>4、InnoDB 的 max_trx_id 递增值每次 MySQL 重启都会被保存起来，上文中提到的脏读的例子就是一个必现的 bug，好在还有很充裕的时间去解决。</p><p>5、thread_id 是使用中最常见的，而且也是处理得最好的一个自增 id 逻辑。</p><h1 id=分区表>分区表</h1><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t51</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>ftime</span><span style=color:#000>`</span> <span style=color:#000>datetime</span> <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>ftime</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span> <span style=color:#a90d91>DEFAULT</span> <span style=color:#000>CHARSET</span><span style=color:#000>=</span><span style=color:#000>latin1</span>
</span></span><span style=display:flex><span><span style=color:#000>PARTITION</span> <span style=color:#a90d91>BY</span> <span style=color:#000>RANGE</span> (<span style=color:#a90d91>YEAR</span>(<span style=color:#000>ftime</span>))
</span></span><span style=display:flex><span>(<span style=color:#000>PARTITION</span> <span style=color:#000>p_2017</span> <span style=color:#a90d91>VALUES</span> <span style=color:#a90d91>LESS</span> <span style=color:#a90d91>THAN</span> (<span style=color:#1c01ce>2017</span>) <span style=color:#000>ENGINE</span> <span style=color:#000>=</span> <span style=color:#000>InnoDB</span>,
</span></span><span style=display:flex><span> <span style=color:#000>PARTITION</span> <span style=color:#000>p_2018</span> <span style=color:#a90d91>VALUES</span> <span style=color:#a90d91>LESS</span> <span style=color:#a90d91>THAN</span> (<span style=color:#1c01ce>2018</span>) <span style=color:#000>ENGINE</span> <span style=color:#000>=</span> <span style=color:#000>InnoDB</span>,
</span></span><span style=display:flex><span> <span style=color:#000>PARTITION</span> <span style=color:#000>p_2019</span> <span style=color:#a90d91>VALUES</span> <span style=color:#a90d91>LESS</span> <span style=color:#a90d91>THAN</span> (<span style=color:#1c01ce>2019</span>) <span style=color:#000>ENGINE</span> <span style=color:#000>=</span> <span style=color:#000>InnoDB</span>,
</span></span><span style=display:flex><span><span style=color:#000>PARTITION</span> <span style=color:#000>p_others</span> <span style=color:#a90d91>VALUES</span> <span style=color:#a90d91>LESS</span> <span style=color:#a90d91>THAN</span> <span style=color:#a90d91>MAXVALUE</span> <span style=color:#000>ENGINE</span> <span style=color:#000>=</span> <span style=color:#000>InnoDB</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t51</span> <span style=color:#a90d91>values</span>(<span style=color:#c41a16>&#39;2017-4-1&#39;</span>,<span style=color:#1c01ce>1</span>),(<span style=color:#c41a16>&#39;2018-4-1&#39;</span>,<span style=color:#1c01ce>1</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>这个表包含了一个.frm 文件和 4 个.ibd 文件，每个分区对应一个.ibd 文件。即：
1、对于引擎层来说，这是 4 个表；</p><p>2、对于 Server 层来说，这是 1 个表。</p><p>（略，待补充）</p><h1 id=最佳实践>最佳实践</h1><h2 id=更新相同数据>更新相同数据</h2><p>表：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t3</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span><span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span> <span style=color:#a90d91>primary</span> <span style=color:#a90d91>key</span> <span style=color:#000>auto_increment</span>,
</span></span><span style=display:flex><span><span style=color:#000>`</span><span style=color:#000>a</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t3</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>2</span>);  <span style=color:#000>#</span> <span style=color:#000>只有一条数据</span>
</span></span></code></pre></td></tr></table></div></div></div><p>执行更新语句<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; update t3 <span style=color:#a90d91>set</span> <span style=color:#000>a</span><span style=color:#000>=</span><span style=color:#1c01ce>2</span> where <span style=color:#000>id</span><span style=color:#000>=</span>1;
</span></span><span style=display:flex><span>Query OK, <span style=color:#1c01ce>0</span> rows affected <span style=color:#000>(</span>0.03 sec<span style=color:#000>)</span>
</span></span><span style=display:flex><span>Rows matched: 1  Changed: 0  Warnings: <span style=color:#1c01ce>0</span>
</span></span></code></pre></td></tr></table></div></div></div></p><p>可能发生以下三种情况：
1、更新都是先读后写，MySQL 读出数据发现值与原来相同，不更新直接返回；</p><p>2、MySQL 调用了 InnoDB 引擎提供的修改接口，但是引擎发现值与原来相同，不更新直接返回；</p><p>3、InnoDB 执行了修改接口，该解锁的加锁，该更新的更新。</p><p>问题：实际情况是哪种？如何构造实验验证？</p><p><strong>验证情况 1</strong></p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>update t3 set a=2 where id=1;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t3 set a=2 where id=1;<br>(blocked)</td></tr></tbody></table><p>Session B 的 update 语句被 blocked 了，加锁这个动作是 InnoDB 才能做的，所以排除情况 1。</p><p>验证情况 2</p><p>使用可见性实验确认</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select * from t3 where id=1;<br># 返回 (1,2)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t3 set a=3 where id=1;</td></tr><tr><td style=text-align:left>update t3 set a=3 where id=1;<br>Query OK, 0 rows affected (0.00 sec)<br>Rows matched: 1  Changed: 0  Warnings: 0</td><td style=text-align:left></td></tr><tr><td style=text-align:left>select * from t3 where id=1;<br># 返回 (1,3)</td><td style=text-align:left></td></tr></tbody></table><p>（注意：这里 set a=3 不会触发“当前读”）</p><p>session A 的第二个 select 语句是一致性读（快照读)，它是不能看见 session B 的更新的。</p><p>现在它返回的是 (1,3)，表示它看见了某个新的版本，这个版本只能是 session A 自己的 update 语句做更新的时候生成。</p><p>所以应该是情况 3。</p><p>为什么 MySQL 更新前不判断值是否相同？</p><p>其实 MySQL 确认了。只是这个语句中，MySQL 认为读出来的值只有 id=1 是确定的，而要写的是 a=3，只从这两个信息看不出来“不需要修改”。</p><p>验证：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select * from t3 where id=1;<br># 返回 (1,2)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t3 set a=3 where id=1;</td></tr><tr><td style=text-align:left>update t3 set a=3 where id=1 and a=3;<br>Query OK, 0 rows affected (0.01 sec)<br>Rows matched: 1  Changed: 0  Warnings: 0</td><td style=text-align:left></td></tr><tr><td style=text-align:left>select * from t3 where id=1;<br># 返回 (1,2)</td><td style=text-align:left></td></tr></tbody></table><p>注意：上面的验证结果都是在 binlog_format=statement 格式下进行的。</p><p>如果是 binlog_format=row 并且 binlog_row_image=FULL 的时候，由于 MySQL 需要在 binlog 里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来了。</p><p>根据上面说的规则，“既然读了数据，就会判断”， 因此在这时候，select * from t where id=1，结果就是“返回 (1,2)”。</p><p>同理，如果是 binlog_row_image=NOBLOB, 会读出除 blob 外的所有字段，在我们这个例子里，结果还是“返回 (1,2)”。</p><p>MySQL 5.6 版本引入的，对应的代码读字段逻辑：</p><p><img src=../imgs/table_20220409_10.png alt=table_20220409_10.png></p><p>如果表中有 timestamp 字段而且设置了自动更新的话，那么更新“别的字段”的时候，MySQL 会读入所有涉及的字段，这样通过判断，就会发现不需要修改。</p><h2 id=in使用索引>in使用索引</h2><p>例：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>field1</span> <span style=color:#a90d91>in</span> (<span style=color:#c41a16>&#39;AA&#39;</span>,<span style=color:#c41a16>&#34;BB&#34;</span>) <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>field2</span> <span style=color:#a90d91>limit</span> <span style=color:#000>n</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>field1</span> <span style=color:#a90d91>in</span> (<span style=color:#c41a16>&#39;AA&#39;</span>,<span style=color:#c41a16>&#34;BB&#34;</span>) <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>field2</span> <span style=color:#a90d91>limit</span> <span style=color:#a90d91>start</span>,<span style=color:#000>page</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>方法1：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>field1</span><span style=color:#000>=</span><span style=color:#c41a16>&#34;AA&#34;</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>field2</span> <span style=color:#a90d91>limit</span> <span style=color:#000>n</span>; 
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>field1</span><span style=color:#000>=</span><span style=color:#c41a16>&#34;BB&#34;</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>field2</span> <span style=color:#a90d91>limit</span> <span style=color:#000>n</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>field1</span><span style=color:#000>=</span><span style=color:#c41a16>&#34;AA&#34;</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>field2</span> <span style=color:#a90d91>limit</span> (<span style=color:#a90d91>start</span><span style=color:#000>+</span><span style=color:#000>page</span>); 
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>field1</span><span style=color:#000>=</span><span style=color:#c41a16>&#34;BB&#34;</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>field2</span> <span style=color:#a90d91>limit</span> (<span style=color:#a90d91>start</span><span style=color:#000>+</span><span style=color:#000>page</span>);
</span></span></code></pre></td></tr></table></div></div></div></p><p>方法2：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>id</span>,<span style=color:#000>a</span>,... <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>field1</span><span style=color:#000>=</span><span style=color:#c41a16>&#34;AA&#34;</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>field2</span> <span style=color:#a90d91>limit</span> (<span style=color:#a90d91>start</span><span style=color:#000>+</span><span style=color:#000>page</span>); 
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>id</span>,<span style=color:#000>a</span>,... <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>field1</span><span style=color:#000>=</span><span style=color:#c41a16>&#34;BB&#34;</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>field2</span> <span style=color:#a90d91>limit</span> (<span style=color:#a90d91>start</span><span style=color:#000>+</span><span style=color:#000>page</span>);
</span></span></code></pre></td></tr></table></div></div></div></p><h2 id=rand排序>rand排序</h2><p>表结构：</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>words</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span> <span style=color:#000>AUTO_INCREMENT</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>word</span><span style=color:#000>`</span> <span style=color:#a90d91>varchar</span>(<span style=color:#1c01ce>64</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>delimiter</span> ;;
</span></span><span style=display:flex><span><span style=color:#a90d91>create</span> <span style=color:#a90d91>procedure</span> <span style=color:#000>idata_word</span>()
</span></span><span style=display:flex><span><span style=color:#a90d91>begin</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>declare</span> <span style=color:#000>i</span> <span style=color:#a90d91>int</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>set</span> <span style=color:#000>i</span><span style=color:#000>=</span><span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>while</span> <span style=color:#000>i</span><span style=color:#000>&lt;</span><span style=color:#1c01ce>10000</span> <span style=color:#a90d91>do</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>words</span>(<span style=color:#000>word</span>) <span style=color:#a90d91>values</span>(<span style=color:#000>concat</span>(<span style=color:#a90d91>char</span>(<span style=color:#1c01ce>97</span><span style=color:#000>+</span>(<span style=color:#000>i</span> <span style=color:#000>div</span> <span style=color:#1c01ce>1000</span>)), <span style=color:#a90d91>char</span>(<span style=color:#1c01ce>97</span><span style=color:#000>+</span>(<span style=color:#000>i</span> <span style=color:#000>%</span> <span style=color:#1c01ce>1000</span> <span style=color:#000>div</span> <span style=color:#1c01ce>100</span>)), <span style=color:#a90d91>char</span>(<span style=color:#1c01ce>97</span><span style=color:#000>+</span>(<span style=color:#000>i</span> <span style=color:#000>%</span> <span style=color:#1c01ce>100</span> <span style=color:#000>div</span> <span style=color:#1c01ce>10</span>)), <span style=color:#a90d91>char</span>(<span style=color:#1c01ce>97</span><span style=color:#000>+</span>(<span style=color:#000>i</span> <span style=color:#000>%</span> <span style=color:#1c01ce>10</span>))));
</span></span><span style=display:flex><span>    <span style=color:#a90d91>set</span> <span style=color:#000>i</span><span style=color:#000>=</span><span style=color:#000>i</span><span style=color:#000>+</span><span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>end</span> <span style=color:#000>while</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>end</span>;;
</span></span><span style=display:flex><span><span style=color:#a90d91>delimiter</span> ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>call</span> <span style=color:#000>idata_word</span>();
</span></span></code></pre></td></tr></table></div></div></details><br><p>随机读取 3 个单词：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>word</span> <span style=color:#a90d91>from</span> <span style=color:#000>words</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>rand</span>() <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>3</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><p>分析：</p><p>explain 查看 Extra 字段显示 Using temporary，表示需要使用临时表；Using filesort 表示需要执行排序操作。</p><p>对于 InnoDB 表来说，执行全字段排序会减少磁盘访问，会被优先选择。</p><p>但是这里是 临时内存表，回表过程只是简单根据数据行的位置直接访问内存得到数据，不会增加访问磁盘次数。所以优化器会优先考虑用于排序的行越小越好，因此这时会选择 rowid 排序。</p><p>上述随机读取单词 SQL 执行流程：</p><p>1、创建一个临时表。临时表使用的是 memory 引擎，表里有主键 id 和 double 类型的 rand。（表没有索引）</p><p>2、按主键顺序取出所有的 word 字段，对于每一个 word 值，调用 rand() 生成一个大于 0 小于 1 的随机小数，并把随机小数和 word 分别存入临时表的字段中，到此扫描行数是 10000。</p><p>3、在内存临时表中，准备按照 rand() 字段排序。</p><p>4、初始化 sort_buffer。一个主键 id 另外一个 rand 字段。</p><p>5、从内存临时表中一行一行取出 rand 值和位置信息（InnoDB 表是主键 id，MEMORY 引擎不是索引组织表，可以理解 rowid 就是数组的下标），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加了 10000，变成了 20000。</p><p>6、在 sort_buffer 中根据 rand 值进行排序。注意：这里没有涉及到表操作，不会增加扫描行数。</p><p>7、排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</p><p>可以通过慢日志（slow log）验证上述分析得到的扫描行数。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span># Query_time: 0.900376 Lock_time: 0.000347 
</span></span><span style=display:flex><span>Rows_sent: 3 Rows_examined: 20003SET timestamp=1541402277;
</span></span><span style=display:flex><span>select word from words order by rand() limit 3;
</span></span></code></pre></td></tr></table></div></div></div><p>Rows_examined：20003 就表示这个语句执行过程中扫描了 20003 行。</p><h2 id=随机排序>随机排序</h2><p>同上，如果只随机选择 1 个 word 值。</p><h3 id=随机算法1>随机算法1</h3><p>1、取得这个表的主键 id 的最大值 M 和最小值 N；</p><p>2、用随机函数生成一个最大值到最小值之间的数 X = (M-N)*rand() + N；</p><p>3、取不小于 X 的第一个 ID 的行。</p><p>执行语句：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#a90d91>max</span>(<span style=color:#000>id</span>),<span style=color:#a90d91>min</span>(<span style=color:#000>id</span>) <span style=color:#a90d91>into</span> <span style=color:#000>@</span><span style=color:#000>M</span>,<span style=color:#000>@</span><span style=color:#000>N</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> ;
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>@</span><span style=color:#000>X</span><span style=color:#000>=</span> <span style=color:#000>floor</span>((<span style=color:#000>@</span><span style=color:#000>M</span><span style=color:#000>-@</span><span style=color:#000>N</span><span style=color:#000>+</span><span style=color:#1c01ce>1</span>)<span style=color:#000>*</span><span style=color:#000>rand</span>() <span style=color:#000>+</span> <span style=color:#000>@</span><span style=color:#000>N</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span> <span style=color:#000>&gt;=</span> <span style=color:#000>@</span><span style=color:#000>X</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>该方法效率很高，取 max(id) 和 min(id) 都是不需要扫描索引的，而第三步的 select 也可以用索引快速定位，可以认为就只扫描了 3 行。
但它不是真正的随机，因为 id 可能不是连续的，选择不同行的概率不一样。</p><h3 id=随机算法2>随机算法2</h3><p>1、取得整个表的行数，并记为 C。</p><p>2、取得 Y = floor(C * rand())。 floor 函数在这里的作用，就是取整数部分。</p><p>3、再用 limit Y,1 取得一行。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#a90d91>count</span>(<span style=color:#000>*</span>) <span style=color:#a90d91>into</span> <span style=color:#000>@</span><span style=color:#a90d91>C</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>@</span><span style=color:#000>Y</span> <span style=color:#000>=</span> <span style=color:#000>floor</span>(<span style=color:#000>@</span><span style=color:#a90d91>C</span> <span style=color:#000>*</span> <span style=color:#000>rand</span>());
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>@</span><span style=color:#a90d91>sql</span> <span style=color:#000>=</span> <span style=color:#000>concat</span>(<span style=color:#c41a16>&#34;select * from t limit &#34;</span>, <span style=color:#000>@</span><span style=color:#000>Y</span>, <span style=color:#c41a16>&#34;,1&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>prepare</span> <span style=color:#000>stmt</span> <span style=color:#a90d91>from</span> <span style=color:#000>@</span><span style=color:#a90d91>sql</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>execute</span> <span style=color:#000>stmt</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>DEALLOCATE</span> <span style=color:#a90d91>prepare</span> <span style=color:#000>stmt</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>（limit 后面的参数不能直接跟变量，代码中使用了 prepare+execute 的方法）
总结，这种随机算法比 rand 排序效率要高很多。</p><p>进阶：如果需要取 3 个值</p><h3 id=随机算法3>随机算法3</h3><p>1、取得整个表的行数，记为 C；</p><p>2、根据相同的随机方法得到 Y1、Y2、Y3；</p><p>3、再执行三个 limit Y, 1 语句得到三行数据。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#a90d91>count</span>(<span style=color:#000>*</span>) <span style=color:#a90d91>into</span> <span style=color:#000>@</span><span style=color:#a90d91>C</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>@</span><span style=color:#000>Y1</span> <span style=color:#000>=</span> <span style=color:#000>floor</span>(<span style=color:#000>@</span><span style=color:#a90d91>C</span> <span style=color:#000>*</span> <span style=color:#000>rand</span>());
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>@</span><span style=color:#000>Y2</span> <span style=color:#000>=</span> <span style=color:#000>floor</span>(<span style=color:#000>@</span><span style=color:#a90d91>C</span> <span style=color:#000>*</span> <span style=color:#000>rand</span>());
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>@</span><span style=color:#000>Y3</span> <span style=color:#000>=</span> <span style=color:#000>floor</span>(<span style=color:#000>@</span><span style=color:#a90d91>C</span> <span style=color:#000>*</span> <span style=color:#000>rand</span>());
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>limit</span> <span style=color:#000>@</span><span style=color:#000>Y1</span><span style=color:#000>，</span><span style=color:#1c01ce>1</span><span style=color:#000>；</span> <span style=color:#000>//</span><span style=color:#000>在应用代码里面取</span><span style=color:#000>Y1</span><span style=color:#000>、</span><span style=color:#000>Y2</span><span style=color:#000>、</span><span style=color:#000>Y3值</span><span style=color:#000>，拼出</span><span style=color:#000>SQL后执行</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>limit</span> <span style=color:#000>@</span><span style=color:#000>Y2</span><span style=color:#000>，</span><span style=color:#1c01ce>1</span><span style=color:#000>；</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>limit</span> <span style=color:#000>@</span><span style=color:#000>Y3</span><span style=color:#000>，</span><span style=color:#1c01ce>1</span><span style=color:#000>；</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=随机算法4>随机算法4</h3><p>随机算法 3 的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，对其进一步优化，减少扫描行数。</p><p>取 Y1、Y2 和 Y3 里面最大的一个数，记为 M，最小的一个数记为 N，然后执行下面这条 SQL 语句：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>limit</span> <span style=color:#000>N</span>, <span style=color:#000>M</span><span style=color:#000>-</span><span style=color:#000>N</span><span style=color:#000>+</span><span style=color:#1c01ce>1</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>再加上取整个表总行数的 C 行，扫描行数总共只需要 C+M+1 行。</p><h2 id=sql长时间不返回>SQL长时间不返回</h2><p>表结构与数据：</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t4</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>delimiter</span> ;;
</span></span><span style=display:flex><span><span style=color:#a90d91>create</span> <span style=color:#a90d91>procedure</span> <span style=color:#000>idata_4</span>()
</span></span><span style=display:flex><span><span style=color:#a90d91>begin</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>declare</span> <span style=color:#000>i</span> <span style=color:#a90d91>int</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>set</span> <span style=color:#000>i</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>while</span>(<span style=color:#000>i</span><span style=color:#000>&lt;=</span><span style=color:#1c01ce>100000</span>) <span style=color:#a90d91>do</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t4</span> <span style=color:#a90d91>values</span>(<span style=color:#000>i</span>,<span style=color:#000>i</span>);
</span></span><span style=display:flex><span>    <span style=color:#a90d91>set</span> <span style=color:#000>i</span><span style=color:#000>=</span><span style=color:#000>i</span><span style=color:#000>+</span><span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>end</span> <span style=color:#000>while</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>end</span>;;
</span></span><span style=display:flex><span><span style=color:#a90d91>delimiter</span> ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>call</span> <span style=color:#000>idata_4</span>();
</span></span></code></pre></td></tr></table></div></div></details><br><h3 id=等mdl锁>等MDL锁</h3><p>查询语句：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t4</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>一般这种情况，大概率是表 t4 被锁住了。接下来分析原因的时候，一般都是首先执行一下 show processlist 命令，查看当前语句处于什么状态。
show processlist 可以看到 Waiting for table metadata lock，这个状态表示，有一个线程正在表 t4 上请求或者持有 MDL 写锁，把 select 语句堵住了。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; show processlist;
</span></span><span style=display:flex><span>+----+------+-----------------+--------------------+---------+------+---------------------------------+-----------------------------+
</span></span><span style=display:flex><span>| Id | User | Host            | db                 | Command | Time | State                           | Info                        |
</span></span><span style=display:flex><span>+----+------+-----------------+--------------------+---------+------+---------------------------------+-----------------------------+
</span></span><span style=display:flex><span>| <span style=color:#1c01ce>18</span> | root | localhost:52900 | <span style=color:#a90d91>test</span>               | Sleep   |   <span style=color:#1c01ce>52</span> |                                 | NULL                        |
</span></span><span style=display:flex><span>| <span style=color:#1c01ce>20</span> | root | localhost       | <span style=color:#a90d91>test</span>               | Query   |    <span style=color:#1c01ce>5</span> | Waiting <span style=color:#a90d91>for</span> table metadata lock | <span style=color:#a90d91>select</span> * from t4 where <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span> |
</span></span><span style=display:flex><span>| <span style=color:#1c01ce>21</span> | root | localhost       | NULL               | Query   |    <span style=color:#1c01ce>0</span> | starting                        | show processlist            |
</span></span><span style=display:flex><span>+----+------+-----------------+--------------------+---------+------+---------------------------------+-----------------------------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>3</span> rows in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></div><p>MySQL 5.7 复现：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>lock table t4 write;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>select * from t4 where id=1;</td></tr></tbody></table><p>由于在 show processlist 的结果里面，session A 的 Command 列是“Sleep”，导致查找不方便。不过有了 performance_schema 和 sys 系统库之后比较方便。（MySQL 启动时需要设置 performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失)</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>blocking_pid</span> <span style=color:#a90d91>from</span> <span style=color:#000>sys</span>.<span style=color:#000>schema_table_lock_waits</span>;
</span></span></code></pre></td></tr></table></div></div></div><h3 id=等flush>等flush</h3><p>查询语句：</p><p>（这里的 id 是上面 show processlist 结果的 ID）</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>information_schema</span>.<span style=color:#000>processlist</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>通过 State 字段如“Waiting for table flush”，表示有一个线程正要对表 t 做 flush 操作。MySQL 里面对表做 flush 操作的用法，一般有以下两个：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>flush</span> <span style=color:#000>tables</span> <span style=color:#000>t4</span> <span style=color:#a90d91>with</span> <span style=color:#a90d91>read</span> <span style=color:#a90d91>lock</span>; <span style=color:#000>#</span> <span style=color:#000>表</span> <span style=color:#000>t4</span>
</span></span><span style=display:flex><span><span style=color:#000>flush</span> <span style=color:#000>tables</span> <span style=color:#a90d91>with</span> <span style=color:#a90d91>read</span> <span style=color:#a90d91>lock</span>;  <span style=color:#000>#</span> <span style=color:#000>所有的表ß</span>
</span></span></code></pre></td></tr></table></div></div></div></p><p>出现 Waiting for table flush 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 select 语句。
复现：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>select sleep(1) from t4;</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>flush tables t4;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>select * from t4 where id=1;</td></tr></tbody></table><p>session A 中，每行都调用一次 sleep(1)，这样语句默认要执行 10 万秒，在这期间表 t4 一直是被 session A“打开”着。然后，session B 的 flush tables t4 命令再要去关闭表 t4，就需要等 session A 的查询结束。这样，session C 要再次查询的话，就会被 flush 命令堵住了。</p><h3 id=等行锁>等行锁</h3><p>共享锁 (lock in share mode)、排他锁 (for update)</p><p>查询语句：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t4</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span> <span style=color:#a90d91>lock</span> <span style=color:#a90d91>in</span> <span style=color:#a90d91>share</span> <span style=color:#a90d91>mode</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>由于访问 id=1 记录时要加读锁，如果此时已经有一个事务在这行记录上持有一个写锁， select 语句就会被堵住。
排查方法：</p><p>如果是 MySQL 5.7 版本，可以通过 sys.innodb_lock_waits 表查到。</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>sys</span>.<span style=color:#000>innodb_lock_waits</span> <span style=color:#a90d91>where</span> <span style=color:#000>locked_table</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;`test`.`t4`&#39;</span><span style=color:#000>\</span><span style=color:#a90d91>G</span>
</span></span><span style=display:flex><span><span style=color:#000>***************************</span> <span style=color:#1c01ce>1</span>. <span style=color:#a90d91>row</span> <span style=color:#000>***************************</span>
</span></span><span style=display:flex><span>                <span style=color:#000>wait_started</span>: <span style=color:#1c01ce>2022</span><span style=color:#000>-</span><span style=color:#1c01ce>04</span><span style=color:#000>-</span><span style=color:#1c01ce>01</span> <span style=color:#1c01ce>21</span>:<span style=color:#1c01ce>02</span>:<span style=color:#1c01ce>03</span>
</span></span><span style=display:flex><span>                    <span style=color:#000>wait_age</span>: <span style=color:#1c01ce>00</span>:<span style=color:#1c01ce>00</span>:<span style=color:#1c01ce>04</span>
</span></span><span style=display:flex><span>               <span style=color:#000>wait_age_secs</span>: <span style=color:#1c01ce>4</span>
</span></span><span style=display:flex><span>                <span style=color:#000>locked_table</span>: <span style=color:#000>`</span><span style=color:#000>test</span><span style=color:#000>`</span>.<span style=color:#000>`</span><span style=color:#000>t4</span><span style=color:#000>`</span>
</span></span><span style=display:flex><span>                <span style=color:#000>locked_index</span>: <span style=color:#a90d91>PRIMARY</span>
</span></span><span style=display:flex><span>                 <span style=color:#000>locked_type</span>: <span style=color:#000>RECORD</span>
</span></span><span style=display:flex><span>              <span style=color:#000>waiting_trx_id</span>: <span style=color:#1c01ce>281479574768312</span>
</span></span><span style=display:flex><span>         <span style=color:#000>waiting_trx_started</span>: <span style=color:#1c01ce>2022</span><span style=color:#000>-</span><span style=color:#1c01ce>04</span><span style=color:#000>-</span><span style=color:#1c01ce>01</span> <span style=color:#1c01ce>21</span>:<span style=color:#1c01ce>02</span>:<span style=color:#1c01ce>03</span>
</span></span><span style=display:flex><span>             <span style=color:#000>waiting_trx_age</span>: <span style=color:#1c01ce>00</span>:<span style=color:#1c01ce>00</span>:<span style=color:#1c01ce>04</span>
</span></span><span style=display:flex><span>     <span style=color:#000>waiting_trx_rows_locked</span>: <span style=color:#1c01ce>1</span>
</span></span><span style=display:flex><span>   <span style=color:#000>waiting_trx_rows_modified</span>: <span style=color:#1c01ce>0</span>
</span></span><span style=display:flex><span>                 <span style=color:#000>waiting_pid</span>: <span style=color:#1c01ce>22</span>
</span></span><span style=display:flex><span>               <span style=color:#000>waiting_query</span>: <span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t4</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span> <span style=color:#a90d91>lock</span> <span style=color:#a90d91>in</span> <span style=color:#a90d91>share</span> <span style=color:#a90d91>mode</span>
</span></span><span style=display:flex><span>             <span style=color:#000>waiting_lock_id</span>: <span style=color:#1c01ce>281479574768312</span>:<span style=color:#1c01ce>65</span>:<span style=color:#1c01ce>4</span>:<span style=color:#1c01ce>2</span>
</span></span><span style=display:flex><span>           <span style=color:#000>waiting_lock_mode</span>: <span style=color:#000>S</span>
</span></span><span style=display:flex><span>             <span style=color:#000>blocking_trx_id</span>: <span style=color:#1c01ce>408821</span>
</span></span><span style=display:flex><span>                <span style=color:#000>blocking_pid</span>: <span style=color:#1c01ce>20</span>
</span></span><span style=display:flex><span>              <span style=color:#000>blocking_query</span>: <span style=color:#a90d91>NULL</span>
</span></span><span style=display:flex><span>            <span style=color:#000>blocking_lock_id</span>: <span style=color:#1c01ce>408821</span>:<span style=color:#1c01ce>65</span>:<span style=color:#1c01ce>4</span>:<span style=color:#1c01ce>2</span>
</span></span><span style=display:flex><span>          <span style=color:#000>blocking_lock_mode</span>: <span style=color:#000>X</span>
</span></span><span style=display:flex><span>        <span style=color:#000>blocking_trx_started</span>: <span style=color:#1c01ce>2022</span><span style=color:#000>-</span><span style=color:#1c01ce>04</span><span style=color:#000>-</span><span style=color:#1c01ce>01</span> <span style=color:#1c01ce>20</span>:<span style=color:#1c01ce>55</span>:<span style=color:#1c01ce>56</span>
</span></span><span style=display:flex><span>            <span style=color:#000>blocking_trx_age</span>: <span style=color:#1c01ce>00</span>:<span style=color:#1c01ce>06</span>:<span style=color:#1c01ce>11</span>
</span></span><span style=display:flex><span>    <span style=color:#000>blocking_trx_rows_locked</span>: <span style=color:#1c01ce>1</span>
</span></span><span style=display:flex><span>  <span style=color:#000>blocking_trx_rows_modified</span>: <span style=color:#1c01ce>1</span>
</span></span><span style=display:flex><span>     <span style=color:#000>sql_kill_blocking_query</span>: <span style=color:#000>KILL</span> <span style=color:#000>QUERY</span> <span style=color:#1c01ce>20</span>
</span></span><span style=display:flex><span><span style=color:#000>sql_kill_blocking_connection</span>: <span style=color:#000>KILL</span> <span style=color:#1c01ce>20</span>
</span></span><span style=display:flex><span><span style=color:#1c01ce>1</span> <span style=color:#a90d91>row</span> <span style=color:#a90d91>in</span> <span style=color:#a90d91>set</span>, <span style=color:#1c01ce>3</span> <span style=color:#000>warnings</span> (<span style=color:#1c01ce>0</span>.<span style=color:#1c01ce>05</span> <span style=color:#000>sec</span>)
</span></span></code></pre></td></tr></table></div></div></details><br><p>注意：如果上面结果是 Empty set, 3 warnings (0.00 sec)，那么可能是上面查询结果超时了被结束掉了。
可以看到信息很全，20 号线程是造成堵塞的罪魁祸首，并给出了方法就是 KILL QUERY 4 或 KILL 4。“KILL QUERY 4”表示停止 4 号线程当前正在执行的语句，但该方法是没有用的。因为占有行锁的是 update 语句，这个语句已经是之前执行完成了的，现在执行 KILL QUERY，无法让这个事务去掉 id=1 上的行锁。</p><p>实际 KILL 4 才有效，即直接断开这个连接。这里隐含的逻辑是：连接被断开的时候，会自动回滚连接里面正在执行的线程，也就释放了 id=1 上的行锁。</p><h2 id=sql查询慢>SQL查询慢</h2><p>复用上面的表 t4</p><h3 id=没有索引查询慢>没有索引查询慢</h3><p>查询语句：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t4</span> <span style=color:#a90d91>where</span> <span style=color:#a90d91>c</span><span style=color:#000>=</span><span style=color:#1c01ce>50000</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>由于字段 c 上没有索引，这个语句只能走 id 主键顺序扫描，因此需要扫描 5 万行。
可以通过查询慢日志验证</p><p>（注意，为了把所有语句记录到 slow log 里，先执行了 set long_query_time=0，将慢查询日志的时间阈值设置为 0。）</p><h3 id=不加读锁更慢>不加读锁更慢</h3><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>start transaction with consistent snapshot;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t4 set c=c+1 where id=1;<br>//执行一万次</td></tr><tr><td style=text-align:left>select * from t4 where id=1;</td><td style=text-align:left></td></tr><tr><td style=text-align:left>select * from t4 where id=1 lock in share mode;</td><td style=text-align:left></td></tr></tbody></table><p>带 lock in share mode 的 SQL 语句是当前读，会直接读到 1000001 这个结果，所以速度很快；</p><p>而 select * from t where id=1 是一致性读，因此需要从 1000001 开始，依次执行 undo log，执行了 100 万次以后，才将 1 这个结果返回。</p><p>扩展</p><p>如果是下面的语句：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>begin</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#a90d91>c</span><span style=color:#000>=</span><span style=color:#1c01ce>5</span> <span style=color:#a90d91>for</span> <span style=color:#a90d91>update</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>commit</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>那么如何加锁？什么时候释放锁？
RC 隔离级别下，对非索引字段更新，有个锁全表记录的过程，不符合条件的会及时释放行锁，不必等事务结束时释放；而直接用索引列更新，只会锁索引查找值和行。update产生的 X 锁在不释放的情况下，DELETE语句无法执行，但是 UPDATE 语句能更新不符合之前X锁的记录。</p><p>RR 隔离级别下，为保证 binlog 记录顺序，非索引更新会锁住全表记录，且事务结束前不会对不符合条件记录有逐步释放的过程。DELETE 和 UPDATE 语句都不能执行</p><h2 id=客户端响应慢>客户端响应慢</h2><p>如果客户端由于压力过大，迟迟不能接收数据，会对服务端造成什么严重的影响？</p><p>这个问题的核心是，造成了“长事务”。结合锁、MVCC 的知识点。</p><p>1、如果前面的语句有更新，意味着它们在占用着行锁，会导致别的语句更新被锁住；</p><p>2、当然读的事务也有问题，就是会导致 undo log 不能被回收，导致回滚段空间膨胀。</p><h2 id=误删数据>误删数据</h2><p>误删数据一般分为以下几类：</p><p>1、使用 delete 语句误删数据行；</p><p>2、使用 drop table 或者 truncate table 语句误删数据表；</p><p>3、使用 drop database 语句误删数据库；</p><p>4、使用 rm 命令误删整个 MySQL 实例。</p><h3 id=误删行>误删行</h3><p>如果是使用 delete 语句误删了数据行，可以用 Flashback 工具通过闪回把数据恢复回来。</p><p>Flashback 恢复数据的原理，是修改 binlog 的内容，拿回原库重放。而使用这个方案的前提是需要确保 binlog_format=row 和 binlog_row_image=FULL。</p><p>具体恢复数据时，对单个事务做如下处理：</p><p>1、对于 insert 语句，对应的 binlog event 类型是 Write_rows event，把它改成 Delete_rows event 即可；</p><p>2、同理，对于 delete 语句，也是将 Delete_rows event 改为 Write_rows event；</p><p>3、而如果是 Update_rows 的话，binlog 里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</p><p>如果误操作不是一个而是多个，比如下面三个事务：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>(A)delete ...
</span></span><span style=display:flex><span>(B)insert ...
</span></span><span style=display:flex><span>(C)update ...
</span></span></code></pre></td></tr></table></div></div></div><p>用 Flashback 工具解析 binlog 后，写回主库的命令是：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>(reverse C)update ...
</span></span><span style=display:flex><span>(reverse B)delete ...
</span></span><span style=display:flex><span>(reverse A)insert ...
</span></span></code></pre></td></tr></table></div></div></div></p><p>也就是说，如果误删数据涉及到多个事务，需要将事务的顺序调过来再执行。
<strong>需要说明的是，不建议直接在主库上执行这些操作。</strong></p><p>恢复数据比较安全的做法是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。</p><p>因为一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问题的时间晚了，导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数据。如果这时单独恢复这几行数据，而又未经确认的话，就可能会出现对数据的二次破坏。</p><p>误删数据的事前预防：</p><p>1、把 sql_safe_updates 参数设置为 on。如果忘记在 delete 或者 update 语句中写 where 条件，或者 where 条件里面没有包含索引字段的话执行就会报错。</p><p>2、代码上线前，必须经过 SQL 审计。</p><p>delete 全表很慢，需要生成回滚日志、写 redo、写 binlog。所以，从性能角度考虑，应该优先考虑使用 truncate table 或者 drop table 命令。</p><p>使用 truncate /drop table 和 drop database 命令删除数据，没办法通过 Flashback 来恢复。</p><p>因为即使配置了 binlog_format=row，执行命令记录的 binlog 还是 statement 格式。binlog 里面就只有一个 truncate/drop 语句，这些信息无法恢复数据。</p><h3 id=误删库表>误删库表</h3><p>要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份 binlog。</p><p>这两个条件都具备的情况下，假如有人中午 12 点误删了一个库，恢复数据的流程如下：</p><p>1、取最近一次全量备份，假设这个库是一天一备，上次备份是当天 0 点；</p><p>2、用备份恢复出一个临时库；</p><p>3、从日志备份里面，取出凌晨 0 点之后的日志；</p><p>4、把这些日志，除了误删除数据的语句外，全部应用到临时库。</p><p>这个过程需要注意：</p><p>1、如果这个临时库上有多个数据库，为了加速数据恢复，可以在使用 mysqlbinlog 命令时，加上一个–database 参数，用来指定误删表所在的库。这样就避免在恢复数据时还要应用其他库日志的情况。</p><p>2、在应用日志的时候，需要跳过 12 点误操作的那个语句的 binlog：</p><p>1）如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候，先用–stop-position 参数执行到误操作之前的日志，然后再用–start-position 从误操作之后的日志继续执行；</p><p>2）如果实例使用了 GTID 模式更加方便。假设误操作命令的 GTID 是 gtid1，那么只需要执行 set gtid_next=gtid1;begin;commit; 先把这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时候，就会自动跳过误操作的语句。</p><p>使用 mysqlbinlog 方法恢复数据可能还不够快，主要原因有两个：</p><p>1、如果是误删表，最好就是只恢复出这张表，即只重放这张表的操作，但是 mysqlbinlog 工具并不能指定只解析一个表的日志；</p><p>2、用 mysqlbinlog 解析出日志应用，应用日志的过程就只能是单线程。并行复制的方法，在这里都用不上。</p><p>加速备份恢复的办法</p><p>1、从最近一次全量备份恢复出来一个临时库</p><p>2、将误删表的gtid加入临时库</p><p>3、将临时库设为线上备库的从库</p><p>4、临时库就可以并行复制备库的 binlog</p><h3 id=延迟复制从库>延迟复制从库</h3><p>有非常核心的业务，不允许太长的恢复时间，可以考虑搭建延迟复制的备库。这个功能是 MySQL 5.6 版本引入的。</p><p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY = N 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟。比如把 N 设置为 3600，这就代表了如果主库上有数据被误删了，并且在 1 小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时到这个备库上执行 stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。</p><h3 id=预防误删库表>预防误删库表</h3><p>1、账号分离。目的避免写错命令。</p><p>比如：只给业务开发同学 DML 权限，而不给 truncate/drop 权限。而如果业务开发人员有 DDL 需求的话，也可以通过开发管理系统得到支持。即使是 DBA 团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</p><p>show grants 命令查看账户的权限</p><p>2、制定操作规范。目的避免写错要删除的表名。</p><p>在删除数据表之前，必须先对表做改名操作。观察一段时间，确保对业务无影响以后再删除表。改表名时要求给表名加固定的后缀（比如加 _to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且管理系删除表时，只能删除固定后缀的表。</p><h3 id=rm删除数据>rm删除数据</h3><p>对于一个有高可用机制的 MySQL 集群，最不怕 rm 删除数据。只要不是恶意地删除整个集群，而只是删掉了其中某一个节点的数据，HA 系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。要做的就是在这个节点上把数据恢复回来，再接入整个集群。</p><p>现在不止 DBA 有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让整个 MySQL 集群的所有节点都下线。应对这种情况，建议只能是说尽量备份跨机房，或者最好是跨城市保存。</p><h2 id=复制表>复制表</h2><h3 id=mysqldump复制>mysqldump复制</h3><p>把结果输出到临时文件：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysqldump -h<span style=color:#000>$host</span> -P<span style=color:#000>$port</span> -u<span style=color:#000>$user</span> --add-locks<span style=color:#000>=</span><span style=color:#1c01ce>0</span> --no-create-info --single-transaction  --set-gtid-purged<span style=color:#000>=</span>OFF db1 t --where<span style=color:#000>=</span><span style=color:#c41a16>&#34;a&gt;900&#34;</span> --result-file<span style=color:#000>=</span>/client_tmp/t.sql
</span></span></code></pre></td></tr></table></div></div></div><p>主要参数含义如下：
1、–single-transaction 的作用是，在导出数据的时候不需要对表 db1.t 加表锁，而是使用 START TRANSACTION WITH CONSISTENT SNAPSHOT 的方法；</p><p>2、–add-locks 设置为 0，表示在输出的文件结果里，不增加" LOCK TABLES t WRITE;" ；</p><p>3、–no-create-info 的意思是，不需要导出表结构；</p><p>4、–set-gtid-purged=off 表示的是，不输出跟 GTID 相关的信息；</p><p>5、–result-file 指定了输出文件的路径，其中 client 表示生成的文件是在客户端机器上的。</p><p>将这些 INSERT 语句放到 db2 库里去执行：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql -h127.0.0.1 -P13000  -uroot db2 -e <span style=color:#c41a16>&#34;source /client_tmp/t.sql&#34;</span>
</span></span></code></pre></td></tr></table></div></div></div><p>source 不是一条 SQL 语句，而是一个客户端命令。mysql 客户端执行这个命令的流程：
1、打开文件，默认以分号为结尾读取一条条的 SQL 语句；</p><p>2、将 SQL 语句发送到服务端执行。</p><h3 id=导出csv文件>导出csv文件</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>db1</span>.<span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>a</span><span style=color:#000>&gt;</span><span style=color:#1c01ce>900</span> <span style=color:#a90d91>into</span> <span style=color:#000>outfile</span> <span style=color:#c41a16>&#39;/server_tmp/t.csv&#39;</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>注意如下几点。
1、这条语句会将结果保存在服务端。如果执行命令的客户端和 MySQL 服务端不在同一个机器上，客户端机器的临时目录下是不会生成 t.csv 文件的。</p><p>2、into outfile 指定了文件的生成位置（/server_tmp/），这个位置必须受参数 secure_file_priv 的限制。参数 secure_file_priv 的可选值和作用分别是：</p><p>1）如果设置为 empty，表示不限制文件生成的位置，这是不安全的设置；</p><p>2）如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</p><p>3）如果设置为 NULL，就表示禁止在这个 MySQL 实例上执行 select … into outfile 操作。</p><p>3、这条命令不会覆盖文件，因此需要确保 /server_tmp/t.csv 这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。</p><p>4、这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上“\”这个转义符，这样可以跟字段之间、数据行之间的分隔符区分开。</p><p>将数据导入到目标表 db2.t 中：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>load</span> <span style=color:#a90d91>data</span> <span style=color:#000>infile</span> <span style=color:#c41a16>&#39;/server_tmp/t.csv&#39;</span> <span style=color:#a90d91>into</span> <span style=color:#a90d91>table</span> <span style=color:#000>db2</span>.<span style=color:#000>t</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>这条语句的执行流程：
1、打开文件 /server_tmp/t.csv，以制表符 ( ) 作为字段间的分隔符，以换行符（
）作为记录之间的分隔符，进行数据读取；</p><p>2、启动事务。</p><p>3、判断每一行的字段数与表 db2.t 是否相同：</p><p>1）若不相同，则直接报错，事务回滚；</p><p>2）若相同，则构造成一行，调用 InnoDB 引擎接口，写入到表中。</p><p>4、重复步骤 3，直到 /server_tmp/t.csv 整个文件读入完成，提交事务。</p><p><strong>（binlog_format=statement）load 语句记录到 binlog 在从库重放</strong></p><p>由于 /server_tmp/t.csv 文件只保存在主库所在的主机上，如果只是把这条语句原文写到 binlog 中，在备库执行的时候，备库的本地机器上没有这个文件，就会导致主备同步停止。所以流程应该如下：</p><p>1、主库执行完成后，将 /server_tmp/t.csv 文件的内容直接写到 binlog 文件中</p><p>2、往 binlog 文件中写入语句 load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ INTO TABLE <code>db2</code>.<code>t</code>。</p><p>3、把这个 binlog 日志传到备库。</p><p>4、备库的 apply 线程在执行这个事务日志时：</p><p>1）先将 binlog 中 t.csv 文件的内容读出来，写入到本地临时目录 /tmp/SQL_LOAD_MB-1-0 中；</p><p>2）再执行 load data 语句，往备库的 db2.t 表中插入跟主库相同的数据。</p><p>local 的意思是“将执行这条命令的客户端所在机器的本地文件 /tmp/SQL_LOAD_MB-1-0 的内容，加载到目标表 db2.t 中”。有两种用法：</p><p>1、不加“local”，是读取服务端的文件，这个文件必须在 secure_file_priv 指定的目录或子目录下；</p><p>2、加上“local”，读取的是客户端的文件，只要 mysql 客户端有访问这个文件的权限即可。这时候，MySQL 客户端会先把本地文件传给服务端，然后执行上述的 load data 流程。</p><p>select …into outfile 方法不会生成表结构文件, 所以我们导数据时还需要单独的命令得到表结构定义。mysqldump 提供了一个–tab 参数，可以同时导出表结构定义文件和 csv 数据文件。这条命令的使用方法如下：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysqldump -h<span style=color:#000>$host</span> -P<span style=color:#000>$port</span> -u<span style=color:#000>$user</span> ---single-transaction  --set-gtid-purged<span style=color:#000>=</span>OFF db1 t --where<span style=color:#000>=</span><span style=color:#c41a16>&#34;a&gt;900&#34;</span> --tab<span style=color:#000>=</span><span style=color:#000>$secure_file_priv</span>
</span></span></code></pre></td></tr></table></div></div></div><p>这条命令会在 $secure_file_priv 定义的目录下，创建一个 t.sql 文件保存建表语句，同时创建一个 t.txt 文件保存 CSV 数据。</p><h3 id=物理拷贝>物理拷贝</h3><p>在 MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出 + 导入表空间的方式，实现物理拷贝表的功能。</p><p>假设现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r，具体的执行步骤如下：</p><p>1、执行 create table r like t，创建一个相同表结构的空表；</p><p>2、执行 alter table r discard tablespace，这时 r.ibd 文件会被删除；</p><p>3、执行 flush table t for export，这时候 db1 目录下会生成一个 t.cfg 文件；</p><p>4、在 db1 目录下执行 cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令（这里需要注意的是，拷贝得到的两个文件，MySQL 进程要有读写权限）；</p><p>5、执行 unlock tables，这时候 t.cfg 文件会被删除；</p><p>6、执行 alter table r import tablespace，将 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-89e2569382d1c8d44b11a57d472b32e5>2.5 - 04.索引</h1><h1 id=简介>简介</h1><p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样</p><h1 id=索引常见模型>索引常见模型</h1><p>实现索引的方式有很多种，可以用户提高读写效率的数据结构很多，三种常见、比较简单的数据结构分别是：<strong>哈希表、有序数组和搜索树</strong>。</p><p>跳表、LSM 树等数据结构也被用于引擎设计中。</p><h2 id=哈希表>哈希表</h2><p>优点：</p><p>增加新的索引速度很快</p><p>缺点：</p><p>不是有序的，做区间查询慢</p><p>适用于只有等值查询的场景</p><h2 id=有序数组>有序数组</h2><p>优点：</p><p>查询效率高</p><p>缺点：</p><p>更新数据效率低</p><p>只适用于静态存储引擎</p><h2 id=搜索树>搜索树</h2><p>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p><p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><p>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p><h1 id=innodb索引模型>InnoDB索引模型</h1><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p><p><strong>每一个索引在 InnoDB 里面对应一棵 B+ 树。</strong></p><h2 id=索引类型>索引类型</h2><p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p><p>基于主键索引和普通索引的查询有什么区别？</p><ul><li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li><li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h1 id=索引维护>索引维护</h1><h2 id=非自增主键>非自增主键</h2><p>如果新增一个中间的主键 ID 记录，需要逻辑上挪动后面的数据空出位置。更糟的情况是 当前所在的页 已经满了，根据 B+ 树的算法需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为<strong>页分裂</strong>。会影响性能和数据页的利用率。原本放在一个页的数据，需要分到两个页中，整体空间利用率降低大约 50%。（而自增主键防止页分裂，逻辑删除而非物理删除）</p><p>有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><h2 id=自增主键>自增主键</h2><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： <code>NOT NULL PRIMARY KEY AUTO_INCREMENT</code> 。</p><p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p><p>也就是说，自增主键的插入数据模式，正符合了前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><p>而由业务逻辑的字段做主键，则往往不容易保证有序插入，写数据成本相对较高。</p><p><strong>身份证做主键还是自增主键？</strong></p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p><p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p><p><strong>结论：从性能和存储空间方面考量，自增主键往往是合理的选择。</strong></p><p>1、业务字段不一定是递增的，有可能会造成主键索引的页分裂，导致性能不稳定；</p><p>2、二级索引存储的值是主键，如果使用业务字段占用大小不好控制，业务字段过长可能会导致二级索引占用空间过大，利用率不高。</p><p><strong>适合业务字段做主键的场景</strong></p><p>1、只有一个索引</p><p>2、该索引必须是唯一索引</p><p>（这不就是 KV 场景么）</p><p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p><p>非聚集组合索引的一种形式，它包括在查询里的 Select、Join 和 Where 子句用到的所有列（即建立索引的字段正好是覆盖查询语句 [select子句] 与查询条件 [Where子句] 中所涉及的字段，也即，<strong>索引包含了查询正在查找的所有数据</strong>）。</p><h1 id=覆盖索引>覆盖索引</h1><p>不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引的列，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以 MySQL 只能使用 B-Tree 索引做覆盖索引</p><p>当发起一个被索引覆盖的查询(也叫作索引覆盖查询)时，在 EXPLAIN 的Extra 列可以看到“Using index”的信息</p><p>Using where：表示优化器需要通过索引回表查询数据；</p><p>Using index：表示直接访问索引就足够获取到所需要的数据，不需要通过索引回表；</p><p>Using index condition：在5.6版本后加入的新特性（Index Condition Pushdown）;</p><p>Using index condition 会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行；</p><h1 id=最左前缀原则>最左前缀原则</h1><p>索引项是按照索引定义里面出现的字段顺序排序的。</p><p>只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><p><strong>建立联合索引时，如何安排索引内的字段顺序？</strong></p><p>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p><h1 id=索引下推>索引下推</h1><h2 id=索引下推定义>索引下推定义</h2><p>索引下推（index condition pushdown ）简称 ICP，在 Mysql 5.6 的版本上推出，用于优化查询。</p><p>在不使用 ICP 的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给 MySQL 服务器，服务器然后判断数据是否符合条件 。</p><p>在使用 ICP 的情况下，如果存在某些被索引的列的判断条件时，MySQL 服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL 服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器。</p><p>索引条件下推优化可以减少存储引擎查询基础表（回表）的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。</p><h2 id=索引下推案例>索引下推案例</h2><p>如建立了一个联合索引（name, age），要同时查询 name like '张%' and age=20 的条件。</p><p>如果是根据最左前缀索引规则（没有索引下推），只用到了 name 的索引。需要回表到主键索引找出数据行，然后再比对 age 过滤。</p><p>使用了索引下推，就会在（name, age）联合索引内部判断 age 是否等于 20，减少回表的次数。</p><h1 id=索引查询过程>索引查询过程</h1><p>1、对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足索引条件的记录。</p><p>2、对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p><p>这点不同带来的影响微乎其微。因为 InnoDB 是按数据页为单位读写的，当读一条记录的时候，并不是将这个记录从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。</p><p>对于下一条记录在同一个数据页时，多做的那一次“查找和判断下一条记录”操作，只需要一次指针寻找和一次计算。对于整型字段，一个数据页可以存放近千个 key，所以在同一个数据页的概率较大。</p><p>如果下一条记录在下一个数据页，则必须读取下一个数据页。</p><p>综合计算平均性能差异时，扔可以认为该操作成本可以忽略不计。</p><h1 id=优化器>优化器</h1><p>优化器选择索引的依据是综合考虑 扫描行数、是否使用临时表、是否排序等因素。</p><h2 id=扫描行数>扫描行数</h2><p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。（explain 中的 rows 字段）</p><p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。基数越大，索引的区分度越好。</p><p>可以使用 <code>show index from tablename</code> 看到索引的基数</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>show</span> <span style=color:#a90d91>index</span> <span style=color:#a90d91>from</span> <span style=color:#000>t1</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span> <span style=color:#a90d91>Table</span> <span style=color:#000>|</span> <span style=color:#000>Non_unique</span> <span style=color:#000>|</span> <span style=color:#000>Key_name</span> <span style=color:#000>|</span> <span style=color:#000>Seq_in_index</span> <span style=color:#000>|</span> <span style=color:#a90d91>Column_name</span> <span style=color:#000>|</span> <span style=color:#a90d91>Collation</span> <span style=color:#000>|</span> <span style=color:#a90d91>Cardinality</span> <span style=color:#000>|</span> <span style=color:#000>Sub_part</span> <span style=color:#000>|</span> <span style=color:#000>Packed</span> <span style=color:#000>|</span> <span style=color:#a90d91>Null</span> <span style=color:#000>|</span> <span style=color:#000>Index_type</span> <span style=color:#000>|</span> <span style=color:#a90d91>Comment</span> <span style=color:#000>|</span> <span style=color:#000>Index_comment</span> <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span> <span style=color:#000>t1</span>    <span style=color:#000>|</span>          <span style=color:#1c01ce>0</span> <span style=color:#000>|</span> <span style=color:#a90d91>PRIMARY</span>  <span style=color:#000>|</span>            <span style=color:#1c01ce>1</span> <span style=color:#000>|</span> <span style=color:#000>id</span>          <span style=color:#000>|</span> <span style=color:#000>A</span>         <span style=color:#000>|</span>      <span style=color:#1c01ce>100256</span> <span style=color:#000>|</span>     <span style=color:#a90d91>NULL</span> <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span>   <span style=color:#000>|</span>      <span style=color:#000>|</span> <span style=color:#000>BTREE</span>      <span style=color:#000>|</span>         <span style=color:#000>|</span>               <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>|</span> <span style=color:#000>t1</span>    <span style=color:#000>|</span>          <span style=color:#1c01ce>1</span> <span style=color:#000>|</span> <span style=color:#000>a</span>        <span style=color:#000>|</span>            <span style=color:#1c01ce>1</span> <span style=color:#000>|</span> <span style=color:#000>a</span>           <span style=color:#000>|</span> <span style=color:#000>A</span>         <span style=color:#000>|</span>      <span style=color:#1c01ce>100256</span> <span style=color:#000>|</span>     <span style=color:#a90d91>NULL</span> <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span>   <span style=color:#000>|</span> <span style=color:#000>YES</span>  <span style=color:#000>|</span> <span style=color:#000>BTREE</span>      <span style=color:#000>|</span>         <span style=color:#000>|</span>               <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>|</span> <span style=color:#000>t1</span>    <span style=color:#000>|</span>          <span style=color:#1c01ce>1</span> <span style=color:#000>|</span> <span style=color:#000>b</span>        <span style=color:#000>|</span>            <span style=color:#1c01ce>1</span> <span style=color:#000>|</span> <span style=color:#000>b</span>           <span style=color:#000>|</span> <span style=color:#000>A</span>         <span style=color:#000>|</span>      <span style=color:#1c01ce>100256</span> <span style=color:#000>|</span>     <span style=color:#a90d91>NULL</span> <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span>   <span style=color:#000>|</span> <span style=color:#000>YES</span>  <span style=color:#000>|</span> <span style=color:#000>BTREE</span>      <span style=color:#000>|</span>         <span style=color:#000>|</span>               <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#1c01ce>3</span> <span style=color:#a90d91>rows</span> <span style=color:#a90d91>in</span> <span style=color:#a90d91>set</span> (<span style=color:#1c01ce>0</span>.<span style=color:#1c01ce>05</span> <span style=color:#000>sec</span>)
</span></span></code></pre></td></tr></table></div></div></div><p>三个索引的基数值不同，结果并不一定准确。
<strong>如何得到索引的基数？</strong></p><p>一行行统计代价太高，一般选择“采样统计”。</p><p>采样的时候 InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p>而数据表会持续更新，索引统计信息也不会固定不变。所以当变更的数据行数超过 1/M 时，会自动触发重新做一次索引统计。</p><p>MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：</p><p>1、设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</p><p>2、设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</p><p>优化器会根据扫描行数和索引类型（主键索引、普通索引）综合权衡。</p><p><strong>解决统计信息不准确</strong></p><p>当统计信息不准确，可以通过 <code>analyze table tablename</code> 命令，可以用来重新统计索引信息.</p><h2 id=索引选择异常和处理>索引选择异常和处理</h2><p>方法1：<strong>使用 force index 强行选择一个索引。</strong></p><p>缺点：写法不优美；索引名称变动可能很麻烦；变更的及时性、不够敏捷。</p><p>方法2：<strong>修改语句，引导使用期望的索引。</strong></p><p>见索引实践->选错索引</p><p>方法3：<strong>新建索引或删除误用索引。</strong></p><h1 id=前缀索引>前缀索引</h1><p>在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p><p>针对字符串字段如何加索引呢？</p><p>可以考虑前缀索引，对于前缀长度可以通过 count(distinct) 来评估。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> 
</span></span><span style=display:flex><span>  <span style=color:#a90d91>count</span>(<span style=color:#a90d91>distinct</span> <span style=color:#000>xxx</span>) <span style=color:#a90d91>as</span> <span style=color:#000>L</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>count</span>(<span style=color:#a90d91>distinct</span> <span style=color:#a90d91>left</span>(<span style=color:#000>xxx</span>,<span style=color:#1c01ce>4</span>)<span style=color:#000>）</span><span style=color:#a90d91>as</span> <span style=color:#000>L4</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>count</span>(<span style=color:#a90d91>distinct</span> <span style=color:#a90d91>left</span>(<span style=color:#000>xxx</span>,<span style=color:#1c01ce>5</span>)<span style=color:#000>）</span><span style=color:#a90d91>as</span> <span style=color:#000>L5</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>count</span>(<span style=color:#a90d91>distinct</span> <span style=color:#a90d91>left</span>(<span style=color:#000>xxx</span>,<span style=color:#1c01ce>6</span>)<span style=color:#000>）</span><span style=color:#a90d91>as</span> <span style=color:#000>L6</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>from</span> <span style=color:#000>tablename</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>可能会损失区分度，设定可接受的损失比例 x%，计算 Lx=L*(1-x%)，选择最小的Lx。
缺点：</p><p>1、可能会增加扫描行数</p><p>2、对覆盖索引有影响</p><p>无法利用覆盖索引对查询性能的优化。</p><h1 id=索引实践>索引实践</h1><h2 id=重建索引>重建索引</h2><p>表 T 定义：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>create</span> <span style=color:#a90d91>table</span> <span style=color:#000>T</span>(
</span></span><span style=display:flex><span><span style=color:#000>id</span> <span style=color:#a90d91>int</span> <span style=color:#a90d91>primary</span> <span style=color:#a90d91>key</span>, 
</span></span><span style=display:flex><span><span style=color:#000>k</span> <span style=color:#a90d91>int</span> <span style=color:#a90d91>not</span> <span style=color:#a90d91>null</span>, 
</span></span><span style=display:flex><span><span style=color:#000>name</span> <span style=color:#a90d91>varchar</span>(<span style=color:#1c01ce>16</span>),
</span></span><span style=display:flex><span><span style=color:#a90d91>index</span> (<span style=color:#000>k</span>))<span style=color:#000>engine</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>如果要重建索引 k，两个 SQL 语句可以这么写：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>T</span> <span style=color:#a90d91>drop</span> <span style=color:#a90d91>index</span> <span style=color:#000>k</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>T</span> <span style=color:#a90d91>add</span> <span style=color:#a90d91>index</span>(<span style=color:#000>k</span>);
</span></span></code></pre></td></tr></table></div></div></div></p><p>如果要重建主键索引，也可以这么写：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>T</span> <span style=color:#a90d91>drop</span> <span style=color:#a90d91>primary</span> <span style=color:#a90d91>key</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>T</span> <span style=color:#a90d91>add</span> <span style=color:#a90d91>primary</span> <span style=color:#a90d91>key</span>(<span style=color:#000>id</span>);
</span></span></code></pre></td></tr></table></div></div></div></p><p>问题：两个重建索引的做法是否合理？
重建索引 k 的做法是合理的，可以达到节省空间的目的。但是，重建主键索引的过程不合理！不论是删除主键还是创建主键，都会将整个表重建。所以连着 重建索引 k 和 重建主键索引 两个动作，第一个就白做了。可以使用一个语句替代：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>T</span> <span style=color:#000>engine</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>
</span></span></code></pre></td></tr></table></div></div></div><p><strong>附：首先解释重建索引的原因</strong></p><p>索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。</p><h2 id=多个索引合理性>多个索引合理性</h2><p>表定义：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>geek</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>a</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>b</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>d</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>a</span><span style=color:#000>`</span>,<span style=color:#000>`</span><span style=color:#000>b</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#000>ca</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span>,<span style=color:#000>`</span><span style=color:#000>a</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#000>cb</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span>,<span style=color:#000>`</span><span style=color:#000>b</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>历史原因，该表需要 a，b 做联合主键，查询场景：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>geek</span> <span style=color:#a90d91>where</span> <span style=color:#a90d91>c</span><span style=color:#000>=</span><span style=color:#000>N</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>a</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>geek</span> <span style=color:#a90d91>where</span> <span style=color:#a90d91>c</span><span style=color:#000>=</span><span style=color:#000>N</span> <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>b</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><p>问题：“ca”、“cb”是否合理？
联合主键的聚簇索引组织顺序相当于 order by a,b，也就是先按 a 排序再按 b 排序，c 无序。</p><p>索引 c 的组织顺序是 cab</p><p>索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键（注意这里主键部分只有 b），即 cab</p><p>索引 cb 的组织是先按 c 排序，再按 b 排序，同时记录主键（注意这里主键部分只有 a），即 cab</p><p>所以，结论就是 ca 可以去掉（或者去掉索引 c），cb 可以保留。</p><h2 id=普通索引和唯一索引>普通索引和唯一索引</h2><p>唯一索引和普通索引在查询能力上没有差别，主要考虑的是更新性能的影响，建议尽量选择普通索引。</p><p>结合 change buffer 原理及其使用场景，如果数据更新（包括插入）之后会立即查询，应当关闭 change buffer。其它情况下，change buffer 和普通索引的配合使用，对于数据量大的表的更新优化还是挺明显的。</p><p>尤其使用机械硬盘时，change buffer 的收益非常显著。这种情况下，尽量使用普通索引，将 change buffer 尽量开大，以确保数据写入速度。</p><h2 id=选错索引>选错索引</h2><p>隔离级别 RR，表结构：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t1</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span> <span style=color:#000>AUTO_INCREMENT</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>a</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>b</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#000>a</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#000>a</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#000>b</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#000>b</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>利用存储过程创建数据：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>delimiter</span> ;;  <span style=color:#000>#</span> <span style=color:#000>重定义分隔符</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>create</span> <span style=color:#a90d91>procedure</span> <span style=color:#000>idata</span>()
</span></span><span style=display:flex><span><span style=color:#a90d91>begin</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>declare</span> <span style=color:#000>i</span> <span style=color:#a90d91>int</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>set</span> <span style=color:#000>i</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>while</span>(<span style=color:#000>i</span><span style=color:#000>&lt;=</span><span style=color:#1c01ce>100000</span>)<span style=color:#a90d91>do</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t1</span> <span style=color:#a90d91>values</span>(<span style=color:#000>i</span>, <span style=color:#000>i</span>, <span style=color:#000>i</span>);
</span></span><span style=display:flex><span>    <span style=color:#a90d91>set</span> <span style=color:#000>i</span><span style=color:#000>=</span><span style=color:#000>i</span><span style=color:#000>+</span><span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>end</span> <span style=color:#000>while</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>end</span>;;
</span></span><span style=display:flex><span><span style=color:#a90d91>delimiter</span> ;  <span style=color:#000>#</span> <span style=color:#000>恢复分隔符</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>call</span> <span style=color:#000>idata</span>();  <span style=color:#000>#</span> <span style=color:#000>调用存储过程</span>
</span></span></code></pre></td></tr></table></div></div></div></p><p>额外操作：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>drop procedure idata; <span style=color:#177500># 删除存储过程</span>
</span></span><span style=display:flex><span>SELECT * FROM information_schema.routines WHERE <span style=color:#000>routine_name</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;idata&#39;</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><h3 id=选错case1>选错case1</h3><p>实验过程：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>explain</span> <span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t1</span> <span style=color:#a90d91>where</span> <span style=color:#000>a</span> <span style=color:#a90d91>between</span> <span style=color:#1c01ce>10000</span> <span style=color:#a90d91>and</span> <span style=color:#1c01ce>20000</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span> <span style=color:#000>id</span> <span style=color:#000>|</span> <span style=color:#000>select_type</span> <span style=color:#000>|</span> <span style=color:#a90d91>table</span> <span style=color:#000>|</span> <span style=color:#000>partitions</span> <span style=color:#000>|</span> <span style=color:#a90d91>type</span>  <span style=color:#000>|</span> <span style=color:#000>possible_keys</span> <span style=color:#000>|</span> <span style=color:#a90d91>key</span>  <span style=color:#000>|</span> <span style=color:#000>key_len</span> <span style=color:#000>|</span> <span style=color:#a90d91>ref</span>  <span style=color:#000>|</span> <span style=color:#a90d91>rows</span>  <span style=color:#000>|</span> <span style=color:#000>filtered</span> <span style=color:#000>|</span> <span style=color:#000>Extra</span>                 <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span>  <span style=color:#1c01ce>1</span> <span style=color:#000>|</span> <span style=color:#a90d91>SIMPLE</span>      <span style=color:#000>|</span> <span style=color:#000>t1</span>    <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span>       <span style=color:#000>|</span> <span style=color:#000>range</span> <span style=color:#000>|</span> <span style=color:#000>a</span>             <span style=color:#000>|</span> <span style=color:#000>a</span>    <span style=color:#000>|</span> <span style=color:#1c01ce>5</span>       <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span> <span style=color:#000>|</span> <span style=color:#1c01ce>10001</span> <span style=color:#000>|</span>   <span style=color:#1c01ce>100</span>.<span style=color:#1c01ce>00</span> <span style=color:#000>|</span> <span style=color:#a90d91>Using</span> <span style=color:#a90d91>index</span> <span style=color:#000>condition</span> <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+-----------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#1c01ce>1</span> <span style=color:#a90d91>row</span> <span style=color:#a90d91>in</span> <span style=color:#a90d91>set</span>, <span style=color:#1c01ce>1</span> <span style=color:#000>warning</span> (<span style=color:#1c01ce>0</span>.<span style=color:#1c01ce>01</span> <span style=color:#000>sec</span>)
</span></span></code></pre></td></tr></table></div></div></div><p>事务并发操作：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>start transaction with consistent snapshot;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>delete from t1;<br>call idata();</td></tr><tr><td style=text-align:left></td><td style=text-align:left>explain select * from t1 where a between 10000 and 20000;</td></tr><tr><td style=text-align:left>commit;</td><td style=text-align:left></td></tr></tbody></table><p>Session B 使用以下 SQL 语句，然后查看 慢查询日志 耗时。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>long_query_time</span><span style=color:#000>=</span><span style=color:#1c01ce>0</span>;  <span style=color:#000>#</span> <span style=color:#000>设置超时时间为</span> <span style=color:#1c01ce>0</span> 
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t1</span> <span style=color:#a90d91>where</span> <span style=color:#000>a</span> <span style=color:#a90d91>between</span> <span style=color:#1c01ce>10000</span> <span style=color:#a90d91>and</span> <span style=color:#1c01ce>20000</span>; <span style=color:#177500>/*Q1*/</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t1</span> <span style=color:#a90d91>force</span> <span style=color:#a90d91>index</span>(<span style=color:#000>a</span>) <span style=color:#a90d91>where</span> <span style=color:#000>a</span> <span style=color:#a90d91>between</span> <span style=color:#1c01ce>10000</span> <span style=color:#a90d91>and</span> <span style=color:#1c01ce>20000</span>;<span style=color:#177500>/*Q2*/</span>
</span></span></code></pre></td></tr></table></div></div></div><p>选错原因：不断删除和新增导致采样统计不准确。这里就是扫描行数的统计不准确。
场景：对应不断删除历史数据和新增数据的场景。</p><p>解决办法：可以考虑使用 force index。</p><p><strong>为什么需要 Session A 的配合？</strong></p><p>Session A 开启了事务并没有提交，RR 级别会创建一个一致性读视图。Session B 的删除会产生记录的新版本（空记录），同时会产生新的 undo log；一致性读视图需要的 undo log 不会删除，所以之前插入的 10 万行数据不能删除。因此之前的数据每一行数据都有两个版本，旧版本是 delete 之前的数据，新版本是标记为 deleted 的数据。不删除的情况下，记录还在数据页上占着空间，Session B 又把数据加回来，索引数据页出现大量分裂，导致 caredinality 不准。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>show</span> <span style=color:#a90d91>table</span> <span style=color:#000>status</span> <span style=color:#a90d91>like</span> <span style=color:#c41a16>&#39;t1&#39;</span><span style=color:#000>\</span><span style=color:#a90d91>G</span> <span style=color:#000>#</span> <span style=color:#000>\</span><span style=color:#a90d91>G</span> <span style=color:#000>等于</span> <span style=color:#000>分号？</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=选错case2>选错case2</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>explain</span> <span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t1</span> <span style=color:#a90d91>where</span> (<span style=color:#000>a</span> <span style=color:#a90d91>between</span> <span style=color:#1c01ce>1</span> <span style=color:#a90d91>and</span> <span style=color:#1c01ce>1000</span>) <span style=color:#a90d91>and</span> (<span style=color:#000>b</span> <span style=color:#a90d91>between</span> <span style=color:#1c01ce>50000</span> <span style=color:#a90d91>and</span> <span style=color:#1c01ce>100000</span>) <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>b</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+------------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span> <span style=color:#000>id</span> <span style=color:#000>|</span> <span style=color:#000>select_type</span> <span style=color:#000>|</span> <span style=color:#a90d91>table</span> <span style=color:#000>|</span> <span style=color:#000>partitions</span> <span style=color:#000>|</span> <span style=color:#a90d91>type</span>  <span style=color:#000>|</span> <span style=color:#000>possible_keys</span> <span style=color:#000>|</span> <span style=color:#a90d91>key</span>  <span style=color:#000>|</span> <span style=color:#000>key_len</span> <span style=color:#000>|</span> <span style=color:#a90d91>ref</span>  <span style=color:#000>|</span> <span style=color:#a90d91>rows</span>  <span style=color:#000>|</span> <span style=color:#000>filtered</span> <span style=color:#000>|</span> <span style=color:#000>Extra</span>                              <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+------------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>|</span>  <span style=color:#1c01ce>1</span> <span style=color:#000>|</span> <span style=color:#a90d91>SIMPLE</span>      <span style=color:#000>|</span> <span style=color:#000>t1</span>    <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span>       <span style=color:#000>|</span> <span style=color:#000>range</span> <span style=color:#000>|</span> <span style=color:#000>a</span>,<span style=color:#000>b</span>           <span style=color:#000>|</span> <span style=color:#000>b</span>    <span style=color:#000>|</span> <span style=color:#1c01ce>5</span>       <span style=color:#000>|</span> <span style=color:#a90d91>NULL</span> <span style=color:#000>|</span> <span style=color:#1c01ce>50128</span> <span style=color:#000>|</span>     <span style=color:#1c01ce>1</span>.<span style=color:#1c01ce>00</span> <span style=color:#000>|</span> <span style=color:#a90d91>Using</span> <span style=color:#a90d91>index</span> <span style=color:#000>condition</span>; <span style=color:#a90d91>Using</span> <span style=color:#a90d91>where</span> <span style=color:#000>|</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span><span style=color:#177500>----+-------------+-------+------------+-------+---------------+------+---------+------+-------+----------+------------------------------------+
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#1c01ce>1</span> <span style=color:#a90d91>row</span> <span style=color:#a90d91>in</span> <span style=color:#a90d91>set</span>, <span style=color:#1c01ce>1</span> <span style=color:#000>warning</span> (<span style=color:#1c01ce>0</span>.<span style=color:#1c01ce>04</span> <span style=color:#000>sec</span>)
</span></span></code></pre></td></tr></table></div></div></div><p>经过 expalin 分析，返回结果 key 字段显示，优化器选择了索引 b，而 rows 字段需要扫描的行数是 50128。
原因：</p><p>优化器认为使用索引 b 可以避免排序（b 本身是索引，已经有序），所以即使扫描行数多，也判定为代价更小。</p><p>解决办法：引导优化器选择期望的索引，修改 SQL 语句：</p><p>方法1：修改语义</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t1</span> <span style=color:#a90d91>where</span> (<span style=color:#000>a</span> <span style=color:#a90d91>between</span> <span style=color:#1c01ce>1</span> <span style=color:#a90d91>and</span> <span style=color:#1c01ce>1000</span>) <span style=color:#a90d91>and</span> (<span style=color:#000>b</span> <span style=color:#a90d91>between</span> <span style=color:#1c01ce>50000</span> <span style=color:#a90d91>and</span> <span style=color:#1c01ce>100000</span>) <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>b</span>,<span style=color:#000>a</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>方法2：修改 limit：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span>  (<span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t1</span> <span style=color:#a90d91>where</span> (<span style=color:#000>a</span> <span style=color:#a90d91>between</span> <span style=color:#1c01ce>1</span> <span style=color:#a90d91>and</span> <span style=color:#1c01ce>1000</span>)  <span style=color:#a90d91>and</span> (<span style=color:#000>b</span> <span style=color:#a90d91>between</span> <span style=color:#1c01ce>50000</span> <span style=color:#a90d91>and</span> <span style=color:#1c01ce>100000</span>) <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#000>b</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>100</span>)<span style=color:#a90d91>alias</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><p>通过 limit 100 让优化器意识到，使用索引 b 代价很高。根据数据特征诱导优化器，不具备通用型。</p><h2 id=字符串字段加索引>字符串字段加索引</h2><h3 id=使用前缀索引>使用前缀索引</h3><p>表定义：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>create</span> <span style=color:#a90d91>table</span> <span style=color:#000>SUser</span>(
</span></span><span style=display:flex><span><span style=color:#000>ID</span> <span style=color:#a90d91>bigint</span> <span style=color:#000>unsigned</span> <span style=color:#a90d91>primary</span> <span style=color:#a90d91>key</span>,
</span></span><span style=display:flex><span><span style=color:#000>email</span> <span style=color:#a90d91>varchar</span>(<span style=color:#1c01ce>64</span>), 
</span></span><span style=display:flex><span>... 
</span></span><span style=display:flex><span>)<span style=color:#000>engine</span><span style=color:#000>=</span><span style=color:#000>innodb</span>; 
</span></span></code></pre></td></tr></table></div></div></div><p>使用邮箱登录：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>f1</span>, <span style=color:#000>f2</span> <span style=color:#a90d91>from</span> <span style=color:#000>SUser</span> <span style=color:#a90d91>where</span> <span style=color:#000>email</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;xxx&#39;</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><p>考虑增加索引：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>SUser</span> <span style=color:#a90d91>add</span> <span style=color:#a90d91>index</span> <span style=color:#000>index1</span>(<span style=color:#000>email</span>);
</span></span><span style=display:flex><span><span style=color:#000>或</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>alter</span> <span style=color:#a90d91>table</span> <span style=color:#000>SUser</span> <span style=color:#a90d91>add</span> <span style=color:#a90d91>index</span> <span style=color:#000>index2</span>(<span style=color:#000>email</span>(<span style=color:#1c01ce>6</span>));
</span></span></code></pre></td></tr></table></div></div></div></p><p>如何选取前缀索引长度？<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> 
</span></span><span style=display:flex><span>  <span style=color:#a90d91>count</span>(<span style=color:#a90d91>distinct</span> <span style=color:#000>email</span>) <span style=color:#a90d91>as</span> <span style=color:#000>L</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>count</span>(<span style=color:#a90d91>distinct</span> <span style=color:#a90d91>left</span>(<span style=color:#000>email</span>,<span style=color:#1c01ce>4</span>)<span style=color:#000>）</span><span style=color:#a90d91>as</span> <span style=color:#000>L4</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>count</span>(<span style=color:#a90d91>distinct</span> <span style=color:#a90d91>left</span>(<span style=color:#000>email</span>,<span style=color:#1c01ce>5</span>)<span style=color:#000>）</span><span style=color:#a90d91>as</span> <span style=color:#000>L5</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>count</span>(<span style=color:#a90d91>distinct</span> <span style=color:#a90d91>left</span>(<span style=color:#000>email</span>,<span style=color:#1c01ce>6</span>)<span style=color:#000>）</span><span style=color:#a90d91>as</span> <span style=color:#000>L6</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>count</span>(<span style=color:#a90d91>distinct</span> <span style=color:#a90d91>left</span>(<span style=color:#000>email</span>,<span style=color:#1c01ce>7</span>)<span style=color:#000>）</span><span style=color:#a90d91>as</span> <span style=color:#000>L7</span>,
</span></span><span style=display:flex><span><span style=color:#a90d91>from</span> <span style=color:#000>SUser</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><p>可能会损失区分度，如设定可接受的损失比例 5%，计算 Lx=L*95%，选择最小的Lx。</p><h3 id=使用倒序索引>使用倒序索引</h3><p>如身份证同一个地区一般前 6 位相同，前缀索引区分度不高，相反后 6 位区分度较高。可以使用 count(distinct) 验证。</p><p>如果将身份证倒序存储，那么建立索引后查询时也倒序就可以提高效率（利用 reverse 函数）。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>xx</span> <span style=color:#a90d91>from</span> <span style=color:#000>xx</span> <span style=color:#a90d91>where</span> <span style=color:#000>id_card</span> <span style=color:#000>=</span> <span style=color:#000>reverse</span>(<span style=color:#000>xxx</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>再进一步，可以采用 倒序索引+前缀索引 的方式。
缺点：</p><p>不支持范围查询</p><h3 id=使用hash字段>使用hash字段</h3><p>如新增额外的整型字段，如通过 crc32() 函数，一般在图片链接可以通过这种方式。</p><p>注意事项：</p><p>hash 可能冲突，SQL 的 where 条件需要再加上原字段的判断条件。</p><p>缺点：</p><p>不支持范围查询，只支持等值查询</p><h3 id=学号加索引>学号加索引</h3><p>邮箱作为登录名是 学号@gmail.com，学号规则：十五位的数字，前三位是所在城市编号、第四到第六位是学校编号、第七位到第十位是入学年份、最后五位是顺序编号。</p><p>问题：如何创建登录名的索引？</p><p>前 6 位是固定的，邮箱后缀相同，因此可以只存 入学年份和顺序编号，长度共为 9 位。</p><h2 id=索引效率低下案例>索引效率低下案例</h2><h3 id=month函数案例>month函数案例</h3><p>表定义：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>tradelog</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>tradeid</span><span style=color:#000>`</span> <span style=color:#a90d91>varchar</span>(<span style=color:#1c01ce>32</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#a90d91>operator</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>t_modified</span><span style=color:#000>`</span> <span style=color:#000>datetime</span> <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#000>tradeid</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#000>tradeid</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#000>t_modified</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#000>t_modified</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span> <span style=color:#a90d91>DEFAULT</span> <span style=color:#000>CHARSET</span><span style=color:#000>=</span><span style=color:#000>utf8mb4</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>表里记录了从 2016 年初到 2018 年底的所有数据，要统计发生在所有年份中 7 月份的交易记录总数。SQL 语句可能是：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#a90d91>count</span>(<span style=color:#000>*</span>) <span style=color:#a90d91>from</span> <span style=color:#000>tradelog</span> <span style=color:#a90d91>where</span> <span style=color:#a90d91>month</span>(<span style=color:#000>t_modified</span>)<span style=color:#000>=</span><span style=color:#1c01ce>7</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><p>虽然 t_modified 字段上有索引，但语句却执行了很久。因为<strong>对字段做了函数计算就用不上索引</strong>。
进一步分析，条件是 where t_modified='2018-7-1’的时候为什么可以用上索引。实际上 B+ 树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</p><p>注意：<strong>优化器并不是要放弃使用这个索引</strong>。</p><p>这个例子中放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引 t_modified，优化器对比索引大小后发现，索引 t_modified 更小，遍历这个索引比遍历主键索引来得更快。因此最终还是会选择索引 t_modified。</p><p>也可通过 explain 命令查看 key 字段确实使用了 t_modified 索引，rows 扫描了的行数也是所有行，Extra 字段的 Using index，表示的使用了覆盖索引。</p><p>改进 SQL（加上所有年份的 7 月）：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#a90d91>count</span>(<span style=color:#000>*</span>) <span style=color:#a90d91>from</span> <span style=color:#000>tradelog</span> <span style=color:#a90d91>where</span>
</span></span><span style=display:flex><span>    <span style=color:#000>-&gt;</span> (<span style=color:#000>t_modified</span> <span style=color:#000>&gt;=</span> <span style=color:#c41a16>&#39;2016-7-1&#39;</span> <span style=color:#a90d91>and</span> <span style=color:#000>t_modified</span><span style=color:#000>&lt;</span><span style=color:#c41a16>&#39;2016-8-1&#39;</span>) <span style=color:#a90d91>or</span>
</span></span><span style=display:flex><span>    <span style=color:#000>-&gt;</span> (<span style=color:#000>t_modified</span> <span style=color:#000>&gt;=</span> <span style=color:#c41a16>&#39;2017-7-1&#39;</span> <span style=color:#a90d91>and</span> <span style=color:#000>t_modified</span><span style=color:#000>&lt;</span><span style=color:#c41a16>&#39;2017-8-1&#39;</span>) <span style=color:#a90d91>or</span> 
</span></span><span style=display:flex><span>    <span style=color:#000>-&gt;</span> (<span style=color:#000>t_modified</span> <span style=color:#000>&gt;=</span> <span style=color:#c41a16>&#39;2018-7-1&#39;</span> <span style=color:#a90d91>and</span> <span style=color:#000>t_modified</span><span style=color:#000>&lt;</span><span style=color:#c41a16>&#39;2018-8-1&#39;</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>注意，对于不改变有序性的函数，优化器也不会优化，如：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>tradelog</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span> <span style=color:#000>+</span> <span style=color:#1c01ce>1</span> <span style=color:#000>=</span> <span style=color:#1c01ce>10000</span>
</span></span></code></pre></td></tr></table></div></div></div></p><p>需要改成 <code>where id = 10000 - 1</code> 才可以。</p><h3 id=隐式类型转换案例>隐式类型转换案例</h3><p>复用上述 tradelog 表，分析下述 SQL 语句：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>tradelog</span> <span style=color:#a90d91>where</span> <span style=color:#000>tradeid</span><span style=color:#000>=</span><span style=color:#1c01ce>123456</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>tradeid 是有索引的，但是 explain 结果显示这条语句需要走全表扫描。因为 tradeid 的字段是 varchar(32)，而输入的参数却是整型，所以需要做类型转换。
类型转换的规则</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#c41a16>&#34;10&#34;</span> <span style=color:#000>&gt;</span> <span style=color:#1c01ce>9</span>
</span></span></code></pre></td></tr></table></div></div></div><p>这条语句的结果是 1。所以能确认 MySQL 的转换规则：<strong>在 MySQL 中，字符串和数字做比较的话，是将字符串转换成数字。</strong>
所以上面的 SQL 查询语句相当于：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>tradelog</span> <span style=color:#a90d91>where</span> <span style=color:#a90d91>CAST</span>(<span style=color:#000>tradid</span> <span style=color:#a90d91>AS</span> <span style=color:#000>signed</span> <span style=color:#a90d91>int</span>) <span style=color:#000>=</span> <span style=color:#1c01ce>123456</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>即触发了规则：对索引字段做函数操作，优化器会放弃走树搜索功能。
扩展延伸</p><p>id 是 int 类型，那么下面这条语句，是否导致全表扫描：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>tradelog</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#c41a16>&#34;123&#34;</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>验证：
上面验证了当字符串和数字作比较是将字符串转换成数字，索引隐式转换不会应用到字段上，所以可以走索引。另外，当字符串不能转换成数字时，都被转换成 0 了，下面的语句可以验证。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#c41a16>&#39;a&#39;</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;  <span style=color:#000>#</span> <span style=color:#000>结果是</span> <span style=color:#1c01ce>1</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=隐式字符编码转换案例>隐式字符编码转换案例</h3><p>复用上面的表 tradelog，在这基础上再加上下面的表：</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>trade_detail</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>tradeid</span><span style=color:#000>`</span> <span style=color:#a90d91>varchar</span>(<span style=color:#1c01ce>32</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>trade_step</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>, <span style=color:#177500>/*操作步骤*/</span>
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>step_info</span><span style=color:#000>`</span> <span style=color:#a90d91>varchar</span>(<span style=color:#1c01ce>32</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>, <span style=color:#177500>/*步骤信息*/</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#000>tradeid</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#000>tradeid</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span> <span style=color:#a90d91>DEFAULT</span> <span style=color:#000>CHARSET</span><span style=color:#000>=</span><span style=color:#000>utf8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>tradelog</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>1</span>, <span style=color:#c41a16>&#39;aaaaaaaa&#39;</span>, <span style=color:#1c01ce>1000</span>, <span style=color:#000>now</span>());
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>tradelog</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>2</span>, <span style=color:#c41a16>&#39;aaaaaaab&#39;</span>, <span style=color:#1c01ce>1000</span>, <span style=color:#000>now</span>());
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>tradelog</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>3</span>, <span style=color:#c41a16>&#39;aaaaaaac&#39;</span>, <span style=color:#1c01ce>1000</span>, <span style=color:#000>now</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>1</span>, <span style=color:#c41a16>&#39;aaaaaaaa&#39;</span>, <span style=color:#1c01ce>1</span>, <span style=color:#c41a16>&#39;add&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>2</span>, <span style=color:#c41a16>&#39;aaaaaaaa&#39;</span>, <span style=color:#1c01ce>2</span>, <span style=color:#c41a16>&#39;update&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>3</span>, <span style=color:#c41a16>&#39;aaaaaaaa&#39;</span>, <span style=color:#1c01ce>3</span>, <span style=color:#c41a16>&#39;commit&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>4</span>, <span style=color:#c41a16>&#39;aaaaaaab&#39;</span>, <span style=color:#1c01ce>1</span>, <span style=color:#c41a16>&#39;add&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>5</span>, <span style=color:#c41a16>&#39;aaaaaaab&#39;</span>, <span style=color:#1c01ce>2</span>, <span style=color:#c41a16>&#39;update&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>6</span>, <span style=color:#c41a16>&#39;aaaaaaab&#39;</span>, <span style=color:#1c01ce>3</span>, <span style=color:#c41a16>&#39;update again&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>7</span>, <span style=color:#c41a16>&#39;aaaaaaab&#39;</span>, <span style=color:#1c01ce>4</span>, <span style=color:#c41a16>&#39;commit&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>8</span>, <span style=color:#c41a16>&#39;aaaaaaac&#39;</span>, <span style=color:#1c01ce>1</span>, <span style=color:#c41a16>&#39;add&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>9</span>, <span style=color:#c41a16>&#39;aaaaaaac&#39;</span>, <span style=color:#1c01ce>2</span>, <span style=color:#c41a16>&#39;update&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>10</span>, <span style=color:#c41a16>&#39;aaaaaaac&#39;</span>, <span style=color:#1c01ce>3</span>, <span style=color:#c41a16>&#39;update again&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>11</span>, <span style=color:#c41a16>&#39;aaaaaaac&#39;</span>, <span style=color:#1c01ce>4</span>, <span style=color:#c41a16>&#39;commit&#39;</span>);
</span></span></code></pre></td></tr></table></div></div></details><br><p>如果要查询 id=2 的交易的所有操作步骤信息，SQL 语句可以是：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>d</span>.<span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>tradelog</span> <span style=color:#000>l</span>, <span style=color:#000>trade_detail</span> <span style=color:#000>d</span> <span style=color:#a90d91>where</span> <span style=color:#000>d</span>.<span style=color:#000>tradeid</span><span style=color:#000>=</span><span style=color:#000>l</span>.<span style=color:#000>tradeid</span> <span style=color:#a90d91>and</span> <span style=color:#000>l</span>.<span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>2</span>; <span style=color:#177500>/*语句Q1*/</span>
</span></span></code></pre></td></tr></table></div></div></div></p><p>explain 结果如下：
<img src=../imgs/index_20220409_1.png alt=index_20220409_1.png></p><p>1、第一行显示优化器会先在交易记录表 tradelog 上查到 id=2 的行，这个步骤用上了主键索引，rows=1 表示只扫描一行；</p><p>2、第二行 key=NULL，表示没有用上交易详情表 trade_detail 上的 tradeid 索引，进行了全表扫描。</p><p>在这个执行计划里，是从 tradelog 表中取 tradeid 字段，再去 trade_detail 表里查询匹配字段。因此，我们把 tradelog 称为驱动表，把 trade_detail 称为被驱动表，把 tradeid 称为关联字段。</p><p>上面 SQL 的执行流程：</p><p>1、根据 id 在 tradelog 表里找到 id=2 这一行；</p><p>2、从这行中取出 tradeid 字段的值；</p><p>3、根据 tradeid 值到 trade_detail 表中查找条件匹配的行。explain 结果里第二行 key=NULL 表示：这个过程是通过遍历主键索引的方式，逐一判断 tradeid 的值是否匹配。</p><p>这时会发现第 3 步不符合预期。原因：两个表的字符集不同，一个是 utf8，一个是utf8mb4，所以做表连接查询时用不上关联子弹的索引。</p><p>将第 3 步单独改成 SQL 语句：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>trade_detail</span> <span style=color:#a90d91>where</span> <span style=color:#000>tradeid</span><span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>L2</span>.<span style=color:#000>tradeid</span>.<span style=color:#000>value</span>; <span style=color:#000>#</span> <span style=color:#000>L2</span> <span style=color:#000>表示</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>2</span> <span style=color:#000>的行</span>
</span></span></code></pre></td></tr></table></div></div></div><p>$L2.tradeid.value 的字符集是 utf8mb4。utf8mb4 是 utf8 的超集，所以当这两个类型的字符串做比较时，MySQL 会先把 utf8 字符串转成 utf8mb4 字符集，再做比较。
即：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>trade_detail</span>  <span style=color:#a90d91>where</span> <span style=color:#a90d91>CONVERT</span>(<span style=color:#000>traideid</span> <span style=color:#a90d91>USING</span> <span style=color:#000>utf8mb4</span>)<span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>L2</span>.<span style=color:#000>tradeid</span>.<span style=color:#000>value</span>; 
</span></span></code></pre></td></tr></table></div></div></div><p>CONVERT() 函数会将字符串转成 utf8mb4 字符集。还是触发了规则：对索引字段做函数操作，优化器会放弃走树搜索功能。
<strong>对比验证</strong></p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>l</span>.<span style=color:#a90d91>operator</span> <span style=color:#a90d91>from</span> <span style=color:#000>tradelog</span> <span style=color:#000>l</span> , <span style=color:#000>trade_detail</span> <span style=color:#000>d</span> <span style=color:#a90d91>where</span> <span style=color:#000>d</span>.<span style=color:#000>tradeid</span><span style=color:#000>=</span><span style=color:#000>l</span>.<span style=color:#000>tradeid</span> <span style=color:#a90d91>and</span> <span style=color:#000>d</span>.<span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>4</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>同上，第 3 步可以转换成：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#a90d91>operator</span> <span style=color:#a90d91>from</span> <span style=color:#000>tradelog</span> <span style=color:#a90d91>where</span> <span style=color:#000>traideid</span> <span style=color:#000>=</span><span style=color:#000>$</span><span style=color:#000>R4</span>.<span style=color:#000>tradeid</span>.<span style=color:#000>value</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><p>$R4.tradeid.value 的字符集是 utf8, 按照字符集转换规则，要转成 utf8mb4，所以这个过程就被改写成：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#a90d91>operator</span> <span style=color:#a90d91>from</span> <span style=color:#000>tradelog</span>  <span style=color:#a90d91>where</span> <span style=color:#000>traideid</span> <span style=color:#000>=</span><span style=color:#a90d91>CONVERT</span>(<span style=color:#000>$</span><span style=color:#000>R4</span>.<span style=color:#000>tradeid</span>.<span style=color:#000>value</span> <span style=color:#a90d91>USING</span> <span style=color:#000>utf8mb4</span>); 
</span></span></code></pre></td></tr></table></div></div></div></p><p>这里的 CONVERT 函数是加在输入参数上，可以用上被驱动表的 traideid 索引。
这里也可以结合 expain 分析。</p><p>优化方案</p><p>1、修改 trade_detail 表数据集为 utf8mb4</p><p>2、如果业务数据量大无法做第 1 步的 DDL，那么实行修改 SQL：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>d</span>.<span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>tradelog</span> <span style=color:#000>l</span> , <span style=color:#000>trade_detail</span> <span style=color:#000>d</span> <span style=color:#a90d91>where</span> <span style=color:#000>d</span>.<span style=color:#000>tradeid</span><span style=color:#000>=</span><span style=color:#a90d91>CONVERT</span>(<span style=color:#000>l</span>.<span style=color:#000>tradeid</span> <span style=color:#a90d91>USING</span> <span style=color:#000>utf8</span>) <span style=color:#a90d91>and</span> <span style=color:#000>l</span>.<span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>2</span>; 
</span></span></code></pre></td></tr></table></div></div></div><h3 id=字段长度超长案例>字段长度超长案例</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>table_a</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>b</span><span style=color:#000>`</span> <span style=color:#a90d91>varchar</span>(<span style=color:#1c01ce>10</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#000>b</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#000>b</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>如果表中有 100 万行数据，其中有 10 万行数据的值是 ‘1234567890’，分析下述 SQL 语句执行过程：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>table_a</span> <span style=color:#a90d91>where</span> <span style=color:#000>b</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;1234567890abcd&#39;</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><p>这条 SQL 语句执行很慢，流程如下：</p><p>1、传给引擎执行时做了字符截断。因为引擎里面这个行只定义了长度是 10，所以只截取前 10 个字节，就是’1234567890’进去做匹配；</p><p>2、这样满足条件的数据有 10 万行；</p><p>3、因为是 select *， 所以要做 10 万次回表；</p><p>4、但是每次回表后查出整行，到 server 层判断，b 的值都不是’1234567890abcd’；</p><p>5、返回结果是空。</p><p><strong>虽然执行过程中可能经过函数操作，但是最终在拿到结果后，server 层还要做一轮判断。</strong></p><h1 id=索引优化>索引优化</h1><h2 id=索引下推优化><strong>索引下推优化</strong></h2><p>合理借助联合索引。</p><h2 id=覆盖索引优化><strong>覆盖索引优化</strong></h2><p>身份证号是市民的唯一标识。如果有根据身份证号查询市民信息的需求，只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p><h2 id=查询优化><strong>查询优化</strong></h2><p><strong>优化顺序</strong></p><p>1）尽量少作计算。</p><p>2）尽量少 join。</p><p>3）尽量少排序。</p><p>4）尽量避免 select *。</p><p>5）尽量用 join 代替子查询。</p><p>6）尽量少 or。</p><p>7）尽量用 union all 代替 union。</p><p>8）尽量早过滤。</p><p>9）避免类型转换。</p><p>10）优先优化高并发的 SQL，而不是执行频率低某些“大”SQL。</p><p>11）从全局出发优化，而不是片面调整。</p><p>12）尽可能对每一条运行在数据库中的SQL进行 Explain。</p><p><strong>优化方向</strong></p><ul><li>加索引</li><li>避免返回不必要的数据</li><li>适当分批量进行</li><li>优化sql结构</li><li>分库分表</li><li>读写分离</li></ul><h3 id=慢查询优化步骤>慢查询优化步骤</h3><p>0、先运行看看是否真的很慢，注意设置SQL_NO_CACHE</p><p>1、where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</p><p>2、explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</p><p>3、order by limit 形式的sql语句让排序的表优先查</p><p>4、了解业务方使用场景</p><p>5、加索引时参照建索引的几大原则</p><p>6、观察结果，不符合预期继续从0分析</p><h3 id=不走索引情况>不走索引情况</h3><p>1、索引列计算</p><p>2、前导模糊查询不能命中索引（如like '%xxx%'，但是like 'xxx%'走索引！！）</p><p>3、正则表达式</p><p>4、字符串与数字比较（如 where <code>a</code>=1）</p><p>5、使用or（除非每个字段都是索引才走）</p><p>6、mysql估计全表扫描比使用索引快（约30%内的数据走索引？）</p><p><strong>注意：范围查询如果有索引会走索引，但是多个范围，只有第一个范围查询走索引。</strong></p><p><strong>联合索引中，范围列后的字段不走索引</strong></p><h3 id=优化count-查询><strong>优化COUNT()查询</strong></h3><p><strong>执行效果上：</strong></p><p>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL。</p><p>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL 。</p><p>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</p><p><strong>执行效率上：</strong></p><p>列名为主键，count(列名)会比count(1)快。</p><p>列名不为主键，count(1)会比count(列名)快。</p><p>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）。</p><p>如果有主键，则 select count（主键）的执行效率是最优的。</p><p>如果表只有一个字段，则 select count（*）最优。</p><p>注意：MyISAM引擎统计了行数，不使用where时效率很高。</p><h3 id=优化关联查询><strong>优化关联查询</strong></h3><p>1）using或者on的字段，在第二张表中应当为索引，第一张表中不需要创建索引</p><pre><code>要理解优化关联查询的第一个技巧，就需要理解MySQL是如何执行关联查询的。当前MySQL关联执行的策略非常简单，它对任何的关联都执行嵌套循环关联操作，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。
</code></pre><p>2）确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化。</p><h3 id=limit优化><strong>limit优化</strong></h3><p>避免深度翻页。</p><p>比如：LIMIT 10000 20这样的查询，MySQL需要查询10020条记录然后只返回20条记录，前面的10000条都将被抛弃，这样的代价非常高。</p><p>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。</p><p>方法一：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#000>优化前</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>SELECT</span> <span style=color:#000>film_id</span>,<span style=color:#000>description</span> <span style=color:#a90d91>FROM</span> <span style=color:#000>film</span> <span style=color:#a90d91>ORDER</span> <span style=color:#a90d91>BY</span> <span style=color:#000>title</span> <span style=color:#a90d91>LIMIT</span> <span style=color:#1c01ce>50</span>,<span style=color:#1c01ce>5</span>;
</span></span><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#000>优化后</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>SELECT</span> <span style=color:#000>film</span>.<span style=color:#000>film_id</span>,<span style=color:#000>film</span>.<span style=color:#000>description</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>FROM</span> <span style=color:#000>film</span> <span style=color:#a90d91>INNER</span> <span style=color:#a90d91>JOIN</span> (
</span></span><span style=display:flex><span>    <span style=color:#a90d91>SELECT</span> <span style=color:#000>film_id</span> <span style=color:#a90d91>FROM</span> <span style=color:#000>film</span> <span style=color:#a90d91>ORDER</span> <span style=color:#a90d91>BY</span> <span style=color:#000>title</span> <span style=color:#a90d91>LIMIT</span> <span style=color:#1c01ce>50</span>,<span style=color:#1c01ce>5</span>
</span></span><span style=display:flex><span>) <span style=color:#a90d91>AS</span> <span style=color:#000>tmp</span> <span style=color:#a90d91>USING</span>(<span style=color:#000>film_id</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>方法二：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>#</span><span style=color:#000>优化前</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>SELECT</span> <span style=color:#000>id</span> <span style=color:#a90d91>FROM</span> <span style=color:#000>t</span> <span style=color:#a90d91>LIMIT</span> <span style=color:#1c01ce>10000</span>, <span style=color:#1c01ce>10</span>;
</span></span><span style=display:flex><span><span style=color:#000>#</span><span style=color:#000>优化后</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>SELECT</span> <span style=color:#000>id</span> <span style=color:#a90d91>FROM</span> <span style=color:#000>t</span> <span style=color:#a90d91>WHERE</span> <span style=color:#000>id</span> <span style=color:#000>&gt;</span> <span style=color:#1c01ce>10000</span> <span style=color:#a90d91>LIMIT</span> <span style=color:#1c01ce>10</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><p>其它优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p><h3 id=优化union><strong>优化UNION</strong></h3><pre><code>MySQL处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION查询中都没有办法很好的时候。经常需要手动将WHERE、LIMIT、ORDER BY等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。

除非确实需要服务器去重，否则就一定要使用UNION ALL，如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用ALL关键字，MySQL总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。

**union、in、or 都能够命中索引**，建议使用 in。查询的CPU消耗：or &gt; in &gt;union
</code></pre><p>联合索引的使用有一个好处，就是索引的下一个字段是会自动排序的。</p><p>在进行优化的时候，需要暂时关闭数据库自带的缓存，这种缓存在平时查询时确实是个优势，但是在优化调试sql的时候很有必要关掉，在 select 后面加上 sql_no_cache 即可临时关上数据库缓存</p><h3 id=groupby优化>groupby优化</h3><p><strong>利用GROUP BY统计大数据时，应当将查询与统计分离，优化查询语句。</strong></p><p>优化前查询</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>SELECT</span> <span style=color:#000>cpe_id</span>, <span style=color:#a90d91>COUNT</span>(<span style=color:#000>*</span>) <span style=color:#000>restarts</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>FROM</span> <span style=color:#000>business_log</span> 
</span></span><span style=display:flex><span><span style=color:#a90d91>WHERE</span> <span style=color:#000>operate_time</span><span style=color:#000>&gt;=</span><span style=color:#c41a16>&#39;2012-12-05 00:00:00&#39;</span> <span style=color:#a90d91>AND</span> <span style=color:#000>operate_time</span><span style=color:#000>&lt;</span><span style=color:#c41a16>&#39;2018-01-05 00:00:00&#39;</span> <span style=color:#a90d91>AND</span> <span style=color:#000>operate_type</span><span style=color:#000>=</span><span style=color:#1c01ce>3</span> <span style=color:#a90d91>AND</span> <span style=color:#a90d91>result</span><span style=color:#000>=</span><span style=color:#1c01ce>0</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>GROUP</span> <span style=color:#a90d91>BY</span> <span style=color:#000>cpe_id</span>
</span></span></code></pre></td></tr></table></div></div></div><p>优化后查询<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>SELECT</span> <span style=color:#000>cpe_id</span>, <span style=color:#a90d91>COUNT</span>(<span style=color:#000>*</span>) <span style=color:#000>restarts</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>FROM</span> (
</span></span><span style=display:flex><span>    <span style=color:#a90d91>SELECT</span> <span style=color:#000>cpe_id</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>FROM</span> <span style=color:#000>business_log</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>WHERE</span> <span style=color:#000>operate_time</span><span style=color:#000>&gt;=</span><span style=color:#c41a16>&#39;2012-12-05 00:00:00&#39;</span> <span style=color:#a90d91>AND</span> <span style=color:#000>operate_time</span><span style=color:#000>&lt;</span><span style=color:#c41a16>&#39;2018-01-05 00:00:00&#39;</span> <span style=color:#a90d91>AND</span> <span style=color:#000>operate_type</span><span style=color:#000>=</span><span style=color:#1c01ce>3</span> <span style=color:#a90d91>AND</span> <span style=color:#a90d91>result</span><span style=color:#000>=</span><span style=color:#1c01ce>0</span>
</span></span><span style=display:flex><span>) <span style=color:#000>t</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>GROUP</span> <span style=color:#a90d91>BY</span> <span style=color:#000>cpe_id</span>
</span></span></code></pre></td></tr></table></div></div></div></p><p><strong>group by 执行计划出现 using filesort</strong></p><p>优化方案 group by field 后面加 order by null</p><p>(1) group by本质是先分组后排序【绝不是先排序后分组】</p><p>(2) group by默认会出现 Using filesort， 很多场景我只需要分组后的列【即被去重的列】, 众所周知这个东东会影响查询性能, 解决方法就是 group by ... order by null</p><p>(3) group by column 默认会按照column分组, 然后根据column升序排列;  group by column order by null 则默认按照column分组,然后根据标的主键ID升序排列</p><h1 id=实战操作>实战操作</h1><h2 id=慢查询>慢查询</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#000>慢查询状态</span> <span style=color:#000>slow_query_log</span> <span style=color:#000>，默认禁用</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>show</span> <span style=color:#000>variables</span>  <span style=color:#a90d91>like</span> <span style=color:#c41a16>&#39;%slow_query_log%&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#000>开启慢查询，只对当前数据库生效，</span><span style=color:#000>MySQL</span> <span style=color:#000>重启后则会失效</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#a90d91>global</span> <span style=color:#000>slow_query_log</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#000>永久生效，必须修改配置文件</span><span style=color:#000>my</span>.<span style=color:#000>cnf</span><span style=color:#000>（其它系统变量也是如此）</span>
</span></span></code></pre></td></tr></table></div></div></div><h1 id=reference>Reference</h1><p><a href=https://www.cnblogs.com/Chenjiabing/p/12600926.html>https://www.cnblogs.com/Chenjiabing/p/12600926.html</a></p><p><a href=https://www.cnblogs.com/happyflyingpig/p/7662881.html>https://www.cnblogs.com/happyflyingpig/p/7662881.html</a></p><p><a href=https://blog.csdn.net/fzy629442466/article/details/90711104>https://blog.csdn.net/fzy629442466/article/details/90711104</a></p><p><a href=https://mp.weixin.qq.com/s/j7IAlEy4szzmoc8n2Pb0DQ>https://mp.weixin.qq.com/s/j7IAlEy4szzmoc8n2Pb0DQ</a></p><p><a href=https://dbaplus.cn/news-155-1531-1.html>https://dbaplus.cn/news-155-1531-1.html</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-ad92d6c116d2b87e6f117464895446b9>2.6 - 05.锁</h1><h1 id=背景>背景</h1><p>数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p><p>根据加锁的范围，MySQL 里面的锁大致可以分成<strong>全局锁</strong>、<strong>表级锁</strong>和<strong>行锁</strong>三类。</p><h1 id=全局锁>全局锁</h1><h2 id=全局锁定义>全局锁定义</h2><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>Flush tables with <span style=color:#a90d91>read</span> lock <span style=color:#000>(</span>FTWRL<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></div><p>当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，对里面任何一个表做加字段操作，都是会被锁住的。</p><h2 id=全局锁使用场景>全局锁使用场景</h2><p>全局锁的典型使用场景是，做<strong>全库逻辑备份</strong>。也就是把整库每个表都 select 出来存成文本。</p><p>如果是一张一张表分别做备份而不是锁全库，将会出现表之间的数据不一致。需要保证备份的库是在同一个逻辑时间点下。</p><p>官方自带的逻辑备份工具是 mysqldump。在 RR 隔离级别下，当 mysqldump 使用参数 –single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p><p><strong>为什么使用 FTWRL 而不是 mysqldump</strong></p><p>前提条件是引擎要支持 RR 隔离级别。MyISAM 就不支持，只能使用 FTWRL。</p><p><strong>全库只读，为什么不使用 set global readonly=true 的方式</strong></p><p>这种方式也能让全库进入只读状态。两个原因不使用：</p><p>1、readonly可能用作其他逻辑</p><p>有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议使用。</p><p>2、在异常处理机制上有差异。</p><p>如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</p><h1 id=表级锁>表级锁</h1><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><h2 id=表锁>表锁</h2><p>表锁的语法是<code>lock tables 表名 read/write</code>。与 FTWRL 类似，可以用 <code>unlock tables</code> 主动释放锁，也可以在客户端断开的时候自动释放。</p><p>需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><h2 id=元数据锁>元数据锁</h2><p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。</p><p>在 MySQL 5.5 版本中引入了 MDL，<strong>当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁</strong>。防止表结构变更导致数据读写有问题。</p><p>1、读锁之间不互斥，可以有多个线程对同一张表增删改查</p><p>2、读写锁之间、写锁之间互斥，用来保证变更表结构操作的安全性。因此，如果多个线程同时修改表结构需要串行；变更表期间不允许对表增删改查。</p><h2 id=如何安全修改表结构>如何安全修改表结构</h2><p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。如果此时需改表结构，需要 MDL 写锁会被阻塞。之后所有要新申请 MDL 读锁的请求也会被阻塞，可能导致库的线程被打满。</p><p>在 MySQL 的 information_schema 库的 innodb_trx 表中，可以查到当前执行中的事务。如果要做 DDL 变更的表时有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务（kill可能不管用，因为新的请求可能又来了）。</p><p>阻塞了可以通过 <code>show processlist</code> 看到大量的Waiting for table metadata lock。真正阻塞的会话的 State 为空，Command 为 Sleep。</p><p>比较理想的机制，在 alter table 语句中设定等待时间，等待时间内拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句。</p><p>MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。需要确认是否支持该语法。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>ALTER</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>tbl_name</span> <span style=color:#000>NOWAIT</span> <span style=color:#a90d91>add</span> <span style=color:#a90d91>column</span> ...
</span></span><span style=display:flex><span><span style=color:#a90d91>ALTER</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>tbl_name</span> <span style=color:#000>WAIT</span> <span style=color:#000>N</span> <span style=color:#a90d91>add</span> <span style=color:#a90d91>column</span> ... 
</span></span></code></pre></td></tr></table></div></div></div><p>当使用 NOWAIT 关键字时，则在执行ddl语句时，遇到 MDL 锁不进行等待。
当使用 WAIT 关键字时，等待 N</p><p><strong>Online DDL</strong></p><p>过程</p><p>1、拿MDL写锁</p><p>2、降级成MDL读锁</p><p>3、真正做DDL</p><p>4、升级成MDL写锁</p><p>5、释放MDL锁</p><p>1、2、4、5如果没有锁冲突，执行时间非常短。第3步占用了DDL绝大部分时间，这期间这个表可以正常读写数据，是因此称为“Online”。一般在第 1 步会被阻塞。</p><p>第 2 步退化成读锁的目的是为了实现 Online 更新，因为 MDL 读锁不会阻塞增删改操作。</p><p>不直接解锁是为了保护自己，禁止其他线程对这个表同时做 DDL。</p><p>额外说明的是，重建方法都会扫描原表数据和构建临时文件。对于大表来说该操作很消耗 IO 和 CPU 资源。Online DDL 可以考虑在业务低峰期使用，线上服务如果想要更安全的操作的话，建议使用 GitHub 开源的 gh-ost 来操作。</p><h1 id=行锁>行锁</h1><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p><h2 id=两阶段锁>两阶段锁</h2><p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p><p>举例：</p><table><thead><tr><th style=text-align:left>事务A</th><th style=text-align:left>事务B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>update t set k=k+1 where id=1;<br>update t set k=k+1 where id=2;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>begin;<br>update t set k=k+2 where id=1;</td></tr><tr><td style=text-align:left>commit;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>commit;</td></tr></tbody></table><p>事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。事务 A 持有的两个记录的行锁，都是在 commit 的时候才释放的。</p><h2 id=死锁和死锁检测>死锁和死锁检测</h2><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p><p>死锁举例：</p><table><thead><tr><th style=text-align:left>事务A</th><th style=text-align:left>事务B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>update t set k=k+1 where id=1;<br></td><td style=text-align:left>begin;</td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t set k=k+2 where id=2;</td></tr><tr><td style=text-align:left>update t set k=k+1 where id=2;</td><td style=text-align:left></td></tr><tr><td style=text-align:left>commit;</td><td style=text-align:left>update t set k=k+2 where id=1;</td></tr><tr><td style=text-align:left></td><td style=text-align:left>commit;</td></tr></tbody></table><p>解决策略：</p><p>1、设置等待超时，通过参数 innodb_lock_wait_timeout 来设置</p><p>InnnoDB 中该参数默认值为 50s，在线业务无法接受。但设置太短容易误伤简单的锁等待。</p><p>2、发起死锁检测，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑（默认开启）。</p><p>一般采取主动死锁检测。但每个新来的线程被堵住都要判断是否因为自己的加入导致死锁，时间复杂度为 O(n)。需要消耗大量的 CPU 资源。因此可以看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p><p><strong>那么怎么解决热点行更新导致的性能问题？</strong></p><p>1、如果确保业务一定不会出现死锁，可以关闭死锁检测。</p><p>2、控制并发度。比如同一行同时最多只能有 10 个线程在更新，那么死锁的检测成本很低。在数据库接入层（中间件/修改 MySQL 源码）做并发控制，而不是客户端！</p><p>3、将一行记录拆分成多行来减少行冲突，如账户金额，可以拆成多个子账户，金额相加即为总账户金额。（可能会使业务逻辑变复杂）</p><h1 id=间隙锁>间隙锁</h1><p>本节隔离级别无特别说明默认 RR。</p><p>**锁是加在索引上的，这是 InnoDB 的一个基础设定。**所以分析加锁过程就具体分析锁加在哪个索引上。</p><h2 id=幻读的由来>幻读的由来</h2><p>表定义：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t5</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>d</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t5</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>0</span>,<span style=color:#1c01ce>0</span>,<span style=color:#1c01ce>0</span>),(<span style=color:#1c01ce>5</span>,<span style=color:#1c01ce>5</span>,<span style=color:#1c01ce>5</span>),
</span></span><span style=display:flex><span>(<span style=color:#1c01ce>10</span>,<span style=color:#1c01ce>10</span>,<span style=color:#1c01ce>10</span>),(<span style=color:#1c01ce>15</span>,<span style=color:#1c01ce>15</span>,<span style=color:#1c01ce>15</span>),(<span style=color:#1c01ce>20</span>,<span style=color:#1c01ce>20</span>,<span style=color:#1c01ce>20</span>),(<span style=color:#1c01ce>25</span>,<span style=color:#1c01ce>25</span>,<span style=color:#1c01ce>25</span>);
</span></span></code></pre></td></tr></table></div></div></div><table><thead><tr><th style=text-align:left></th><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>T1</td><td style=text-align:left>begin;<br>select * from t5 where d=5 for update; // Q1<br>result: (5,5,5)</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left>T2</td><td style=text-align:left></td><td style=text-align:left>update t5 set d=5 where id=0;</td><td style=text-align:left></td></tr><tr><td style=text-align:left>T3</td><td style=text-align:left>select * from t5 where d=5 for update; // Q2<br>result: (0,0,5), (5,5,5)</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left>T4</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>insert into t5 values (1,1,5);</td></tr><tr><td style=text-align:left>T5</td><td style=text-align:left>select * from t5 where d=5 for update; // Q3<br>result: (0,0,5),(1,1,5),(5,5,5)</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left>T6</td><td style=text-align:left>commit;</td><td style=text-align:left></td><td style=text-align:left></td></tr></tbody></table><p>Q3 读到 id=1 这一行的现象，被称为“幻读”。<strong>幻读指一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</strong></p><p>幻读特别说明：</p><p>1、在 RR 隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此幻读在“当前读”下才会出现。</p><p>2、上面 session B 的修改结果，被 session A 之后的 select 语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。</p><h2 id=幻读的问题>幻读的问题</h2><p>1、语义的破坏</p><p>Session A 在 T1 时刻声明了“要把所有 d=5 的行锁住，不允许其它事务进行读写操作”。而实际上破坏了 Q1 的加锁声明，语义被破坏。</p><p>2、数据一致性的问题</p><p><strong>锁的设计是为了保证数据的一致性。不止数据库内部数据状态在同一时刻的一致性，还包含数据和日志在逻辑上的一致性。</strong></p><p>数据不一致举例：</p><table><thead><tr><th style=text-align:left></th><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>T1</td><td style=text-align:left>begin;<br>select * from t5 where d=5 for update; // Q1<br>update t5 set d=100 where d=5;</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left>T2</td><td style=text-align:left></td><td style=text-align:left>update t5 set d=5 where id=0;</td><td style=text-align:left></td></tr><tr><td style=text-align:left>T3</td><td style=text-align:left>select * from t5 where d=5 for update; // Q2</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left>T4</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>insert into t5 values (1,1,5);</td></tr><tr><td style=text-align:left>T5</td><td style=text-align:left>select * from t5 where d=5 for update; // Q3</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left>T6</td><td style=text-align:left>commit;</td><td style=text-align:left></td><td style=text-align:left></td></tr></tbody></table><p>如果按照前面的分析，数据应该是</p><p>T1: (5,5,100)</p><p>T2: (0,5,0)</p><p>T4: (1,1,5)</p><p>但是 binlog 内容是：</p><p>T2 时刻，Session B 事务提交，写入了两条语句；</p><p>T4 时刻，Session C 事务提交，写入了两条语句；</p><p>T6 时刻，Session A 事务提交，写入了 update t set d=100 where d=5 这条语句。</p><p>即：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>update</span> <span style=color:#000>t</span> <span style=color:#a90d91>set</span> <span style=color:#000>d</span><span style=color:#000>=</span><span style=color:#1c01ce>5</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>0</span>; <span style=color:#177500>/*(0,0,5)*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>5</span>); <span style=color:#177500>/*(1,1,5)*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>update</span> <span style=color:#000>t</span> <span style=color:#a90d91>set</span> <span style=color:#000>d</span><span style=color:#000>=</span><span style=color:#1c01ce>100</span> <span style=color:#a90d91>where</span> <span style=color:#000>d</span><span style=color:#000>=</span><span style=color:#1c01ce>5</span>;<span style=color:#177500>/*所有d=5的行，d改成100*/</span>
</span></span></code></pre></td></tr></table></div></div></div><p>binlog 用作主从同步或者克隆库时，数据为：(0,0,100)、(1,1,100) 和 (5,5,100)。
这样就造成了数据的不一致。</p><p>解决办法自然就是将 <strong>扫描过程中碰到的行都加上写锁</strong>。即 T1 时刻 Session A 把所有行都加上写锁。这样 T2 时刻 Session B 就被阻塞了，需要等到 T6 时刻 Session A commit 之后才能执行。</p><p>但是此时仍然有问题，对于 Session C 的插入行无法阻塞。</p><p>id 为 1 的行在数据库中是 (1,1,5)</p><p>binlog 内容为：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>5</span>); <span style=color:#177500>/*(1,1,5)*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>update</span> <span style=color:#000>t</span> <span style=color:#a90d91>set</span> <span style=color:#000>d</span><span style=color:#000>=</span><span style=color:#1c01ce>100</span> <span style=color:#a90d91>where</span> <span style=color:#000>d</span><span style=color:#000>=</span><span style=color:#1c01ce>5</span>;<span style=color:#177500>/*所有d=5的行，d改成100*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>update</span> <span style=color:#000>t</span> <span style=color:#a90d91>set</span> <span style=color:#000>d</span><span style=color:#000>=</span><span style=color:#1c01ce>5</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>0</span>; <span style=color:#177500>/*(0,0,5)*/</span>
</span></span></code></pre></td></tr></table></div></div></div><p>而按照 binlog 的执行顺序是 (1,1,100)。
造成这个问题的原因是给所有行都加上锁时，id=1 这一行还不在所以加不上行锁。</p><h2 id=解决幻读>解决幻读</h2><p>产生幻读的原因是行锁只能锁住行，但是新插入记录，要更新记录之间的“间隙”。因此为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</p><p>当执行 <code>select * from t where d=5 for update</code> 时，就不止是给数据库中已有的 6 个记录加上行锁，同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。</p><p>与行锁的冲突间不一样，跟间隙锁存在冲突关系的是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。举例：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select * from t5 where c=7 lock in share mode;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>begin;<br>select * from t5 where c=7 for update;</td></tr></tbody></table><p>这两个会话是不会冲突的，即 Session B 不会被阻塞。因为表中并没有 c=7 的数据，两个语句都是加的间隙锁，保证间隙不会插入数据。</p><p><strong>间隙锁 + 行锁 = next-key</strong></p><p><strong>Gap-Lock是左开右开，next-key lock是左开右闭</strong></p><p><strong>间隙锁在 RR 隔离级别下才会生效。如果把隔离级别设置为 RC 就没有间隙锁了。但同时要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。</strong></p><p>但间隙锁的出现，会影响并发度，比如带来了死锁的问题。如（分析略）：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select * from t5 where id=9 for update;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>begin;<br>select * from t5 where id=9 for update;</td></tr><tr><td style=text-align:left></td><td style=text-align:left>insert into t5 values (9,9,9);<br>(block)</td></tr><tr><td style=text-align:left>insert into t5 values (9,9,9);<br>(error, Deadlock found)</td><td style=text-align:left></td></tr></tbody></table><h1 id=加锁规则>加锁规则</h1><p>前提：MySQL 后面的版本可能会改变加锁策略，这里的规则只限于截止到现在的最新版本，即 5.x 系列 &lt;=5.7.24，8.0 系列 &lt;=8.0.13</p><p>2个原则+2个优化+1个bug</p><p>原则 1：加锁的基本单位是 next-key lock（前开后闭区间）。</p><p>原则 2：查找过程中访问到的对象才会加锁。</p><p>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</p><p>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</p><p>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p><p>表：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t5</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>d</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t5</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>0</span>,<span style=color:#1c01ce>0</span>,<span style=color:#1c01ce>0</span>),(<span style=color:#1c01ce>5</span>,<span style=color:#1c01ce>5</span>,<span style=color:#1c01ce>5</span>),
</span></span><span style=display:flex><span>(<span style=color:#1c01ce>10</span>,<span style=color:#1c01ce>10</span>,<span style=color:#1c01ce>10</span>),(<span style=color:#1c01ce>15</span>,<span style=color:#1c01ce>15</span>,<span style=color:#1c01ce>15</span>),(<span style=color:#1c01ce>20</span>,<span style=color:#1c01ce>20</span>,<span style=color:#1c01ce>20</span>),(<span style=color:#1c01ce>25</span>,<span style=color:#1c01ce>25</span>,<span style=color:#1c01ce>25</span>);
</span></span></code></pre></td></tr></table></div></div></div><h2 id=等值查询间隙锁>等值查询间隙锁</h2><p>查询示例：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>update t5 set d=d+1 where id=7;</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>insert into t5 values(8,8,8);<br>(blocked)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>update t5 set d=d+1 where id=10;<br>(Query OK)</td></tr></tbody></table><p>由于表 t 中没有 id=7 的记录，所以用加锁规则判断：</p><p>1、根据原则 1，加锁单位是 next-key lock，Session A 加锁范围就是 (5,10]；</p><p>2、根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</p><p>所以，Session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 Session C 修改 id=10 这行是可以的。</p><h2 id=非唯一索引等值锁>非唯一索引等值锁</h2><p>查询示例：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select id from t5 where c=5 lock in share mode;</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t5 set d=d+1 where id=5;<br>(Query OK)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>insert into t5 values(7,7,7);<br>(blocked)</td></tr></tbody></table><p>Session A 要给索引 c 上 c=5 的这一行加上读锁。</p><p>1、根据原则 1，加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。</p><p>2、要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。</p><p>3、同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</p><p>4、根据原则 2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 Session B 的 update 语句可以执行完成。</p><p>Session C 要插入一个 (7,7,7) 的记录，会被 Session A 的间隙锁 (5,10) 锁住。注意，这个例子中 lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样。 执行 for update 时，系统会认为接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p><p>这个例子说明，锁是加在索引上的；同时，如果要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 Session A 的查询语句改成 select d from t where c=5 lock in share mode。</p><h2 id=主键索引范围锁>主键索引范围锁</h2><p>思考，下面两个语句加锁范围：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>10</span> <span style=color:#a90d91>for</span> <span style=color:#a90d91>update</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>&gt;=</span><span style=color:#1c01ce>10</span> <span style=color:#a90d91>and</span> <span style=color:#000>id</span><span style=color:#000>&lt;</span><span style=color:#1c01ce>11</span> <span style=color:#a90d91>for</span> <span style=color:#a90d91>update</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>逻辑上，id 是 int 型，两条查语句肯定是等价的，但是它们的加锁规则不太一样。
查询示例：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select * from t5 where id>=10 and id&lt;11 for update;</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>insert into t5 values(8,8,8);<br>(Query OK)<br>insert into t5 values(13,13,13);<br>(blocked)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>update t5 set d=d+1 where id=15;<br>(blocked)</td></tr></tbody></table><p>Session A 会加锁：</p><p>1、开始执行要找到第一个 id=10 的行，本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</p><p>2、范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。</p><p>所以，Session A 锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15]。</p><p>这里需要注意，首次 Session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</p><p>如果 Session A 是 <code>select * from t5 where id=10 for update;</code> ，那么 Session B 和 Session C 都不会阻塞。</p><h2 id=非唯一索引范围锁>非唯一索引范围锁</h2><p>示例：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select * from t5 where c>=10 and c&lt;11 for update;</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>insert into t5 values(8,8,8);<br>(blocked)<br>insert into t5 values(13,13,13);<br>(blocked)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>update t5 set d=d+1 where c=15;<br>(blocked)</td></tr></tbody></table><p>Session A 用字段 c 来判断，加锁规则跟 唯一索引范围锁 唯一的不同是：在第一次用 c=10 定位记录时，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则不会蜕变为行锁，因此最终加锁为：索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。</p><p>Session c 需要扫描到 c=15 才停止扫描，是合理的，因为 InnoDB 要扫到 c=15，才知道不需要继续往后查找。注意：如果是 <code>update t5 set d=d+1 where id=15</code> 是不阻塞的，因为这是用的主键索引更新没有锁住的索引 c。但如果是 <code>update t5 set c=c+1 where id=15</code> 仍然是阻塞的，因为更新了锁住的索引 c。</p><h2 id=唯一索引范围锁bug>唯一索引范围锁bug</h2><p>示例：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select * from t5 where id>10 and id&lt;=15 for update;</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t5 set d=d+1 where id=20;<br>(blocked)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>insert into t5 values(16,16,16);<br>(blocked)</td></tr></tbody></table><p>Session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15]这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。</p><p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20]这个 next-key lock 也会被锁上。</p><p>Bug 范围：InnoDB（5.x 系列 &lt;=5.7.24，8.0 系列 &lt;=8.0.13。）【待验证】</p><p>非主键唯一索引 bug 范围：InnoDB （&lt;=8.0.21）【待验证】</p><p>注意 唯一索引 并不一定是 主键索引。</p><h2 id=非唯一索引存在等值>非唯一索引存在等值</h2><p>先在索引 c 上增加一条 c=10 的记录：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t5</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>30</span>,<span style=color:#1c01ce>10</span>,<span style=color:#1c01ce>30</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>示例：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>delete from t5 where c=10;</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>insert into t5 values(12,12,12);<br>(blocked)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>update t5 set d=d+1 where c=15;<br>(Query OK)</td></tr></tbody></table><p>Session A 在遍历的时候，先访问第一个 c=10 的记录。根据原则 1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。然后，session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。</p><h2 id=limit加锁>limit加锁</h2><p>接着上面 非唯一索引存在等值 的情况，同样地这里也增加一条 c=10 的记录。</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>delete from t5 where c=10 limit2;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>insert into t5 values(12,12,12);<br>(Query OK)</td></tr></tbody></table><p>Session A 的 delete 语句加了 limit 2。其实表 t5 里 c=10 的记录其实只有两条加不加 limit 2，删除的效果是一样的，但是加锁的效果却不同。可以看到Session B 的 insert 语句执行通过了，跟上面案例的结果不同。</p><p>这里 delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间。(c=10,id=30）之后的这个间隙并没有在加锁范围里，因此 insert 语句插入 c=12 是可以执行成功的。</p><p>经验：<strong>在删除数据的时候尽量加 limit。不仅可以控制删除数据的条数让操作更安全，还可以减小加锁的范围。</strong></p><p>注意：binlog 格式为 statement时，删除语句where中有多个索引并且带limit可能会导致不同数据库之间，所选用的索引不一致而导致选到的数据不一致。</p><h2 id=死锁示例>死锁示例</h2><p>示例：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select id from t5 where c=10 lock in share mode;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t5 set d=d+1 where c=10;<br>(blocked)</td></tr><tr><td style=text-align:left>insert into t5 values(8,8,8);<br>(Query OK)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>Deadlock found</td></tr></tbody></table><p>分析：</p><p>1、Session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock (5,10] 和间隙锁 (10,15)；</p><p>2、Session B 的 update 语句也要在索引 c 上加 next-key lock (5,10] ，进入锁等待；</p><p>3、Session A 要再插入 (8,8,8) 这一行，被 Session B 的间隙锁（B 的加锁范围和 A 相同）锁住。由于出现了死锁，InnoDB 让 session B 回滚。</p><p>问题：Session B 的锁不是阻塞了吗？为什么还会有死锁？</p><p>Session B 加 next-key lock (5,10] 操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。（间隙锁之间不冲突，行锁与间隙锁才冲突）</p><h2 id=order加锁>order加锁</h2><p>示例：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select * from t5 where c>=15 and c&lt;=20 order by c desc lock in share mode;</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>insert into t5 values(8,8,8);<br>(blocked)</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>insert into t5 values(11,11,11);<br>(blocked)</td></tr></tbody></table><p>分析：</p><p>1、由于是 order by c desc，第一个要定位的是索引 c 上“最右边的”c=20 的行，所以会加上间隙锁 (20,25) 和 next-key lock (15,20]。</p><p>2、在索引 c 上向左遍历，要扫描到 c=10 才停下来，所以 next-key lock 会加到 (5,10]，这正是阻塞 Session B 的 insert 语句的原因。</p><p>3、扫描过程中，c=20、c=15、c=10 这三行都存在值，由于是 select *，所以会在主键 id 上加三个行锁，c=10 不满足条件就蜕化了。</p><p>所以 Session A 的 select 语句锁的范围就是：</p><p>1、索引 c 上 (5, 25)；</p><p>2、主键索引上 id=15、20 两个行锁。</p><h2 id=insert加锁>insert加锁*</h2><p>表：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t41</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span> <span style=color:#000>AUTO_INCREMENT</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>d</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>),
</span></span><span style=display:flex><span>  <span style=color:#a90d91>UNIQUE</span> <span style=color:#a90d91>KEY</span> <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> (<span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t41</span> <span style=color:#a90d91>values</span>(<span style=color:#a90d91>null</span>, <span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>1</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t41</span> <span style=color:#a90d91>values</span>(<span style=color:#a90d91>null</span>, <span style=color:#1c01ce>2</span>,<span style=color:#1c01ce>2</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t41</span> <span style=color:#a90d91>values</span>(<span style=color:#a90d91>null</span>, <span style=color:#1c01ce>3</span>,<span style=color:#1c01ce>3</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t41</span> <span style=color:#a90d91>values</span>(<span style=color:#a90d91>null</span>, <span style=color:#1c01ce>4</span>,<span style=color:#1c01ce>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>create</span> <span style=color:#a90d91>table</span> <span style=color:#000>t42</span> <span style=color:#a90d91>like</span> <span style=color:#000>t41</span>;
</span></span></code></pre></td></tr></table></div></div></div><h3 id=insert-select语句>insert select语句</h3><p>insert … select 是很常见的在两个表之间拷贝数据的方法。在可重复读隔离级别下，这个语句会给 select 的表里扫描到的记录和间隙加读锁。不加锁会出现主从不一致。</p><h3 id=insert循环写入>insert循环写入</h3><p>语句1：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t42</span>(<span style=color:#a90d91>c</span>,<span style=color:#000>d</span>)  (<span style=color:#a90d91>select</span> <span style=color:#a90d91>c</span><span style=color:#000>+</span><span style=color:#1c01ce>1</span>, <span style=color:#000>d</span> <span style=color:#a90d91>from</span> <span style=color:#000>t41</span> <span style=color:#a90d91>force</span> <span style=color:#a90d91>index</span>(<span style=color:#a90d91>c</span>) <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#a90d91>c</span> <span style=color:#a90d91>desc</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>这个语句的加锁范围是表 t41 索引 c 上的 (3,4] 和 (4,supremum] 这两个 next-key lock，以及主键索引上 id=4 这一行。
慢查询日志查到 Rows_examined=1，正好验证了执行这条语句的扫描行数为 1。</p><p>语句2：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t41</span>(<span style=color:#a90d91>c</span>,<span style=color:#000>d</span>)  (<span style=color:#a90d91>select</span> <span style=color:#a90d91>c</span><span style=color:#000>+</span><span style=color:#1c01ce>1</span>, <span style=color:#000>d</span> <span style=color:#a90d91>from</span> <span style=color:#000>t41</span> <span style=color:#a90d91>force</span> <span style=color:#a90d91>index</span>(<span style=color:#a90d91>c</span>) <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#a90d91>c</span> <span style=color:#a90d91>desc</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>慢查询日志 Rows_examined 的值是 5。<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; explain insert into t41<span style=color:#000>(</span>c,d<span style=color:#000>)</span>  <span style=color:#000>(</span><span style=color:#a90d91>select</span> c+1, d from t41 force index<span style=color:#000>(</span>c<span style=color:#000>)</span> order by c desc limit 1<span style=color:#000>)</span>;
</span></span><span style=display:flex><span>+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------+
</span></span><span style=display:flex><span>| id | select_type | table | partitions | <span style=color:#a90d91>type</span>  | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
</span></span><span style=display:flex><span>+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------+
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>1</span> | INSERT      | t41   | NULL       | ALL   | NULL          | NULL | NULL    | NULL | NULL |     NULL | NULL            |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>1</span> | SIMPLE      | t41   | NULL       | index | NULL          | c    | 5       | NULL |    <span style=color:#1c01ce>1</span> |   100.00 | Using temporary |
</span></span><span style=display:flex><span>+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>2</span> rows in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></div></p><p>Extra 字段可以看到“Using temporary”字样，表示这个语句用到了临时表。即执行过程中，需要把表 t 的内容读出来，写入临时表。但 rows 为 1。
可以通过 <code>show status like '%Innodb_rows_read%';</code> 看看 InnoDB 扫描的行数。</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; show status like <span style=color:#c41a16>&#39;%Innodb_rows_read%&#39;</span>;
</span></span><span style=display:flex><span>+------------------+---------+
</span></span><span style=display:flex><span>| Variable_name    | Value   |
</span></span><span style=display:flex><span>+------------------+---------+
</span></span><span style=display:flex><span>| Innodb_rows_read | <span style=color:#1c01ce>1474566</span> |
</span></span><span style=display:flex><span>+------------------+---------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>1</span> row in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.01 sec<span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql&gt; insert into t41<span style=color:#000>(</span>c,d<span style=color:#000>)</span>  <span style=color:#000>(</span><span style=color:#a90d91>select</span> c+1, d from t41 force index<span style=color:#000>(</span>c<span style=color:#000>)</span> order by c desc limit 1<span style=color:#000>)</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#1c01ce>1</span> row affected <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span><span style=display:flex><span>Records: 1  Duplicates: 0  Warnings: <span style=color:#1c01ce>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql&gt; show status like <span style=color:#c41a16>&#39;%Innodb_rows_read%&#39;</span>;
</span></span><span style=display:flex><span>+------------------+---------+
</span></span><span style=display:flex><span>| Variable_name    | Value   |
</span></span><span style=display:flex><span>+------------------+---------+
</span></span><span style=display:flex><span>| Innodb_rows_read | <span style=color:#1c01ce>1474570</span> |
</span></span><span style=display:flex><span>+------------------+---------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>1</span> row in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></details><br><p>可以看到，这个语句执行前后，Innodb_rows_read 的值增加了 4。因为默认临时表是使用 Memory 引擎的，所以这 4 行查的都是表 t41，也就是说对表 t41 做了全表扫描。
执行过程：</p><p>1、创建临时表，表里有两个字段 c 和 d。</p><p>2、按照索引 c 扫描表 t，依次取 c=4、3、2、1，然后回表读到 c 和 d 的值写入临时表。这时，Rows_examined=4。</p><p>3、由于语义里面有 limit 1，所以只取了临时表的第一行，再插入到表 t 中。这时，Rows_examined 的值加 1，变成了 5。</p><p>也就是这个语句会导致在表 t41 上做全表扫描，并且会给索引 c 上的所有间隙都加上共享的 next-key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据。</p><p>对于一边遍历数据，一边更新数据的情况，如果不使用临时表保存遍历的数据，可能会导致读到刚刚插入的记录，与语义不符。 优化：创建临时表，先插入临时表，再从临时表中取数据。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>create</span> <span style=color:#a90d91>temporary</span> <span style=color:#a90d91>table</span> <span style=color:#000>temp_t</span>(<span style=color:#a90d91>c</span> <span style=color:#a90d91>int</span>,<span style=color:#000>d</span> <span style=color:#a90d91>int</span>) <span style=color:#000>engine</span><span style=color:#000>=</span><span style=color:#000>memory</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>temp_t</span>  (<span style=color:#a90d91>select</span> <span style=color:#a90d91>c</span><span style=color:#000>+</span><span style=color:#1c01ce>1</span>, <span style=color:#000>d</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>force</span> <span style=color:#a90d91>index</span>(<span style=color:#a90d91>c</span>) <span style=color:#a90d91>order</span> <span style=color:#a90d91>by</span> <span style=color:#a90d91>c</span> <span style=color:#a90d91>desc</span> <span style=color:#a90d91>limit</span> <span style=color:#1c01ce>1</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t</span> <span style=color:#a90d91>select</span> <span style=color:#000>*</span> <span style=color:#a90d91>from</span> <span style=color:#000>temp_t</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>drop</span> <span style=color:#a90d91>table</span> <span style=color:#000>temp_t</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>如果 insert 和 select 的对象是同一个表，则有可能会造成循环写入。这种情况下需要引入用户临时表来做优化。</p><h3 id=insert冲突加锁>insert冲突加锁</h3><p>举例（RR 下）：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>insert into t41 values(10,10,10);</td><td style=text-align:left></td></tr><tr><td style=text-align:left>begin;<br>insert into t41 values(11,10,10);<br>(Duplicate entry '10' for key 'c')</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>insert into t41 values(12,9,9);<br>(blocked)</td></tr></tbody></table><p>Session A 执行的 insert 语句，发生唯一键冲突时，并不只是简单地报错返回，还在冲突的索引上加了锁。一个 next-key lock 就是由它右边界的值定义的。这时 Session A 持有索引 c 上的 (5,10] 共享 next-key lock（读锁）。</p><p><a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html>官方文档</a> 描述认为如果冲突的是主键索引就加记录锁，唯一索引才加 next-key lock。但实际上，这两类索引冲突加的都是 next-key lock。</p><p>按照提交的信息看这是mysql bug，已经修正。 （mysql 5.7.33）primary key 是不会block 的，唯一索引还是加的 next-key lock。</p><p><strong>唯一键冲突导致死锁场景</strong></p><table><thead><tr><th style=text-align:left></th><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th><th style=text-align:left>Session C</th></tr></thead><tbody><tr><td style=text-align:left>T1</td><td style=text-align:left>begin;<br>insert into t41 values(null,5,5);</td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left>T2</td><td style=text-align:left></td><td style=text-align:left>insert into t41 values(null,5,5);</td><td style=text-align:left>insert into t41 values(null,5,5);</td></tr><tr><td style=text-align:left>T3</td><td style=text-align:left>rollback;</td><td style=text-align:left></td><td style=text-align:left>(Deadlock found)</td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td></tr></tbody></table><p>这个死锁产生的逻辑：</p><p>1、在 T1 时刻，启动 Session A，并执行 insert 语句，此时在索引 c 的 c=5 上加了记录锁。注意，这个索引是唯一索引，因此退化为记录锁。</p><p>2、在 T2 时刻，session B 要执行相同的 insert 语句，发现了唯一键冲突，加上读锁；同样地，Session C 也在索引 c 上，c=5 这一个记录上，加了读锁。</p><p>3、T3 时刻，Session A 回滚。这时 Session B 和 Session C 都试图继续执行插入操作，都要加上写锁。两个 session 都要等待对方的行锁，所以就出现了死锁。（B C有一个会被执行，另一个被回滚）</p><p>insert 语句如果出现唯一键冲突，会在冲突的唯一值上加共享的 next-key lock(S 锁)。因此，碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。</p><h3 id=insert-on-duplicate>insert on duplicate</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t41</span> <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>11</span>,<span style=color:#1c01ce>10</span>,<span style=color:#1c01ce>10</span>) <span style=color:#a90d91>on</span> <span style=color:#000>duplicate</span> <span style=color:#a90d91>key</span> <span style=color:#a90d91>update</span> <span style=color:#000>d</span><span style=color:#000>=</span><span style=color:#1c01ce>100</span>; 
</span></span></code></pre></td></tr></table></div></div></div><p>会给索引 c 上 (5,10] 加一个排他的 next-key lock（写锁）。
insert into … on duplicate key update 这个语义的逻辑是，插入一行数据，如果碰到唯一键约束，就执行后面的更新语句。如果有多个列违反了唯一性约束，就会按照索引的顺序，修改跟第一个索引冲突的行。</p><p>执行语句的 affected rows 返回的如果是 2 很容易造成误解。实际真正更新的只有一行，只是在代码实现上，insert 和 update 都认为成功了，update 计数加了 1， insert 计数也加了 1。</p><h1 id=最佳实践>最佳实践</h1><h2 id=如何查看死锁>如何查看死锁</h2><p>执行 <code>show engine innodb status</code> 命令会输出很多信息，有一节 LATESTDETECTED DEADLOCK，就是记录的最后一次死锁信息。</p><p>结果分成三部分：</p><p>(1) TRANSACTION，是第一个事务的信息；</p><p>(2) TRANSACTION，是第二个事务的信息；</p><p>WE ROLL BACK TRANSACTION (1)，是最终的处理结果，如回滚了哪一个事务。</p><p>（更多信息略）</p><p>得到两个结论：</p><p>1、由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；</p><p>2、会回滚成本更小的事务。如在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以 InnoDB 选择了回滚成本更小的 lock in share mode 语句。</p><h2 id=如何查看锁等待>如何查看锁等待</h2><p>数据库记录为本文中的 t5。</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select * from t5 where id>10 and id&lt;15 for update;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>delete from t5 where id=10;<br>(Query OK)</td></tr><tr><td style=text-align:left></td><td style=text-align:left>insert into t5 values(10,10,10);<br>(blocked)</td></tr></tbody></table><p>通过 <code>show engine innodb status</code> 查看信息，锁信息是在这个命令输出结果的 TRANSACTIONS 这一节</p><p><img src=../imgs/lock_20220409_1.png alt=lock_20220409_1.png></p><p>查看信息可以知道这是因为间隙锁阻塞了，原来的两个间隙 (5,10)、(10,15）变成了一个 (5,15)。</p><p><strong>间隙是随着数据的改变而改变。</strong></p><h2 id=update示例>update示例</h2><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select c from t5 where c>5 lock in share mode;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t set c=1 where c=5;<br>(Query OK)</td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t set c=5 where c=1;<br>(blocked)</td></tr></tbody></table><p>Session A 的加锁范围是索引 c 上的 (5,10]、(10,15]、(15,20]、(20,25]和 (25,supremum]。注意：根据 c>5 查到的第一个记录是 c=10，因此不会加 (0,5]这个 next-key lock。</p><p>Session B 的第一个 update 语句，要把 c=5 改成 c=1，可以理解为两步：</p><p>1、插入 (c=1, id=5) 这个记录；</p><p>2、删除 (c=5, id=5) 这个记录。</p><p>索引 c 上 (5,10) 间隙是由这个间隙右边的记录，也就是 c=10 定义的。所以通过这个操作，Session A 的加锁范围就变成了 (1,10]、(10,15]、(15,20]、(20,25]和 (25,supremum]。</p><p>接下来 Session B 要执行 update t set c = 5 where c = 1 一样地可以拆成两步：</p><p>1、插入 (c=5, id=5) 这个记录；</p><p>2、删除 (c=1, id=5) 这个记录。</p><p>第一步试图在已经加了间隙锁的 (1,10) 中插入数据就被堵住了。</p><p><strong>这个例子的间隙也是随着数据的改变而改变。</strong></p><h1 id=faq>FAQ</h1><h2 id=备份时ddl会怎么样>备份时DDL会怎么样</h2><p>问题：当备库用 mysqldump 工具 –single-transaction 做逻辑备份的时候，如果从主库的 binlog 传来一个 DDL 语句会怎么样？</p><p>备份过程关键语句：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
</span></span><span style=display:flex><span>Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；
</span></span><span style=display:flex><span>/* other tables */
</span></span><span style=display:flex><span>Q3:SAVEPOINT sp;
</span></span><span style=display:flex><span>/* 时刻 <span style=color:#1c01ce>1</span> */
</span></span><span style=display:flex><span>Q4:show create table <span style=color:#c41a16>`</span>t1<span style=color:#c41a16>`</span>;
</span></span><span style=display:flex><span>/* 时刻 <span style=color:#1c01ce>2</span> */
</span></span><span style=display:flex><span>Q5:SELECT * FROM <span style=color:#c41a16>`</span>t1<span style=color:#c41a16>`</span>;
</span></span><span style=display:flex><span>/* 时刻 <span style=color:#1c01ce>3</span> */
</span></span><span style=display:flex><span>Q6:ROLLBACK TO SAVEPOINT sp;
</span></span><span style=display:flex><span>/* 时刻 <span style=color:#1c01ce>4</span> */
</span></span><span style=display:flex><span>/* other tables */
</span></span></code></pre></td></tr></table></div></div></div><p>在备份开始的时候，为了确保 RR（可重复读）隔离级别，再设置一次 RR 隔离级别 (Q1)；
启动事务，这里用 WITH CONSISTENT SNAPSHOT 确保这个语句执行完就可以得到一个一致性视图（Q2)；</p><p>设置一个保存点，这个很重要（Q3）；</p><p>show create 是为了拿到表结构 (Q4)，然后正式导数据 （Q5），回滚到 SAVEPOINT sp，在这里的作用是释放 t1 的 MDL 锁 （Q6）。当然这部分属于“超纲”，上文正文里面都没提到。</p><p>DDL 从主库传过来的时间按照效果不同，定义了四个时刻。题目设定为小表，假定到达后，如果开始执行，则很快能够执行完成。</p><p>参考答案如下：</p><p>1、如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。</p><p>2、如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump 终止；</p><p>3、如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。</p><p>4、从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。</p><p>总结：</p><p>如果 mysqldump 备份的是整个 schema，某个小表t1只是该schema上其中有一张表</p><p>情况1：</p><p>master上对小表 t1 的 DDL 传输到 slave 去应用的时刻，mysqldump 已经备份完了t1表的数据，此时slave 同步正常，不会有问题。</p><p>情况2：</p><p>master上对小表 t1 的 DDL 传输到slave去应用的时刻，mysqldump 正在备份t1表的数据,此时会发生MDL 锁，从库上t1表的所有操作都会Hang 住。</p><p>情况3：</p><p>master 上对小表 t1 的 DDL 传输到slave去应用的时刻，mysqldump 还没对t1表进行备份，该DDL会在slave的t1表应用成功，但是当导出到t1表的时候会报“ERROR 1412 (HY000): Table definition has changed, please retry transaction” 错误，导致导出失败！</p><p><strong>在备份期间，备份线程 mysqldump 用 RR ，而业务线程用的是 RC。同时存在两种事务隔离级别会不会有问题？</strong></p><h2 id=批量删除数据>批量删除数据</h2><p>删除一个表中的前 10000 条数据，有 3 种方法：</p><p>1、直接执行 <code>delete from t limit 10000</code></p><p>2、在一个连接中循环执行 20 次 <code>delete from t limit 500</code></p><p>3、在 20 个连接中同时执行 <code>delete from t limit 500</code></p><p>答案：</p><p>第 2 种方式相对较好。</p><p>第 1 种方式单个语句占用时间长，持有锁时间长，大事务还会导致主从延迟。</p><p>第 3 种方式会人为造成锁冲突。</p><p>或者采取用某种条件将 10000 行数据天然分开，如主键id或业务条件（结合第3种）</p><h2 id=空表是否有间隙>空表是否有间隙</h2><p>一个空表就只有一个间隙。</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>create table t7(id int primary key)engine=innodb;<br>begin;<br>select * from t7 where id>1 for update;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>insert into t7 values(2);<br>(blocked)</td></tr><tr><td style=text-align:left>show engine innodb status;</td><td style=text-align:left></td></tr></tbody></table><p>Session A 加锁的范围就是 next-key lock (-∞, supremum]。</p><p><img src=../imgs/lock_20220409_2.png alt=lock_20220409_2.png></p></div><div class=td-content style=page-break-before:always><h1 id=pg-2d169502965da79dfedf0b7ae28eb3a0>2.7 - 06.事务隔离</h1><h1 id=背景>背景</h1><p>MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p><h1 id=事务特性><strong>事务特性</strong></h1><p>ACID（Atomicity、Consistency、Isolation、Durability）</p><p>原子性:满足原子操作单元,对数据的操作,要么全部执行,要么全部失败。</p><p>一致性:事务开始和完成,数据都必须保持一致,</p><p>隔离性:事务之间是相互独立的,中间状态对外不可见。</p><p>持久性:数据的修改是永久的。</p><h1 id=事务隔离级别>事务隔离级别</h1><h2 id=事务并发问题>事务并发问题</h2><p>当数据库上有多个事务同时执行的时候，就可能出现下列问题：</p><p>1、脏读（dirty read）</p><p>A事务还未提交,B事务就读到了A事务的结果。(<strong>破坏了隔离性</strong>)</p><p>2、不可重复读（non-repeatable read）</p><p>A事务在本次事务中,对自己未操作过的数据,进行了多次读取,结果出现了不一致或记录不存在的情况（<strong>破坏了一致性</strong>，update和delete）</p><p>3、幻读（phantom read）</p><p>A事务在本次事务中，对自己未操作过的数据，进行了多次读取，第一次读取时记录不存在，第二次读取时却出现记录</p><p>为了解决这些问题，就有了“隔离级别”的概念。</p><h2 id=隔离级别>隔离级别</h2><p>隔离级别越高，效率就会越低。因此需要在二者之间寻找一个平衡点。</p><p>SQL 标准的事务隔离级别包括：</p><p>1、读未提交（read uncommitted）</p><p>一个事务还没提交时，它做的变更就能被别的事务看到</p><p>2、读已提交（read committed）</p><p>一个事务提交之后，它做的变更才会被其他事务看到</p><p>3、可重复读（repeatable read）</p><p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</p><p>4、串行化（serializable ）</p><p>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><p>注意：这四个级别只是一个标准，各个数据库厂商，并不是完全按照这个标准来做的。</p><h2 id=案例-不同隔离级别下读>案例：不同隔离级别下读</h2><table><thead><tr><th style=text-align:left>事务A</th><th style=text-align:left>事务B</th></tr></thead><tbody><tr><td style=text-align:left>启动事务，<br>查询得到值 1</td><td style=text-align:left>启动事务</td></tr><tr><td style=text-align:left></td><td style=text-align:left>查询得到值 1</td></tr><tr><td style=text-align:left></td><td style=text-align:left>将值 1 改成 2</td></tr><tr><td style=text-align:left>查询得到值 V1</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>提交事务B</td></tr><tr><td style=text-align:left>查询得到值 V2</td><td style=text-align:left></td></tr><tr><td style=text-align:left>提交事务A</td><td style=text-align:left></td></tr><tr><td style=text-align:left>查询得到值 V3</td><td style=text-align:left></td></tr></tbody></table><p>针对这个案例，不同隔离级别会有不同的返回结果：</p><p><strong>读未提交</strong></p><p>虽然事务B还没有提交，但是事务A可以看到，V1 是 2，V2、V3都是2。</p><p><strong>读已提交</strong></p><p>事务A不可以看到事务B未提交的数据，因此 V1 是 1。事务B提交后事务A可以看到，因此 V2 是 2，V3 也是 2。</p><p><strong>可重复读</strong></p><p>V1 是 1，因为事务A在执行期间看到的数据前后必须是一致的，所以 V2 是 1，提交之后可见其它事务提交的数据，所以 V3 是 2。</p><p><strong>串行化</strong></p><p>事务B执行“将1改成2”时会被锁住，直到事务A提交后，事务B才可以继续执行。所以 V1、V2 是 1，V3 是 2。</p><h2 id=db默认级别>DB默认级别</h2><p>大部分数据库的默认隔离级别是“读已提交”，如 Oracle。</p><p>而MySQL 默认隔离级别为“可重复读”。</p><h1 id=事务实现-innodb>事务实现(InnoDB)</h1><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p><p>在“可重复读”隔离级别下，视图是在事务启动时创建的，整个事务存在期间都用这个视图。</p><p>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。</p><p>这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</p><p>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p><h2 id=锁机制>锁机制</h2><p>阻止其他事务对数据进行操作,各个隔离级别主要体现在读取数据时加的锁和释放时机。</p><p>RU</p><p>事务读取的时候,不加锁</p><p>RC</p><p>事务读取的时候加行级共享锁(读到才加锁),一旦读完,立刻释放(并不是事务结束)。</p><p>RR</p><p>事务读取时加行级共享锁,直到事务结束才会释放。</p><p>SE</p><p>事务读取时加表级共享锁,直到事务结束时,才会释放。</p><p>其他还有一些不同,主要就这些。</p><h2 id=mvcc机制>MVCC机制</h2><p>生成一个数据快照,并用这个快照来提供一定级别的一致性的读取,也成为了多版本数据控制。</p><p>实际就是[CAS版本控制』和『读写分离』的思想。主要作用于 RC 和 RR 级别。</p><h1 id=mvcc>MVCC</h1><h2 id=视图>视图</h2><p>在 MySQL 中，有两个“视图”概念：</p><p>1、一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</p><p>2、另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</p><p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p><h2 id=快照>快照</h2><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p><p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p><p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p><p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p><p>如下图就是一个记录被多个事务连续更新后的状态。</p><p>行状态变更图</p><p><img src=../imgs/transaction_20220409_1.png alt=transaction_20220409_1.png></p><p>上图中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p><h2 id=一致性视图>一致性视图</h2><p>按照可重复读的定义，一个事务启动时，能够看到所有已经提交的事务结果。但是之后这个事务的执行期间，其他事务的更新对它不可见。</p><p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。<strong>“活跃”指的就是，启动了但还没提交</strong>。</p><p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）</p><p>而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</p><p>视图数据把所有的 row trx_id 分成了几种不同的情况。</p><p><img src=../imgs/transaction_20220409_2.png alt=transaction_20220409_2.png></p><p>[数据版本可见性规则]</p><p>对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p><p>1、如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</p><p>2、如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</p><p>3、如果落在黄色部分，那就包括两种情况</p><p>a、若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</p><p>b、若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。（注意上面说的“活跃”：启动了但还没提交）</p><p>所以InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</p><p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p><p><strong>1、版本未提交，不可见；</strong></p><p><strong>2、版本已提交，但是是在视图创建后提交的，不可见；</strong></p><p><strong>3、版本已提交，而且是在视图创建前提交的，可见。</strong></p><p>换言之 一致性读 下：</p><p>1、对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</p><p>2、对于读提交，查询只承认在语句启动前就已经提交完成的数据。</p><p><strong>而当前读，总是读取已经提交完成的最新版本。</strong></p><h2 id=当前读>当前读</h2><p><strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）</strong></p><p>除了 update 语句外，select 语句如果加锁（lock in share mode 或 for update），也是当前读。如：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>k</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span> <span style=color:#a90d91>lock</span> <span style=color:#a90d91>in</span> <span style=color:#a90d91>share</span> <span style=color:#a90d91>mode</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#000>k</span> <span style=color:#a90d91>from</span> <span style=color:#000>t</span> <span style=color:#a90d91>where</span> <span style=color:#000>id</span><span style=color:#000>=</span><span style=color:#1c01ce>1</span> <span style=color:#a90d91>for</span> <span style=color:#a90d91>update</span>;
</span></span></code></pre></td></tr></table></div></div></div><h2 id=mvcc延伸>MVCC延伸</h2><p>表结构变更（DDL）为什么不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。</p><p>MySQL 8.0 已经可以把表结构放在 InnoDB 字典里了，也许以后会支持表结构的可重复读。</p><h1 id=案例>案例</h1><h2 id=无法更新数据>无法更新数据</h2><p>事务隔离级别为 RR。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>CREATE</span> <span style=color:#a90d91>TABLE</span> <span style=color:#000>`</span><span style=color:#000>t</span><span style=color:#000>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>NOT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>`</span><span style=color:#a90d91>c</span><span style=color:#000>`</span> <span style=color:#a90d91>int</span>(<span style=color:#1c01ce>11</span>) <span style=color:#a90d91>DEFAULT</span> <span style=color:#a90d91>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#a90d91>PRIMARY</span> <span style=color:#a90d91>KEY</span> (<span style=color:#000>`</span><span style=color:#000>id</span><span style=color:#000>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#000>ENGINE</span><span style=color:#000>=</span><span style=color:#000>InnoDB</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>insert</span> <span style=color:#a90d91>into</span> <span style=color:#000>t</span>(<span style=color:#000>id</span>, <span style=color:#a90d91>c</span>) <span style=color:#a90d91>values</span>(<span style=color:#1c01ce>1</span>,<span style=color:#1c01ce>1</span>),(<span style=color:#1c01ce>2</span>,<span style=color:#1c01ce>2</span>),(<span style=color:#1c01ce>3</span>,<span style=color:#1c01ce>3</span>),(<span style=color:#1c01ce>4</span>,<span style=color:#1c01ce>4</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>更新数据：0 rows<style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql&gt; begin;
</span></span><span style=display:flex><span>Query OK, <span style=color:#1c01ce>0</span> rows affected <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql&gt; <span style=color:#a90d91>select</span> * from t;
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>| id | c    |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>1</span> |    <span style=color:#1c01ce>1</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>2</span> |    <span style=color:#1c01ce>2</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>3</span> |    <span style=color:#1c01ce>3</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>4</span> |    <span style=color:#1c01ce>4</span> |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>4</span> rows in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql&gt; update t <span style=color:#a90d91>set</span> <span style=color:#000>c</span><span style=color:#000>=</span><span style=color:#1c01ce>0</span> where <span style=color:#000>id</span><span style=color:#000>=</span>c;
</span></span><span style=display:flex><span>Query OK, <span style=color:#1c01ce>0</span> rows affected <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span><span style=display:flex><span>Rows matched: 0  Changed: 0  Warnings: <span style=color:#1c01ce>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql&gt; <span style=color:#a90d91>select</span> * from t;
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>| id | c    |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>1</span> |    <span style=color:#1c01ce>1</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>2</span> |    <span style=color:#1c01ce>2</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>3</span> |    <span style=color:#1c01ce>3</span> |
</span></span><span style=display:flex><span>|  <span style=color:#1c01ce>4</span> |    <span style=color:#1c01ce>4</span> |
</span></span><span style=display:flex><span>+----+------+
</span></span><span style=display:flex><span><span style=color:#1c01ce>4</span> rows in <span style=color:#a90d91>set</span> <span style=color:#000>(</span>0.00 sec<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></details><br></p><p>问题：模拟该情况，并说明原理。
答案1：</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left>begin;<br>select * from t;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t set c=c+1;</td></tr><tr><td style=text-align:left>update t set c=0 where id=c;<br>select * from t;</td><td style=text-align:left></td></tr></tbody></table><p>答案2：（类似答案1）</p><table><thead><tr><th style=text-align:left>Session A</th><th style=text-align:left>Session B</th></tr></thead><tbody><tr><td style=text-align:left></td><td style=text-align:left>begin;<br>select * from t;</td></tr><tr><td style=text-align:left>begin;<br>select * from t;</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>update t set c=c+1;<br>commit;</td></tr><tr><td style=text-align:left>update t set c=0 where id=c;<br>select * from t;</td><td style=text-align:left></td></tr></tbody></table><h1 id=实战操作>实战操作</h1><h2 id=事务启动方式>事务启动方式</h2><p>显示启动事务</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>begin;  <span style=color:#177500># 或 start transaction</span>
</span></span><span style=display:flex><span>rollback;
</span></span><span style=display:flex><span>commit;
</span></span></code></pre></td></tr></table></div></div></div><p>隐式启动事务<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 取消线程的自动提交，直到主动执行 commit 或 rollback</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>set</span> <span style=color:#000>autocommit</span><span style=color:#000>=</span><span style=color:#1c01ce>0</span>  <span style=color:#177500># 建议设置为 1，显示启动事务</span>
</span></span></code></pre></td></tr></table></div></div></div></p><p>注意：</p><p>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。</p><p>第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；</p><p>第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</p><p>额外说明：</p><p>“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在 RC 隔离级别下，这个用法就没意义了，等效于普通的 start transaction。</p><p>因为 RC 级别下，事务开启后每一个语句执行前都会重新计算一个新视图，用这种方式解决脏读，但是有不可重复读的问题。和 RR 级别下创建视图和使用视图不一样。</p><h1 id=faq>FAQ</h1><h2 id=避免长事务影响>避免长事务影响</h2><p>从应用开发端和数据库端来看：</p><h3 id=应用开发端>应用开发端</h3><p>1、确认是否使用了 set_autocommit=0。</p><p>可以通过开启 general_log，查询日志开启。（将其值改为 1）</p><p>方法一： 　</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 设置路径 　　</span>
</span></span><span style=display:flex><span>mysql&gt;set global <span style=color:#000>general_log_file</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;/tmp/general.lg&#39;</span>; 
</span></span><span style=display:flex><span><span style=color:#177500># 开启general log模式</span>
</span></span><span style=display:flex><span>mysql&gt;set global <span style=color:#000>general_log</span><span style=color:#000>=</span>on; 
</span></span><span style=display:flex><span>mysql&gt;set global <span style=color:#000>general_log</span><span style=color:#000>=</span>off; 
</span></span></code></pre></td></tr></table></div></div></div><p>关闭general log模式 命令行设置即可,无需重启 在general log模式开启过程中，所有对数据库的操作都将被记录 general.log 文件
方法二：</p><p>也可以将日志记录在表中 set global log_output='table' 运行后,可以在mysql数据库下查找 general_log 表</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#000>二、查询日志关闭</span> <span style=color:#000>查看是否是开启状态：</span> 
</span></span><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>show</span> <span style=color:#a90d91>global</span> <span style=color:#000>variables</span> <span style=color:#a90d91>like</span> <span style=color:#c41a16>&#39;%general%&#39;</span>; 
</span></span><span style=display:flex><span><span style=color:#000>mysql</span><span style=color:#000>&gt;</span> <span style=color:#a90d91>set</span> <span style=color:#a90d91>global</span> <span style=color:#000>general_log</span> <span style=color:#000>=</span> <span style=color:#a90d91>off</span>; <span style=color:#000>//</span> <span style=color:#000>关闭查询日志</span>
</span></span></code></pre></td></tr></table></div></div></div><p>2、确实是否有不必要的只读事务</p><p>有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</p><p>3、控制每个语句执行的最长时间</p><p>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，避免单个语句意外执行太长时间。</p><h3 id=数据库端>数据库端</h3><p>1、监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill</p><p>2、Percona 的 pt-kill 这个工具不错，推荐使用</p><p>3、在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；</p><p>4、如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</p><p>innodb_undo_tablespaces 是控制 undo 是否开启独立的表空间的参数。</p><p>为0表示：undo使用系统表空间，即ibdata1</p><p>不为0表示：使用独立的表空间，一般名称为 undo001 undo002，存放地址的配置项为：innodb_undo_directory 一般innodb_undo_tablespaces 默认配置为0，innodb_undo_directory默认配置为当前数据目录</p><h1 id=reference>Reference</h1><p><a href=https://github.com/Yhzhtk/note/issues/42>https://github.com/Yhzhtk/note/issues/42</a></p><p><a href=https://juejin.im/post/6844903919387148296>https://juejin.im/post/6844903919387148296</a></p><p><a href=https://tech.meituan.com/2014/08/20/innodb-lock.html>https://tech.meituan.com/2014/08/20/innodb-lock.html</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-0cacbe2389748a5d32062a1f0c3659cc>2.8 - MySQL技术内幕-InnoDB</h1><h1 id=体系结构与存储引擎>体系结构与存储引擎</h1><h2 id=定义数据库与实例>定义数据库与实例</h2><p>数据库：物理操作系统文件或其他形式文件类型的集合。</p><p>实例：MySQL数据库由后台线程以及一个共享内存区组成</p><p>MySQL被设计为一个<strong>单进程多线程</strong>架构的数据库，与SQL Server比较类似。而Oracle是<strong>多进程</strong>的架构。</p><p>查看MySQL实例启动时，在哪些位置查找配置文件：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mysql --help | grep my.cnf
</span></span></code></pre></td></tr></table></div></div></div><p>可以看出，是按/etc/my.cnf -> /etc/mysql/my.cnf -> /url/local/mysql/etc/my.cnf -> ~/.my.cnf 的顺序读取配置文件，以最后读取到的配置文件为准。</p><h1 id=innodb存储引擎>InnoDB存储引擎</h1><h2 id=innodb体系架构>InnoDB体系架构</h2><p>内存池负责工作：</p><p>1、维护所有进程/线程需要访问的多个内部数据结构</p><p>2、缓冲磁盘上的数据，方便快速读取，<strong>同时对磁盘文件的数据修改之前在这里缓冲</strong></p><p>3、重做日志（redo log）缓冲</p><p>后台线程的作用：</p><p>1、负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据</p><p>2、将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态</p><h3 id=后台线程>后台线程</h3><p>1、Master Thread</p><p>（核心线程）负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等</p><p>2、IO Thread</p><p>使用大量异步线程处理写IO请求。write/read/insert buffer/log IO thread</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>SHOW VARIABLES LIKE <span style=color:#c41a16>&#39;innodb_version&#39;</span><span style=color:#c41a16>\G</span>;
</span></span><span style=display:flex><span>SHOW VARIBALES LIKE <span style=color:#c41a16>&#39;innodb_%io_threads&#39;</span><span style=color:#c41a16>\G</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>可以通过命令<strong>SHOW ENGINE INNODB STATUS</strong>观察InnoDB的IO Thread。
3、Purge Thread</p><p>事务被提交后，其所使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。</p><p>4、Page Cleaner Thread</p><p>作用：将之前版本中脏页的刷新操作都放入到单独的线程中来完成。目的：减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高性能。</p><h3 id=内存>内存</h3><h4 id=1-缓冲池>1、缓冲池</h4><p>缓冲池缓存的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等。</p><p>缓冲池实例数（默认1，可配置）：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>SHOW VARIABLES LIKE <span style=color:#c41a16>&#39;innodb_buffer_pool_instances&#39;</span><span style=color:#c41a16>\G</span>;
</span></span></code></pre></td></tr></table></div></div></div><h4 id=2-lru-free-flush>2、LRU、Free、Flush</h4><p>LRU加入了midpoint位置，新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置。该算法称为midpoint insertion strategy。默认配置该位置在LRU列表长度的5/8处。由参数innodb_old_blocks_pct控制。innodb_old_blocks_time表示页读取到mid位置后需要等待多久才能被加入到LRU列表的热端。</p><p>命令（红色）结果Database pages表示LRU列表中页的数量。</p><p>page made young表示LRU列表中页移动到前端的次数。</p><p>脏页（LRU列表中的页被修改后，称为脏页）通过CHECKPOIN机制将脏页刷新回磁盘，而Flush列表中的页即为脏页。</p><blockquote><p>脏页既存在于LRU列表中，也存在于Flush列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘，二者互不影响。</p></blockquote><p>Modified db pages 表示脏页的数量</p><p>元数据表可查看：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>SELECT TABLE_NAME, SPACE, PAGE_NUMBER, PAGE_TYPE 
</span></span><span style=display:flex><span>FROM INNODB_BUFFER_PAGE_LRU
</span></span><span style=display:flex><span>WHERE OLDEST_MODIFICATION &gt; 0;
</span></span></code></pre></td></tr></table></div></div></div><p>Free为空闲列表</p><h4 id=3-重做日志缓冲>3、重做日志缓冲</h4><p>redo log buffer</p><p>大小有配置参数innodb_log_buffer_size控制。通常8MB满足绝大部分应用，因为下列三种情况会将内容刷新到外部磁盘的重做日志文件中：</p><p>1）Master Thread每一秒将重做日志缓冲刷新到重做日志文件</p><p>2）每个事物提交是会将重做日志缓冲刷新到重做日志文件</p><p>3）当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</p><h4 id=4-额外的内存池>4、额外的内存池</h4><p>对内存的管理是通过一种称为内存堆（heap）的方式进行的。内存分配时，需要从额外的内存池中进行申请，例如分配缓冲池，每个缓冲池中的帧缓冲（frame buffer）还有对应的缓冲控制对象（buffer control block）（记录LRU、锁、等待等信息）。所以申请很大的缓冲池时，也应考虑相应增加该值。</p><h4 id=buffer-pool的lru算法>Buffer Pool的LRU算法</h4><p>了解完了InnoDB的内存结构之后，我们来仔细看看Buffer Pool的LRU算法是如何实现将最近没有使用过的数据给过期的。</p><p><strong>原生LRU</strong></p><p>首先明确一点，此处的LRU算法和我们传统的LRU算法有一定的区别。为什么呢？因为实际生产环境中会存在全表扫描的情况，如果数据量较大，可能会将Buffer Pool中存下来的热点数据给全部替换出去，而这样就会导致该段时间MySQL性能断崖式下跌。</p><p>对于这种情况，MySQL有一个专用名词叫缓冲池污染。所以MySQL对LRU算法做了优化。</p><p><strong>优化后的LRU</strong></p><p>优化之后的链表被分成了两个部分，分别是 New Sublist 和 Old Sublist，其分别占用了 Buffer Pool 的3/4和1/4。</p><p><img src=../imgs/mysql-innodb20220229_1.png alt=mysql-innodb20220229_1.png></p><p>该链表存储的数据来源有两部分，分别是：</p><p>1、MySQL的预读线程预先加载的数据</p><p>2、用户的操作，例如Query查询</p><p>默认情况下，由用户操作影响而进入到Buffer Pool中的数据，会被立即放到链表的最前端，也就是 New Sublist 的 Head 部分。但如果是MySQL启动时预加载的数据，则会放入MidPoint中，如果这部分数据被用户访问过之后，才会放到链表的最前端。</p><p>这样一来，虽然这些页数据在链表中了，但是由于没有被访问过，就会被移动到后1/4的 Old Sublist中去，直到被清理掉。</p><h3 id=checkpoint技术>Checkpoint技术</h3><p>当前事务数据库系统普遍采用Write Ahead Log策略，即当事务提交时，先写重做日志，再修改页。宕机通过重做日志恢复数据，保证数据持久性。</p><p>Checkpoint（检查点）技术的目的解决如下问题：</p><p>1、缩短数据库的恢复时间</p><p>2、缓冲池不够用时，将脏页刷新到磁盘</p><p>3、重做日志不可用时，刷新脏页</p><p>宕机时，不需要重做所有的日志，Checkpoint之前的页都已经刷新回磁盘，大大缩短恢复时间。</p><p>重做日志不可用是因为其设计为循环使用，并不是让其无限增大。重做日志可以被重用的部分是指这些重做日志已经不再需要，即宕机时，恢复操作不需要这部分的重做日志，因此可以覆盖使用。若此时还需要使用，则必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p><p>Checkpoint将缓冲池中的脏页刷回到磁盘。</p><p>两种Checkpoint：</p><p>1、Sharp Checkpoint</p><p>2、Fuzzy Checkpoint</p><p>Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘，默认工作方式，即参数innodb_fast_shutdown=1</p><p>如果运行时使用Sharp Checkpoint性能受到很大影响。故使用Fuzzy Checkpoint只刷新一部分脏页，而不是刷新所有的脏页回磁盘。</p><p>几种情况的Fuzzy Checkpoint：</p><p>1、Master Thread Checkpoint</p><blockquote><p>每秒或每十秒异步</p></blockquote><p>2、FLUSH_LRU_LIST Checkpoint</p><blockquote><p>保证LRU列表需要大约100多个空闲也可用，移除LRU列表尾端的页需要Checkpoint</p></blockquote><p>3、Async/Sync Flush Checkpoint</p><blockquote><p>重做日志不可用，保证重做日志循环使用</p></blockquote><p>4、Dirty Page too much Checkpoint</p><blockquote><p>脏页数量太多（配置参数：innodb_max_dirty_pages_pct）</p></blockquote><h2 id=master-thread工作方式>Master Thread工作方式</h2><h3 id=1-0-x版本之前的master-thread>1.0.x版本之前的Master Thread</h3><p>具有最高的线程优先级别。内部由多个循环组成（根据数据库运行状态进行切换）：</p><p><strong>1、主循环（loop）</strong></p><p>每秒一次的操作包括：</p><ul><li>日志缓冲刷新到磁盘，即使事务还没有提交（总是）</li><li>合并插入缓冲（可能）</li><li>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）</li><li>如果当前没有用户活动，则切换到background loop（可能）</li></ul><p>**即使某个事物还没有提交，InnoDB存储引擎仍然每秒会将重做日志缓冲中的内容刷新到重做日志文件。**所以解释为什么再大的事务提交（commit）时间也是很短的。</p><p>InnoDB存储引擎判断当前一秒内发生IO次数是否小于5次，是则认为当前IO压力小，可以执行合并插入缓冲的操作。</p><p>判断当前缓冲池中脏页的比例（buf_get_modified_ratio_pct，默认为90，代表90%），如果超过，则刷新100个脏页到磁盘。</p><p>每十秒的操作包括：</p><ul><li>刷新100个脏页到磁盘（可能）</li><li>合并至多5个插入缓冲（总是）</li><li>将日志缓冲刷新到磁盘（总是）</li><li>删除无用的Undo页（总是）</li><li>刷新100个或者10个脏页到磁盘（总是）</li></ul><p>判断过去10秒之内磁盘IO操作是否小于200次，是则认为磁盘IO具备操作能力，因此将100个脏页刷新到磁盘。</p><p>接着合并插入缓冲操作（总是）。</p><p>之后将日志缓冲刷新到磁盘（总是）（和每秒操作一致）。</p><p>接着执行full purge操作，即删除无用的Undo页。判断是否可以删除，可以则立即删除。</p><p>然后判断缓冲池脏页比例（buf_get_modified_ratio_pct），超过70%，则刷新100个脏页到磁盘，否则刷新10个。</p><p>2、后台循环（backgroup loop）</p><p>若当前没有用户活动（数据空闲时）或者数据库关闭（shutdown），就会切换到这个循环。backgroup loop会执行以下操作：</p><ul><li>删除无用的Undo页（总是）</li><li>合并20个插入缓冲（总是）</li><li>跳回到主循环（总是）</li><li>不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）</li></ul><p>3、刷新循环（flush loop）</p><p>若flush loop也没有事可以做，会切换到suspend loop，将Master Thread挂起，等待事件的发生。若用户启用（enable）InnoDB存储引擎，却未使用任何表，Master Thread总是处于挂起状态。</p><p>4、暂停循环（suspend loop）</p><h3 id=1-2-x版本之前的master-thread>1.2.x版本之前的Master Thread</h3><p>1.0.x版本之前对于IO有限制，在缓冲池想磁盘刷新时做了硬编码（hard coding），固态硬盘（SSD）出现，则限制了对磁盘IO的性能，尤其是写入。</p><p>分析：无论何时，最大只会刷新100个脏页到磁盘，合并20个插入缓冲。如果是写密集每秒可能产生大于100个脏页，如果产生大于20个插入缓冲，Master Thread可能忙不过来或者说慢。</p><p>从1.0.x版本提供参数innodb_io_capacity表示磁盘吞吐量，默认200。对于刷新到磁盘页的数量，会按照该参数的百分比来控制。规则如下：</p><ul><li>合并插入缓冲时，数量为该参数的5%</li><li>从缓冲区刷新脏页时，数量为该值</li></ul><p>参数innodb_max_dirty_pages_pct默认值90，即脏页占缓冲池90%。该值太大，内存很大时DB压力很大，刷新脏页速度很慢，数据恢复时间更久。</p><p>1.0.x版本提供默认值75，和Google测试的80最接近。这样既可以加快刷新脏页的频率，又能保证磁盘IO的负载。（太小增加磁盘的压力）</p><p>增加参数innodb_adaptive_flushing（自适应地刷新）。原来刷新规则：脏页在缓冲池所占比例小于innodb_max_dirtypages_pct时，不刷新脏页；大于时刷新100个脏页。引入该参数后，buf_flush_get_desired_flush_rate函数通过判断产生重做日志（redo log）的速度决定最适合的刷新脏页数量。因此脏页比例小于innodb_max_dirtypages_pct时，也会刷新一定量的脏页。</p><p>之前每次full purge时，最多回收20个Undo页，1.0.x版本引入参数innodb_purge_batch_size，控制每次full purge回收的Undo页的数量。默认值为20。</p><p>1.0.x版本在性能方面取得了极大的提高。</p><h3 id=1-2-x版本的master-thread>1.2.x版本的Master Thread</h3><p>对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，减轻主线程工作，提高并发。</p><h2 id=innodb关键特性>InnoDB关键特性</h2><h3 id=1-插入缓冲-insert-buffer>1、插入缓冲（Insert Buffer）</h3><p>性能提升</p><h4 id=1-insert-buffer>1）Insert Buffer</h4><p>对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引是否在缓冲池中，若在直接插入，否则先放到一个Insert Buffer对象中。然后以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作。这通常能将多个插入合并到一个操作中（在一个索引页中），大大提高非聚集索引插入的性能</p><p>使用需要满足两个条件：</p><ul><li>索引是辅助索引</li><li>索引<strong>不是唯一</strong>的</li></ul><p>问题：若宕机有大量的Insert Buffer并没有合并到实际的非聚集索引中，恢复需要大量时间（甚至几小时）。修改占用缓冲池大小的比例</p><h4 id=2-change-buffer>2）Change Buffer</h4><p>1.0.x版本引入了Change Buffer，可将其视为Insert Buffer的升级。可以对DML操作（INSERT/ DELETE/UPDATE）都进行缓冲，分别是Insert Buffer、Delete Buffer、Purge Buffer。</p><p>适用条件：<strong>非唯一的辅助索引</strong>。</p><p>UPDATE操作可分为两个过程：</p><ul><li>将记录标记为已删除（Delete Buffer）</li><li>真正将记录删除（Purge Buffer）</li></ul><p>参数innofb_chage_buffering用来开启各种buffer选项。可选inserts/deletes/purges /changes/all/none（默认all）。参数innodb_change_buffer_max_size控制Change Buffer最大使用内存数量。默认25，表示最多使用25%的缓冲池内存空间，最大有效值50。</p><h4 id=3-insert-buffer的内部实现>3）Insert Buffer的内部实现</h4><p>其数据结构是一颗B+树。MySQL4.1之前的版本中每张表都有一颗Insert Buffer B+树，现在版本全局只有一颗。存放在共享空间中，默认也就是ibdata1中。因此试图通过独立表空间idb文件恢复表中数据时，往往会导致CHECK TABLE失败。因为表的辅助索引中的数据可能还在Insert Buffer中，也就是共享空间中，所以还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。（详情见P51）</p><h4 id=4-merge-insert-buffer>4）Merge Insert Buffer</h4><p>Insert Buffer的记录合并（merge）到真正的辅助索引中</p><p>该操作可能发生在以下几种情况下：</p><ul><li>辅助索引页被读取到缓冲池时</li><li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时</li><li>Master Thread</li></ul><h3 id=2-两次写-double-write>2、两次写（Double Write）</h3><p>可靠性。</p><p>解决诸如部分写失效（partial page write）等问题。</p><p>为什么不使用重做日志恢复？因为重做日志记录的是对页的物理操作，如偏移量xx写AA。如果页本身损坏，重做没有意义。即应用重做日志前，需要一个页的副本，当写入失效发生时，先通过页的副本还原该页，再进行重做，这就是doublewrite。</p><p>doublewrite由两部分组成：</p><ul><li>doublewrite buffer（2MB）</li><li>物理磁盘上共享表空间中连续的128个页，即2个区（extent），大小同样为2MB。
在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序写入共享表空间的物理磁盘上（顺序文件），然后调用fsync函数，同步磁盘（真正的数据文件.ibd），避免缓冲写带来的问题。</li></ul><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>SHOW GLOBAL STATUS LIKE <span style=color:#c41a16>&#39;innodb_dblwr%&#39;</span><span style=color:#c41a16>\G</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>innodb_dblwr_pages_written为写了的页数，innodb_dblwr_writes为实际写入次数，其比例小于64：1则说明系统写入压力不高。
参数skip_innodb_doublewrite可以禁止doublewrite功能，从服务器提高性能可以考虑，主服务器确保开启双写服务。</p><blockquote><p>诸如ZFS文件系统本身提供了部分写失效的防范机制，可以不启用双写</p></blockquote><p><strong>理解</strong></p><p>这时利用redo log （页（数据块）的物理操作）来恢复已经损坏的数据块是无效的！数据块的本身已经损坏，再次重做依然是一个坏块！所以此时需要一个数据块的副本来还原该损坏的数据块，再利用重做日志进行其他数据块的重做操作，这就是doublwrite的原因作用！</p><p>理解可参考：<a href=http://jockchou.github.io/blog/2015/07/23/innodb-doublewrite-buffer.html>http://jockchou.github.io/blog/2015/07/23/innodb-doublewrite-buffer.html</a></p><h3 id=3-自适应哈希索引-adaptive-hash-index-ahi>3、自适应哈希索引（Adaptive Hash Index，AHI）</h3><p>（Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升）</p><p><img src=../imgs/mysql-innodb20220229_2.png alt=mysql-innodb20220229_2.png></p><p>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引。AHI是通过缓冲池的B+树页构造出来，建立速度很快，不需要对整张表构建哈希索引。</p><p>要求：对这个页的连续访问模式必须是一样的。</p><p>参数innodb_adaptive_hash_index禁用或启动此特性。默认开启。</p><p>缺点：</p><ul><li>会占用innodb buffer pool</li><li>只能等值查找</li></ul><h3 id=4-异步io-async-io>4、异步IO（Async IO）</h3><p>除了异步，还有一个优势是IO Merge操作。</p><p>1.1.x之前，AIO通过代码模拟实现。1.1.x提供了内核级别AIO的支持（Native AIO，mac系统不支持）。需要libaio库支持。</p><p>参数innodb_use_native_aio用来控制是否启用Native AIO，Linux系统下默认ON。</p><h3 id=5-刷新临接页-flush-neighbor-page>5、刷新临接页（Flush Neighbor Page）</h3><p>当刷新一个脏页时，检测该页所在区（extent）的所有页，如果是脏页，那么一起刷新。通过AIO将多个IO写入操作合并为一个。</p><p>两个问题：</p><p>1、是否可能将不怎么脏的页进行写入，该页很快又会变成脏页？</p><p>2、固态硬盘有较高的IOPS，也需要该特性？</p><p>1.2.x版本开始提供innodb_flush_neighbors控制是否启用该特性。建议传统机械硬盘启动，固态硬盘不启用。</p><h2 id=启动-关闭与恢复>启动、关闭与恢复</h2><p>参数innodb_fast_shutdown影响：</p><ul><li>0表示DB关闭时，需完成所有的full purge和merge insert buffer，并且将所有的脏页刷新回磁盘</li></ul><blockquote><p>full purge：删除无用的Undo页
merge insert buffer：Insert Buffer的记录合并到真正的辅助索引中</p></blockquote><ul><li>1为默认值，不需要完成full purge和merge insert buffer，但将所有脏页刷新会磁盘</li><li>2两者皆不，而是将日志都写入日志文件，下次启动，会进行恢复操作（recovery）</li></ul><blockquote><p>kill关闭DB，也会进行恢复操作</p></blockquote><p>参数innodb_force_recovery，略</p><h1 id=文件>文件</h1><h2 id=参数文件>参数文件</h2><h2 id=日志文件>日志文件</h2><h3 id=1-错误日志>1、错误日志</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>SHOW VARIABLES LIKE <span style=color:#c41a16>&#39;log_error&#39;</span> <span style=color:#177500># 定位文件名和路径</span>
</span></span><span style=display:flex><span>system hostname  <span style=color:#177500># 主机名，默认错误日志为 主机名.err</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=2-慢查询日志>2、慢查询日志</h3><p>参数long_query_time设置运行时间阈值，超过（不包括等于）则记录在慢查询日志中，默认值为10（秒）。</p><p>参数log_slow_queries为记录开关。</p><p>参数log_queries_not_using_indexes，如果运行语句没有使用索引，是否记录到该日志开关。</p><h3 id=3-查询日志>3、查询日志</h3><h3 id=4-二进制日志>4、二进制日志</h3><p>记录了对DB执行更改的所有操作，但不包括SELECT和SHOW这类操作</p><blockquote><p>若操作本身并没有导致DB发生变化，那么可能也会写入二进制日志</p></blockquote><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>SHOW MASTER STATUS # 得到File名称
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SHOW BINLOG EVENTS IN &#39;mysqld.000008&#39; # 使用File名称查询
</span></span></code></pre></td></tr></table></div></div></div><p>二进制日志作用：</p><ul><li>恢复（recovery）</li><li>复制（replication）</li><li>审计（audit）：判断是否有进行注入的攻击</li></ul><h2 id=套接字文件>套接字文件</h2><p>UNIX系统本地连接MySQL可采用UNIX域套接字方式，需要一个套接字（socket）文件，一般在/tmp目录下，名为mysql.sock。</p><h2 id=pid文件>pid文件</h2><p>默认位于数据库目录下，文件名为主机名.pid</p><h2 id=表结构定义文件>表结构定义文件</h2><p>每个表都有一个以frm为后缀的文件，记录表结构定义，视图也有。可直接只用cat查看</p><h2 id=innodb存储引擎文件>InnoDB存储引擎文件</h2><h3 id=1-表空间文件>1、表空间文件</h3><h3 id=2-重做日志文件>2、重做日志文件</h3><h1 id=表>表</h1><h2 id=索引组织表>索引组织表</h2><p>表根据主键顺序组织存放的，这种存储方式成为索引组织表（index organized table）。</p><p>如果没有显式地定义主键，InnoDB则会按如下方式选择或创建主键：</p><p>1、首先判断表中是否有<strong>非空的唯一索引</strong>（Unique NOT NULL），如果有，则该列即为主键。</p><p>2、如果不符合上述条件，InnoDB自动创建一个6字节大小的指针</p><blockquote><p>当表中有多个非空唯一索引时，会选择建表时第一个定义的非空唯一索引为主键。（定义索引的顺序，而不是建表时列的顺序。</p></blockquote><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>select a,b,c,d,_rowid from table
</span></span></code></pre></td></tr></table></div></div></div><p>_rowid可以显示表的主键，但只能用于查看单个列为主键的情况</p><h2 id=innodb逻辑存储结构>InnoDB逻辑存储结构</h2><p>所有数据被逻辑地存放在一个空间中，称之为表空间（tablespace）。<strong>表空间又由段（segment）、区（extent）、页（page）组成</strong>。页在一些文档中有时也称为块（block）。</p><h3 id=表空间>表空间</h3><p>共享表空间iddata1，即所有数据都存放在该表空间中。若启用参数innodb_file_per_table，则每张表内的数据可以单独放到一个表空间内。</p><p>注意：每张表的表空间内存放的只是数据、索引和插入缓冲Bitmap页，其他类的数据，如回滚(undo)信息，插入缓冲索引页、系统事务信息，二次写缓冲(Double write buffer)等还是存放在原来的共享表空间内。</p><p>所以即使启动该参数，共享表空间还是不断增大。</p><h3 id=段>段</h3><p>表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。</p><p>InnoDB存储引擎表示索引组织的（index organized），因此数据即索引，索引即数据。</p><p>数据段：B+树的叶子节点</p><p>索引段：B+树的非叶子节点</p><p>对段的管理是引擎自身完成的。</p><h3 id=区>区</h3><p><strong>区是由连续页组成的空间，在任何情况下每个区的大小都为1MB</strong>。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘中申请4-5个区。默认情况下页大小为16KB，即一个区中共有64个连续的页。</p><p>1.0.x版本开始引入压缩页，页大小可通过参数KYE_BLOCK_SIZE设置为8KB/4KB/2KB，因此每个区对应页的数量为128、256、512。</p><p>1.2.x版本新增参数innodb_page_size，可将默认页大小置为4K/8K，但页中的数据库不是压缩，此时区中页的数量同样为256、128。</p><h3 id=页>页</h3><p>页（page）也称为块，是InnoDB磁盘管理的最小单位。</p><p>1.2.x版本新增参数innodb_page_size，可将页的大小设置为4K/8K/16K，设置完成，则所有表中页的大小都为该值，不可以对其再次进行修改。除非通过mysqldump导入和导出操作来产生新的库。</p><p>常见的页类型有：</p><ul><li>数据页（B-tree Node）</li><li>undo页（undo Log Page）</li><li>系统页（System Page）</li><li>事务数据页（Transaction system Page）</li><li>插入缓冲位图页（Insert Buffer Bitmap）</li><li>插入缓冲空闲列表页（Insert Buffer Free List）</li><li>未压缩的二进制大对象页（Uncompressed BLOB Page）</li><li>压缩的二进制大对象页（compressed BLOB Page）</li></ul><h3 id=行>行</h3><p>InnoDB引擎是面向行（row-oriented），也就是数据时按行进行存放的。每个页存放的行记录有硬性指标，最多允许存放16KB/2-200行，即7992行记录。</p><h2 id=innodb行记录格式>InnoDB行记录格式</h2><h3 id=compact行记录格式>Compact行记录格式</h3><h3 id=redundant行记录格式>Redundant行记录格式</h3><h3 id=行溢出数据>行溢出数据</h3><p>MySQL数据库的VARCHAR类型可以存放65535字节。通过测试最长长度为为65532，因为有别的开销。（字符集为latin1，UTF-8、GBK不一样）</p><blockquote><p>注意如果没有讲SQL_MODE设为严格模式，或许可以建立表，但会抛出warning。自动将VARCHAR类型转换成了TEXT类型。</p></blockquote><h3 id=compressed和dynamic行记录格式>Compressed和Dynamic行记录格式</h3><h3 id=char的行结构存储>CHAR的行结构存储</h3><h2 id=innodb数据页结构>InnoDB数据页结构</h2><p>InnoDB数据页由以下7个部分组成：</p><ul><li>File Header（文件头）</li><li>Page Header（页头）</li><li>Infimun和Supremum Records</li><li>User Records（用户记录，即行记录）</li><li>Free Space（空闲空间）</li><li>Page Directory（页目录）</li><li>File Trailer（文件结尾信息）</li></ul><h2 id=named-file-formats机制>Named File Formats机制</h2><h2 id=约束>约束</h2><h3 id=数据完整性>数据完整性</h3><h3 id=约束的创建和查找>约束的创建和查找</h3><h3 id=约束和索引的区别>约束和索引的区别</h3><h3 id=对错误数据的约束>对错误数据的约束</h3><h3 id=enum和set约束>ENUM和SET约束</h3><h3 id=触发器与约束>触发器与约束</h3><h3 id=外键约束>外键约束</h3><h2 id=视图>视图</h2><h2 id=分区表>分区表</h2><h1 id=索引与算法>索引与算法</h1><h2 id=innodb存储引擎索引概述>InnoDB存储引擎索引概述</h2><p>常见索引：</p><ul><li>B+树索引</li><li>全文索引</li><li>哈希索引</li></ul><p>常常被忽略的问题：B+树索引并不能找到一个给定键值的具体行，B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p><h2 id=数据结构与算法>数据结构与算法</h2><h3 id=二分查找法>二分查找法</h3><h3 id=二叉查找树和平衡二叉树>二叉查找树和平衡二叉树</h3><h2 id=b-树>B+树</h2><h3 id=b-树索引>B+树索引</h3><p>1、聚集索引</p><p>表中数据按照主键顺序存放</p><p>2、辅助索引</p><p>3、B+树索引的分裂</p><p>4、B+树索引的管理</p><p>5、Cardinality值</p><p>怎么查看索引是否是高选择性（举例，性别不属于高选择性。取值范围广，几乎没有重复，即高选择性）。Cardinality值表示索引中不重复记录数量的预估值。</p><blockquote><p>注意，这是个预估值，不是准确值。</p></blockquote><p>数据库对于Cardinality的统计都是通过采样（Sample）的方法来完成。</p><p>InnoDB存储引擎内部对更新Cardinality信息的策略为：</p><ul><li>表中1/16的数据已发生过变化</li><li>stat_modified_counter > 2 000 000 000</li></ul><h2 id=b-树索引的使用>B+树索引的使用</h2><h3 id=不同应用中b-树索引的使用>不同应用中B+树索引的使用</h3><h3 id=联合索引>联合索引</h3><h3 id=覆盖索引>覆盖索引</h3><p>即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。</p><h3 id=优化器选择不适用索引的情况>优化器选择不适用索引的情况</h3><p>多发生在范围查找、JOIN链接操作等情况下</p><h3 id=索引提示>索引提示</h3><p>显式地告诉优化器使用哪个索引。</p><h3 id=multi-range-read优化>Multi-Range Read优化</h3><p>好处：</p><ul><li>MRR是数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果按照主键进行排序，并按照主键排序的顺序进行书签查找</li><li>减少缓冲池中页被替换的次数</li><li>批量处理对键值的查询操作</li></ul><p>MRR的工作方式：</p><ul><li>将查询得到的辅助索引键值存放于一个缓存中，这时缓存的数据时根据辅助索引键值排序的</li><li>将缓存中的键值根据RowID进行排序</li><li>根据RowID的排列顺序来访问实际的数据文件</li></ul><h3 id=index-condition-pushdown-icp-优化>Index Condition Pushdown（ICP）优化</h3><p>MySQL5.6开始支持。</p><p>将WHERE的部分过滤操作放在了存储引擎层。大大减少上层SQL层对记录的索取（fetch），提高性能。</p><h2 id=哈希算法>哈希算法</h2><h2 id=全文索引>全文索引</h2><p>1.2.x版本开始支持全文索引。</p><h1 id=锁>锁</h1><h2 id=innodb引擎里面的锁>InnoDB引擎里面的锁</h2><h3 id=一致性非锁定读>一致性非锁定读</h3><p>一致性非锁定读（consistent nonlocking read）是指InnoDB存储引擎通过行多版本控制（mutil versioning）的方式来读取当前执行时间数据库中行的数据。</p><h3 id=一致性锁定读>一致性锁定读</h3><p>两种一致性的锁定读（locking read）操作：</p><p>1、SELECT ... FOR UPDATE</p><p>2、SELECT ... LOCK IN SHARE MODE</p><p>第一种操作对读取的行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。</p><p>第二种操作对读取的行记录加S锁，其他事务可以向被锁定的行加S锁，但如果加X锁，会被阻塞。</p><h3 id=自增长与锁>自增长与锁</h3><p>在InnoDB存储引擎的内存结构中，对每个含有自增长值得表都有一个自增长计数器（auto-increment counter）。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>SELECT</span> <span style=color:#a90d91>MAX</span>(<span style=color:#000>auto_inc_col</span>) <span style=color:#a90d91>FROM</span> <span style=color:#000>t</span> <span style=color:#a90d91>FOR</span> <span style=color:#a90d91>UPDATE</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>这种实现方式称作AUTO-INC Locking。这种锁其实是采用一种特殊的表锁机制，为了提高插入的性能，<strong>锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放</strong>。
问题：</p><p>1、并发插入性能差，事务必须等待前一个插入的完成（虽然不用等待事务的完成）</p><p>2、对于INSERT ... SELECT的大数据两的插入会有插入性能问题</p><p>MySQL 5.1.22版本开始，InnoDB提供了一种轻量级互斥量的自增长实现机制，大大提高了自增长值插入的性能。并提供参数innodb_autoinc_lock_mode控制自增长模式，默认值为1。</p><p>首先介绍插入类型：</p><p>1、insert-like</p><p>所有的插入语句，如INSERT、REPLACE、INSERT...SELECT、REPLACE...SELECT、LOAD DATA等</p><p>2、simple inserts</p><p>插入前能确定插入行数的语句，如INSERT...SELECT、REPLACE...SELECT、LOAD DATA</p><blockquote><p>不包括INSERT...ON DUPLICATE KEY UPDATE这类语句</p></blockquote><p>3、bulk inserts</p><p>插入前不能确定插入行数的语句，如INSERT...SERLECT，REPLACE...SELECT，LOAD DATA</p><p>4、mixed-mode inserts</p><p>插入中有一部分是自增长的，有一部分是确定的。如INSERT INTO t1(c1, c2) VALUES (1, 'a'), (NULL, 'b')；也可以是指INSERT...ON DUPLICATE KEY UPDATE</p><p>上述参数innodb_autoinc_lock_mode以及各个设置下对自增的影响，共有三个有效值可以设定，即0、1、2，具体说明如下：</p><p><strong>值为0：</strong></p><p>MySQL5.1.22版本之前自增长的实现方式，即通过表锁的AUTO-INC Locking。</p><p><strong>值为1：</strong></p><p>默认值。</p><p>对于“simple inserts”，该值会用互斥量（mutex）去对内存中的计数器进行累加的操作。</p><p>对于“bulk inserts”，还是使用传统表锁的AUTO-INC Locking方式。</p><p>在这种配置下，如果不考虑回滚操作，对于自增值列的增长还是连续的。并且在这种方式下，statement-based方式的replication还是能很好地工作。需要注意的是，如果已经使用AUTO-INC Locking方式去产生自增长的值，而这时需要再进行“simple inserts”的操作时，还是需要等待AUTO-INC Locking的释放。</p><p><strong>值为2：</strong></p><p>该模式下，对于所有的“INSERT-like”自增长值的产生都是通过互斥量，而不是AUTO-INC Locking的方式。显然这是性能最高的方式。但在并发插入的情况下，自增长的的值可能不是连续的。</p><p>最重要的是，<strong>基于Statement-Base Replication会出现问题。因此，使用该模式任何时候都应该使用row-base replication</strong>。这样才能保证最大的并发性能及replication主从数据的一致。</p><blockquote><p>InnoDB自增长的实现与MyISAM不同，MyISAM存储引擎是表锁设计，自增长不用考虑并发插入问题。因此在master上用InnoDB，在slave上用MyISAM的replication架构下，用户必须考虑这种情况。</p></blockquote><p>InnoDB中，自增长的列必须是索引，同时必须是索引的第一个列，如果不是则会抛出异常，而MyISAM没有这个问题。</p><h3 id=外键和锁>外键和锁</h3><p>InnoDB会自动对其加一个索引，这样可以避免表锁——这比Oracle做得好，Oracle不会自动添加索引，用户必须自己手动添加，这也导致了Oracle可能产生死锁。</p><p>对于外键值的插入或者更新，首先需要查询父表中的记录，即SELECT父表。但是对于父表的SELECT操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，因此这时使用的是SELECT...LOCK IN SHARE MODE方式，即主动对父表加一个S锁。如果这时父表上已经加了X锁，子表上的操作会被阻塞。</p><h2 id=锁的算法>锁的算法</h2><h3 id=行锁的3种算法>行锁的3种算法</h3><p>InnoDB存储引擎有3种行锁的算法，分别是：</p><ul><li>Record Lock：单个行记录上的锁</li><li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身</li><li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li></ul><p>当查询的索引含有唯一属性时，InnoDB会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。若是辅助索引，其加上的是Next-Key Lock。</p><p>用户可以通过以下两种方式来显式地关闭Gap Lock：</p><ul><li>将事务的隔离级别设置为READ COMMITTED</li><li>将参数innodb_locks_unsafe_for_binlog设置为1</li></ul><p>在上述的配置下，除了外键约束和唯一性检查依然需要的Gap Lock，其余情况仅使用Record Lock进行锁定。但是，上述设置破坏了事务的隔离性，并且对于replication，可能会导致主从数据的不一致。此外，从性能上来看，READ COMMITTED也不会优于默认的事务隔离级别READ REPEATEABLE。</p><h3 id=解决phantome-problem>解决Phantome Problem</h3><p>Phantom Problem是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次SQL语句可能会返回之前不存在的行。</p><p>在默认的事务隔离级别下，即REPEATABLE READ下，InnoDB采用Next-Key Locking机制来避免Phantom Problem（幻象问题）。其他DB可能需要在SERIALIZABLE的事务隔离级别下才能解决该问题。</p><h2 id=锁问题>锁问题</h2><h3 id=脏读>脏读</h3><h3 id=不可重复读>不可重复读</h3><h3 id=丢失更新>丢失更新</h3><h2 id=阻塞>阻塞</h2><h2 id=死锁>死锁</h2><h2 id=锁升级>锁升级</h2><p>锁升级（Lock Escalation）是指当前锁的粒度降低。比如，DB把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。这种升级保护了系统资源，防止系统用太多的内存来维护锁，在一定程度上提高了效率。但锁升级带来的一个问题是因为锁粒度的降低而导致并发性能的降低。</p><h1 id=事务>事务</h1><h2 id=事务的实现>事务的实现</h2><h3 id=redo>redo</h3><h3 id=undo>undo</h3><h3 id=purge>purge</h3><p>delete和update操作可能并不直接删除原有的数据。例如delete，将主键列等于xx的记录delete flag设置为1，记录并没有被删除，即记录还存在于B+树中。其次，对辅助索引没有做处理，甚至没有产生undo log。而真正删除这行记录的操作其实被“延时”了，最终在purge操作中完成。</p><p>purge用于最终完成delete和update操作。这样设计是因为InnoDB支持MVCC，所以记录不能在事务提交时立即进行处理。这时其他事务可能正在引用这行，故InnoDB需要保存记录之前的版本。而是否可以删除该跳记录通过purge来进行判断。若该行记录已不被任何其他事务引用，那就可以进行真正的delete操作。</p><p>因为undo log可重用没有顺序，所以使用history list记录了顺序，然后从undo page中找undo log。这样是为了避免大量的随机读取操作，从而提高purge的效率。</p><p>全局动态参数innodb_purge_batch_size用来设置每次purge操作需要清理的undo page数量。</p><h3 id=group-commit>group commit</h3><p>一次fsync可以确保多个事务日志被写入文件。InnoDB事务提交时会进行两个阶段的操作：</p><p>1）修改内存中事务对应的细腻，并且将日志写入重做日志缓冲</p><p>2）调用fsync将确保日志都从重做日志缓冲写入磁盘</p><p>问题：</p><p>InnoDB1.2版本之前，开启二进制后，该功能失效，从而导致性能下降。并且在线环境多使用replication环境，因此二进制日志的选项基本都为开启状态，因此该问题显著。</p><p>原因：</p><p>开启二进制日志后，为了博阿正存储引擎层中的事务和二进制日志的一致性，二者之间使用了两阶段事务，其步骤如下：</p><p>1）当事务提交时InnoDB存储引擎进行prepare操作</p><p>2）MySQL数据库上层写入二进制日志</p><p>3）InnoDB存储引擎层将日志写入重做日志文件</p><p>a）修改内存中事务对应的信息，并且将日志写入重做日志缓冲</p><p>b）调用fsync将确保日志都从重做日志缓冲写入磁盘</p><p>为了保证MySQL数据库上层二进制日志的写入顺序和InnoDB层的事务提交顺序一致，MySQL数据内部使用了prepare_commit_mutex这个锁。但是在启用这个锁之后，步骤3）的步骤a）步不可以在其他事务执行步骤b）时进行，从而导致group commit失效。</p><p>解决方案：</p><p>Binary Log Group Commit(BLGC)，步骤如下：</p><ul><li>Flush阶段，将每个事务的二进制日志写入内存中</li><li>Sync阶段，将内存中的二进制日志刷新到磁盘，若队列中有多个事务，那么仅一次fsync操作就完成了二进制日志的写入，这就是BLGC</li><li>commit阶段，leader根据顺序调用存储引擎层事务的提交，InnoDB存储引擎本就支持group commit，因此修复了原先由于锁prepare_commit_mutex导致group commit失效的问题</li></ul><h2 id=事务控制语句>事务控制语句</h2><h2 id=隐式提交的sql语句>隐式提交的SQL语句</h2><p>以下SQL语句会产生一个隐式的提交操作，即执行完这些语句后会有一个隐式的COMMIT操作：</p><ul><li>DDL语句</li><li>用来隐式地修改MySQL架构的操作：CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD</li><li>管理语句：ANALYZE TABLE、CACHE INDEX、CHECK TABLE、LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE</li></ul><h2 id=对于事务操作的统计>对于事务操作的统计</h2><p>每秒事务处理的能力（Transaction Per Second，TPS），计算TPS的方法是(com_commit+com_rollback)/time，但是利用这个方法计算的前提是：所有事务必须都是显式提交，如果存在隐式提价和回滚（默认autocommit=1），不会计算到com_commit和com_rollback变量中。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>SHOW</span> <span style=color:#a90d91>GLOBAL</span> <span style=color:#000>STATUS</span>  <span style=color:#a90d91>LIKE</span> <span style=color:#c41a16>&#39;com_commit&#39;</span>
</span></span></code></pre></td></tr></table></div></div></div><h2 id=分布式事务>分布式事务</h2><h3 id=mysql数据库分布式事务>MySQL数据库分布式事务</h3><p>InnoDB提供了对XA事务的支持，并通过XA事务支持分布式事务的实现。</p><blockquote><p>在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE</p></blockquote><p>XA事务允许不同的数据库之间的分布式事务</p><p>XA事务由一个或多个资源管理器（Resource Managers）、一个事务管理器（Transaction Manager）以及一个应用程序（Application Program）组成。</p><ul><li><p>资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器</p></li><li><p>事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信</p></li><li><p>应用程序：定义事务的边界，指定全局事务中的操作
分布式事务使用两段式提交（two-phase commit）的方式：</p></li><li><p>所有参与全局事务的节点都开始准备（PREPARE）</p></li><li><p>事务管理器告诉资源管理器执行ROLLBACK还是COMMIT</p></li></ul><h2 id=不好的事务习惯>不好的事务习惯</h2><h3 id=在循环中提交>在循环中提交</h3><h3 id=使用自动提交>使用自动提交</h3><h3 id=使用自动回滚>使用自动回滚</h3><h2 id=长事务>长事务</h2><p>长事务（Long-Lived Transaction）。</p><p>可以分解成多个小事务</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3543749e44f03a87413d5435c686d875>3 - Redis</h1><h1 id=introduction>Introduction</h1><p>Redis</p></div><div class=td-content><h1 id=pg-7c5bf47b0f395e37baa104838561cd81>3.1 - Redis开发与运维</h1><h1 id=01-初始redis>01 初始Redis</h1><h2 id=1-1-盛赞redis>1.1 盛赞Redis</h2><p>    Redis中的值可以是由string、hash、list、set、zset、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等多种数据结构和算法组成。    </p><h2 id=1-2-redis特性>1.2 Redis特性</h2><p>1、速度快</p><ul><li>存储在内存中</li><li>C语言编写，一般来说C语言编写的程序“距离”操作系统更近</li><li>单线程架构，预防了多线程可能产生的竞争</li><li>作者对源代码精打细磨（稍有的集性能和优雅于一身的开源代码）</li></ul><p>2、基于键值对的数据结构服务器</p><p>3、丰富的功能</p><p>    除了5中数据结构，还提供了许多额外功能：</p><ul><li>键过期功能，可以实现缓存</li><li>发布订阅功能，可以实现消息系统</li><li>支持Lua脚本功能，可以利用Lua创造出新的Redis命令</li><li>简单的事务功能，能在一定程度上保证事务特性</li><li>流水线（Pipeline）功能，使客户端能将一批命令一次性传到Redis，减少网络开销</li></ul><p>4、简单稳定</p><ul><li>源码少（早期2万行，3.0版本以后增加集群，5万行）</li><li>单线程模型，服务端处理模型简单，客户端开发简单</li><li>不依赖与操作系统中类库，自己实现了事件处理的相关功能</li></ul><p>5、客户端语言多</p><p>    提供简单的TCP协议</p><p>6、持久化</p><p>    两种持久化方式:RDB和AOF</p><p>7、主从复制</p><p>8、高可用和分布式</p><p>    高可用实现Redis Sentinel保证Redis节点的故障发现和故障自动转移；分布式实现Redis Cluster</p><h2 id=1-3-redis使用场景>1.3 Redis使用场景</h2><h3 id=1-3-1-redis可以做什么>1.3.1 Redis可以做什么</h3><ol><li>缓存</li><li>排行榜系统</li><li>计数器应用</li><li>社交网络</li><li>消息队列系统</li></ol><h3 id=1-3-2-redis不可以做什么>1.3.2 Redis不可以做什么</h3><p>    数据量大的、冷数据</p><h2 id=1-4-用好redis的建议>1.4 用好Redis的建议</h2><h2 id=1-5-正确安装并启动redis>1.5 正确安装并启动Redis</h2><h2 id=1-6-redis重大版本>1.6 Redis重大版本</h2><p>    借鉴Linux操作系统对于版本号的命名规则，版本号第二位如果是奇数，则为非稳定版本，偶数则为稳定版本</p><p>1、Redis 2.6</p><p>    2012年正式发布</p><p>    1）服务端支持Lua脚本</p><p>    2）去掉虚拟内存相关功能</p><p>    3）放开对客户端连接数的硬编码限制</p><p>    4）键的过期时间支持毫秒</p><p>    5）从节点提供只读功能</p><p>    6）两个新的位图命令：bitcount和bitop</p><p>    7）增强redis-benchmark的功能：支持定制化的压测，CSV输出等功能</p><p>    8）基于浮点数自增命令：incrbyfloat和hincrbyfloat</p><p>    9）redis-cli可以使用--eval参数实现Lua脚本执行</p><p>    10）shutdown命令增强</p><p>    11）info可以按照section输出，并且添加了一些统计项</p><p>    12）重构了大量的核心代码，所有集群相关的代码都去掉了，cluster功能将会是3.0版本最大的亮点</p><p>    13）sort命令优化</p><p>2、Redis 2.8</p><p>    2013年11月22日正式发布</p><p>    1）添加部分主从复制的功能，在一定程度上降低了由于网络问题，造成频繁全量复制生成RDB对系统造成的压力</p><p>    2）尝试性地支持IPv6</p><p>    3）可以通过config set命令设置maxclients</p><p>    4）可以用bind命令绑定多个IP地址</p><p>    5）Redis设置明显的进程名，方便使用ps命令查看系统进程</p><p>    6）confi rewrite命令可以将config set持久化到Redis配置文件中</p><p>    7）发布订阅添加了pubsub命令</p><p>    8）Redis Sentinal第二版，相比于Redis 2.6的Redis Sentinel，此版本变成生产可用</p><p>3、Redis 3.0</p><p>    2015年4月1日正式发布</p><p>    1）Redis Cluster：Redis的官方分布式实现</p><p>    2）全新的embedded string对象编码结果，优化小对象内存访问，在特定的工作负载下速度大幅提升</p><p>    3）lru算法大幅提升</p><p>    4）migrate链接缓存，大幅提升迁移的速度</p><p>    5）migrate命令两个新的参数copy和replace</p><p>    6）新的client pause命令，在指定时间内停止处理客户端请求</p><p>    7）bitcount命令性能提升</p><p>    8）confit set设置maxmemory时可以设置不同的单位（之前只能是字节），例如config set maxmemory 1gb</p><p>    9）Redis日志小做调整：日志中会反应当前实例的角色（master或者slave）</p><p>    10）incr命令性能提升</p><p>4、Redis 3.2</p><p>    2016年5月6日正式发布</p><p>    1）添加GEO相关功能</p><p>    2）SDS在速度和节省空间上都做了优化</p><p>    3）支持用upstart或者systemd管理Redis进程</p><p>    4）新的List编码类型：quicklist</p><p>    5）从节点读取过期数据保持一致性</p><p>    6）添加hstrlen命令</p><p>    7）增强了debug命令，支持了更多的参数</p><p>    8）Lua脚本功能增强</p><p>    9）添加了Lua Debugger</p><p>    10）config set支持更多的配置参数</p><p>    11）优化了Redis崩溃后的相关报告</p><p>    12）新的RDB格式，但是仍然兼容旧的RDB</p><p>    13）加速RDB的加载速度</p><p>    14）spop命令支持个数参数</p><p>    15）cluster nodes命令支持个数参数</p><p>    16）Jemalloc更新到4.0.3版本</p><p>5、Redis 4.0</p><p>    1）模块系统，方便第三方开发者扩展Redis功能</p><p>    2）PSYNC 2.0：优化了之前版本中，主从节点切换必然引起全量复制的问题</p><p>    3）提供了新的缓存提出算法：LFU(Last Frequently Used)，并优化已有算法</p><p>    4）提供了非阻塞del和flushall/flushdb功能，有效解决删除bigkey可能造成的Redis阻塞</p><p>    5）提供了RDB-AOF混合持久化格式，充分利用了AOF和RDB各自优势</p><p>    6）提供了memory命令，实现对内存更为全面的监控统计</p><p>    7）提供了交互数据库功能，实现Redis内部数据库之间的数据置换</p><p>    8）Redis Cluster兼容NAT和Docker</p><h1 id=02-api的理解与使用>02 API的理解与使用</h1><h2 id=2-1-预备>2.1 预备</h2><h3 id=2-1-1-全局命令>2.1.1 全局命令</h3><ol><li>key*  查看所有键</li><li>dbsize  键总数</li><li>exists key  检查键是否存在</li><li>del key  删除键</li><li>expire key seconds  键过期</li><li>type key  键的数据结构类型</li></ol><h3 id=2-1-2-数据结构和内部编码>2.1.2 数据结构和内部编码</h3><p>    每种数据结构都有两种以上的内部编码实现，例如list包含linkedlist和ziplist，可使用object encoding key来查看</p><h3 id=2-1-3-单线程架构>2.1.3 单线程架构</h3><p>    Redis使用单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。</p><p>    每次客户端调用都经历发送命令、执行命令、返回结果三个过程。</p><p>    采用I/O多路复用技术来解决I/O的问题。</p><p>    单线程快的原因：</p><ol><li>纯内存访问（响应时长100纳秒）</li><li>非阻塞I/O（使用epoll作为I/O多路复用技术，加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费时间）</li><li>单线程避免了线程切换和竞态产生的消耗</li></ol><h2 id=2-2-字符串>2.2 字符串</h2><p>    值最大不超过512MB</p><h3 id=2-2-1-命令>2.2.1 命令</h3><p>1、set key value</p><p>ex seconds：设置秒级过期时间</p><p>px milliseconds：设置毫秒级过期时间</p><p>nx： 键必须不存在，才可以设置成功，用于添加，分布式锁</p><p>xx：与nx相反，用于更新</p><p>mset key value [key value …]</p><p>2、get key    </p><p>mget key [key …]</p><ol><li>incr key 计数</li><li>append key value 追加字符串值</li><li>strlen key 字符串长度</li><li>getset key value</li><li>setrange key offset value</li><li>getrange key start end</li></ol><h3 id=2-2-2-内部编码>2.2.2 内部编码</h3><p>    字符串的内部编码有3种：</p><ul><li>int：8个字节的长整形</li><li>embstr：小于等于39个字节的字符创</li><li>raw：大于39个字节的字符串</li></ul><p>Redis会根据当前值的类型和长度决定使用哪种内部编码实现</p><h3 id=2-2-3-典型使用场景>2.2.3 典型使用场景</h3><ol><li>缓存功能</li><li>计数</li><li>共享session</li><li>限速（一分钟不超过x次）</li></ol><h2 id=2-3-哈希>2.3 哈希</h2><h3 id=2-3-1-命令>2.3.1 命令</h3><h3 id=2-3-2-内部编码>2.3.2 内部编码</h3><p>    哈希类型的内部编码有两种：</p><ul><li>ziplist（压缩列表）：当元素个数小于hash-max-ziplist-entries(512)、同时所有值都小于hash-max-ziplist-vallue(64)时</li><li>hashtable（哈希表）：无法满足ziplist的条件</li></ul><h2 id=2-4-列表>2.4 列表</h2><h3 id=2-4-1-命令>2.4.1 命令</h3><h3 id=2-4-2-内部编码>2.4.2 内部编码</h3><ul><li>ziplist（压缩列表）：同上</li><li>linkedlist（链表）：同</li></ul><h2 id=2-5-集合>2.5 集合</h2><h3 id=2-5-2-内部编码>2.5.2 内部编码</h3><ul><li>intset（整数集合）</li><li>hashtable（哈希表）</li></ul><h2 id=2-6-有序集合>2.6 有序集合</h2><h3 id=2-6-2-内部编码>2.6.2 内部编码</h3><ul><li>ziplist（压缩列表）</li><li>skiplist（跳跃表）</li></ul><h2 id=2-7-键管理>2.7 键管理</h2><h1 id=03-小功能大用处>03 小功能大用处</h1><h2 id=3-1-慢查询分析>3.1 慢查询分析</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>config <span style=color:#a90d91>set</span> slowlog-log-slower-than <span style=color:#1c01ce>20000</span>
</span></span><span style=display:flex><span>config <span style=color:#a90d91>set</span> slowlog-max-len <span style=color:#1c01ce>1000</span>
</span></span><span style=display:flex><span>config rewrite
</span></span><span style=display:flex><span>slowlog get
</span></span><span style=display:flex><span>slowlog len 
</span></span></code></pre></td></tr></table></div></div></div><h2 id=3-2-redis-shell>3.2 Redis shell</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>redis-cli
</span></span><span style=display:flex><span>redis-server
</span></span><span style=display:flex><span>redis-benchmark 
</span></span></code></pre></td></tr></table></div></div></div><h2 id=3-3-pipeline>3.3 Pipeline</h2><p>    RTT（Round Trip Time，往返时间），节省网络传输时间，一次性执行多个命令</p><h2 id=3-4-事务与lua>3.4 事务与Lua</h2><h3 id=3-4-3-redis与lua>3.4.3 Redis与Lua</h3><p>    eval和evalsha</p><h1 id=04-客户端>04 客户端</h1><h2 id=4-1-客户端通信协议>4.1 客户端通信协议</h2><h2 id=4-2-java客户端jedis>4.2 Java客户端Jedis</h2><h2 id=4-3-python客户端redis-py>4.3 Python客户端redis-py</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#177500># 1、引入依赖，生成客户端连接</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>redis</span>
</span></span><span style=display:flex><span><span style=color:#000>client</span> <span style=color:#000>=</span> <span style=color:#000>redis</span><span style=color:#000>.</span><span style=color:#000>StrictRedis</span>(<span style=color:#000>host</span><span style=color:#000>=</span><span style=color:#000>‘</span><span style=color:#1c01ce>127.0.0.1</span><span style=color:#000>’</span>, <span style=color:#000>port</span><span style=color:#000>=</span><span style=color:#1c01ce>6379</span>)
</span></span><span style=display:flex><span><span style=color:#177500># 2、生成pipeline</span>
</span></span><span style=display:flex><span><span style=color:#000>pipeline</span> <span style=color:#000>=</span> <span style=color:#000>redis</span><span style=color:#000>.</span><span style=color:#000>pipelien</span>(<span style=color:#000>transaction</span><span style=color:#000>=</span><span style=color:#a90d91>False</span>)
</span></span><span style=display:flex><span><span style=color:#177500># 3、将命令封装到pipeline中</span>
</span></span><span style=display:flex><span><span style=color:#000>pipeline</span><span style=color:#000>.</span><span style=color:#000>set</span>(<span style=color:#000>“</span><span style=color:#000>hello</span><span style=color:#000>”</span>,<span style=color:#000>”</span><span style=color:#000>world</span><span style=color:#000>”</span>)
</span></span><span style=display:flex><span><span style=color:#000>pipelien</span><span style=color:#000>.</span><span style=color:#000>incr</span>(<span style=color:#000>“</span><span style=color:#000>counter</span><span style=color:#000>”</span>)
</span></span><span style=display:flex><span><span style=color:#177500># 4、执行pipeline</span>
</span></span><span style=display:flex><span><span style=color:#000>result</span> <span style=color:#000>=</span> <span style=color:#000>pipeline</span><span style=color:#000>.</span><span style=color:#000>execute</span>() 
</span></span></code></pre></td></tr></table></div></div></div><h2 id=4-4-客户端管理>4.4 客户端管理</h2><h3 id=4-4-1-客户端api>4.4.1 客户端API</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>client list
</span></span><span style=display:flex><span>info clients 
</span></span></code></pre></td></tr></table></div></div></div><h1 id=05-持久化>05 持久化</h1><h2 id=5-1-rdb>5.1 RDB</h2><h3 id=5-1-1-触发机制>5.1.1 触发机制</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 手动触发命令</span>
</span></span><span style=display:flex><span>save <span style=color:#177500># 阻塞当前Redis服务器，直到RDB过程完成</span>
</span></span><span style=display:flex><span>bgsave <span style=color:#177500># 阻塞只发生在fork阶段，一般时间很短 </span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500># 自动触发命令</span>
</span></span><span style=display:flex><span>save m n <span style=color:#177500># m秒内数据集存在n次修改</span>
</span></span><span style=display:flex><span>debug reload
</span></span><span style=display:flex><span>shutdown <span style=color:#177500># 默认情况下执行，如果没有开启AOF持久化功能则自动执行bgsave </span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=5-1-2-流程说明>5.1.2 流程说明</h3><p>bgsave是主流的触发RDB持久化方式，流程如下：</p><p>1）执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在bgsave命令直接返回</p><p>2）父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒</p><p>3）父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令</p><p>4）子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。（执行lastsave命令可以获得最后一次生成RDB的时间，对应info统计的rdb_last_save_time选项</p><p>5）进程发送信号给父进程表示完成，父进程更新统计信息，具体见info Persistence下的rdb_*相关选项</p><h3 id=5-1-3-rdb文件的处理>5.1.3 RDB文件的处理</h3><p>    压缩：默认采用LZF算法对生成的RDB文件进行压缩处理，如果文件损坏，可以使用redis-check-dump检测获取错误报告</p><h3 id=5-1-4-rdb的优缺点>5.1.4 RDB的优缺点</h3><p>优点：</p><ol><li>紧凑压缩的二进制文件，非常适合用于备份，全量复制等场景</li><li>Redis加载RDB恢复数据远远快于AOF的方式</li></ol><p>缺点：</p><ol><li>没有办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li><li>二进制文件保存，版本更替有多个格式，存在老版本服务无法兼容新版格式的问题</li></ol><h2 id=5-2-aof-append-only-file>5.2 AOF(append only file)</h2><p>    追加命令到文件实现持久化</p><h3 id=5-2-3-文件同步>5.2.3 文件同步</h3><h3 id=5-2-4-重写机制>5.2.4 重写机制</h3><p>    重写后的AOF文件变小的原因：</p><p>1）进程内已超时的数据不再写入文件</p><p>2）旧的AOF文件含有无效命令，只保留最终数据的写入命令</p><p>3）多条写命令可以合并为一个</p><p>    重写过程可以手动触发和自动触发：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 手动触发 直接执行</span>
</span></span><span style=display:flex><span>bgrewriteaof
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#177500># 自动触发  参数确定自动触发时机</span>
</span></span><span style=display:flex><span><span style=color:#177500># auto-aof-rewrite-min-size 运行重写时文件的最小体积，默认64M</span>
</span></span><span style=display:flex><span><span style=color:#177500># auto-aof-rewrite-percentage 当前AOF文件空间和上一次重写后的比值 </span>
</span></span></code></pre></td></tr></table></div></div></div><h1 id=06-复制>06 复制</h1><h2 id=6-1配置>6.1配置</h2><h3 id=6-1-1-建立复制>6.1.1 建立复制</h3><p>    配置复制的方式：</p><ol><li>在配置文件中加入slaveof {masterHost} {masterPort}随Redis启动生效</li><li>在redis-server启动命令后加入—slaveof {masterHost} {masterPort}</li><li>直接使用命令：slaveof {masterHost} {masterPort}生效</li></ol><h2 id=6-2-拓扑>6.2 拓扑</h2><ol><li>一主一从结构</li><li>一主多从结构</li><li>树状主从结构</li></ol><h2 id=6-3-原理>6.3 原理</h2><h3 id=6-3-1-复制过程>6.3.1 复制过程</h3><ol><li>保存主节点信息</li><li>从节点内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接</li><li>发送ping命令</li><li>权限验证</li><li>同步数据集</li><li>命令持续复制</li></ol><h3 id=6-3-2-数据同步>6.3.2 数据同步</h3><ul><li>全量复制</li><li>部分复制</li></ul><h2 id=6-4-开发与运维中的问题>6.4 开发与运维中的问题</h2><h3 id=6-4-1-读写分离>6.4.1 读写分离</h3><p>    当使用从节点响应读请求时，业务端可能会遇到如下问题：</p><p>1、数据延迟</p><p>2、读到过期数据</p><p>    Redis内部需要维护过期数据删除策略：惰性删除和定时删除</p><p>3、从节点故障问题</p><h3 id=6-4-2-主从配置不一致>6.4.2 主从配置不一致</h3><h3 id=6-4-3-规避全量复制>6.4.3 规避全量复制</h3><h3 id=6-4-4-规避复制风暴>6.4.4 规避复制风暴</h3><h1 id=07-redis的噩梦-阻塞>07 Redis的噩梦：阻塞</h1><h2 id=7-1-发现阻塞>7.1 发现阻塞</h2><p>    在实现异常统计时要注意，由于Redis调用API会分散在项目的多个地方，每个地方都监听异常并加入监控代码必然难以维护。可以借助日志系统！（RedisAppender）</p><h2 id=7-2-内在原因>7.2 内在原因</h2><h3 id=7-2-1-api或数据结构使用不合理>7.2.1 API或数据结构使用不合理</h3><p>1、如何发现慢查询</p><p>slowlog get {n} # 获取最近的n条慢查询命令</p><p>调整方向：1）修改为低算法度的命令，如hgetall改为hmget等，禁用keys、sort等命令；2）调整大对象，拆分为小对象，防止一次命令操作过多的数据</p><p>2、如何发现大对象</p><p>redis-cli -h {ip} -p {port} -—bigkeys</p><p>redis-cli —-bigkeys</p><h3 id=7-2-2-cpu饱和>7.2.2 CPU饱和</h3><h3 id=7-2-3-持久化相关的阻塞>7.2.3 持久化相关的阻塞</h3><p>1、fork阻塞</p><p>2、AOF刷盘阻塞</p><p>3、HugePage写操作阻塞</p><h2 id=7-3-外在原因>7.3 外在原因</h2><h3 id=7-3-1-cpu竞争>7.3.1 CPU竞争</h3><h3 id=7-3-2-内存交换>7.3.2 内存交换</h3><h3 id=7-3-3-网络问题>7.3.3 网络问题</h3><p>1、连接拒绝（网络闪断、Redis连接拒绝、连接溢出）</p><p>2、网络延迟</p><p>3、网卡软中断</p><h1 id=08-理解内存>08 理解内存</h1><h2 id=8-1-内存消耗>8.1 内存消耗</h2><h3 id=8-1-1-内存使用统计>8.1.1 内存使用统计</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>info memory 
</span></span></code></pre></td></tr></table></div></div></div><h3 id=8-1-2-内存消耗划分>8.1.2 内存消耗划分</h3><p>    Redis进程内消耗主要包括：自身内存+对象内存+缓冲内存+内存碎片</p><p>1、对象内存</p><p>    可以简单理解为sizeof(keys) + sizeof(values)</p><p>2、缓冲内存</p><p>    主要包括：客户端缓冲、复制挤压缓冲区、AOF缓冲区</p><p>3、内存碎片</p><h3 id=8-1-3-子进程内存消耗>8.1.3 子进程内存消耗</h3><h2 id=8-2-内存管理>8.2 内存管理</h2><h3 id=8-2-1-设置内存上限>8.2.1 设置内存上限</h3><h3 id=8-2-2-动态调整内存上限>8.2.2 动态调整内存上限</h3><h3 id=8-2-3-内存回收策略>8.2.3 内存回收策略</h3><p>1、删除过期键对象</p><ul><li>惰性删除</li><li>定时任务删除</li></ul><p>2、内存溢出控制策略</p><h2 id=8-3-内存优化>8.3 内存优化</h2><h3 id=8-3-1-redisobject对象>8.3.1 redisObject对象</h3><p>    Redis存储的所有值对象在内部定义为redisObject结构体</p><p>1、type：表示当前对象使用的数据类型，如string、hash、list、set、zset等，可以使用 type {key}查看对象所属类型</p><p>2、encoding：表示Redis内部编码类型</p><p>3、lru：记录对象最后一次被访问的时间</p><p>4、refcount：记录当前对象被引用的次数，用于引用次数回收内存，当为0时可以安全回收当前对象空间</p><p>5、*ptr：与对象的数据内容相关，如果是整数，直接存储数据；否则指向数据的指针</p><h3 id=8-3-2-缩减键值对象>8.3.2 缩减键值对象</h3><p>    降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度。序列化工具，如protostuff、kryo等</p><h3 id=8-3-3-共享对象池>8.3.3 共享对象池</h3><p>    指Redis内部维护[0-9999]的整数对象池。每个redisObject内部结构至少占16字节，用于节约内存</p><p>    问：为什么开启maxmemory和LRU淘汰策略后对象池无效？</p><p>    答：LRU算法需要获取对象最后被访问时间（lru字段），对象共享意味着多个引用共享同一个redisObject，这是lru字段也会被共享，导致无法获取每个对象的最后访问时间。如果没有设置maxmemory，直到内存被用尽Redis也不回触发内存回收，所以共享对象池可以正常工作。综述：共享对象池与maxmemory+LRU策略冲突，使用时需要注意。</p><p>    问：为什么只有整数对象池？</p><p>    答：因为整数比较算法时间复杂度为O(1)，只保留一万个整数为了防止对象池浪费。字符串判断相等性，时间复杂度O(n)，特别是长字符串更消耗性能（浮点数在Redis内部使用字符串存储）。更复杂的数据结构如hash、list等，相等性判断需要O(n*n)。</p><h3 id=8-3-4-字符串优化>8.3.4 字符串优化</h3><p>1、字符串结构</p><p>    Redis没有采用原生C语言的字符串类型而是自己实现了字符串结构，内部简单动态字符串（simple dynamic string, SDS)。</p><p>    Redis自身实现的字符串结构特点：</p><ul><li>O(1)时间复杂度获取：字符串长度、已用长度、未用长度</li><li>可用于保存字节数组，支持安全的二进制数据存储</li><li>内部实现空间预分配机制，降低内存再分配次数</li><li>惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留</li></ul><p>2、预分配机制</p><p>3、字符串重构</p><h3 id=8-3-5-编码优化>8.3.5 编码优化</h3><p>1、了解编码</p><p>2、控制编码类型</p><p>3、ziplist编码</p><p>4、intset编码</p><h3 id=8-3-6-控制键的数量>8.3.6 控制键的数量</h3><h1 id=09-哨兵-redis-sentinel>09 哨兵（Redis Sentinel）</h1><p>9.1 基本概念</p><p>9.1.1 主从复制的问题</p><p>9.1.2 高可用</p><p>9.1.3 Redis Sentinel的高可用性</p><p>    注意：Redis 2.6（Redis Sentinel v1）功能性和健壮性都有一些问题，建议使用Redis 2.8（Redis Sentinel v2）以上。</p><p>    Redis Sentinel功能：</p><ul><li>监控</li><li>通知</li><li>主节点故障转移</li><li>配置提供者</li><li>节点的故障判断由多个Sentinel节点共同完成，防止误判</li><li>Sentinel节点集合由若干个Sentinel节点组成，即使个别不可用，整个节点集合依然是健壮的
9.2 安装和部署</li></ul><p>9.2.1 部署拓扑结构</p><p>9.2.2 部署Redis数据节点</p><p>9.2.3 部署Sentinel节点</p><p>9.2.4 配置优化</p><p>9.2.5 部署技巧</p><p>9.3 API</p><p>9.4 客户端连接</p><p>9.4.1 Redis Sentinel的客户端</p><p>9.4.2 Redis Sentinel客户端基本实现原理</p><p>9.4.3 Java操作Redis Sentinel</p><p>9.5 实现原理</p><p>9.5.1 三个定时监控任务</p><p>9.5.2 主观下线和客观下线</p><p>9.5.3 领导者Sentinel节点选举</p><p>9.5.4 故障转移</p><p>9.6 开发与运维中的问题</p><p>9.6.1 故障转移日志分析</p><p>9.6.2 节点运维</p><p>9.6.3 高可用读写分离</p><h1 id=10-集群>10 集群</h1><p>之前Redis分布式方案一般有两种：</p><ul><li>客户端分区方案（优点：分区逻辑可控，缺点：自己处理数据路由、高可用、故障转移等问题）</li><li>代理方案（优点：简化客户端分布式逻辑和升级维护遍历，缺点：加重架构部署复杂度和性能损耗）</li></ul><p>官方提供的集群方案：Redis Cluster，优雅地解决了Redis集群方面的问题。</p><h2 id=10-1-数据分布>10.1 数据分布</h2><h3 id=10-1-1-数据分布理论>10.1.1 数据分布理论</h3><p>    常见的分区规则有哈希分区和顺序分区两种。Redis Cluster采用哈希分区规则。常见的分区规则：</p><p>1、节点取余分区</p><p>2、一致性哈希分区</p><p>优点：加入或删除节点只影响哈希环中相邻的节点，对其它节点无影响。</p><p>问题：</p><ol><li>加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这部分数据，因此一致性哈希常用语缓存场景</li><li>当使用少量节点时，节点变化将大范围影响哈希环中的数据映射，因此这种方式不适合少量数据节点的分布式方案</li><li>普通的一致性哈希分区在增减分区节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡
3、虚拟槽分区</li></ol><p>    虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有的数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。这个范围一般远远大于节点数，比如Redis Cluster槽范围是0~16383。槽是集群内数据管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据才分和集群扩展。</p><h3 id=10-1-2-redis数据分区>10.1.2 Redis数据分区</h3><p>    Redis虚拟槽分区的特点：</p><ul><li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度</li><li>节点自身维护槽的映射关系，不需要客户或者代理服务维护槽分区元数据</li><li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景</li></ul><h3 id=10-1-3-集群功能限制>10.1.3 集群功能限制</h3><p>    Redis集群相对单机在功能上存在一些限制：</p><ol><li>key批量操作支持有限。如mset、mget，目前只支持具有相同slot值得key执行批量操作。对于映射为不同slot值得key由于执行mset、mget等操作可能存在于多个节点因此不被支持</li><li>key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能</li><li>key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash、list等映射到不同的节点</li><li>不支持多数据库空间。单机下的Redis可以支持16个数据库，集群模式下只能使用一个数据库空间，即db 0</li><li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构</li></ol><h2 id=10-2-搭建集群>10.2 搭建集群</h2><p>步骤：1、准备节点；2、节点握手；3、分配槽</p><p>10.2.1 准备节点</p><p>10.2.2 节点握手</p><p>10.2.3 分配槽</p><p>10.2.4 用redis-trib.rb搭建集群</p><p>    redis-trib.rb是采用Ruby实现的Redis集群管理工具。内部通过Cluster相关命令帮我们简化集群创建、检查、槽迁移和均衡等常见运维操作，使用之前需要安装Ruby依赖环境。</p><p>10.3 节点通信</p><p>10.3.1 通信流程</p><p>10.3.2 Gossip通信</p><p>10.3.3 节点选择</p><p>10.4 集群伸缩</p><p>10.4.1 伸缩原理</p><p>10.4.2 扩容集群</p><p>10.4.3 收缩集群</p><p>10.5 请求路由</p><p>10.5.1 请求量定向</p><p>10.5.2 Smart客户端</p><p>10.6 故障转移</p><p>10.6.1 故障发现</p><p>    故障发现通过消息传播机制实现，主要环节包括：主管下线（pfail）和客观下线（fail）</p><ul><li>主观下线：指某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。</li><li>客观下线：指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。
10.6.2 故障恢复</li></ul><p>10.6.3 故障转移时间</p><p>10.6.4 故障转移演练</p><p>10.7 集群运维</p><p>10.7.1 集群完整性</p><p>10.7.2 带宽消耗</p><p>10.7.3 Pub/Sub广播问题</p><p>10.7.4 集群倾斜</p><p>10.7.5 集群读写分离</p><p>10.7.6 手动故障转移</p><p>10.7.7 数据迁移</p><h1 id=11-缓存设计>11 缓存设计</h1><h2 id=11-1-缓存的收益和成本>11.1 缓存的收益和成本</h2><p>收益：</p><ul><li>加速读写</li><li>降低后端复杂</li></ul><p>成本：</p><ul><li>数据不一致性：缓存层和数据层的数据存在着一定时间窗口的不一致性，时间窗口跟更新策略有关</li><li>代码维护成本：加入缓存后，需要同时处理缓存层和存储层的逻辑，增大了开发者维护代码的成本</li><li>运维成本：以Redis Cluster为例，加入后无形中增加了运维成本</li></ul><p>缓存的使用场景包括如下两种：</p><ul><li>开销大的复杂计算</li><li>加速请求响应</li></ul><h2 id=11-2-缓存更新策略>11.2 缓存更新策略</h2><p>1、LRU/LFU/FIFO算法剔除</p><p>2、超时剔除</p><p>3、主动更新</p><p>4、最佳实践</p><table><thead><tr><th style=text-align:left>策略</th><th style=text-align:left>一致性</th><th style=text-align:left>维护成本</th></tr></thead><tbody><tr><td style=text-align:left>LRU/LRF/FIFO算法剔除</td><td style=text-align:left>最差</td><td style=text-align:left>低</td></tr><tr><td style=text-align:left>超时剔除</td><td style=text-align:left>较差</td><td style=text-align:left>较低</td></tr><tr><td style=text-align:left>主动更新</td><td style=text-align:left>强</td><td style=text-align:left>高</td></tr></tbody></table><h2 id=11-3-缓存粒度控制>11.3 缓存粒度控制</h2><p>    缓存全部属性还是缓存部分重要属性？从以下3个角度进行说明</p><p>1、通用性</p><p>    缓存全部数据比部分数据更加通用，但从实际经验看，很长时间内应用只需要几个重要的属性</p><p>2、空间占用</p><p>    缓存全部数据占用更多的空间，可能存在以下问题：1）内存的浪费；2）全部数据每次传输产生的网络流量会比较大，耗时相对较大，在极端情况下回阻塞网络；3）全部数据的序列化和反序列化的CPU开销大</p><p>3、代码维护</p><p>    全部数据的优势更加明显，而部分数据一旦要加新字段需要修改业务代码，而且修改后通常还需要刷新缓存数据</p><h2 id=11-4-穿透优化>11.4 穿透优化</h2><p>    缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。步骤如下：</p><ol><li>缓存层不命中</li><li>存储层不命中，不将结果写回缓存</li><li>返回空结果
解决缓存穿透问题：</li></ol><p>1、缓存空对象</p><p>问题：1）空值做了缓存，意味着缓存层存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。2）缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。列如设置过期时间为5分钟，此时存储层添加了这个数据，那么会出现不一致情况，可以利用消息系统或其他方式清除掉缓存层中的空对象。</p><p>2、布隆过滤器拦截</p><p>    在访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来，做第一层拦截。</p><p>    这种方法适用于数据命中不高、数据相对固定、实时性低（通常是数据集较大）的应用场景，代码维护较为复杂，但是缓存空间占用少。</p><p>2种方案对比</p><table><thead><tr><th style=text-align:left>解决缓存穿透</th><th style=text-align:left>适用场景</th><th style=text-align:left>维护成本</th></tr></thead><tbody><tr><td style=text-align:left>缓存空对象</td><td style=text-align:left>1、数据命中不高<br>2、数据频繁变化实时性高</td><td style=text-align:left>1、代码维护简单<br>2、需要过多的缓存空间<br>3、数据不一致<br><br></td></tr><tr><td style=text-align:left>布隆过滤器</td><td style=text-align:left>1、数据命中不高<br>2、数据相对固定实时性低</td><td style=text-align:left>1、代码维护复杂<br>2、缓存空间占用少<br><br></td></tr></tbody></table><h2 id=11-5-无底洞优化>11.5 无底洞优化</h2><p>    “无底洞”现象：添加大量新Memcache节点，但是性能不但没有变好反而下降。</p><p>无底洞现象分析：</p><ul><li>客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多、耗时会不断增大。</li><li>网络连接数变多，对节点的性能也有一定影响。</li></ul><p>常见的IO优化思路：</p><ul><li>命令本身的优化，例如优化SQL语句等</li><li>减少网络通信次数</li><li>降低接入成本，例如客户端使用长连/连接池、NIO等</li></ul><p>4种分布式批量操作方案对比：</p><table><thead><tr><th style=text-align:left>方案</th><th style=text-align:left>优点</th><th style=text-align:left>缺点</th><th style=text-align:left>网络IO</th></tr></thead><tbody><tr><td style=text-align:left>串行命令</td><td style=text-align:left>1）编程简单<br>2）如果少量keys，性能可以满足要求</td><td style=text-align:left>大量keys请求延迟严重</td><td style=text-align:left>O(keys)</td></tr><tr><td style=text-align:left>串行IO</td><td style=text-align:left>1）编程简单<br>2）少量节点，性能满足要求</td><td style=text-align:left>大量node延迟严重</td><td style=text-align:left>O(nodes)</td></tr><tr><td style=text-align:left>并行IO</td><td style=text-align:left>利用并行特性，延迟取决于最慢的节点</td><td style=text-align:left>1）编程复杂<br>2）由于多线程，问题定威可能较差</td><td style=text-align:left>O(max_slow(nodes))</td></tr><tr><td style=text-align:left>hash_tag</td><td style=text-align:left>性能最高</td><td style=text-align:left>1）业务维护成本较高<br>2）容易出现数据倾斜</td><td style=text-align:left>O(1)</td></tr></tbody></table><h2 id=11-6-雪崩优化>11.6 雪崩优化</h2><p>    如果缓存层由于某些原因不能提供服务，所有的请求都会打到存储层呢刚，存储层的调用量会暴增，造成存储层也会级联宕机的情况。缓存雪崩（stampeding herd，奔逃的野牛）指的是缓存层宕掉后，流量就会像奔逃的野牛一样，打到后端存储。</p><p>    预防和解决缓存雪崩问题，可以从以下三个方面进行着手。</p><p>1）保证缓存层服务高可用性。</p><p>2）依赖隔离组件为后端限流并降级。（Java依赖隔离工具：Hystrix）</p><p>3）提前演练</p><h2 id=11-7-热点key重建优化>11.7 热点key重建优化</h2><p>    使用“缓存+过期时间”的策略既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足大部分需。但是如果同时出现以下2个问题，会对应用造成致命的伤害：</p><ul><li>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大</li><li>重建缓存不能再短时间完成，可能是一个复杂计算，例如复杂的SQL、多次IO、多个依赖等</li></ul><p>    要解决这个问题也不是很复杂，但是不能为了解决这个问题给系统带来更多的麻烦，所以需要制定如下目标：</p><ul><li>减少重建缓存的次数</li><li>数据尽可能一致</li><li>较少的潜在危险</li></ul><p>1、互斥锁（mutex key）</p><p>    此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。</p><p>2、永远不过期</p><p>    包括两层意思：</p><ul><li>没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。</li><li>从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</li></ul><table><thead><tr><th style=text-align:left>解决方案</th><th style=text-align:left>优点</th><th style=text-align:left>缺点</th></tr></thead><tbody><tr><td style=text-align:left>简单分布式锁</td><td style=text-align:left>1、思路简单<br>2、保证一致性</td><td style=text-align:left>1、代码复杂度增大<br>2、存在死锁的风险<br>3、存在线程池阻塞的风险</td></tr><tr><td style=text-align:left>“永远不过期”</td><td style=text-align:left>基本杜绝热点key问题</td><td style=text-align:left>1、不保证一致性<br>2、逻辑过期时间增加代码维护成本和内存成本</td></tr></tbody></table><h1 id=12-开发运维的-陷进>12 开发运维的“陷进”</h1><h2 id=12-1-linux配置优化>12.1 Linux配置优化</h2><h3 id=12-1-1-内存分配控制>12.1.1 内存分配控制</h3><p>1、vm.overcommit_memory</p><p>    overcommit：Linux操作系统对大部分申请内存的请求都回复yes，以便能运行更多的程序。因为申请内存后，并不会马上使用内存，这种技术叫做overcommit。</p><p>2、获取和设置</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>获取
</span></span><span style=display:flex><span><span style=color:#177500># cat /proc/sys/vm/overcommit_memory</span>
</span></span><span style=display:flex><span><span style=color:#1c01ce>0</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>设置
</span></span><span style=display:flex><span><span style=color:#177500># echo “vm.overcommit_memory=1” &gt;&gt; /etc/sysctl.conf</span>
</span></span><span style=display:flex><span>sysctl vm.overcommit_memory<span style=color:#000>=</span>1 
</span></span></code></pre></td></tr></table></div></div></div><p>3、最佳实践</p><ul><li>Redis设置合理的maxmemory，保证机器有20%~30%的闲置内存</li><li>集中化管理AOF重写和RDB的bgsave</li><li>设置vm.overcommit_memory=1，防止极端情况下会造成fork失败</li></ul><h3 id=12-1-2-swappiness>12.1.2 swappiness</h3><p>1、参数说明</p><p>    swap：当物理内存不足时，可以将一部分内存进行swap操作，swap空间由硬盘提供，对于需要高并发、高吞吐的应用来说，磁盘IO通常成为系统瓶颈。在Linux中，并不是要等到所有物理内存都是用完才会使用swap，系统参数swappiness会决定操作系统使用swap的倾向程度。swappiness的取值范围是0~100，swappiness的值越大，说明操作系统可能使用swap的概率越高，swappiness值越低，表示操作系统更加倾向于使用物理内存。swap的默认值是60。</p><p>    swappiness重要值策略说明：</p><table><thead><tr><th style=text-align:left>值</th><th style=text-align:left>策略</th></tr></thead><tbody><tr><td style=text-align:left>0</td><td style=text-align:left>Linux3.5以及以上：宁愿用OOM killer也不用swap</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>Linux3.4以及以上：宁愿用swap也不用OOM killer</td></tr><tr><td style=text-align:left>60</td><td style=text-align:left>默认值</td></tr><tr><td style=text-align:left>100</td><td style=text-align:left>操作系统会主动地使用swap</td></tr></tbody></table><p>OOM(Out of Memory) killer机制是指Linux操作系统发现可用内存不足时，强制杀死一些用户进程（非内核进程），来保证系统有足够的可用内存进行分配。</p><p>2、设置方法</p><p>echo {bestvalue} > /proc/sys/vm/swappiness    # 设置操作     # 重启系统后就会失效</p><p>echo vm.swappiness={bestvalue} >> /etc/sysctl.conf    #追加操作</p><p>3、如何监控swap</p><p>（1）查看swap的总体情况</p><p>    free命令查询操作系统的内存使用情况</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>free -m<span style=color:#000>(</span>以兆为单位<span style=color:#000>)</span> 
</span></span></code></pre></td></tr></table></div></div></div><p>（2）实时查看swap的使用</p><p>    vmstat命令查询系统的相关性能指标，其中包括负载、CPU、内存、swap、IO的相关属性。但其中和swap有关的指标是si和so，分别代表操作系统的swap in和swap out。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>vmstat 1<span style=color:#000>(</span>每隔1秒输出<span style=color:#000>)</span> 
</span></span></code></pre></td></tr></table></div></div></div><p>（3）查看指定进程的swap使用情况</p><p>    /proc/{pid}目录是存储指定进程的相关信息，其中/proc/{pid}/smaps记录了当前进程所对应的内存映像信息，这个信息对于查询指定进程的swap使用情况很有帮助。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 通过info server 获取Redis的进程号process_id</span>
</span></span><span style=display:flex><span><span style=color:#177500># redis-cli -h ip -p port info server | grep process_id</span>
</span></span><span style=display:flex><span>process_id:986
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>cat /proc/986/smaps  <span style=color:#177500># 会输出多个内存块信息</span>
</span></span><span style=display:flex><span>cat /proc/986/smaps | grep Swap    <span style=color:#177500># 单独输出每个内存块镜像信息中这个进程用到的swap量 </span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=12-1-3-thp>12.1.3 THP</h3><p>    Transparent Huge Pages（THP）：Linux kernel在2.6.38内核增加了THP特性，支持大内存页（2MB）分配，默认开启。当开启时可以加快fork子进程的速度，但fork操作之后，每个内存页从原来4KB变为2MB，会大幅增加重写期间父进程内存消耗。同时每次写命令引起的复制内存页单位放大了512倍，会拖慢写操作的执行时间，导致大量写操作慢查询，例如简单的incr命令也会出现在慢查询中。因此Redis日志中建议将此特性进行禁用，方法如下：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a90d91>echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled <span style=color:#177500># 注意有的OS路径不一致 </span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=12-1-4-oom-killer>12.1.4 OOM killer</h3><p>    OOM killer会在可用内存不足时选择性地杀掉用户进程。运行规则：OOM killer进程会为每个用户进程设置一个权值，这个权值越高，被“下手”的概率就越高，反之概率越低。每个进程的权值存放在/proc/{progress_id}/oom_score中，这个值受/proc/{progress_id}/oom_adj的控制，oom_adj在不同的Linux版本中最小值不同。当oom_adj设置为最小值时，该进程将不会被OOM killer杀掉，设置方法如下。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a90d91>echo</span> <span style=color:#000>{</span>value<span style=color:#000>}</span> &gt; /proc/<span style=color:#c41a16>${</span><span style=color:#000>process_id</span><span style=color:#c41a16>}</span>/oom_adj 
</span></span></code></pre></td></tr></table></div></div></div><p>    对于Redis所在的服务器来说，可以将所有Redis的oom_adj设置为最低值或者稍小的值，降低被OOM killer杀掉的概率。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a90d91>for</span> redis_pid in <span style=color:#a90d91>$(</span>pgrep -f “redis-server”<span style=color:#a90d91>)</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>do</span> 
</span></span><span style=display:flex><span>    <span style=color:#a90d91>echo</span> -17 &gt; /proc/<span style=color:#c41a16>${</span><span style=color:#000>redis_pid</span><span style=color:#c41a16>}</span>/oom_adj
</span></span><span style=display:flex><span><span style=color:#a90d91>done</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=12-1-5-使用ntp>12.1.5 使用NTP</h3><p>    NTP（Network Time Protocol，网络时间协议）是一种保证不同机器时钟一致性的服务。</p><p>例如每小时的同步1次NTP服务：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#1c01ce>0</span> **** /usr/sbin/ntpdate ntp.xx.com &gt; /dev/null 2&gt;&amp;1 
</span></span></code></pre></td></tr></table></div></div></div><h3 id=12-1-6-ulimit>12.1.6 ulimit</h3><p>    在Linux中，可以通过ulimit查看和设置系统当前用户进程的资源数。其中ulimit -a命令包含的open files参数，是单个用户同时打开的最大文件个数：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># ulimit -a </span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=12-1-7-tcp-backlog>12.1.7 TCP backlog</h3><p>    Redis默认的tcp-backlog值为511，可以通过修改配置tcp-backlog进行调整。</p><p>查看方法：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># cat /proc/sys/net/core/somaxconn</span>
</span></span><span style=display:flex><span><span style=color:#1c01ce>128</span>
</span></span></code></pre></td></tr></table></div></div></div><p>修改方法：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a90d91>echo</span> <span style=color:#1c01ce>511</span> &gt; /proc/sys/net/core/somaxconn 
</span></span></code></pre></td></tr></table></div></div></div></p><h2 id=12-2-flushall-flushdb误操作>12.2 flushall/flushdb误操作</h2><p>    Redis的flushall/flushdb命令可以做数据清除。</p><h3 id=12-2-1-缓存与存储>12.2.1 缓存与存储</h3><p>    Redis可以做缓存或者存储，被误操作flush后，使用策略有所不同。</p><h3 id=12-2-2-借助aof机制恢复>12.2.2 借助AOF机制恢复</h3><p>    执行flush之后，提示如下所示：</p><p>（1）appendonly no：对AOF持久化没有任何影响，因为不存在AOF文件</p><p>（2）appendonly yes：只不过在AOF文件中追加了一条记录。如：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>*1
</span></span><span style=display:flex><span><span style=color:#000>$8</span>
</span></span><span style=display:flex><span>flushall 
</span></span></code></pre></td></tr></table></div></div></div><p>虽然Redis中的数据被清除掉了，但是AOF文件还保存着flush操作之前完整的数据，对恢复数据还是很有帮助的，但注意问题如下：</p><p>1）如果发生了AOF重写，Redis遍历所有数据库重新生成AOF文件，并会覆盖之前的AOF文件。所有如果AOF重写发生了，也就意味着之前的数据就丢掉了，那么利用AOF文件来恢复的办法就失效了。所以当误操作后，需要考虑如下两件事：</p><ul><li>调大AOF重写参数auto-aof-rewrite-percentage和auto-aof-rewrite-min-size，让Redis不能产生AOF自动重写。</li><li>拒绝手动bgrewriteaof</li></ul><p>2）如果要用AOF文件进行数据恢复，那么必须要将AOF文件中的flushall相关操作去掉，为了更加安全，可以在去掉之后使用redis-check-aof这个工具去检验和修复一下AOF文件，确保AOF文件格式正确，保证数据恢复正常。</p><h3 id=12-2-3-rdb有什么变化>12.2.3 RDB有什么变化</h3><p>    Redis执行了flushall操作后，RDB持久化文件会受到什么影响呢？</p><p>1）如果没有开启RDB的自动策略，也就是配置文件中没有如下类似配置：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>save 900 1
</span></span><span style=display:flex><span>save 300 10
</span></span><span style=display:flex><span>save 60 10000 
</span></span></code></pre></td></tr></table></div></div></div><p>那么除非手动执行过save、bgsave或者发生了主从的全量复制，否则RDB文件也会保存flush操作之前的数据，可以作为恢复数据的数据源。注意问题如下：</p><ul><li>防止手动执行save、bgsave，如果此时执行save、bgsave，新的RDB文件就不会包含flush操作之前的数据，被老的RDB文件进行覆盖。</li><li>RDB文件中的数据可能没有AOF实时性高，也就是说，RDB文件很可能很久之前主从全量复制生成的，或者之前用save、bgsave备份的。</li></ul><p>2）如果开启了RDB的自动策略，由于flush涉及键值数量较多，RDB文件会被清除，意味着使用RDB恢复基本无望。</p><p>综上，如果AOF已经开启，那么用AOF来恢复比较合理，如果AOF关闭，那么RDB虽然数据不是很实时，但是也能恢复部分数据，完全取决于RDB是什么时候备份的。（RDB的恢复速度比AOF快很多，但总体来说对于flush操作之后不是最好的恢复数据源）</p><h3 id=12-2-4-从节点有什么变化>12.2.4 从节点有什么变化</h3><p>    Redis从节点同步了主节点的flush命令，所以从节点的数据也是被清除了，从节点的RDB与AOF的变化与主节点没有任何区别。</p><h3 id=12-2-5-快速恢复数据>12.2.5 快速恢复数据</h3><p>    下面使用AOF作为数据源进行恢复演练</p><p>    1）防止AOF重写。快速修改Redis主从的auto-aof-rewrite-percentage和auto-aof-rewrite-min-size变为一个很大的值，从而防止了AOF重写的发生。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>config <span style=color:#a90d91>set</span> auto-aof-rewrite-percentage <span style=color:#1c01ce>1000</span>
</span></span><span style=display:flex><span>config <span style=color:#a90d91>set</span> auto-aof-rewrite-min-size <span style=color:#1c01ce>10000000000</span> <span style=color:#000>(</span>11个0，大就完事了） 
</span></span></code></pre></td></tr></table></div></div></div><p>    2）去掉主从AOF文件中的flush相关内容</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>*1
</span></span><span style=display:flex><span>&amp;<span style=color:#1c01ce>8</span>
</span></span><span style=display:flex><span>flushall 
</span></span></code></pre></td></tr></table></div></div></div><p>    3）重启Redis主节点服务器，恢复数据</p><h2 id=12-3-安全的redis>12.3 安全的Redis</h2><p>    被攻击Redis的特点：</p><ul><li>Redis所在机器有外网IP</li><li>Redis以默认端口6379为启动端口，并且是对外网开放的</li><li>Redis是以root用户启动的</li><li>Redis没有设置密码</li><li>Redis的bind设置为0.0.0.0或者“”</li></ul><h3 id=12-3-1-redis密码机制>12.3.1 Redis密码机制</h3><h3 id=12-3-2-伪装危险命令>12.3.2 伪装危险命令</h3><p>1、引入rename-command</p><p>2、没有免费的午餐</p><ul><li>管理员有一定的开发和维护成本，都需要使用重命名之后的命令</li><li>rename-command配置不支持config set，所以在启动前一定要确定哪些命令需要使用rename-command</li><li>如果AOF和RDB文件包含了rename-command之前的命令，Redis将无法启动，因为此时它识别不了rename-command之前的命令</li><li>Redis源码中一些命令是写死的，rename-command可能造成Redis无法正常工作，例如config命令。</li></ul><p>3、最佳实践</p><ul><li>对于危险的命令，无论内网外网，一律使用rename-command配置</li><li>建议第一次配置Redis时，就应该配置rename-command，因为rename-command不支持config set</li><li>如果涉及主从关系，一定要保持主从节点配置的一致性，否则存在主从数据不一致的可能性</li></ul><h3 id=12-3-3-防火墙>12.3.3 防火墙</h3><p>    限制输入和输出的IP或者IP范围、端口或者端口范围。（必杀技）</p><h3 id=12-3-4-bind>12.3.4 bind</h3><p>1、对于bind的错误认识</p><p>    bind指定的是Redis和哪个网卡进行绑定，和客户端是什么网段没有关系。</p><p>2、建议</p><ul><li>如果机器有外网IP，但部署的Redis是给内部使用，建议去掉外网网卡或者使用bind配置限制流量从外网进入</li><li>如果客户端和Redis部署在一台机器上，可以使用回环地址</li><li>bind配置不支持config set，所以尽可能在第一次启动前配置好</li></ul><h3 id=12-3-5-定期备份数据>12.3.5 定期备份数据</h3><h3 id=12-3-6-不适用默认端口>12.3.6 不适用默认端口</h3><p>    Redis的默认端口是6379</p><h3 id=12-3-7-使用非root用户启动>12.3.7 使用非root用户启动</h3><h2 id=12-4-处理bigkey>12.4 处理bigkey</h2><h3 id=12-4-1-bigkey的危害>12.4.1 bigkey的危害</h3><ul><li>内存空间不均匀</li><li>超时阻塞</li><li>网络拥塞</li></ul><h3 id=12-4-2-如何发现>12.4.2 如何发现</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>redis-cli —bigkeys
</span></span><span style=display:flex><span>debug object key
</span></span><span style=display:flex><span>strlen key 
</span></span></code></pre></td></tr></table></div></div></div><p>在实际生产环境中发现bigkey的两种方式如下：</p><ul><li>被动收集（开发人员日志key）</li><li>主动监测</li></ul><h3 id=12-4-3-如何删除>12.4.3 如何删除</h3><h2 id=12-5-寻找热点key>12.5 寻找热点key</h2><p>1、客户端</p><p>    使用map&lt;key, count>记录，如在connection类中的sendCommand方法是所有命令执行的枢纽</p><ul><li>无法预知key的个数</li><li>对于客户端代码有侵入</li><li>只能了解当前客户端的热点key，无法实现规模化运维统计</li></ul><p>    除了使用本地字典计数外，还可以使用其他存储来完成异步计数</p><p>2、代理端</p><p>3、Redis代理端</p><p>4、机器</p><p>    可以通过对机器上所有Redis端口的TCP数据包进行抓取完成热点key的统计</p><p>寻找热点key的四种方案</p><table><thead><tr><th style=text-align:left>方案</th><th style=text-align:left>优点</th><th style=text-align:left>缺点</th></tr></thead><tbody><tr><td style=text-align:left>客户端</td><td style=text-align:left>实现简单</td><td style=text-align:left>1、内存泄露隐患<br>2、维护成本高<br>3、只能统计单个客户端</td></tr><tr><td style=text-align:left>代理</td><td style=text-align:left>代理是客户端和服务端的桥梁，实现最方便最系统</td><td style=text-align:left>增加代理端的开发部署成本</td></tr><tr><td style=text-align:left>服务端</td><td style=text-align:left>实现简单</td><td style=text-align:left>1、Monitor本身的使用成本和危害，只能短时间使用<br>2、只能统计单个Redis节点</td></tr><tr><td style=text-align:left>机器</td><td style=text-align:left>对于客户端和服务端无侵入和影响</td><td style=text-align:left>需要专业的运维团队开发，并且增加了机器的部署成本</td></tr></tbody></table><p>13 Redis监控运维云平台CacheCloud</p><p>13.1 CacheCloud是什么</p><p>13.2 快速部署</p><p>13.3 机器部署</p><p>13.4 接入应用</p><p>13.5 用户功能</p><p>13.6 运维功能</p><p>13.7 客户端上报</p><p>2020年01月11日（周六）完</p></div><div class=td-content style=page-break-before:always><h1 id=pg-dbad5e56ec419875a875e1ae622d097c>4 - TiDB</h1><h1 id=introduction>Introduction</h1><p>TiDB</p></div><div class=td-content><h1 id=pg-8efec6d6843be08756a1666c851838b7>4.1 - TiDB初探</h1><h1 id=tidb简介>TiDB简介</h1><p>TiDB 是一个开源的、兼容 MySQL、可以横向扩展的、可以完美替代分库分表的原生分布式关系型数据库，且支持 HTAP。2015 年在 GitHub 开源立项。</p><p><img src=../imgs/20230211_tidb_base_1.png alt=20230211_tidb_base_1.png></p><h1 id=tidb架构>TiDB架构</h1><h2 id=主要模块>主要模块</h2><p>TiDB 架构主要分为四个模块：</p><ul><li>TiDB Server</li><li>TiKV Server</li><li>TiSpark</li><li>PD（Placement Drive）Server
TiKV Server：负责数据存储，一个分布式的提供事务的Key-Value存储引擎，维护多副本（默认三副本），支持高可用和自动故障转移。</li></ul><p>PD Server：整个 TiDB 集群的元信息管理模块，负责存储每个 TiKV 节点实时的数据分布情况和集群的整体拓扑结构，提供 TiDB Dashboard 管控界面，并未分布式事务分配事务 ID。还会根据 TiKV 节点实时上报数据分布状态，下发数据调度命令给具体的 TiKV 节点（如热点 region 调度），可以说是整个集群的“大脑”。</p><p>TiDB Server：SQL 层，对外暴露 MySQL 协议连接 endpoint，负责接受客户端的连接，执行 SQL 解析和优化，最终生成分布式执行计划，也支持所有 SQL 算子实现。TiDB 层本身无状态，内部可提供多个实例，通过负载均衡组件（如 LVS、HAProxy、F5）对外提供统一的接入。</p><p>TiFlash：用来做重型 IP 的 SQL 或者作业查询，做一些分布式计算。</p><h2 id=整体架构>整体架构</h2><p><img src=../imgs/20230211_tidb_base_2.png alt=20230211_tidb_base_2.png></p><h1 id=tikv>TiKV</h1><h2 id=概述>概述</h2><p>本文依次从下向上按照数据结构、表模型、分片策略、复制、多版本控制、分布式事务等维度的介绍 TiKV 的选择与平衡。</p><h2 id=数据结构>数据结构</h2><p>传统的 OLTP 系统中，写操作是最昂贵的成本。</p><ul><li>传统的 B-tree 索引至少要写两次数据：预写日志（WAL）和树本身。</li><li>B-tree是一个严格平衡的数据结构，整体设计对读友好。数据写入触发的 B-tree 分裂和平衡的成本非常高，对写相对不够友好。</li><li>传统的主从架构中，集群的写入容量无法扩展，集群的写入容量完全由主库的机器配置决定，扩容只能通过非常昂贵的集群拆分，即分库来实现。
LSM-tree 结构本质上是一个用空间置换写入延迟，用顺序写入替换随机写入的数据结构。</li></ul><p>TiKV节点选择了基于 LSM-tree 的 RocksDB 引擎。其支持很多特性：</p><ul><li>批量写入（事务）</li><li>无锁的快照读（数据副本迁移）</li></ul><h2 id=数据副本与复制>数据副本与复制</h2><p>数据冗余决定了系统的可用性，如何选择复制协议尤为重要。</p><p>Raft 是一种用于替代 Paxos 的共识算法。相比 Paxos，Raft 的目标是提供更清晰的逻辑分工使得算法本身能被更好地理解，同时它的安全性更好，并能提供一些额外的特性。</p><p>Raft 算法通过先选出 leader 节点、有序日志等方式简化流程、提高效率，并通过约束减少了不确定性的状态空间。相对 Paxos 它的逻辑更加清晰、容易理解以及工程化实现。</p><p>所以利用 Raft 可以基于 RocksDB 构建一个多副本的集群。</p><h2 id=分片>分片</h2><p>数据分片是分布式数据里的关键设计，从底层技术来看实现扩展就是要做分片。分片分为：</p><ul><li><p>预先分片（静态分片）</p></li><li><p>自动分片（动态分片）
创传统的分库分表或者分区的方案都是预先分片。这种分片只解决了表的容量问题，没有解决更细粒度的弹性问题。所以，第一要实现扩展要使用自动分片的算法，其次分片需要一个维度和算法。常见的分片算法有：</p></li><li><p>哈希（hash）</p></li><li><p>范围（range）</p></li><li><p>列举（list）
TiKV 使用了 Range 算法，原因如下：</p></li><li><p>更高效的扫描数据记录</p></li></ul><blockquote><p>支持范围查询，如 >= 的查询。Range 分片可以更高效的扫描数据行数。而使用另外两种算法，由于数据被打散，扫描操作的 I/O 成本会更跳跃、开销会更大。</p></blockquote><ul><li>简单实现自动完成分裂与合并</li></ul><blockquote><p>对弹性本身比较重要</p></blockquote><ul><li>弹性优先，分片可以自由调度
Range 分片的问题是热点分片问题（最新的分片往往最热）。一般通过再分片来解决热点问题。</li></ul><h3 id=分离与扩展>分离与扩展</h3><p>当 Region 大小超过一定限制（默认144MB），TiKV 会将它分裂为两个或更多个 Region，以保证各个Region大小大致接近，这样有利于 PD（Placement Driver）进行调度决策。反之亦然，两个相邻的比较小的Region会自动合并。</p><h3 id=调度机制>调度机制</h3><ul><li>分片数量、Leader、吞吐量自动平衡</li><li>自定义调度接口<ul><li>支持跨 IDC 表级同时写入
<img src=../imgs/20230211_tidb_base_3.png alt=20230211_tidb_base_3.png></li></ul></li></ul><h3 id=tikv整体架构>TiKV整体架构</h3><p><img src=../imgs/20230211_tidb_base_4.png alt=20230211_tidb_base_4.png></p><h2 id=多版本控制-mvcc>多版本控制(MVCC)</h2><p>TiKV 的 MVCC 实现是通过在 Key 后面添加版本号来实现。</p><h3 id=分布式事务模型>分布式事务模型</h3><ul><li>去中心化的两阶段提交<ul><li>每个 TiKV 节点分配单独区域存放锁信息（CF lock）</li><li>通过 PD 全局授时（TSO）</li><li>~4M timestamps 每秒</li></ul></li><li>Google Percolator 事务模型</li><li>TiKV 支持完整事务 KV API</li><li>默认乐观事务模型<ul><li>支持悲观事务模型（3.0+版本）</li></ul></li><li>默认隔离级别 Snapshot Isolation（SI，和RR接近，没有幻读）
传统的两阶段提交需要一个事务管理器 GTM，其往往会成为整个集群的性能瓶颈，而 TiKV 采取了一个去中心化的两阶段提交。在每个 TiKV 存储节点上，会单独分配一个存储锁信息的地方。TiKV 的锁是基于列簇，锁信息称为 CF Lock。通过该机制将锁信息放在不同的存储节点，而不是像传统的数据库将锁信息放在行上的方式。然后通过 PD 全局授时。</li></ul><h3 id=协作处理器-coprocessor>协作处理器（Coprocessor）</h3><p><img src=../imgs/20230211_tidb_base_5.png alt=20230211_tidb_base_5.png></p><p>整体结构：</p><p><img src=../imgs/20230211_tidb_base_6.png alt=20230211_tidb_base_6.png></p><h1 id=sql引擎>SQL引擎</h1><h2 id=基于kv实现逻辑表>基于KV实现逻辑表</h2><p><img src=../imgs/20230211_tidb_base_7.png alt=20230211_tidb_base_7.png></p><p>对于已经有的<strong>全局有序</strong>的分布式的 Key-Value 的存储引擎。</p><ul><li>对于快速获取一个数据，找到具体的Key（主键），能够通过 TiKV 提供的一个 Seek 方法快速定位这一行数据所在的位置，找到 Value（其它列的数据）。</li><li>对于扫描全表的需求，如果能映射为一个 Key 的范围，可以从 StartKey 扫描到 EndKey，通过该方式获取全表数据。类似 Index 的思路。
TiKV的实现：</li></ul><p>TiKV对于每个表分配一个 TableID，每个索引分配一个 IndexID，每行数据分配一个 RowID，如果表示有整数的 Primary Key（主键），可以把 RowID + IndexID 简单看做 Key，Value 看成所有的列按照等位偏移的方式进行 connect 进行连接。数据查询过程中通过等位偏移量进行对 Value 进行反解析，然后再对应与 Schema 的元信息进行列信息映射。</p><h3 id=基于kv的二级索引设计>基于KV的二级索引设计</h3><p>TiKV 中，二级索引也是一个全局有序的 Key-Value map，简单理解为 Key 就是索引的列信息，Value 是原表的 Primary key 主键，通过该主键在原表的 Key-Value map 进行再一次扫描找到 Value，然后再按照等位偏移量进行列信息解析。该过程和传统数据库 B-tree 的回表逻辑类似。</p><p><img src=../imgs/20230211_tidb_base_8.png alt=20230211_tidb_base_8.png></p><h3 id=sql引擎过程>SQL引擎过程</h3><p>SQL 引擎层：</p><p><img src=../imgs/20230211_tidb_base_9.png alt=20230211_tidb_base_9.png></p><p>SQL 引擎很重要的模块就是优化器，负责从很多执行计划中找到最优的执行计划。简单理解为车子出行中的交通工具如：数据寻址或者数据计算的各种算子，比如常见的 hash join、Index reader、Table Scan 等。路况：表、索引、列的数据分布统计信息等。</p><p>除了优化器，还有如下必须的组成部分，如 SQL 引擎过程：</p><ol><li>SQL<ol><li>词法解析</li><li>语法解析</li><li>语义解析</li><li>权限控制等</li></ol></li><li>AST（抽象语法树）<ol><li>将 SQL 从文本解析成一个结构化的数据，生成 AST 文件</li></ol></li><li>Logical Plan<ol><li>SQL 逻辑部分将各种 SQL 等价改写以及优化，如将子查询改成表关联、各种不必要的信息裁剪（列裁剪、分区裁剪、left join 裁剪等）</li></ol></li><li>Optimized Logical Plan<ol><li>物理优化会基于统计信息与成本进行生产执行计划</li></ol></li></ol><blockquote><p>SQL优化中最重要、优化空间最大的部分</p></blockquote><ol start=5><li>执行器<ol><li>执行引擎与根据优化器定下来的执行路径进行相应的数据的寻址、数据的计算
<img src=../imgs/20230211_tidb_base_10.png alt=20230211_tidb_base_10.png></li></ol></li></ol><h2 id=关键算子>关键算子</h2><h3 id=基于成本优化器>基于成本优化器</h3><ul><li>Power CBO Optimizer<ul><li>Hash join、Sort merge、Index join、Apply（Nested loop）</li><li>table_reader、table_scan、index_reader、index_scan、index_lookup</li><li>Steam aggregation、Hash agg</li></ul></li><li>Cost<ul><li>Cost(p) = N(p)*FN+M(p)*FM+C(p)*FC, N stands for the network cost, M stands for the memory cost and C stands for the CPU cost.</li></ul></li><li>task ( handle on TiDB or TiKV )<ul><li>corp、root
<img src=../imgs/20230211_tidb_base_11.png alt=20230211_tidb_base_11.png></li></ul></li></ul><h3 id=分布式sql引擎主要优化策略>分布式SQL引擎主要优化策略</h3><p>最大程度让数据在分布式存储层尽快的完成过滤以及计算，即最大下推策略（Push Down）。</p><p>用户表在不同存储节点的分片进行预计算，完成本地的数据过滤以及统计，然后再将本地存储节点的临时结果、中间结果上报到 Server 层进行再一次 SUM 返回最终结果，利用了分布式多节点的计算能力。而不是上传到 Server 端进行统一的过滤及计算，没有利用 TiKV 的并行能力。</p><p><img src=../imgs/20230211_tidb_base_12.png alt=20230211_tidb_base_12.png></p><h3 id=关键算子分布式化>关键算子分布式化</h3><p>TiDB-Server 中的 Hash Join 不管是在数据寻址，还是在内层进行分批匹配，都可以通过并行与分批的处理。这也是在大表 Join 的场景，比传统的 MySQL 的 join 的场景要快很多的原因。</p><p><img src=../imgs/20230211_tidb_base_13.png alt=20230211_tidb_base_13.png></p><h3 id=online-ddl算法>Online DDL算法</h3><ul><li>TiDB 没有分表概念，整个 DDL 完成过程非常快速<ol><li>Schema（表结构）只存储一份，新增字段时，新增数据按照新的Schema进行存储，老数据只需要在读到（默认值）和变更时，才需要进行新 Schema 的重组。</li></ol></li><li>保证多个计算节点的Schema信息一致：根据 Google 的 F1 论文算法，将 Schema 变更异步分成了多个版本，把 DDL 过程分成 Public、Delete-only、Write-only 等几个相邻状态，每个相邻状态在多节点之间互相同步和一致，最终完成完整的 DDL。
<img src=../imgs/20230211_tidb_base_14.png alt=20230211_tidb_base_14.png></li></ul><h2 id=tidb-server>TiDB-Server</h2><p>TiDB-Server 是一个对等、无状态的，可横向扩展，支持多点写入，直接承接用户 SQL 入口。</p><p>连接到 TiDB-Server：</p><p><img src=../imgs/20230211_tidb_base_15.png alt=20230211_tidb_base_15.png></p><p>从进程角度看 TiDB-Server</p><p><img src=../imgs/20230211_tidb_base_16.png alt=20230211_tidb_base_16.png></p><p>从内部结构看 TiDB-Server</p><p><img src=../imgs/20230211_tidb_base_17.png alt=20230211_tidb_base_17.png></p><h3 id=其它功能>其它功能</h3><p>前台功能：</p><ul><li><p>管理链接和账号权限管理</p></li><li><p>MySQL 协议编码解码</p></li><li><p>独立的 SQL 执行</p></li><li><p>库表元信息以及系统变量
后台功能：</p></li><li><p>垃圾回收（GC）</p></li><li><p>执行 DDL</p></li><li><p>统计信息管理</p></li><li><p>SQL 优化器与执行器</p></li></ul><h2 id=tidb与tikv关系>TiDB与TiKV关系</h2><p><img src=../imgs/20230211_tidb_base_18.png alt=20230211_tidb_base_18.png></p><h1 id=分布式htap数据库>分布式HTAP数据库</h1><ul><li>TiDB 是一款支撑 HTAP 数据服务的数据库</li><li>理解 TiDB 在 HTAP 场景下的体系架构与产品迭代</li><li>了解 HTAP 应用场景</li></ul><h2 id=hatp-发展的必然性>HATP 发展的必然性</h2><p>HTAP 数据库需要同时支持 OLTP 和 OLAP 场景。基于创建的计算存储框架，在同一份数据上保证了事物的同时又支持实时分析，省去了费时的 ETL 过程。</p><p>在线分析事务（OLAP）相关技术：并行计算、物化视图、列存、Partition、Bitmap、索引等。</p><p>数据技术驱动的两个关键性因素：</p><ul><li>数据容量</li><li>业务创建导致的场景多样性
在数据容量爆发性的前提下，OLTP 与 OLTP 技术开始分道扬镳，OLTP 业务更加追求吞吐的高并发、低延迟（小汽车：灵活、快速），OLAP 业务更加关注整个数据的吞吐量（大轮船：装载量和吞吐量）。因此形成了狭义的数据和大数据两个方向。</li></ul><p><img src=../imgs/20230211_tidb_base_19.png alt=20230211_tidb_base_19.png></p><p>而分布式技术的发展，逐步解决了数据容量爆炸的问题，分布式关系型数据库，同时满足了 OLTP 的需求，也解决了数据容量的问题。在此基础上，很多传统的 OLAP 技术可以在此架构上进行再融合，实现了更大数据容量的混合数据库，也就是 HTAP。同时业务创新的场景多样性，在使用层面开始模糊了 OLTP 和 OLAP 的划分，比如业财一体、后台运营、客服后台、大屏展示、报表系统。从该角度，HTAP 又是一个数据服务的需求，其核心诉求是数据服务的统一。</p><h2 id=tidb用于数据中台>TiDB用于数据中台</h2><ul><li>海量存储允许多数据源汇聚，数据实时同步</li><li>支持标准SQL，多表关联快速出结果</li><li>透明多业务模块、支持分表聚合后可以任务维度查询</li><li>TiDB 最大下推机制、以及并行 hash join 等算子，决定 TiDB 在表关联上的优势
这些特性适用于后台运营系统、财务报表、大屏展现、用户画像等数据中台的一些业务。</li></ul><h2 id=引入spark缓解数据中台算力>引入spark缓解数据中台算力</h2><p>TiDB-Server 虽然有上面说到的诸多特性，但其还是主要面向 OLTP 的业务，对于 OLAP 中间结果过大的查询还会造成内存使用过量，甚至 OOM 的问题。为了满足用户的需求，借助社区的力量，引入了大数据技术 Spark 的生态， 让 Spark 识别 TiKV 的数据格式、统计信息、索引、执行器，最终构建了一个能跑在 TiKV 上的 Spark 的计算引擎，并封装为 TiSpark。</p><p><img src=../imgs/20230211_tidb_base_20.png alt=20230211_tidb_base_20.png>
进而实现了一个分布式的技术平台，在面对大批量数据的报表和重量级的 Adhoc 里提供了一个可行的方案。</p><p>Spark 只能提供低并发的重量级查询，在应用场景，很多中小规模的轻量 AP 查询，也需要高并发、相对技术低延迟计数能力，该场景下，Spark 的技术模型重，资源消耗高的缺点就会暴露。</p><h2 id=物理隔离是最好的资源隔离>物理隔离是最好的资源隔离</h2><p>OLTP 和 OLAP 的资源隔离很难通过软件层面彻底解决好，从数据库资源隔离的角度看，依次是数据库软件层、副本调度、容器、虚拟机、物理机等，越接近物理机的隔离性会越好。</p><p>在传统的主从架构下，读写分离其实也是资源隔离的问题。隔离就需要有一个单独的副本进行 AP 的查询。列存天然对 OLAP 查询类友好，所以选择将这个副本放到一个列式存储引擎上。列式存储引擎需要按照列的单位进行存储，每个列是一个独立的对象。这种引擎对批量写入友好，最大的挑战在于对实时跟新不友好。</p><p><img src=../imgs/20230211_tidb_base_21.png alt=20230211_tidb_base_21.png></p><p>借助列式引擎的思想，引入了 Delta tree 的方法，最终实现了一个支持准实时更新的列式引擎 TiFlash。</p><p>TiFlash 以 Raft Learner 方式接入 Multi-Raft 组，使用异步方式传输数据，对 TiKV 产生非常小的负担。当数据同步到 TiFlash 时，会被从行格式拆解为列格式。</p><blockquote><p>一般可以采用 binlog 方式，为了高效采用 raft 复制。</p></blockquote><h2 id=计算统一>计算统一</h2><p>构建好一个支持标准 SQL 的 TiDB-Server，将列存的信息暴露给 TiDB-Server，设计成一个新的统计信息规则——CBO cost 模型。让 TiDB-Server 的优化器可以通过新的 cost 模型来自由地选择数据寻址的方式，形成一个既包括了行式的存储和列式存储的统一的执行计划。</p><p>比如：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>select</span> <span style=color:#a90d91>avg</span>(<span style=color:#000>s</span>.<span style=color:#000>price</span>) <span style=color:#a90d91>from</span> <span style=color:#000>prod</span> <span style=color:#000>p</span>, <span style=color:#000>sales</span> <span style=color:#000>s</span> <span style=color:#a90d91>where</span> <span style=color:#000>p</span>.<span style=color:#000>pid</span> <span style=color:#000>=</span> <span style=color:#000>s</span>.<span style=color:#000>pid</span> <span style=color:#a90d91>and</span> <span style=color:#000>p</span>.<span style=color:#000>batch_id</span> <span style=color:#000>=</span> <span style=color:#c41a16>&#39;A1234&#39;</span>
</span></span></code></pre></td></tr></table></div></div></div><p>该语句典型的有表关联、表过滤、聚合等操作。
TiDB-Server 会根据数据统计期评估，最终只需要计算 sales 表中的 price 列的平均值，没有必要读取其他列的信息，同时因为在 batch_id 列上有二级索引，最优的方式可能是通过二级索引进行数据过滤，过滤完的数据再去 TiSpark 进行寻址，然后并在列存里进行读取和聚合。这样既节省了 IO，又降低了网络传输的带宽。整个 SQL 一部分是通过了行存进行过滤，一部分通过列存进行了预聚合，通过优化器串联在一起。</p><h2 id=mmp引擎>MMP引擎</h2><p>MMP引擎也就是并行计算。MMP架构是将任务并行地分散到多个服务器和节点上，在每个节点上，计算完成后，将各自部分的结果汇聚到一起得到结果。</p><p><strong>如何实现 join 下推</strong></p><p>如果要让一个 join 多个节点并行计算，需要将 join 的两个表的分片在节点的分布尽量一致，不一致需要通过网络将分片临时拷贝为一份临时数据进行 join 和计算，该过程就是 shuffle。MMP 计算模型本质上是通过网络与存储成本来置换计算资源。</p><p><img src=../imgs/20230211_tidb_base_22.png alt=20230211_tidb_base_22.png></p><p>如果启动 MMP 计算，首先在各个 TiFlash 节点将多表关联的结果进行数据分布一致，即上图中 TiFlash 上的红色箭头。接下来每个 TiFlash 节点上面的 MPP Worker 负责将表 Join 在多个节点的并行进行计算，最终将每个节点的临时结果返回到 TiDB-Server 进行再计算。</p><h2 id=htap下一步探索>HTAP下一步探索</h2><ul><li>分布式数据库在大数据规模下提供 HTAP 的基础</li><li>TiDB-Server 最大程度下推算法与 Hash Join 关键算子提供基础 AP 能力</li><li>借助生态，让 Spark 运行在 TiKV 之上</li><li>行列混合引擎，列式引擎提供实时写入能力</li><li>行列引擎采取 Raft-Base replication，解决数据同步效率</li><li>TiDB-Server 统一技术服务</li><li>MPP 解决技术节点的扩展性与并行计算
TiDB HTAP 的发展路径中既有产品内嵌功能，又有生态的数据连同，这是两套工程化的思路。</li></ul><p>HTAP 会逐步转化为是<strong>数据服务统一</strong>的代名词：</p><ul><li>产品内嵌功能的迭代，由一些具体产品完成 HTAP</li><li>整合多个技术栈与产品，并进行数据的连通，形成服务的 HTAP
过去一段时间，OLAP的场景基本基于数仓，流计算的发展将数仓分了几个阶段，最早的批处理，即 ETL 的离线数仓；批、流结合的 Lambda 架构；流计算为主的 Kappa 架构。在此基础上又可以和 OLTP 技术进行融合，如分区、列式存储、并行计算等。</li></ul><p>流计算在复杂计算中的天然限制可以在分布式 HTAP 中得到解决。流计算的实时计算能力为不同的数据技术栈，以产品提供了丰富多样的数据连同能力。流计算加基于分布式关系数据的 HTAP 产品，将形成更有爆发力的 HTAP 的数据服务。</p><h1 id=tidb关键技术创新>TiDB关键技术创新</h1><h2 id=分层的分布式架构>分层的分布式架构</h2><p>三个分布式系统：</p><ul><li>分布式的 KV 存储系统</li><li>分布式的 SQL 计算系统</li><li>分布式的 HTAP 架构系统</li></ul><h2 id=自动分片与调度>自动分片与调度</h2><p>自动分片技术时更细维度弹性的基础：</p><ul><li><p>全局有序的 KV map</p></li><li><p>按照等长大小策略自动分片（96M）</p></li><li><p>每个分片是连续的 KV，通过 Start/End Key 来寻址</p></li><li><p>称分片为 Region，是复制、调度的最小单位
自动merge：</p></li><li><p>96 MB 自增分片</p></li><li><p>20 MB 合并分片
<img src=../imgs/20230211_tidb_base_23.png alt=20230211_tidb_base_23.png></p></li></ul><p>Multi-Raft 将复制组更离散</p><ul><li>Raft、Multi-raft</li><li>leader、follower、learner</li><li>强主模式、读写在 leader 上</li><li>4.0 版本开启 follower read
Raft 是一个强一致算法，保证了 RPO 为0，业务数据所能容忍的数据丢失量为零，在很多金融级的场景里至关重要。TiKV 设计中，把自动分片也就是 Region 机制与 Raft 进行了结合，形成了以分片为单位的复制组，即 Region base Multi-Raft。一套集群可以同时存在几十万个独立的复制组，这种设计大大提升了整个集群的整体可用性以及多点写入，同时大大优化了 RTO 灾难发生时恢复的时长。</li></ul><p>基于 Multi-Raft 实现写入的线性扩展：新增一个物理节点时，意味着整个集群的写入容量会进行线性增长。</p><h2 id=跨idc单表多点写入>跨IDC单表多点写入</h2><p>Region base Multi-Raft 机制，实现了一个表可以同时有多个写入点，TiKV 的调度机制，可以识别单个节点的物理信息，比如 IDC、REC（机柜）、Host（机架）、宿主机等，并进行约束与绑定。</p><h2 id=去中心化的分布式事务>去中心化的分布式事务</h2><p>去中心化的两阶段提交，解决了事务能力的扩展性。</p><p>TiDB 5.0 以上版本，针对 OLTP 常见的高并发、小数据量的写入场景，TiDB 事务在第二阶段提交采取了异步处理的方式（Async commit），变相实现了 1PC 的效果，大大优化了分布式事务里 2PC 通用的延迟问题。</p><p>其中也有两个大的挑战：</p><ul><li><p>如何确定所有 key 已被 prewrite</p></li><li><p>如何确定事务提交的时间戳
解决：</p></li><li><p>将所有事物的行的 key 与事物的 Primary key（状态位）进行索引的 mapping</p></li><li><p>通过统一 PD 来保障全局时间递增</p></li></ul><h2 id=local-read-and-geo-partition>Local Read and Geo-partition</h2><p>Geo-partition 指多滴多活跨地域数据分布。</p><p>TiDB 5.0 中将中央的授时服务改为了分布式授时服务，能够提高场景的数据性能以及降低延迟。可以在多个 IDC 甚至跨洲际同时提供数据服务，也可以按照本地提供数据安全合规，不出境的方式来访问数据的场景。</p><p>总结：</p><ul><li>多地部署支持，低延时访问</li><li>数据安全合规，符合数据不出境的场景</li><li>支持异步多活容灾</li><li>支持冷热数据分离</li></ul><h2 id=tp和ap融合>TP和AP融合</h2><p>更大数据容量下的 TP 和 AP 融合：</p><ul><li>TiDB 引入了实时更新的列式引擎，既解决了资源隔离，又提升了 AP 效率</li><li>列存上引入 MPP 模型，实现 SQL join 的下推与并行处理</li><li>通过 Raft-base replication 实现时效性</li><li>融合大数据生态，比如 TiSpark</li></ul><h2 id=数据服务统一>数据服务统一</h2><p>TiDB 的 CBO 可以采集行列 Cost 模型进行配置，并同步收集不同引擎的统计信息，统一进行最佳执行路径的选择。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9e167dd3abe5e966a867e1608aa6eca0>5 - SQL引擎</h1><h1 id=introduction>Introduction</h1><p>SQL引擎</p></div><div class=td-content><h1 id=pg-57913b8619c14271e28f8fb18439d412>5.1 - 01.SQL解析器介绍</h1><h1 id=背景>背景</h1><p>传统的关系型数据库都支持 SQL 查询，另外在大数据领域，为了降低大数据的学习成本和难度方便用户，都开始支持 SQL 查询。SQL 查询让更多的用户可以方便快捷地查询数据，极大降低了学习门槛。</p><h1 id=解析流程>解析流程</h1><p>通常解析器主要包括：</p><ul><li>词法解析</li><li>语法解析</li><li>语义解析</li></ul><h2 id=词法解析>词法解析</h2><p>根据构词规则识别字符并切割成一个个的词条，如遇到空格进行分割，遇到分号时结束词法解析。</p><h2 id=语法解析>语法解析</h2><p>语法分析的任务会在词法分析的结果上将词条序列组合成不同语法短句，组成的语法短句将与相应的语法规则进行适配，若适配成功则生成对应的抽象语法树，否则报会抛出语法错误异常。</p><h2 id=语义解析>语义解析</h2><p>语义分析的任务是对语法解析得到的抽象语法树进行有效的校验，比如字段、字段类型、函数、表等进行检查。</p><h1 id=常用sql解析器>常用SQL解析器</h1><p><strong>C/C++中，可以使用 LEX 和 YACC 来做词法分析和语法分析；Java中，可以使用 JavaCC 或 ANTLR</strong> 。</p><h1 id=antlr>ANTLR</h1><p>ANTLR是一款功能强大的语法分析器生成器，几乎支持所有主流变成语言的解析（<a href=https://github.com/antlr/grammars-v4>antlr/grammars-v4</a>）。可以用来读取、处理、执行和转换结构化文本或者二进制文件。在大数据的一些SQL框架里面有有广泛的应用，比如Hive的词法文件是ANTLR3写的，Presto词法文件也是ANTLR4实现的，SparkSQLambda词法文件也是用Presto的词法文件改写的，另外还有HBase的SQL工具Phoenix也是用ANTLR工具进行SQL解析的。</p><h2 id=执行过程>执行过程</h2><ul><li>实现词法文件（.g4）</li><li>生成词法分析器和语法分析器</li><li>生成抽象语法书（AST）</li><li>遍历AST，生成语义树</li><li>访问统计信息</li><li>生成逻辑执行计划</li><li>生成物理执行计划</li></ul><h2 id=parser>Parser</h2><p>Parser用来识别语言程序，包括两个部分：</p><ul><li><p>词法分析器：关键字、标识符；</p></li><li><p>语法分析器：基于词法分析结果构造语法分析树。
转换过程：</p></li><li><p>字符流</p></li><li><p>Token流</p></li><li><p>（语法分析树）非叶子节点</p></li><li><p>（语法分析树）叶子结点</p></li></ul><h2 id=grammar>Grammar</h2><p>ANTLR提供了很多常用语言的语法文件（<a href=https://github.com/antlr/grammars-v4>antlr/grammars-v4</a>）。</p><p>使用语法注意事项：</p><ul><li>语法名称和文件名要一致</li><li>语法分析器规则以小写字母开始</li><li>词法分析器规则以大写字母开始</li><li>用'string'单引号引出字符串</li><li>不需要指定开始符号</li><li>规则以分号结束</li></ul><h2 id=实现四则运算>实现四则运算</h2><p>实现的基本流程：</p><ol><li>按照ANTLR4的规则编写自定义语法的语义规则, 保存成以g4为后缀的文件；</li><li>使用ANTLR4工具处理g4文件，生成词法分析器、句法分析器代码、词典文件；</li><li>编写代码继承Visitor类或实现Listener接口，开发自己的业务逻辑代码。
一般有两种模式：</li></ol><ul><li><p>Visitor模式<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>antlr4 -package com.chnherb.sql -no-listener -visitor .<span style=color:#c41a16>\x</span>xx.g4
</span></span></code></pre></td></tr></table></div></div></div></p></li><li><p>Listener模式<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>antlr4 -package com.chnherb.sql -listener .<span style=color:#c41a16>\x</span>xx.g4
</span></span></code></pre></td></tr></table></div></div></div></p></li></ul><h3 id=定义词法规则文件>定义词法规则文件</h3><p>CommonLexerRules.g4</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>// 定义词法规则
</span></span><span style=display:flex><span>lexer grammar CommonLexerRules;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>//////// 定义词法
</span></span><span style=display:flex><span>// 匹配ID
</span></span><span style=display:flex><span>ID     : [a-zA-Z]+ ;
</span></span><span style=display:flex><span>// 匹配INT
</span></span><span style=display:flex><span>INT    : [0-9]+    ;
</span></span><span style=display:flex><span>// 匹配换行符
</span></span><span style=display:flex><span>NEWLINE: &#39;\n&#39;(&#39;\r&#39;?);
</span></span><span style=display:flex><span>// 跳过空格、跳格、换行符
</span></span><span style=display:flex><span>WS     : [ \t\n\r]+ -&gt; skip;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>//////// 运算符
</span></span><span style=display:flex><span>DIV:&#39;/&#39;;
</span></span><span style=display:flex><span>MUL:&#39;*&#39;;
</span></span><span style=display:flex><span>ADD:&#39;+&#39;;
</span></span><span style=display:flex><span>SUB:&#39;-&#39;;
</span></span><span style=display:flex><span>EQU:&#39;=&#39;;
</span></span></code></pre></td></tr></table></div></div></details><br><h3 id=定义语法规则文件>定义语法规则文件</h3><p>LibExpr.g4</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>
</span></span><span style=display:flex><span>// 定于语法规则
</span></span><span style=display:flex><span>grammar LibExpr;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>// 导入词法规则
</span></span><span style=display:flex><span>import CommonLexerRules;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>// 词法根
</span></span><span style=display:flex><span>prog:stat+ EOF?;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>// 定义声明
</span></span><span style=display:flex><span>stat:expr (NEWLINE)?         # printExpr
</span></span><span style=display:flex><span>    | ID &#39;=&#39; expr (NEWLINE)? # assign
</span></span><span style=display:flex><span>    | NEWLINE                # blank
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>// 定义表达式
</span></span><span style=display:flex><span>expr:expr op=(&#39;*&#39;|&#39;/&#39;) expr # MulDiv
</span></span><span style=display:flex><span>    |expr op=(&#39;+&#39;|&#39;-&#39;) expr # AddSub
</span></span><span style=display:flex><span>    |&#39;(&#39; expr &#39;)&#39;           # Parens
</span></span><span style=display:flex><span>    |ID                     # Id
</span></span><span style=display:flex><span>    |INT                    # Int
</span></span><span style=display:flex><span>    ;
</span></span></code></pre></td></tr></table></div></div></details><br><h3 id=编译生成文件>编译生成文件</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#000>&lt;dependencies&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>&lt;groupId&gt;</span>org.antlr<span style=color:#000>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>&lt;artifactId&gt;</span>antlr4<span style=color:#000>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>&lt;version&gt;</span>4.9.3<span style=color:#000>&lt;/version&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>&lt;groupId&gt;</span>org.antlr<span style=color:#000>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>&lt;artifactId&gt;</span>antlr4-runtime<span style=color:#000>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>&lt;version&gt;</span>4.9.3<span style=color:#000>&lt;/version&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>&lt;/dependencies&gt;</span>
</span></span></code></pre></td></tr></table></div></div></div><p>执行命令：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>mvn generate-sources
</span></span></code></pre></td></tr></table></div></div></div></p><h3 id=编写示例代码>编写示例代码</h3><p>示例文本：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>1+2
</span></span><span style=display:flex><span>1+2*3
</span></span><span style=display:flex><span>1+2*3-4
</span></span><span style=display:flex><span>1+2*3-4+20/5
</span></span><span style=display:flex><span>(1+2)*3
</span></span></code></pre></td></tr></table></div></div></div><p>逻辑代码：<style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 45
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 46
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 47
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 48
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 49
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 50
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 51
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 52
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 53
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 54
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 55
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 56
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 57
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 58
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 59
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 60
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 61
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 62
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 63
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 64
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 65
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 66
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 67
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 68
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 69
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 70
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 71
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 72
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 73
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 74
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 75
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 76
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 77
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 78
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 79
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 80
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 81
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 82
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 83
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 84
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 85
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 86
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 87
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 88
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 89
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 90
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 91
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 92
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 93
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 94
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 95
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 96
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 97
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 98
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 99
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">100
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">101
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">102
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">103
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a90d91>package</span> <span style=color:#000>com.chnherb.sql</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>java.util.HashMap</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>java.util.Map</span><span style=color:#000>;</span> 
</span></span><span style=display:flex><span><span style=color:#177500>/**
</span></span></span><span style=display:flex><span><span style=color:#177500> * 重写访问器规则，实现数据计算功能
</span></span></span><span style=display:flex><span><span style=color:#177500> * 目标：
</span></span></span><span style=display:flex><span><span style=color:#177500> *     1+2 =&gt; 1+2=3
</span></span></span><span style=display:flex><span><span style=color:#177500> *     1+2*4 =&gt; 1+2*4=9
</span></span></span><span style=display:flex><span><span style=color:#177500> *     1+2*4-5 =&gt; 1+2*4-5=4
</span></span></span><span style=display:flex><span><span style=color:#177500> *     1+2*4-5+20/5 =&gt; 1+2*4-5+20/5=8
</span></span></span><span style=display:flex><span><span style=color:#177500> *     (1+2)*4 =&gt; (1+2)*4=12
</span></span></span><span style=display:flex><span><span style=color:#177500> */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>LibExprVisitorImpl</span> <span style=color:#a90d91>extends</span> <span style=color:#000>LibExprBaseVisitor</span><span style=color:#000>&lt;</span><span style=color:#000>Integer</span><span style=color:#000>&gt;</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>    <span style=color:#177500>// 定义数据
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>Map</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>,</span><span style=color:#000>Integer</span><span style=color:#000>&gt;</span> <span style=color:#000>data</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>HashMap</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>,</span><span style=color:#000>Integer</span><span style=color:#000>&gt;();</span>
</span></span><span style=display:flex><span>    <span style=color:#177500>// expr (NEWLINE)?         # printExpr
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#000>Integer</span> <span style=color:#000>visitPrintExpr</span><span style=color:#000>(</span><span style=color:#000>LibExprParser</span><span style=color:#000>.</span><span style=color:#836c28>PrintExprContext</span> <span style=color:#000>ctx</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>println</span><span style=color:#000>(</span><span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>expr</span><span style=color:#000>().</span><span style=color:#836c28>getText</span><span style=color:#000>()+</span><span style=color:#c41a16>&#34;=&#34;</span><span style=color:#000>+</span><span style=color:#000>visit</span><span style=color:#000>(</span><span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>expr</span><span style=color:#000>()));</span>
</span></span><span style=display:flex><span>        <span style=color:#a90d91>return</span> <span style=color:#000>visit</span><span style=color:#000>(</span><span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>expr</span><span style=color:#000>());</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span>    <span style=color:#177500>// ID &#39;=&#39; expr (NEWLINE)? # assign
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#000>Integer</span> <span style=color:#000>visitAssign</span><span style=color:#000>(</span><span style=color:#000>LibExprParser</span><span style=color:#000>.</span><span style=color:#836c28>AssignContext</span> <span style=color:#000>ctx</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 获取id
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>String</span> <span style=color:#000>id</span> <span style=color:#000>=</span> <span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>ID</span><span style=color:#000>().</span><span style=color:#836c28>getText</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// // 获取value
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>int</span> <span style=color:#000>value</span> <span style=color:#000>=</span> <span style=color:#000>Integer</span><span style=color:#000>.</span><span style=color:#836c28>valueOf</span><span style=color:#000>(</span><span style=color:#000>visit</span><span style=color:#000>(</span><span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>expr</span><span style=color:#000>()));</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 缓存ID数据
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>data</span><span style=color:#000>.</span><span style=color:#836c28>put</span><span style=color:#000>(</span><span style=color:#000>id</span><span style=color:#000>,</span><span style=color:#000>value</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 打印日志
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>println</span><span style=color:#000>(</span><span style=color:#000>id</span><span style=color:#000>+</span><span style=color:#c41a16>&#34;=&#34;</span><span style=color:#000>+</span><span style=color:#000>value</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#a90d91>return</span> <span style=color:#000>value</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span> 
</span></span><span style=display:flex><span>    <span style=color:#177500>// NEWLINE                # blank
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#000>Integer</span> <span style=color:#000>visitBlank</span><span style=color:#000>(</span><span style=color:#000>LibExprParser</span><span style=color:#000>.</span><span style=color:#836c28>BlankContext</span> <span style=color:#000>ctx</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#a90d91>return</span> <span style=color:#000>0</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span>    <span style=color:#177500>// expr op=(&#39;*&#39;|&#39;/&#39;) expr # MulDiv
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#000>Integer</span> <span style=color:#000>visitMulDiv</span><span style=color:#000>(</span><span style=color:#000>LibExprParser</span><span style=color:#000>.</span><span style=color:#836c28>MulDivContext</span> <span style=color:#000>ctx</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 左侧数字
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>int</span> <span style=color:#000>left</span> <span style=color:#000>=</span> <span style=color:#000>Integer</span><span style=color:#000>.</span><span style=color:#836c28>valueOf</span><span style=color:#000>(</span><span style=color:#000>visit</span><span style=color:#000>(</span><span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>expr</span><span style=color:#000>(</span><span style=color:#000>0</span><span style=color:#000>)));</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 右侧数字
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>int</span> <span style=color:#000>right</span> <span style=color:#000>=</span> <span style=color:#000>Integer</span><span style=color:#000>.</span><span style=color:#836c28>valueOf</span><span style=color:#000>(</span><span style=color:#000>visit</span><span style=color:#000>(</span><span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>expr</span><span style=color:#000>(</span><span style=color:#000>1</span><span style=color:#000>)));</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 操作符号
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>int</span> <span style=color:#000>opType</span> <span style=color:#000>=</span> <span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>op</span><span style=color:#000>.</span><span style=color:#836c28>getType</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 调试
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#177500>// System.out.println(&#34;visitMulDiv&gt;&gt;&gt;&gt;&gt; left:&#34;+left+&#34;,opType:&#34;+opType+&#34;,right:&#34;+right);
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#177500>// 判断是否为乘法
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>if</span><span style=color:#000>(</span><span style=color:#000>LibExprParser</span><span style=color:#000>.</span><span style=color:#836c28>MUL</span><span style=color:#000>==</span><span style=color:#000>opType</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>            <span style=color:#a90d91>return</span> <span style=color:#000>left</span><span style=color:#000>*</span><span style=color:#000>right</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>}</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 判断是否为除法
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>return</span> <span style=color:#000>left</span><span style=color:#000>/</span><span style=color:#000>right</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#177500>// expr op=(&#39;+&#39;|&#39;-&#39;) expr # AddSub
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#000>Integer</span> <span style=color:#000>visitAddSub</span><span style=color:#000>(</span><span style=color:#000>LibExprParser</span><span style=color:#000>.</span><span style=color:#836c28>AddSubContext</span> <span style=color:#000>ctx</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 获取值和符号
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#177500>// 左侧数字
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>int</span> <span style=color:#000>left</span> <span style=color:#000>=</span> <span style=color:#000>Integer</span><span style=color:#000>.</span><span style=color:#836c28>valueOf</span><span style=color:#000>(</span><span style=color:#000>visit</span><span style=color:#000>(</span><span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>expr</span><span style=color:#000>(</span><span style=color:#000>0</span><span style=color:#000>)));</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 右侧数字
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>int</span> <span style=color:#000>right</span> <span style=color:#000>=</span> <span style=color:#000>Integer</span><span style=color:#000>.</span><span style=color:#836c28>valueOf</span><span style=color:#000>(</span><span style=color:#000>visit</span><span style=color:#000>(</span><span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>expr</span><span style=color:#000>(</span><span style=color:#000>1</span><span style=color:#000>)));</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 操作符号
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>int</span> <span style=color:#000>opType</span> <span style=color:#000>=</span> <span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>op</span><span style=color:#000>.</span><span style=color:#836c28>getType</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 调试
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#177500>// System.out.println(&#34;visitAddSub&gt;&gt;&gt;&gt;&gt; left:&#34;+left+&#34;,opType:&#34;+opType+&#34;,right:&#34;+right);
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#177500>// 判断是否为加法
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>if</span><span style=color:#000>(</span><span style=color:#000>LibExprParser</span><span style=color:#000>.</span><span style=color:#836c28>ADD</span><span style=color:#000>==</span><span style=color:#000>opType</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>            <span style=color:#a90d91>return</span> <span style=color:#000>left</span><span style=color:#000>+</span><span style=color:#000>right</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>}</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 判断是否为减法
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>return</span> <span style=color:#000>left</span><span style=color:#000>-</span><span style=color:#000>right</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span>    <span style=color:#177500>// &#39;(&#39; expr &#39;)&#39;           # Parens
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#000>Integer</span> <span style=color:#000>visitParens</span><span style=color:#000>(</span><span style=color:#000>LibExprParser</span><span style=color:#000>.</span><span style=color:#836c28>ParensContext</span> <span style=color:#000>ctx</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 递归下调
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>return</span> <span style=color:#000>visit</span><span style=color:#000>(</span><span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>expr</span><span style=color:#000>());</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span> 
</span></span><span style=display:flex><span>    <span style=color:#177500>// ID                     # Id
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#000>Integer</span> <span style=color:#000>visitId</span><span style=color:#000>(</span><span style=color:#000>LibExprParser</span><span style=color:#000>.</span><span style=color:#836c28>IdContext</span> <span style=color:#000>ctx</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 获取id
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>String</span> <span style=color:#000>id</span> <span style=color:#000>=</span> <span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>ID</span><span style=color:#000>().</span><span style=color:#836c28>getText</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 判断ID是否被定义
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>if</span><span style=color:#000>(</span><span style=color:#000>data</span><span style=color:#000>.</span><span style=color:#836c28>containsKey</span><span style=color:#000>(</span><span style=color:#000>id</span><span style=color:#000>)){</span>
</span></span><span style=display:flex><span>            <span style=color:#177500>// System.out.println(&#34;visitId&gt;&gt;&gt;&gt;&gt; id:&#34;+id+&#34;,value:&#34;+data.get(id));
</span></span></span><span style=display:flex><span><span style=color:#177500></span>            <span style=color:#a90d91>return</span> <span style=color:#000>data</span><span style=color:#000>.</span><span style=color:#836c28>get</span><span style=color:#000>(</span><span style=color:#000>id</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#000>}</span>
</span></span><span style=display:flex><span>        <span style=color:#a90d91>return</span> <span style=color:#000>0</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span>    <span style=color:#177500>// INT                    # Int
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#000>Integer</span> <span style=color:#000>visitInt</span><span style=color:#000>(</span><span style=color:#000>LibExprParser</span><span style=color:#000>.</span><span style=color:#836c28>IntContext</span> <span style=color:#000>ctx</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// System.out.println(&#34;visitInt&gt;&gt;&gt;&gt;&gt; int:&#34;+ctx.INT().getText());
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>return</span> <span style=color:#000>Integer</span><span style=color:#000>.</span><span style=color:#836c28>valueOf</span><span style=color:#000>(</span><span style=color:#000>ctx</span><span style=color:#000>.</span><span style=color:#836c28>INT</span><span style=color:#000>().</span><span style=color:#836c28>getText</span><span style=color:#000>());</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span></code></pre></td></tr></table></div></div></details><br></p><p>Main函数：</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a90d91>package</span> <span style=color:#000>com.chnherb.sql</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>org.antlr.v4.runtime.tree.ParseTree</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>java.io.FileNotFoundException</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>java.io.IOException</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>org.antlr.v4.runtime.*</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#177500>/**
</span></span></span><span style=display:flex><span><span style=color:#177500> * 打印语法树
</span></span></span><span style=display:flex><span><span style=color:#177500> */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>TestLibExprPrint</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>    <span style=color:#177500>// 打印语法树 input -&gt; lexer -&gt; tokens -&gt; parser -&gt; tree -&gt; print
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>public</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>void</span> <span style=color:#000>main</span><span style=color:#000>(</span><span style=color:#000>String</span> <span style=color:#000>args</span><span style=color:#000>[]){</span>
</span></span><span style=display:flex><span>        <span style=color:#000>printTree</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;./testCase.txt&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span>    <span style=color:#177500>/**
</span></span></span><span style=display:flex><span><span style=color:#177500>     * 打印语法树 input -&gt; lexer -&gt; token -&gt; parser -&gt; tree
</span></span></span><span style=display:flex><span><span style=color:#177500>     * @param fileName
</span></span></span><span style=display:flex><span><span style=color:#177500>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>void</span> <span style=color:#000>printTree</span><span style=color:#000>(</span><span style=color:#000>String</span> <span style=color:#000>fileName</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 定义输入流
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>ANTLRInputStream</span> <span style=color:#000>input</span> <span style=color:#000>=</span> <span style=color:#a90d91>null</span><span style=color:#000>;</span> 
</span></span><span style=display:flex><span>        <span style=color:#177500>// 判断文件名是否为空,若不为空，则读取文件内容，若为空，则读取输入流
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>if</span><span style=color:#000>(</span><span style=color:#000>fileName</span><span style=color:#000>!=</span><span style=color:#a90d91>null</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>            <span style=color:#a90d91>try</span><span style=color:#000>{</span>
</span></span><span style=display:flex><span>                <span style=color:#000>input</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>ANTLRFileStream</span><span style=color:#000>(</span><span style=color:#000>fileName</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>            <span style=color:#000>}</span><span style=color:#a90d91>catch</span><span style=color:#000>(</span><span style=color:#000>FileNotFoundException</span> <span style=color:#000>fnfe</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>                <span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>println</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;文件不存在，请检查后重试！&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>            <span style=color:#000>}</span><span style=color:#a90d91>catch</span><span style=color:#000>(</span><span style=color:#000>IOException</span> <span style=color:#000>ioe</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>                <span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>println</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;文件读取异常，请检查后重试！&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>            <span style=color:#000>}</span>
</span></span><span style=display:flex><span>        <span style=color:#000>}</span><span style=color:#a90d91>else</span><span style=color:#000>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a90d91>try</span><span style=color:#000>{</span>
</span></span><span style=display:flex><span>                <span style=color:#000>input</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>ANTLRInputStream</span><span style=color:#000>(</span><span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>in</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>            <span style=color:#000>}</span><span style=color:#a90d91>catch</span><span style=color:#000>(</span><span style=color:#000>FileNotFoundException</span> <span style=color:#000>fnfe</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>                <span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>println</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;文件不存在，请检查后重试！&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>            <span style=color:#000>}</span><span style=color:#a90d91>catch</span><span style=color:#000>(</span><span style=color:#000>IOException</span> <span style=color:#000>ioe</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>                <span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>println</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;文件读取异常，请检查后重试！&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>            <span style=color:#000>}</span>
</span></span><span style=display:flex><span>        <span style=color:#000>}</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 定义词法规则分析器
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>LibExprLexer</span> <span style=color:#000>lexer</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>LibExprLexer</span><span style=color:#000>(</span><span style=color:#000>input</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 生成通用字符流
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>CommonTokenStream</span> <span style=color:#000>tokens</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>CommonTokenStream</span><span style=color:#000>(</span><span style=color:#000>lexer</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 语法解析
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>LibExprParser</span> <span style=color:#000>parser</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>LibExprParser</span><span style=color:#000>(</span><span style=color:#000>tokens</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 生成语法树
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>ParseTree</span> <span style=color:#000>tree</span> <span style=color:#000>=</span> <span style=color:#000>parser</span><span style=color:#000>.</span><span style=color:#836c28>prog</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 打印语法树
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#177500>// System.out.println(tree.toStringTree(parser));
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#177500>// 生命访问器
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>LibExprVisitorImpl</span> <span style=color:#000>visitor</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>LibExprVisitorImpl</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>        <span style=color:#000>visitor</span><span style=color:#000>.</span><span style=color:#836c28>visit</span><span style=color:#000>(</span><span style=color:#000>tree</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span></code></pre></td></tr></table></div></div></details><br><h2 id=解析csv文件>解析CSV文件</h2><h3 id=裁剪g4文件>裁剪g4文件</h3><p>定义SelectBase.g4文件。直接参考Presto源码，g4文件并不需要从零开发，只需要基于Presto的g4文件裁剪即可。</p><p>核心规则为: SELECT  selectItem (',' selectItem)*  (FROM relation (',' relation)*)?</p><p>查询数据表被抽象成了relation。</p><p>裁剪后的内容如下：</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">  9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 45
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 46
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 47
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 48
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 49
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 50
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 51
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 52
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 53
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 54
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 55
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 56
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 57
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 58
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 59
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 60
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 61
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 62
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 63
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 64
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 65
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 66
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 67
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 68
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 69
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 70
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 71
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 72
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 73
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 74
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 75
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 76
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 77
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 78
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 79
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 80
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 81
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 82
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 83
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 84
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 85
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 86
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 87
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 88
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 89
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 90
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 91
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 92
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 93
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 94
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 95
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 96
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 97
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 98
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 99
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">100
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">101
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">102
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">103
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">104
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>grammar SqlBase;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>tokens {
</span></span><span style=display:flex><span>    DELIMITER
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>singleStatement
</span></span><span style=display:flex><span>    : statement EOF
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>statement
</span></span><span style=display:flex><span>    : query                                                            #statementDefault
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>query
</span></span><span style=display:flex><span>    :  queryNoWith
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>queryNoWith:
</span></span><span style=display:flex><span>      queryTerm
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>queryTerm
</span></span><span style=display:flex><span>    : queryPrimary                                                             #queryTermDefault
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>queryPrimary
</span></span><span style=display:flex><span>    : querySpecification                   #queryPrimaryDefault
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>querySpecification
</span></span><span style=display:flex><span>    : SELECT  selectItem (&#39;,&#39; selectItem)*
</span></span><span style=display:flex><span>      (FROM relation (&#39;,&#39; relation)*)?
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>selectItem
</span></span><span style=display:flex><span>    : expression  #selectSingle
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>relation
</span></span><span style=display:flex><span>    :  sampledRelation                             #relationDefault
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>expression
</span></span><span style=display:flex><span>    : booleanExpression
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>booleanExpression
</span></span><span style=display:flex><span>    : valueExpression             #predicated
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>valueExpression
</span></span><span style=display:flex><span>    : primaryExpression                                                                 #valueExpressionDefault
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>primaryExpression
</span></span><span style=display:flex><span>    : identifier                                                                          #columnReference
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>sampledRelation
</span></span><span style=display:flex><span>    : aliasedRelation
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>aliasedRelation
</span></span><span style=display:flex><span>    : relationPrimary
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>relationPrimary
</span></span><span style=display:flex><span>    : qualifiedName                                                   #tableName
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>qualifiedName
</span></span><span style=display:flex><span>    : identifier (&#39;.&#39; identifier)*
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>identifier
</span></span><span style=display:flex><span>    : IDENTIFIER             #unquotedIdentifier
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>SELECT: &#39;SELECT&#39;;
</span></span><span style=display:flex><span>FROM: &#39;FROM&#39;;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>fragment DIGIT
</span></span><span style=display:flex><span>    : [0-9]
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>fragment LETTER
</span></span><span style=display:flex><span>    : [A-Z]
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>IDENTIFIER
</span></span><span style=display:flex><span>    : (LETTER | &#39;_&#39;) (LETTER | DIGIT | &#39;_&#39; | &#39;@&#39; | &#39;:&#39;)*
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>WS
</span></span><span style=display:flex><span>    : [ \r\n\t]+ -&gt; channel(HIDDEN)
</span></span><span style=display:flex><span>    ;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>// Catch-all for anything we can&#39;t recognize.
</span></span><span style=display:flex><span>// We use this to be able to ignore and recover all the text
</span></span><span style=display:flex><span>// when splitting statements with DelimiterLexer
</span></span><span style=display:flex><span>UNRECOGNIZED
</span></span><span style=display:flex><span>    : .
</span></span><span style=display:flex><span>    ;
</span></span></code></pre></td></tr></table></div></div></details><br><h3 id=生成代码>生成代码</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>antlr4 -package com.chnherb.csv -no-listener -visitor .<span style=color:#c41a16>\S</span>qlBase.g4
</span></span></code></pre></td></tr></table></div></div></div><h3 id=语法树节点>语法树节点</h3><p><img src=../imgs/sql_intro_230310_1.png alt=sql_intro_230310_1.png></p><h3 id=解析类>解析类</h3><p>基于visitor模式实现解析类AstBuilder，以visitQuerySpecification为例：</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>@Override</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#000>Node</span> <span style=color:#000>visitQuerySpecification</span><span style=color:#000>(</span><span style=color:#000>SqlBaseParser</span><span style=color:#000>.</span><span style=color:#836c28>QuerySpecificationContext</span> <span style=color:#000>context</span><span style=color:#000>)</span>
</span></span><span style=display:flex><span><span style=color:#000>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000>Optional</span><span style=color:#000>&lt;</span><span style=color:#000>Relation</span><span style=color:#000>&gt;</span> <span style=color:#000>from</span> <span style=color:#000>=</span> <span style=color:#000>Optional</span><span style=color:#000>.</span><span style=color:#836c28>empty</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>    <span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>SelectItem</span><span style=color:#000>&gt;</span> <span style=color:#000>selectItems</span> <span style=color:#000>=</span> <span style=color:#000>visit</span><span style=color:#000>(</span><span style=color:#000>context</span><span style=color:#000>.</span><span style=color:#836c28>selectItem</span><span style=color:#000>(),</span> <span style=color:#000>SelectItem</span><span style=color:#000>.</span><span style=color:#836c28>class</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>Relation</span><span style=color:#000>&gt;</span> <span style=color:#000>relations</span> <span style=color:#000>=</span> <span style=color:#000>visit</span><span style=color:#000>(</span><span style=color:#000>context</span><span style=color:#000>.</span><span style=color:#836c28>relation</span><span style=color:#000>(),</span> <span style=color:#000>Relation</span><span style=color:#000>.</span><span style=color:#836c28>class</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>if</span> <span style=color:#000>(!</span><span style=color:#000>relations</span><span style=color:#000>.</span><span style=color:#836c28>isEmpty</span><span style=color:#000>())</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// synthesize implicit join nodes
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>Iterator</span><span style=color:#000>&lt;</span><span style=color:#000>Relation</span><span style=color:#000>&gt;</span> <span style=color:#000>iterator</span> <span style=color:#000>=</span> <span style=color:#000>relations</span><span style=color:#000>.</span><span style=color:#836c28>iterator</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>        <span style=color:#000>Relation</span> <span style=color:#000>relation</span> <span style=color:#000>=</span> <span style=color:#000>iterator</span><span style=color:#000>.</span><span style=color:#836c28>next</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#000>from</span> <span style=color:#000>=</span> <span style=color:#000>Optional</span><span style=color:#000>.</span><span style=color:#836c28>of</span><span style=color:#000>(</span><span style=color:#000>relation</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#a90d91>new</span> <span style=color:#000>QuerySpecification</span><span style=color:#000>(</span>
</span></span><span style=display:flex><span>            <span style=color:#000>getLocation</span><span style=color:#000>(</span><span style=color:#000>context</span><span style=color:#000>),</span>
</span></span><span style=display:flex><span>            <span style=color:#a90d91>new</span> <span style=color:#000>Select</span><span style=color:#000>(</span><span style=color:#000>getLocation</span><span style=color:#000>(</span><span style=color:#000>context</span><span style=color:#000>.</span><span style=color:#836c28>SELECT</span><span style=color:#000>()),</span> <span style=color:#a90d91>false</span><span style=color:#000>,</span> <span style=color:#000>selectItems</span><span style=color:#000>),</span>
</span></span><span style=display:flex><span>            <span style=color:#000>from</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span></code></pre></td></tr></table></div></div></details><br><p>解析出查询的数据源和具体字段，封装到QuerySpecification对象中。</p><h3 id=statement查询数据>Statement查询数据</h3><p>将用户输入的语句解析成ParseTree，对其遍历生成Statement对象。核心代码如下：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#000>SqlParser</span> <span style=color:#000>sqlParser</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>SqlParser</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span><span style=color:#000>Statement</span> <span style=color:#000>statement</span> <span style=color:#000>=</span> <span style=color:#000>sqlParser</span><span style=color:#000>.</span><span style=color:#836c28>createStatement</span><span style=color:#000>(</span><span style=color:#000>sql</span><span style=color:#000>);</span>
</span></span></code></pre></td></tr></table></div></div></div><p>Statement对象使用：</p><ul><li>Query类型的Statement有QueryBody属性。</li><li>QuerySpecification类型的QueryBody有select属性和from属性。<ul><li>从from属性中获取待查询的目标表Table。这里约定表名和csv文件名一致。</li><li>从select属性中获取待查询的目标字段SelectItem。这里约定csv首行为title行。
流程如下：</li></ul></li></ul><ol><li>获取查询的数据表以及字段。</li><li>通过数据表名称定为到数据文件，并读取数据文件数据。</li><li>格式化输出字段名称到命令行。</li><li>格式化输出字段内容到命令行。</li></ol><h3 id=编写代码>编写代码</h3><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#177500>/**
</span></span></span><span style=display:flex><span><span style=color:#177500> * 获取待查询的表名和字段名称
</span></span></span><span style=display:flex><span><span style=color:#177500> */</span>
</span></span><span style=display:flex><span><span style=color:#000>QuerySpecification</span> <span style=color:#000>specification</span> <span style=color:#000>=</span> <span style=color:#000>(</span><span style=color:#000>QuerySpecification</span><span style=color:#000>)</span> <span style=color:#000>query</span><span style=color:#000>.</span><span style=color:#836c28>getQueryBody</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span><span style=color:#000>Table</span> <span style=color:#000>table</span><span style=color:#000>=</span> <span style=color:#000>(</span><span style=color:#000>Table</span><span style=color:#000>)</span> <span style=color:#000>specification</span><span style=color:#000>.</span><span style=color:#836c28>getFrom</span><span style=color:#000>().</span><span style=color:#836c28>get</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span><span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>SelectItem</span><span style=color:#000>&gt;</span> <span style=color:#000>selectItems</span> <span style=color:#000>=</span> <span style=color:#000>specification</span><span style=color:#000>.</span><span style=color:#836c28>getSelect</span><span style=color:#000>().</span><span style=color:#836c28>getSelectItems</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span><span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>String</span><span style=color:#000>&gt;</span> <span style=color:#000>fieldNames</span> <span style=color:#000>=</span> <span style=color:#000>Lists</span><span style=color:#000>.</span><span style=color:#836c28>newArrayList</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>for</span><span style=color:#000>(</span><span style=color:#000>SelectItem</span> <span style=color:#000>item</span><span style=color:#000>:</span><span style=color:#000>selectItems</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>    <span style=color:#000>SingleColumn</span> <span style=color:#000>column</span> <span style=color:#000>=</span> <span style=color:#000>(</span><span style=color:#000>SingleColumn</span><span style=color:#000>)</span> <span style=color:#000>item</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>fieldNames</span><span style=color:#000>.</span><span style=color:#836c28>add</span><span style=color:#000>(((</span><span style=color:#000>Identifier</span><span style=color:#000>)</span><span style=color:#000>column</span><span style=color:#000>.</span><span style=color:#836c28>getExpression</span><span style=color:#000>()).</span><span style=color:#836c28>getValue</span><span style=color:#000>());</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span> 
</span></span><span style=display:flex><span><span style=color:#177500>/**
</span></span></span><span style=display:flex><span><span style=color:#177500> * 基于表名确定查询的数据源文件
</span></span></span><span style=display:flex><span><span style=color:#177500> */</span>
</span></span><span style=display:flex><span><span style=color:#000>String</span> <span style=color:#000>fileLoc</span> <span style=color:#000>=</span> <span style=color:#000>String</span><span style=color:#000>.</span><span style=color:#836c28>format</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;./data/%s.csv&#34;</span><span style=color:#000>,</span><span style=color:#000>table</span><span style=color:#000>.</span><span style=color:#836c28>getName</span><span style=color:#000>());</span>
</span></span><span style=display:flex><span><span style=color:#177500>/**
</span></span></span><span style=display:flex><span><span style=color:#177500> * 从csv文件中读取指定的字段
</span></span></span><span style=display:flex><span><span style=color:#177500> */</span>
</span></span><span style=display:flex><span><span style=color:#000>Reader</span> <span style=color:#000>in</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>FileReader</span><span style=color:#000>(</span><span style=color:#000>fileLoc</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span><span style=color:#000>Iterable</span><span style=color:#000>&lt;</span><span style=color:#000>CSVRecord</span><span style=color:#000>&gt;</span> <span style=color:#000>records</span> <span style=color:#000>=</span> <span style=color:#000>CSVFormat</span><span style=color:#000>.</span><span style=color:#836c28>RFC4180</span><span style=color:#000>.</span><span style=color:#836c28>withFirstRecordAsHeader</span><span style=color:#000>().</span><span style=color:#836c28>parse</span><span style=color:#000>(</span><span style=color:#000>in</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span><span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>Row</span><span style=color:#000>&gt;</span> <span style=color:#000>rowList</span> <span style=color:#000>=</span> <span style=color:#000>Lists</span><span style=color:#000>.</span><span style=color:#836c28>newArrayList</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>for</span><span style=color:#000>(</span><span style=color:#000>CSVRecord</span> <span style=color:#000>record</span><span style=color:#000>:</span><span style=color:#000>records</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>    <span style=color:#000>Row</span> <span style=color:#000>row</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>Row</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>for</span><span style=color:#000>(</span><span style=color:#000>String</span> <span style=color:#000>field</span><span style=color:#000>:</span><span style=color:#000>fieldNames</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>        <span style=color:#000>row</span><span style=color:#000>.</span><span style=color:#836c28>addColumn</span><span style=color:#000>(</span><span style=color:#000>record</span><span style=color:#000>.</span><span style=color:#836c28>get</span><span style=color:#000>(</span><span style=color:#000>field</span><span style=color:#000>));</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span>    <span style=color:#000>rowList</span><span style=color:#000>.</span><span style=color:#836c28>add</span><span style=color:#000>(</span><span style=color:#000>row</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span><span style=display:flex><span><span style=color:#177500>/**
</span></span></span><span style=display:flex><span><span style=color:#177500> * 格式化输出到控制台
</span></span></span><span style=display:flex><span><span style=color:#177500> */</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>int</span> <span style=color:#000>width</span><span style=color:#000>=</span><span style=color:#000>30</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#000>String</span> <span style=color:#000>format</span> <span style=color:#000>=</span> <span style=color:#000>fieldNames</span><span style=color:#000>.</span><span style=color:#836c28>stream</span><span style=color:#000>().</span><span style=color:#836c28>map</span><span style=color:#000>(</span><span style=color:#000>s</span><span style=color:#000>-&gt;</span> <span style=color:#c41a16>&#34;%-&#34;</span><span style=color:#000>+</span><span style=color:#000>width</span><span style=color:#000>+</span><span style=color:#c41a16>&#34;s&#34;</span><span style=color:#000>).</span><span style=color:#836c28>collect</span><span style=color:#000>(</span><span style=color:#000>Collectors</span><span style=color:#000>.</span><span style=color:#836c28>joining</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;|&#34;</span><span style=color:#000>));</span>
</span></span><span style=display:flex><span><span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>println</span><span style=color:#000>(</span> <span style=color:#c41a16>&#34;|&#34;</span><span style=color:#000>+</span><span style=color:#000>String</span><span style=color:#000>.</span><span style=color:#836c28>format</span><span style=color:#000>(</span><span style=color:#000>format</span><span style=color:#000>,</span> <span style=color:#000>fieldNames</span><span style=color:#000>.</span><span style=color:#836c28>toArray</span><span style=color:#000>())+</span><span style=color:#c41a16>&#34;|&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a90d91>int</span> <span style=color:#000>flagCnt</span> <span style=color:#000>=</span> <span style=color:#000>width</span><span style=color:#000>*</span><span style=color:#000>fieldNames</span><span style=color:#000>.</span><span style=color:#836c28>size</span><span style=color:#000>()+</span><span style=color:#000>fieldNames</span><span style=color:#000>.</span><span style=color:#836c28>size</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span><span style=color:#000>String</span> <span style=color:#000>rowDelimiter</span> <span style=color:#000>=</span> <span style=color:#000>String</span><span style=color:#000>.</span><span style=color:#836c28>join</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;&#34;</span><span style=color:#000>,</span> <span style=color:#000>Collections</span><span style=color:#000>.</span><span style=color:#836c28>nCopies</span><span style=color:#000>(</span><span style=color:#000>flagCnt</span><span style=color:#000>,</span> <span style=color:#c41a16>&#34;-&#34;</span><span style=color:#000>));</span>
</span></span><span style=display:flex><span><span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>println</span><span style=color:#000>(</span><span style=color:#000>rowDelimiter</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>for</span><span style=color:#000>(</span><span style=color:#000>Row</span> <span style=color:#000>row</span><span style=color:#000>:</span><span style=color:#000>rowList</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>    <span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>println</span><span style=color:#000>(</span> <span style=color:#c41a16>&#34;|&#34;</span><span style=color:#000>+</span><span style=color:#000>String</span><span style=color:#000>.</span><span style=color:#836c28>format</span><span style=color:#000>(</span><span style=color:#000>format</span><span style=color:#000>,</span> <span style=color:#000>row</span><span style=color:#000>.</span><span style=color:#836c28>getColumnList</span><span style=color:#000>().</span><span style=color:#836c28>toArray</span><span style=color:#000>())+</span><span style=color:#c41a16>&#34;|&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span></code></pre></td></tr></table></div></div></details><br><h1 id=calcite>Calcite</h1><h2 id=简介>简介</h2><p>与ANTLR不同，Apache Calcite大大简化了SQL的解析流程，不需要定义接口、生成代码。</p><p>数据库包含的常用功能：</p><ul><li>query language</li><li>query optimization</li><li>query execution</li><li>data management</li><li>data storage
Calcite 设计之初主要关注前三者，将后面两个数据管理和数据存储交给计算/存储引擎。专注于上层通用的模块，控制系统的复杂性。</li></ul><p>同时，Calcite也复用了一些组件，如使用 JavaCC 来将SQL语句转为Java代码，进而转化成AST。另外为了支持灵活的元数据功能，Calcite需要支持运行时编译Java代码，但默认的JavaC太重，使用了轻量开源的 Janino。</p><p>常用的大数据组件都有集成 Calcite，Hive就是自己做了SQL解析，只使用了Calcite的查询优化功能。而像Flink从解析到优化都直接使用了Calcite。</p><h2 id=主要模块>主要模块</h2><ul><li>JDBC Client：支持 JDBC Client 的应用</li><li>SQL Parser and Validator：用来SQL解析和校验</li><li>Expressions Builder：支持SQL解析和校验的框架对接</li><li>Operator Expressions：处理关系表达式</li><li>Metadata Provider：支持外部自定义元数据</li><li>Pluggable Rules：定义优化规则</li><li>Query Optimizer：（核心模块）专注于查询优化</li></ul><h2 id=解析sql>解析SQL</h2><h3 id=pom依赖>pom依赖</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#000>&lt;dependencies&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>&lt;groupId&gt;</span>org.smartloli<span style=color:#000>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>&lt;artifactId&gt;</span>jsql-client<span style=color:#000>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>&lt;version&gt;</span>1.0.0<span style=color:#000>&lt;/version&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#000>&lt;/dependencies&gt;</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=实现代码>实现代码</h3><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a90d91>package</span> <span style=color:#000>com.chnherb.sql</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>com.alibaba.fastjson.JSON</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>com.alibaba.fastjson.JSONArray</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>com.alibaba.fastjson.JSONObject</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>org.smartloli.util.JSqlUtils</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>JSqlClient</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>void</span> <span style=color:#000>main</span><span style=color:#000>(</span><span style=color:#000>String</span><span style=color:#000>[]</span> <span style=color:#000>args</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#000>JSONObject</span> <span style=color:#000>tabSchema</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>JSONObject</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>        <span style=color:#000>tabSchema</span><span style=color:#000>.</span><span style=color:#836c28>put</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;id&#34;</span><span style=color:#000>,</span><span style=color:#c41a16>&#34;integer&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#000>tabSchema</span><span style=color:#000>.</span><span style=color:#836c28>put</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;name&#34;</span><span style=color:#000>,</span><span style=color:#c41a16>&#34;varchar&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#000>JSONArray</span> <span style=color:#000>datasets</span> <span style=color:#000>=</span> <span style=color:#000>JSON</span><span style=color:#000>.</span><span style=color:#836c28>parseArray</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;[{\&#34;id\&#34;:1,\&#34;name\&#34;:\&#34;aaa\&#34;,\&#34;age\&#34;:20},{\&#34;id\&#34;:2,\&#34;name\&#34;:\&#34;bbb\&#34;,\&#34;age\&#34;:21},{\&#34;id\&#34;:3,\&#34;name\&#34;:\&#34;ccc\&#34;,\&#34;age\&#34;:22}]&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#000>String</span> <span style=color:#000>tabName</span> <span style=color:#000>=</span> <span style=color:#c41a16>&#34;userinfo&#34;</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>        <span style=color:#000>String</span> <span style=color:#000>sql</span> <span style=color:#000>=</span> <span style=color:#c41a16>&#34;select count(*) as cnt from \&#34;userinfo\&#34;&#34;</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>        <span style=color:#a90d91>try</span><span style=color:#000>{</span>
</span></span><span style=display:flex><span>           <span style=color:#000>String</span> <span style=color:#000>result</span> <span style=color:#000>=</span> <span style=color:#000>JSqlUtils</span><span style=color:#000>.</span><span style=color:#836c28>query</span><span style=color:#000>(</span><span style=color:#000>tabSchema</span><span style=color:#000>,</span><span style=color:#000>tabName</span><span style=color:#000>,</span><span style=color:#000>datasets</span><span style=color:#000>,</span><span style=color:#000>sql</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>            <span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>println</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;result: &#34;</span><span style=color:#000>+</span><span style=color:#000>result</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#000>}</span><span style=color:#a90d91>catch</span> <span style=color:#000>(</span><span style=color:#000>Exception</span> <span style=color:#000>e</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>            <span style=color:#000>e</span><span style=color:#000>.</span><span style=color:#836c28>printStackTrace</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>        <span style=color:#000>}</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span></code></pre></td></tr></table></div></div></details><br><h1 id=reference>Reference</h1><p><a href=https://github.com/antlr/antlr4>https://github.com/antlr/antlr4</a></p><p><a href=https://github.com/antlr/grammars-v4>https://github.com/antlr/grammars-v4</a></p><p><a href=https://github.com/apache/calcite>https://github.com/apache/calcite</a></p><p><a href=https://github.com/smartloli/EFAK>https://github.com/smartloli/EFAK</a></p><p><a href=https://prestodb.io/docs/current/>https://prestodb.io/docs/current/</a></p><p><a href=https://github.com/prestodb/presto>https://github.com/prestodb/presto</a></p><p><a href=https://mp.weixin.qq.com/s/oYsCmTg4OVlIuB9a8Eu1Vw>探究Presto SQL引擎(1)-巧用Antlr</a></p><p><a href=https://mp.weixin.qq.com/s/2FH4WuO1FMbxqiv4RUvdrA>如何实现一个SQL解析器</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-1f3b4428a1c3ce6dcce34a27b1a096d7>5.2 - 02.Join操作</h1><h1 id=背景>背景</h1><p>业务开发使用数据库时，通常规定不允许使用过多的表Join，如阿里巴巴开发手册中：</p><blockquote><p>【强制】超过三个表禁止Join。需要Join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。说明：即使双表Join也要注意表索引、SQL性能。</p></blockquote><p>大数据数仓中，既有星型结构和雪花结构，但最终交付业务使用的大多是宽表。</p><h1 id=join基本原理>Join基本原理</h1><h2 id=join分类>Join分类</h2><p>Join分为如下几类：</p><ul><li>Cross Join</li><li>Inner Join</li><li>Outer Join<ul><li>full join</li><li>left join</li><li>right join</li></ul></li></ul><h3 id=cross-join>Cross Join</h3><p>交叉连接，返回连接的两个表所有数据行的<strong>笛卡尔积</strong>，一般不加条件限制。使用：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#a90d91>SELECT</span>  <span style=color:#000>*</span>  <span style=color:#a90d91>FROM</span>  <span style=color:#000>tableA</span>, <span style=color:#000>tableB</span>  <span style=color:#000>#</span> <span style=color:#000>等价</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>SELECT</span>  <span style=color:#000>*</span>  <span style=color:#a90d91>FROM</span>  <span style=color:#000>tableA</span> <span style=color:#a90d91>CROSS</span> <span style=color:#a90d91>JOIN</span> <span style=color:#000>tableB</span>
</span></span></code></pre></td></tr></table></div></div></div><h3 id=inner-join>Inner Join</h3><p>Inner join 获取两张表的交集，是内联查询，不是产生笛卡尔集，结合ON子句使用，直接基于join condition做连接，生成的join集合就是最终的输出结果，产生的中间数据更小。</p><h3 id=outer-join>Outer Join</h3><p>Outer join 获取两张表的并集，是内联查询。</p><ul><li>full join：产生A和B的并集</li><li>left join：产生表A的完全集，而B表中匹配的则有值，没有匹配的则以NULL值取代。</li><li>right join：产生表B的完全集，而A表中匹配的则有值，没有匹配的则以NULL值取代。</li></ul><h2 id=关联算法>关联算法</h2><blockquote><p>Join关联算法可参考本博客：<a href=https://chnherb.github.io/docs/30.%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0/#%E5%85%B3%E8%81%94%E7%AE%97%E6%B3%95>https://chnherb.github.io/docs/30.%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0/#%E5%85%B3%E8%81%94%E7%AE%97%E6%B3%95</a></p></blockquote><p>常见的关联算法有三大类，分别是</p><ul><li>嵌套循环（Nested Loop Join）</li><li>排序归并（Sort-Merge Join）</li><li>哈希（Hash Join）</li></ul><h1 id=join工程化理论>Join工程化理论</h1><h2 id=火山模型>火山模型</h2><p>SQL语法支持的操作类型非常丰富：查询表(TableScan)、过滤数据(Filter)、排序(Order)、限制(Limit)、字段进行运算(Project)、 聚合(Group)、关联(Join)等。为了实现上述的能力，需要一个具备并行化能力且可扩展的架构。</p><p>1994年Goetz Graefe在论文《Volcano-An Extensible and Parallel Query Evaluation System》提出了一个架构设计思想，这就是大名鼎鼎的火山模型，也称为迭代模型。火山模型包含了文件系统和查询处理两个部分。</p><p><img src=../imgs/sql_join_230311_1.png alt=sql_join_230311_1.png></p><p>来源于《Balancing vectorized execution with bandwidth-optimized storage》</p><h3 id=职责分离>职责分离</h3><p>将不同操作独立成一个的Operator，Operator采用open-next-close的迭代器模式。如一般的SQL语句对应到Scan、Select、Project三个Operator，数据交互通过next()函数实现。</p><p>Presto中的Operator：</p><ul><li>SourceOperator<ul><li>TableScanSourceOperator</li></ul></li><li>OrderOperator</li><li>LimitOperator</li><li>TaskOutputOperator</li></ul><h3 id=动态组装>动态组装</h3><p>Operator基于SQL语句的解析实现动态组装，多个Operator形成一个管道(pipeline)。</p><p>Presto在火山模型的基础上，吸收了其它思想做了如下优化：</p><ul><li>Operator数据处理优化成一次一个Page，而不是一次行(也称为tuple)。</li><li>Page的存储采用列式结构。即相同的列封装到一个Block中。
<strong>批量处理</strong>结合<strong>列式存储</strong>奠定了<strong>向量化计算</strong>的基础**，<strong>也是</strong>数据库领域的优化方向**。 </li></ul><h2 id=批量处理和列式存储>批量处理和列式存储</h2><p>Presto源码中，随处可见 Page 和 Block。</p><p>通常 OLAP 场景不需要读取所有字段，于是衍生了列式存储，如下结构：</p><p><img src=../imgs/sql_join_230311_2.png alt=sql_join_230311_2.png></p><p>将数据封装成Page在各个Operator中流转，一方面避免了对象的序列化和反序列化成本，另一方面相比行（tuple）的方式降低了函数调用的开销。类似集装箱运货降低运输成本的思想。</p><p>示例代码：</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">71
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">72
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">73
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">74
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">75
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">76
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">77
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">78
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">79
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">80
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">81
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">82
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">83
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">84
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">85
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">86
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">87
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">88
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>com.facebook.presto.common.Page</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>com.facebook.presto.common.PageBuilder</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>com.facebook.presto.common.block.Block</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>com.facebook.presto.common.block.BlockBuilder</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>com.facebook.presto.common.type.BigintType</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>com.facebook.presto.common.type.Type</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>com.facebook.presto.common.type.VarcharType</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>com.google.common.collect.Lists</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>io.airlift.slice.Slice</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import</span> <span style=color:#000>java.util.List</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>import static</span> <span style=color:#000>io.airlift.slice.Slices.utf8Slice</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>PageBlockDemo</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#000>Page</span> <span style=color:#000>buildPage</span><span style=color:#000>(</span><span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>Type</span><span style=color:#000>&gt;</span> <span style=color:#000>types</span><span style=color:#000>,</span><span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>Object</span><span style=color:#000>[]&gt;</span> <span style=color:#000>dataSet</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>        <span style=color:#000>PageBuilder</span> <span style=color:#000>pageBuilder</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>PageBuilder</span><span style=color:#000>(</span><span style=color:#000>types</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 封装成Page
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>for</span><span style=color:#000>(</span><span style=color:#000>Object</span><span style=color:#000>[]</span> <span style=color:#000>row</span><span style=color:#000>:</span><span style=color:#000>dataSet</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>            <span style=color:#177500>// 完成一行
</span></span></span><span style=display:flex><span><span style=color:#177500></span>            <span style=color:#000>pageBuilder</span><span style=color:#000>.</span><span style=color:#836c28>declarePosition</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>            <span style=color:#a90d91>for</span> <span style=color:#000>(</span><span style=color:#a90d91>int</span> <span style=color:#000>column</span> <span style=color:#000>=</span> <span style=color:#000>0</span><span style=color:#000>;</span> <span style=color:#000>column</span> <span style=color:#000>&lt;</span> <span style=color:#000>types</span><span style=color:#000>.</span><span style=color:#836c28>size</span><span style=color:#000>();</span> <span style=color:#000>column</span><span style=color:#000>++)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>                <span style=color:#000>BlockBuilder</span> <span style=color:#000>out</span> <span style=color:#000>=</span>  <span style=color:#000>pageBuilder</span><span style=color:#000>.</span><span style=color:#836c28>getBlockBuilder</span><span style=color:#000>(</span><span style=color:#000>column</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>                <span style=color:#000>Object</span> <span style=color:#000>colVal</span> <span style=color:#000>=</span> <span style=color:#000>row</span><span style=color:#000>[</span><span style=color:#000>column</span><span style=color:#000>];</span>
</span></span><span style=display:flex><span>                <span style=color:#a90d91>if</span><span style=color:#000>(</span><span style=color:#000>colVal</span> <span style=color:#000>==</span> <span style=color:#a90d91>null</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>                    <span style=color:#000>out</span><span style=color:#000>.</span><span style=color:#836c28>appendNull</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>                <span style=color:#000>}</span><span style=color:#a90d91>else</span><span style=color:#000>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#000>Type</span> <span style=color:#000>type</span> <span style=color:#000>=</span> <span style=color:#000>types</span><span style=color:#000>.</span><span style=color:#836c28>get</span><span style=color:#000>(</span><span style=color:#000>column</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#000>Class</span><span style=color:#000>&lt;?&gt;</span> <span style=color:#000>javaType</span> <span style=color:#000>=</span> <span style=color:#000>type</span><span style=color:#000>.</span><span style=color:#836c28>getJavaType</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>                    <span style=color:#a90d91>if</span><span style=color:#000>(</span><span style=color:#000>javaType</span> <span style=color:#000>==</span> <span style=color:#a90d91>long</span><span style=color:#000>.</span><span style=color:#836c28>class</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>                        <span style=color:#000>type</span><span style=color:#000>.</span><span style=color:#836c28>writeLong</span><span style=color:#000>(</span><span style=color:#000>out</span><span style=color:#000>,(</span><span style=color:#a90d91>long</span><span style=color:#000>)</span><span style=color:#000>colVal</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#000>}</span><span style=color:#a90d91>else</span> <span style=color:#a90d91>if</span><span style=color:#000>(</span><span style=color:#000>javaType</span> <span style=color:#000>==</span> <span style=color:#000>Slice</span><span style=color:#000>.</span><span style=color:#836c28>class</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>                        <span style=color:#000>type</span><span style=color:#000>.</span><span style=color:#836c28>writeSlice</span><span style=color:#000>(</span><span style=color:#000>out</span><span style=color:#000>,</span> <span style=color:#000>utf8Slice</span><span style=color:#000>((</span><span style=color:#000>String</span><span style=color:#000>)</span><span style=color:#000>colVal</span><span style=color:#000>));</span>
</span></span><span style=display:flex><span>                    <span style=color:#000>}</span><span style=color:#a90d91>else</span><span style=color:#000>{</span>
</span></span><span style=display:flex><span>                        <span style=color:#a90d91>throw</span> <span style=color:#a90d91>new</span> <span style=color:#000>UnsupportedOperationException</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;not implemented&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#000>}</span>
</span></span><span style=display:flex><span>                <span style=color:#000>}</span>
</span></span><span style=display:flex><span>            <span style=color:#000>}</span>
</span></span><span style=display:flex><span>        <span style=color:#000>}</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 生成Page
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>Page</span> <span style=color:#000>page</span> <span style=color:#000>=</span> <span style=color:#000>pageBuilder</span><span style=color:#000>.</span><span style=color:#836c28>build</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>        <span style=color:#000>pageBuilder</span><span style=color:#000>.</span><span style=color:#836c28>reset</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>        <span style=color:#a90d91>return</span> <span style=color:#000>page</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a90d91>private</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>void</span> <span style=color:#000>readColumn</span><span style=color:#000>(</span><span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>Type</span><span style=color:#000>&gt;</span> <span style=color:#000>types</span><span style=color:#000>,</span><span style=color:#000>Page</span> <span style=color:#000>page</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>// 从Page中读取列
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#a90d91>for</span><span style=color:#000>(</span><span style=color:#a90d91>int</span> <span style=color:#000>column</span><span style=color:#000>=</span><span style=color:#000>0</span><span style=color:#000>;</span><span style=color:#000>column</span><span style=color:#000>&lt;</span><span style=color:#000>types</span><span style=color:#000>.</span><span style=color:#836c28>size</span><span style=color:#000>();</span><span style=color:#000>column</span><span style=color:#000>++){</span>
</span></span><span style=display:flex><span>            <span style=color:#000>Block</span> <span style=color:#000>block</span> <span style=color:#000>=</span> <span style=color:#000>page</span><span style=color:#000>.</span><span style=color:#836c28>getBlock</span><span style=color:#000>(</span><span style=color:#000>column</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>            <span style=color:#000>Type</span> <span style=color:#000>type</span> <span style=color:#000>=</span> <span style=color:#000>types</span><span style=color:#000>.</span><span style=color:#836c28>get</span><span style=color:#000>(</span><span style=color:#000>column</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>            <span style=color:#000>Class</span><span style=color:#000>&lt;?&gt;</span> <span style=color:#000>javaType</span> <span style=color:#000>=</span> <span style=color:#000>type</span><span style=color:#000>.</span><span style=color:#836c28>getJavaType</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>            <span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>print</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;column[&#34;</span><span style=color:#000>+</span><span style=color:#000>type</span><span style=color:#000>.</span><span style=color:#836c28>getDisplayName</span><span style=color:#000>()+</span><span style=color:#c41a16>&#34;]&gt;&gt;&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>            <span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>Object</span><span style=color:#000>&gt;</span> <span style=color:#000>colList</span> <span style=color:#000>=</span> <span style=color:#000>Lists</span><span style=color:#000>.</span><span style=color:#836c28>newArrayList</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>            <span style=color:#a90d91>for</span><span style=color:#000>(</span><span style=color:#a90d91>int</span> <span style=color:#000>pos</span><span style=color:#000>=</span><span style=color:#000>0</span><span style=color:#000>;</span><span style=color:#000>pos</span><span style=color:#000>&lt;</span><span style=color:#000>block</span><span style=color:#000>.</span><span style=color:#836c28>getPositionCount</span><span style=color:#000>();</span><span style=color:#000>pos</span><span style=color:#000>++){</span>
</span></span><span style=display:flex><span>                <span style=color:#a90d91>if</span><span style=color:#000>(</span><span style=color:#000>javaType</span> <span style=color:#000>==</span> <span style=color:#a90d91>long</span><span style=color:#000>.</span><span style=color:#836c28>class</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>                    <span style=color:#000>colList</span><span style=color:#000>.</span><span style=color:#836c28>add</span><span style=color:#000>(</span><span style=color:#000>block</span><span style=color:#000>.</span><span style=color:#836c28>getLong</span><span style=color:#000>(</span><span style=color:#000>pos</span><span style=color:#000>));</span>
</span></span><span style=display:flex><span>                <span style=color:#000>}</span><span style=color:#a90d91>else</span> <span style=color:#a90d91>if</span><span style=color:#000>(</span><span style=color:#000>javaType</span> <span style=color:#000>==</span> <span style=color:#000>Slice</span><span style=color:#000>.</span><span style=color:#836c28>class</span><span style=color:#000>){</span>
</span></span><span style=display:flex><span>                    <span style=color:#000>colList</span><span style=color:#000>.</span><span style=color:#836c28>add</span><span style=color:#000>(</span><span style=color:#000>block</span><span style=color:#000>.</span><span style=color:#836c28>getSlice</span><span style=color:#000>(</span><span style=color:#000>pos</span><span style=color:#000>,</span><span style=color:#000>0</span><span style=color:#000>,</span><span style=color:#000>block</span><span style=color:#000>.</span><span style=color:#836c28>getSliceLength</span><span style=color:#000>(</span><span style=color:#000>pos</span><span style=color:#000>)).</span><span style=color:#836c28>toStringUtf8</span><span style=color:#000>());</span>
</span></span><span style=display:flex><span>                <span style=color:#000>}</span><span style=color:#a90d91>else</span><span style=color:#000>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#a90d91>throw</span> <span style=color:#a90d91>new</span> <span style=color:#000>UnsupportedOperationException</span><span style=color:#000>(</span><span style=color:#c41a16>&#34;not implemented&#34;</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>                <span style=color:#000>}</span>
</span></span><span style=display:flex><span>            <span style=color:#000>}</span>
</span></span><span style=display:flex><span>            <span style=color:#000>System</span><span style=color:#000>.</span><span style=color:#836c28>out</span><span style=color:#000>.</span><span style=color:#836c28>println</span><span style=color:#000>(</span><span style=color:#000>colList</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#000>}</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a90d91>public</span> <span style=color:#a90d91>static</span> <span style=color:#a90d91>void</span> <span style=color:#000>main</span><span style=color:#000>(</span><span style=color:#000>String</span><span style=color:#000>[]</span> <span style=color:#000>args</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#177500>/**
</span></span></span><span style=display:flex><span><span style=color:#177500>         * 假设有两个字段，一个字段类型为int, 一个字段类型为varchar
</span></span></span><span style=display:flex><span><span style=color:#177500>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>Type</span><span style=color:#000>&gt;</span> <span style=color:#000>types</span> <span style=color:#000>=</span> <span style=color:#000>Lists</span><span style=color:#000>.</span><span style=color:#836c28>newArrayList</span><span style=color:#000>(</span><span style=color:#000>BigintType</span><span style=color:#000>.</span><span style=color:#836c28>BIGINT</span><span style=color:#000>,</span> <span style=color:#000>VarcharType</span><span style=color:#000>.</span><span style=color:#836c28>VARCHAR</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#177500>// 按行存储
</span></span></span><span style=display:flex><span><span style=color:#177500></span>        <span style=color:#000>List</span><span style=color:#000>&lt;</span><span style=color:#000>Object</span><span style=color:#000>[]&gt;</span> <span style=color:#000>dataSet</span> <span style=color:#000>=</span> <span style=color:#000>Lists</span><span style=color:#000>.</span><span style=color:#836c28>newArrayList</span><span style=color:#000>(</span>
</span></span><span style=display:flex><span>                <span style=color:#a90d91>new</span> <span style=color:#000>Object</span><span style=color:#000>[]{</span><span style=color:#000>1L</span><span style=color:#000>,</span><span style=color:#c41a16>&#34;aa&#34;</span><span style=color:#000>},</span>
</span></span><span style=display:flex><span>                <span style=color:#a90d91>new</span> <span style=color:#000>Object</span><span style=color:#000>[]{</span><span style=color:#000>2L</span><span style=color:#000>,</span><span style=color:#c41a16>&#34;ba&#34;</span><span style=color:#000>},</span>
</span></span><span style=display:flex><span>                <span style=color:#a90d91>new</span> <span style=color:#000>Object</span><span style=color:#000>[]{</span><span style=color:#000>3L</span><span style=color:#000>,</span><span style=color:#c41a16>&#34;cc&#34;</span><span style=color:#000>},</span>
</span></span><span style=display:flex><span>                <span style=color:#a90d91>new</span> <span style=color:#000>Object</span><span style=color:#000>[]{</span><span style=color:#000>4L</span><span style=color:#000>,</span><span style=color:#c41a16>&#34;dd&#34;</span><span style=color:#000>});</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#000>Page</span> <span style=color:#000>page</span> <span style=color:#000>=</span> <span style=color:#000>buildPage</span><span style=color:#000>(</span><span style=color:#000>types</span><span style=color:#000>,</span> <span style=color:#000>dataSet</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#000>readColumn</span><span style=color:#000>(</span><span style=color:#000>types</span><span style=color:#000>,</span><span style=color:#000>page</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span><span style=display:flex><span><span style=color:#177500>// 运行结果：
</span></span></span><span style=display:flex><span><span style=color:#177500>//column[bigint]&gt;&gt;[1, 2, 3, 4]
</span></span></span><span style=display:flex><span><span style=color:#177500>//column[varchar]&gt;&gt;[aa, ba, cc, dd]
</span></span></span></code></pre></td></tr></table></div></div></details><br><h1 id=join工程化实践>Join工程化实践</h1><h2 id=基本流程>基本流程</h2><ul><li>Parser:  借助ANTLR的能力即可实现SQL语法的检测。</li><li>Binding: 基于SQL语句生成AST，利用元数据检测字段和表的映射关系以及Join条件的字段类型。</li><li>Planner: 基于AST生成查询计划。 </li><li>Executor: 基于查询计划生成对应的Operator并执行。</li></ul><h2 id=落地事项>落地事项</h2><ul><li>支持所有的Join语义</li><li>分布式能力</li><li>性能优化</li><li>多表Join的顺序选择</li><li>大表与小表Join</li><li>Semi Join优化</li><li>Join算法倾斜</li></ul><h2 id=示例-nested-loop-join>示例：Nested Loop Join</h2><p>以 Nested Loop Join 算法为例，Presto是拆解为两个阶段：</p><ul><li>组合阶段</li><li>过滤阶段
实现JoinOperator时，只需负责两个表数据的笛卡尔积组合即可。核心代码如下：</li></ul><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#177500>// NestedLoopPageBuilder中实现两个Page计算笛卡尔积的处理逻辑，
</span></span></span><span style=display:flex><span><span style=color:#177500>// 这里RunLengthEncodedBlock用于一个元素复制，典型地笛卡尔积计算中需要将一列元素从1行复制成多行。
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>@Override</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>public</span> <span style=color:#000>Page</span> <span style=color:#000>next</span><span style=color:#000>()</span>
</span></span><span style=display:flex><span><span style=color:#000>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>if</span> <span style=color:#000>(!</span><span style=color:#000>hasNext</span><span style=color:#000>())</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#a90d91>throw</span> <span style=color:#a90d91>new</span> <span style=color:#000>NoSuchElementException</span><span style=color:#000>();</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a90d91>if</span> <span style=color:#000>(</span><span style=color:#000>noColumnShortcutResult</span> <span style=color:#000>&gt;=</span> <span style=color:#000>0</span><span style=color:#000>)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#000>rowIndex</span> <span style=color:#000>=</span> <span style=color:#000>maxRowIndex</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>        <span style=color:#a90d91>return</span> <span style=color:#a90d91>new</span> <span style=color:#000>Page</span><span style=color:#000>(</span><span style=color:#000>noColumnShortcutResult</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#000>rowIndex</span><span style=color:#000>++;</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#177500>// Create an array of blocks for all columns in both pages.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>Block</span><span style=color:#000>[]</span> <span style=color:#000>blocks</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>Block</span><span style=color:#000>[</span><span style=color:#000>numberOfProbeColumns</span> <span style=color:#000>+</span> <span style=color:#000>numberOfBuildColumns</span><span style=color:#000>];</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#177500>// Make sure we always put the probe data on the left and build data on the right.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>int</span> <span style=color:#000>indexForRleBlocks</span> <span style=color:#000>=</span> <span style=color:#000>buildPageLarger</span> <span style=color:#000>?</span> <span style=color:#000>0</span> <span style=color:#000>:</span> <span style=color:#000>numberOfProbeColumns</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>int</span> <span style=color:#000>indexForPageBlocks</span> <span style=color:#000>=</span> <span style=color:#000>buildPageLarger</span> <span style=color:#000>?</span> <span style=color:#000>numberOfProbeColumns</span> <span style=color:#000>:</span> <span style=color:#000>0</span><span style=color:#000>;</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#177500>// For the page with less rows, create RLE blocks and add them to the blocks array
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>for</span> <span style=color:#000>(</span><span style=color:#a90d91>int</span> <span style=color:#000>i</span> <span style=color:#000>=</span> <span style=color:#000>0</span><span style=color:#000>;</span> <span style=color:#000>i</span> <span style=color:#000>&lt;</span> <span style=color:#000>smallPage</span><span style=color:#000>.</span><span style=color:#836c28>getChannelCount</span><span style=color:#000>();</span> <span style=color:#000>i</span><span style=color:#000>++)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#000>Block</span> <span style=color:#000>block</span> <span style=color:#000>=</span> <span style=color:#000>smallPage</span><span style=color:#000>.</span><span style=color:#836c28>getBlock</span><span style=color:#000>(</span><span style=color:#000>i</span><span style=color:#000>).</span><span style=color:#836c28>getSingleValueBlock</span><span style=color:#000>(</span><span style=color:#000>rowIndex</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>        <span style=color:#000>blocks</span><span style=color:#000>[</span><span style=color:#000>indexForRleBlocks</span><span style=color:#000>]</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>RunLengthEncodedBlock</span><span style=color:#000>(</span><span style=color:#000>block</span><span style=color:#000>,</span> <span style=color:#000>largePage</span><span style=color:#000>.</span><span style=color:#836c28>getPositionCount</span><span style=color:#000>());</span>
</span></span><span style=display:flex><span>        <span style=color:#000>indexForRleBlocks</span><span style=color:#000>++;</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#177500>// Put the page with more rows in the blocks array
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>for</span> <span style=color:#000>(</span><span style=color:#a90d91>int</span> <span style=color:#000>i</span> <span style=color:#000>=</span> <span style=color:#000>0</span><span style=color:#000>;</span> <span style=color:#000>i</span> <span style=color:#000>&lt;</span> <span style=color:#000>largePage</span><span style=color:#000>.</span><span style=color:#836c28>getChannelCount</span><span style=color:#000>();</span> <span style=color:#000>i</span><span style=color:#000>++)</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>        <span style=color:#000>blocks</span><span style=color:#000>[</span><span style=color:#000>indexForPageBlocks</span> <span style=color:#000>+</span> <span style=color:#000>i</span><span style=color:#000>]</span> <span style=color:#000>=</span> <span style=color:#000>largePage</span><span style=color:#000>.</span><span style=color:#836c28>getBlock</span><span style=color:#000>(</span><span style=color:#000>i</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span>    <span style=color:#000>}</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#a90d91>new</span> <span style=color:#000>Page</span><span style=color:#000>(</span><span style=color:#000>largePage</span><span style=color:#000>.</span><span style=color:#836c28>getPositionCount</span><span style=color:#000>(),</span> <span style=color:#000>blocks</span><span style=color:#000>);</span>
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span></code></pre></td></tr></table></div></div></details><br></div><div class=td-content style=page-break-before:always><h1 id=pg-a69378d24d0e96b77d18b4cd0bae055d>5.3 - 03.统计计数</h1><h1 id=背景>背景</h1><p>统计计数是一个非常常见场景。除了通常的计数，统计不重复元素个数的需求也非常常见，这种统计称为<strong>基数统计</strong>。分布式SQL引擎，计数的实现原理值得深入研究，特别是基数统计。关于普通计数和基数计数，最典型的例子莫过于PV/UV。</p><h1 id=主要方法>主要方法</h1><p>在SQL语法里面，基数统计对应到count(distinct  field)或者aprox_distinct()。通常做精确计数统计需要用到Set这种数据结构。Set不仅可以获得数量信息，还能不重不漏地获取每一个元素。</p><p>Set内部有两种实现实现原理：Hash和Tree。</p><p>在海量数据的前提下，Hash和Tree有一个致命的问题：内存消耗，而且随着数据量级的增长，内存消耗也是线性增长。</p><p>面对Set内存消耗的问题，通常有两种思路：</p><ul><li>选取其他内存占用更小的数据结构，例如bitmap；</li><li>放弃精确，从数学上寻求近似解，典型的算法有Linear Count和HyperLogLog。</li></ul><h2 id=bitmap>Bitmap</h2><p>在数据库领域Bitmap并不是新事物，一般用作索引，称为位图索引。所谓位图索引，就是用一个bit位向量来记录某个字段值是否存在于对应的记录。它有一个前置条件：记录要有永久的编号，类似于从1开始的自增主键。</p><h3 id=位图向量的构建>位图向量的构建</h3><p>对于数据表的一个字段，如果记录数为n且字段的取值基数为m，那么会得到一个m*n的位图。</p><p>多个字段即得到多个这样的位图。</p><h3 id=位图向量的应用>位图向量的应用</h3><p>单个条件：</p><p>直接取该字段m*n的位图，统计其中 1 的个数。</p><p>多个条件：</p><p>取对应多个字段的位图，多个向量进行交集运算，然后统计 1 的个数。</p><h3 id=优缺点>优缺点</h3><p>优点：</p><ul><li><p>节省内存（数据分布密集压缩空间更大）</p></li><li><p>二进制位操作，执行效率高
缺点：</p></li><li><p>非数值型字段，需要额外转换处理</p></li></ul><h2 id=linear-count>Linear Count</h2><p>Linear Count简称LC算法（利用数学的概率和统计学知识）。 </p><p>算法描述如下：</p><ul><li>初始化：给定m个房间，房间存储数字，初始化为0。</li><li>迭代执行：对于要进行基数统计的集合，用一个哈希函数处理集合中的每一个元素。通过哈希函数处理后，元素就可以放置到一个房间中。</li><li>收尾：统计m个房间中空房间的数量U。</li><li>结论：集合中不重复元素的个数估计值可以通过如下公式计算：n=-m*log(U/m)。
随着m和n的增大，m大约为n的十分之一。</li></ul><h2 id=hyperloglog>HyperLogLog</h2><p>HyperLogLog简称HLL算法，它有如下的特点：</p><ol><li>可以实现由极小的内存开销统计出巨量的数据。在 Redis中实现的HyperLogLog，只需要12K内存就能统计2^64个数据。</li><li>可以方便实现分布式扩展。(对算法在业务系统中落地非常关键)</li></ol><h2 id=基础理论>基础理论</h2><h3 id=伯努利实验>伯努利实验</h3><p>如抛硬币，随着次数地增多，对应的值也就越趋近一个值。这样将统计问题转换成概率论中参数估计的问题。</p><h3 id=调和平均数>调和平均数</h3><p>概率中的极值问题导致最后得到的值不稳定。对于极值的处理策略是多实验几轮，通过平均值来消除极值的影响。</p><p>数学上其实有许多的平均数计算方式：算术平均数、几何平均数、平方平均数。选用调和平均数主要是消除极值的影响。</p><h1 id=核心流程>核心流程</h1><p>MapReduce的核心流程：</p><ul><li>Input</li><li>Splitting</li><li>Mapping</li><li>Shuffling</li><li>Reducing</li><li>Final result
Presto核心流程也是类似的，先分组聚合，然后汇总聚合。</li></ul><h1 id=方案实现>方案实现</h1><h2 id=count-distinct><strong>count distinct</strong></h2><p>以id为主key, 对数据进行hash分发，进行部分聚合，最终整体聚合。依然是map-reduce的思路，只不过数据按id进行了分发。</p><h2 id=aprox-distinct><strong>aprox_distinct</strong></h2><p>免去了基于id的hash分发策略，减少了一个stage。以Presto为例，基础框架airlift中封装了HyperLogLog算法的实现，采用的函数是MurMurHash3算法，生成64位散列值。前6位用于计算当前散列值所在分组m。实现过程中还有一个很有意思的细节：基于待统计的数据量，实现中同时采用了Linear Count算法和HyperLogLog算法。</p><h1 id=小结>小结</h1><p>基数统计是一个非常消耗内存的操作，特别是在分布式系统背景下，不仅消耗内存，而且涉及大量网络数据传输。</p><p>分析对应的业务场景，如果可以提供近似值而非精确值，能大幅度降低系统消耗和响应时间，提升用户体验。或者在设计产品时，对于一些场景的计数，可以优先提供近似估计，如果确实需要精确计数，在管理好响应时间预期下，再提供查询精确值的接口。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-58e370dcab589bd0cfd3917819e042ca>5.4 - Presto简介</h1><h1 id=背景>背景</h1><p>Facebook的数据仓库存储在少量大型Hadoop/HDFS集群，之前Facebook的科学家和分析师一直依靠Hive来做数据分析。但Hive使用MapReduce作为底层计算框架，是专为批处理设计的。随着数据越来越多，使用Hive进行一个简单的数据查询可能要花费几分到几小时，显然不能满足交互式查询的需求。Facebook也调研了其他比Hive更快的工具，但它们要么在功能有所限制要么就太简单，以至于无法操作Facebook庞大的数据仓库。</p><p>2012年开始试用的一些外部项目都不合适，Facebook决定自己开发，即Presto。目前该项目已经在超过1000名Facebook雇员中使用，运行超过30000个查询，每日数据在1PB级别。Facebook称Presto的性能比Hive要好10倍以上。2013年Facebook正式宣布开源Presto。</p><h1 id=简介>简介</h1><p>Presto是由facebook 开源的分布式的MPP(Massive Parallel Processing)架构的SQL查询引擎。基于全内存计算(部分算子数据也可通过session 配置spill到本地磁盘)，并且采用流式pipeline的方式处理数据使其能够节省内存的同时，更快的响应查询。</p><h2 id=特点>特点</h2><ul><li><p>多数据源
Presto可以支持MySQL、PostgreSQL、cassandra、Hive、Kafka等多种数据源查询。也可以帮助从其驻留位置查询数据，例如Hive，Cassandra，专有数据存储或关系数据库。</p></li><li><p>支持SQL
Presto支持部分标准SQL对数据进行查询，并提供SQL shell进行SQL查询。但不支持存储过程，不适合大表Join操作，因为Presto是基于内存的，多张大表关联可能给内存带来压力。</p></li><li><p>扩展性
Presto有很好的扩展向，可以自定义开发特定数据源的Connector，使用SQL分析指定Connector中的数据。</p></li><li><p>混合计算
在Presto中可以根据业务需要使用特定类型的Connector来读取不同数据源的数据，进行join关联计算、合并查询。</p></li><li><p>基于内存计算，高性能
基于内存计算的，减少磁盘IO，计算更快。性能是Hive的10倍以上，能够处理PB级别的数据，但并不是把PB级别的数据一次性加载到内存中计算，而是根据处理方式，例如聚合场景，边读取数据、聚合、再清空内存，循环往复。如果使用Join查询，那么就会产生大量的中间数据，速度会变慢。</p></li><li><p>流水线
由于Presto是基于PipeLine进行设计的，因此在进行海量数据处理过程中，终端用户不用等到所有的数据都处理完成才能看到结果，而是可以向自来水管一样，一旦计算开始，就可以产生一部分结果数据，并且结果数据会一部分接一部分的返回到客户端。</p></li><li><p>架构简单
包括一个coordinator和多个worker。</p></li></ul><h2 id=presto与hive比较>Presto与Hive比较</h2><table><thead><tr><th style=text-align:left></th><th style=text-align:left>Presto</th><th style=text-align:left>Hive</th></tr></thead><tbody><tr><td style=text-align:left><strong>查询语言</strong></td><td style=text-align:left>ANSI SQL</td><td style=text-align:left>HiveQL</td></tr><tr><td style=text-align:left><strong>速度</strong></td><td style=text-align:left>比Hive的速度快5-10倍</td><td style=text-align:left>比Presto慢</td></tr><tr><td style=text-align:left><strong>自定义代码插件</strong></td><td style=text-align:left>没有</td><td style=text-align:left>允许用户插入自定义代码</td></tr><tr><td style=text-align:left><strong>语法差异</strong></td><td style=text-align:left>有</td><td style=text-align:left>有</td></tr><tr><td style=text-align:left><strong>数据限制</strong></td><td style=text-align:left>可以处理有限的数据量</td><td style=text-align:left>可以处理大批量数据</td></tr><tr><td style=text-align:left><strong>长时间运行的查询</strong></td><td style=text-align:left>超过48小时就会终止</td><td style=text-align:left>可以查询长期运行的查询</td></tr></tbody></table><h2 id=presto与spark-sql比较>Presto与Spark SQL比较</h2><table><thead><tr><th style=text-align:left></th><th style=text-align:left>Presto</th><th style=text-align:left>HiveSpark SQL</th></tr></thead><tbody><tr><td style=text-align:left><strong>重点</strong></td><td style=text-align:left>强调查询，支持BI报表</td><td style=text-align:left>强调计算，数据的ETL加工</td></tr><tr><td style=text-align:left><strong>架构</strong></td><td style=text-align:left>MMP主从架构，简单，一个协调器多个Worker</td><td style=text-align:left>MMP主从架构，复杂，很多层，RDD的弹性构建，为作业进行资源管理和协商等</td></tr><tr><td style=text-align:left><strong>内存存储</strong></td><td style=text-align:left>基于内存，不够就OOM</td><td style=text-align:left>内存+落磁盘</td></tr><tr><td style=text-align:left><strong>资源申请</strong></td><td style=text-align:left>预先申请CPU/内存，coordinator和worker一直运行</td><td style=text-align:left>实时申请资源，需要多少资源申请多少</td></tr><tr><td style=text-align:left><strong>数据处理</strong></td><td style=text-align:left>批处理管道处理模式，完成就可以将其发送到下一个任务，大大减少各种查询的端到端响应时间</td><td style=text-align:left>数据需要在进入下一阶段之前完全处理</td></tr><tr><td style=text-align:left><strong>优化措施</strong></td><td style=text-align:left>基于成本的优化器(CBO)，速度更快</td><td style=text-align:left>基于规则的优化(RBO)，复杂查询上执行更好的操作，速度更慢</td></tr><tr><td style=text-align:left><strong>运行时间</strong></td><td style=text-align:left>作为服务一直运行，更容易利用缓存</td><td style=text-align:left>一个任务，作业分发和启动都需要时间</td></tr></tbody></table><h1 id=架构>架构</h1><p><img src=../imgs/pres_intro_230312_1.png alt=pres_intro_230312_1.png></p><p>Presto查询引擎是一个Master-Slave的架构，组成部分：</p><ul><li>一个Coordinator节点</li><li>一个Discovery Server节点（通常内嵌于Coordinator节点中）</li><li>多个Worker节点组成
Coordinator负责解析SQL语句、生成执行计划、分发执行任务给Worker节点执行。</li></ul><p>Worker节点负责实际执行查询任务。Worker节点启动后向Discovery Server服务注册，Coordinator从Discovery Server获得可以正常工作的Worker节点。如果配置了Hive Connector，需要配置一个Hive MetaStore服务为Presto提供Hive元信息，Worker节点与HDFS交互读取数据。</p><h2 id=coordinator>Coordinator</h2><p>协调器（Coordinator）是整个系统的中心节点，负责接收客户端请求、解析查询语句、编译执行计划、并发控制、任务调度、结果合并等。具体来说，协调器的职责包括以下几个方面：</p><ol><li>接收并解析查询请求：协调器负责接收客户端发送的SQL查询请求，并对请求进行解析，获取查询的元数据、查询语句等信息。</li><li>编译执行计划：协调器根据查询语句、元数据等信息生成查询的执行计划，包括任务划分、任务依赖关系等。</li><li>并发控制和任务调度：协调器负责控制查询的并发度和任务调度，根据查询的执行计划将任务分配给不同的工作节点执行。在任务分配时，协调器会考虑数据本地性、节点负载均衡等因素，尽可能地提高查询效率。</li><li>监控和管理任务执行：协调器负责监控任务的执行情况，并根据任务执行情况进行调度和管理。如果某个任务失败或超时，协调器会重新分配任务或者取消查询。</li><li>结果合并和返回：协调器负责将各个任务的执行结果进行合并，并将结果返回给客户端。</li></ol><h2 id=worker>Worker</h2><p>Worker是Presto集群中的工作节点，它们负责执行协调器分配的任务，处理查询请求并生成结果。Worker的主要职责包括以下几个方面：</p><ol><li>接收并处理任务：Worker从协调器接收任务，根据任务的要求从存储系统中获取数据并执行计算操作。</li><li>执行计算任务：Worker将接收到的任务分解为小任务，并利用多个CPU核心和内存执行计算任务。在执行任务时，Worker会将数据读取到内存中，并使用Presto定义的内存数据结构进行计算。</li><li>返回结果：Worker完成任务后，将结果返回给协调器，协调器会对结果进行汇总，最终生成查询结果并返回给客户端。</li><li>资源管理：Worker需要负责管理自己的资源，包括CPU、内存和磁盘等。Worker需要监控自己的资源使用情况，以确保任务能够正确执行并不会消耗过多的资源。</li><li>处理异常：如果任务执行过程中出现异常，Worker需要能够及时捕获并上报给协调器，同时清理异常的状态。
Worker是Presto集群中的核心节点，它们负责处理查询请求、执行计算任务并返回结果。Worker需要高效地利用资源并保证任务执行的正确性，从而提高Presto集群的性能和可靠性。</li></ol><h1 id=模型>模型</h1><h2 id=connector>Connector</h2><p>Connector是一种抽象的数据源接口，用于连接不同的数据源，例如Hive、MySQL、PostgreSQL、Cassandra等。每个Connector实现了一组标准的接口，包括Metadata、Split、PageSource和RecordSet等，以便与Presto核心系统进行交互和协作。</p><p>每种Connector都实现了Presto中标准的SPI接口，只要实现了Presto中标准的SPI接口，就可以轻易实现适合自己需求的Connector。</p><ol><li>Metadata接口：用于提供数据源的元数据信息，例如表和列的结构、数据类型、分区信息等。Metadata接口还提供了一些用于查询和筛选数据的方法，例如getTables、getColumns、getPartitionKeys、getPartitions等。</li><li>Split接口：用于将数据源划分成多个数据块（Split），每个Split包含一部分数据和相关的元数据信息。Split接口提供了一些用于生成和管理Split的方法，例如getSplits、getSplit、isRemotelyAccessible等。</li><li>PageSource接口：用于读取Split中的数据，并返回一个或多个数据页（Page）。PageSource接口提供了一些用于读取数据和处理异常的方法，例如getReader、getPosition、isFinished等。</li><li>RecordSet接口：用于将数据页（Page）转换为行记录（Record），并提供一些用于访问和处理记录的方法，例如getColumnTypes、nextBatch、getRowCount等。
通过Connector接口，Presto可以访问和处理不同的数据源，支持跨数据源的查询和联合查询。Connector还提供了一些可插拔的机制，例如分区发现、列注释、列别名等，以提高查询性能和效率。</li></ol><h2 id=catalog>Catalog</h2><p>Catalog是一个抽象的概念，表示数据源的集合，可以是一个数据库、一个Hive实例、一个S3存储桶等等。Catalog包含了一组Schema（模式），每个Schema表示一个数据库或者命名空间，包含了一组Table（表），每个Table表示一个数据表。Catalog不存储数据，它仅仅是数据源的描述信息，例如表的结构、分区信息等。Presto的Catalog提供了一些用于管理和查询数据源的方法，例如创建和删除Catalog、列出Catalog、切换Catalog、列出Schema、切换Schema、列出Table、描述Table等。</p><p>Presto中的Catalog，相当于数据库的一个实例。在Presto的配置文件中，以.properties结尾，每个properties就对应了Presto中的一个Catalog。</p><h2 id=schema>Schema</h2><p>Schema是一个抽象的概念，表示数据库或者命名空间，用于组织和管理表。每个Schema包含了一组Table（表），每个Table表示一个数据表。Schema的作用类似于关系型数据库中的数据库，可以帮助用户组织和管理表，并提供更好的隔离和权限控制。一个Catalog中可以有多个Schema。</p><h2 id=table>Table</h2><p>Table表示一个数据表，包含了表的结构和数据。每个Table属于一个特定的Schema（数据库或命名空间），可以由Catalog（数据源）中的Schema映射而来，也可以由用户在Presto中创建。</p><p>Presto支持的Table类型包括：</p><ol><li>Native Table：在Presto中创建的Table，通常是一些基于文件、Hive、关系型数据库等数据源的虚拟表。</li><li>External Table：在Presto中定义的对外部数据源的引用，例如S3存储桶、HDFS文件系统等。</li><li>System Table：Presto内置的一些元数据表，用于获取关于集群、任务、查询等运行时信息。
Presto的Table可以使用SQL语句进行查询、过滤、聚合等操作，支持标准的SQL查询语法，例如SELECT、FROM、WHERE、GROUP BY、HAVING、JOIN等关键字。Presto还支持复杂的查询操作，例如嵌套查询、子查询、多级连接、窗口函数等。</li></ol><p>Presto的Table可以使用各种文件格式存储数据，包括文本文件（CSV、JSON、XML等）、列式存储（Parquet、ORC等）、序列化存储（Avro、Thrift等）等。Presto还支持对Table进行分区和桶（bucket）操作，以便于提高查询性能和优化数据访问。</p><h1 id=执行过程>执行过程</h1><h2 id=主要概念>主要概念</h2><h3 id=page>Page</h3><p>Presto中最小数据处理单元是一个Page对象，Page通常是列存储格式的，包含若干行数据。通过Page将数据从一个节点传递到另一个节点。</p><p>Page对象的数据结构如下图所示。一个Page对象包含多个Block对象，每个Block对象是一个字节数组，存储一个字段的若干行。多个Block横切的一行是真实的一行数据。一个Page最大1MB，最多16*1024行数据。</p><p><img src=../imgs/pres_intro_230312_2.png alt=pres_intro_230312_2.png></p><h3 id=stage>Stage</h3><p>Stage是Presto查询计划中的一个执行阶段，可以看作是一个有向无环图(DAG)中的一个节点。每个Stage都是由一个或多个Task组成，每个Task处理一个或多个Split。Stage的主要职责是将查询计划划分为多个阶段并协调Task之间的数据传输和计算。</p><h3 id=task>Task</h3><p>Task是Stage的子节点，是Presto中的计算任务单元。每个Task都处理一个或多个Split，它们可以在不同的Worker上运行，以利用并行计算来加速查询。Task通过Page进行数据交换，将输入数据处理为输出数据，并将输出传递给下一个Task或Stage。</p><h3 id=remotetask>RemoteTask</h3><p>表示在分布式计算中的一个计算任务。与Task的功能类似，但它在集群中的另一个节点上执行计算。Presto通过协调器将数据分发到所有的节点，然后在每个节点上运行RemoteTask，最后将计算结果聚合到协调器上。</p><h3 id=split>Split</h3><p>Split是数据的最小单元，表示数据在存储系统中的一个分片。Presto将查询分解成多个Split，并将它们分配给不同的Task来处理。Split可以是文件、表、分区或其他数据集合。</p><h3 id=sqlstageexecution>SqlStageExecution</h3><p>表示查询执行的阶段的对象，它负责将查询拆分为多个Task，并跟踪这些Task的状态和结果。当SqlStageExecution对象创建时，它会通过ConnectorManager获取查询数据源的元数据信息，然后将查询分解为多个Stage。</p><h3 id=operator>Operator</h3><p>每个Operator表示查询计算的一个操作，它执行特定的计算逻辑。在一个Task中，可能包含多个Operator，这些Operator可以共享输入数据，从而减少数据传输和复制的开销。当一个Operator完成计算时，它将结果写入输出Page。</p><h2 id=查询计划>查询计划</h2><p>查询计划是指将查询语句转换为一系列查询操作和数据流的执行计划。查询计划由Presto的优化器生成，根据查询的语义和查询数据的结构选择最优的执行计划。</p><p>Presto查询计划的主要组成部分如下：</p><ol><li>Source：Source表示查询数据的来源，可以是表、视图、函数等。在查询计划中，每个Source都对应一个SourceNode。</li><li>Filter：Filter表示查询条件，它通常用于过滤出符合查询条件的数据。在查询计划中，Filter通常表示为一个FilterNode。</li><li>Project：Project表示查询的投影操作，它用于选择查询中需要的列。在查询计划中，Project通常表示为一个ProjectNode。</li><li>Join：Join表示查询中的连接操作，它将两个或多个数据源合并在一起。在查询计划中，Join通常表示为一个JoinNode。</li><li>Group By：Group By表示查询中的聚合操作，它将数据按照指定的列进行分组，并计算每个组的聚合值。在查询计划中，Group By通常表示为一个AggregationNode。</li><li>Order By：OrderBy表示查询中的排序操作，它将查询结果按照指定的列进行排序。在查询计划中，OrderBy通常表示为一个SortNode。
在Presto中，查询计划是一个有向无环图（DAG），每个节点表示一个查询操作，每个边表示数据流的传递。在执行查询时，Presto将查询计划转换为一组Task，每个Task对应查询计划中的一个节点。Task可以在多个节点之间并行执行，以利用分布式系统中的多核和多节点资源，提高查询性能。</li></ol><h2 id=执行流程>执行流程</h2><ol><li>解析和编译查询语句：Presto接收到一个查询请求后，首先会对查询语句进行语法分析和语义分析，并生成执行计划。</li><li>执行查询计划：Presto的执行计划是一个有向无环图（DAG），其中包含了各个任务（Task）和它们之间的依赖关系。Presto会根据执行计划中的任务划分为不同的阶段（Stage），并按照阶段依赖关系的拓扑顺序执行任务。</li><li>并行执行任务：Presto支持多节点、多线程的并行执行任务。在每个节点上，Presto会启动一个或多个Executor线程，每个Executor线程负责执行一个或多个任务。Presto还支持数据本地化（Data Locality）优化，尽可能地将任务分配给与数据在同一节点或同一机架的Executor线程。</li><li>合并结果：当所有任务执行完毕后，Presto会将各个任务的结果进行合并，并返回给客户端。在合并结果时，Presto会进行优化，例如对于聚合查询（例如SUM、AVG、MAX等），Presto会在每个节点上进行局部聚合（Partial Aggregation），并在最后一个任务上进行全局聚合（Final Aggregation）。</li><li>清理资源：Presto在执行查询后会释放占用的资源，包括内存、CPU、网络等。Presto还支持查询取消（Cancellation）和查询超时（Timeout）机制，以保证查询不会长时间占用集群资源。
在Presto中，数据是以Page的形式在节点之间传输。Page是Presto中的数据块，它是由一系列的行（Row）组成的，行中的每个字段都被序列化为一个字节数组。在任务执行过程中，Presto会将Page从一个节点传输到另一个节点，以便在不同节点之间共享数据。因为Page是Presto中最基本的数据单位，所以Presto的很多内部实现都是以Page为基础的。</li></ol><p>Presto内存并行计算的过程可以概括为将查询分解为多个Stage，每个Stage包含多个Task，每个Task包含一个或多个Operator。Task会被分配给多个Worker并行执行，Worker之间通过网络传输数据和交换结果，最终返回给协调器的结果会被整合成最终的查询结果。在计算过程中，Presto使用内存中的Page传递数据，这种分布式计算模型可以有效提高计算性能和并发能力。</p><h1 id=优化器>优化器</h1><h2 id=优化策略>优化策略</h2><p>优化器主要负责将查询计划转换为一组高效的执行计划，以便在分布式系统中高效地执行查询。Presto优化器的主要优化策略如下：</p><ol><li>查询重写：Presto优化器会对查询进行重写，以利用索引、分区和其他优化手段来加速查询。重写后的查询可以更好地利用存储系统和网络带宽资源，从而提高查询性能。</li><li>消除冗余计算：Presto会分析查询计划，消除冗余计算，避免在计算过程中重复处理相同的数据。这样可以减少计算量和数据传输量，提高查询效率。</li><li>选择合适的Join算法：Presto优化器会根据查询计划中Join的大小、数据分布和数据类型等因素，选择合适的Join算法，包括Broadcast Join、Hash Join和Sort Merge Join等。</li><li>分区裁剪：对于分区表，Presto优化器会分析查询条件，并根据条件过滤掉不需要的分区，避免在查询过程中扫描所有分区，从而提高查询性能。</li><li>并行查询：Presto优化器会将查询计划分解成多个Stage和Task，以利用分布式系统中的多核和多节点资源，并行执行查询，提高查询效率。</li><li>动态编译：Presto优化器支持动态编译，即将查询计划转换为可执行的机器代码，并将其缓存起来，以便下次查询时可以直接使用，避免重复编译和优化，从而提高查询性能。
通过这些优化策略的应用，Presto可以实现高效、可扩展的分布式查询处理，适用于大规模数据集的查询分析场景。</li></ol><h2 id=主要优化点>主要优化点</h2><p>Presto作为一个交互式的查询引擎，如何实现低延时查询，一些传统的SQL优化原理，主要是下面几个方面：</p><ol><li><p>分布式查询：Presto使用分布式架构进行查询，可以将查询任务分配到集群中的多个节点上并行执行，从而提高查询的并发性和速度。</p></li><li><p>内存计算：Presto使用内存计算来处理数据，可以避免I/O瓶颈，提高计算速度。</p></li><li><p>压缩和编码：Presto使用高效的压缩和编码算法，可以减少数据传输的开销，提高查询的速度。</p></li><li><p>灵活的优化器：Presto具有灵活的查询优化器，可以自动优化查询计划以最大化查询性能。</p></li><li><p>支持多种数据源：Presto可以查询多种数据源，包括Hadoop、Cassandra、MySQL等，可以无缝访问不同数据源的数据，提高查询效率。
具体有以下几个点：</p></li><li><p>完全基于内存的并行计算</p></li><li><p>流水线执行</p></li><li><p>本地化计算</p></li><li><p>动态编译执行计划</p></li><li><p>优化使用内存和数据结构</p></li><li><p>近似查询</p></li><li><p>GC控制</p></li></ol><h2 id=流水线>流水线</h2><h3 id=节点内部流水线计算>节点内部流水线计算</h3><p>Presto的查询处理流程是通过一系列的节点内部流水线计算来实现的，以下是Presto节点内部流水线计算的基本过程：</p><ol><li>分割数据：Presto通过切分查询任务，将数据分割成多个小块，每个小块包含了一个或多个数据分片。这些小块可以在不同的节点上并行处理。</li><li>执行扫描：每个节点都会读取一些数据分片，并执行扫描操作，例如过滤、排序和聚合等。这些操作通常使用流水线计算模型，每个操作的结果会被传递到下一个操作中进行处理。</li><li>执行计算：扫描操作的结果会被传递到计算操作中，例如计算表达式、聚合函数和连接操作等。这些操作也通常使用流水线计算模型，每个操作的结果会被传递到下一个操作中进行处理。</li><li>执行输出：最后，节点会将计算操作的结果输出到客户端或下一个节点中进行处理。输出操作通常包括将数据序列化、压缩和发送等。
Presto节点内部流水线计算是高效的，利用了现代计算机硬件的并行性和内存计算能力，可以有效地处理大规模数据集，提高查询性能。</li></ol><h3 id=节点间流水线计算>节点间流水线计算</h3><p>Presto是一个分布式查询引擎，可以将查询任务分配到集群中的多个节点上并行执行，节点之间的流水线计算是Presto实现分布式查询的核心。</p><p>Presto的节点之间流水线计算的基本过程如下：</p><ol><li>数据分片：查询任务的数据会被分割成多个小块，并分配给集群中的不同节点。每个节点会处理自己负责的数据分片，然后将结果传递给下一个节点。</li><li>执行扫描：每个节点会读取自己负责的数据分片，并执行扫描操作，例如过滤、排序和聚合等。这些操作通常使用流水线计算模型，每个操作的结果会被传递到下一个节点中进行处理。</li><li>数据重分片：为了确保节点之间的负载均衡，Presto会对数据进行重新分片，以便将数据均匀地分配给集群中的不同节点。</li><li>执行计算：重分片后，每个节点会执行计算操作，例如计算表达式、聚合函数和连接操作等。这些操作也通常使用流水线计算模型，每个操作的结果会被传递到下一个节点中进行处理。</li><li>执行输出：最后，节点会将计算操作的结果输出到客户端或下一个节点中进行处理。输出操作通常包括将数据序列化、压缩和发送等。
Presto的节点之间流水线计算是分布式的，需要高效地处理节点之间的数据传输和通信，以实现高性能的查询。Presto使用了一系列高效的网络传输协议和数据格式，以最小化数据传输的开销，并通过智能的节点调度算法动态调整节点的负载，以确保查询的性能和可靠性。</li></ol><h2 id=本地化计算>本地化计算</h2><p>Presto的本地化计算指的是在一个节点上执行查询任务，而不需要将数据发送到其他节点进行处理。这种本地化计算可以有效地减少数据传输和通信的开销，提高查询的性能和效率。</p><p>Presto的本地化计算主要有以下两种方式：</p><ol><li>全部本地化：当查询的数据全部位于一个节点上时，Presto会将查询任务分配到该节点进行处理，这种方式可以最大程度地减少数据传输和通信的开销，提高查询性能。</li><li>部分本地化：当查询的数据分布在多个节点上时，Presto会将查询任务分成多个子任务，其中一部分子任务会分配到本地节点进行处理，另一部分子任务会发送到其他节点进行处理。这种方式可以在尽可能减少数据传输和通信开销的同时，充分利用集群中所有节点的计算资源，提高查询效率。
Presto的本地化计算需要具备一定的硬件和软件支持，例如高速网络和内存计算等。此外，Presto还提供了一系列高级优化功能，例如动态过滤、预读取和预聚合等，可以进一步提高本地化计算的性能和效率。</li></ol><p>Presto在选择Source任务计算节点时，对于每一个Split，会按照以下策略选择一些minCandidates：</p><ol><li><p>优先选择与Split同一个Host的Worker节点</p></li><li><p>如果节点不够优先选择与Split同一个Rack的Worker节点</p></li><li><p>如果节点还不够随机选择其他Rack的节点
对于所有Candidate节点，选择assignedSplits最少的节点。除此之外，会按照以下策略优先选择选择节点：</p></li><li><p>负载均衡：调度器会根据每个节点的负载情况来选择计算节点。负载越低的节点，越有可能被选为计算节点。</p></li><li><p>资源利用率：调度器会计算每个节点的资源利用率，包括CPU、内存和磁盘等资源的使用情况。资源利用率越高的节点，越不可能被选为计算节点。</p></li><li><p>数据位置：如果Split的数据位于某个节点上，那么该节点很可能会被选为计算节点，以避免不必要的数据传输。</p></li><li><p>处理时间：调度器会根据Split的大小和节点的处理能力，计算每个节点处理该Split所需的时间。处理时间越短的节点，越有可能被选为计算节点。</p></li><li><p>网络延迟和带宽：调度器会考虑网络延迟和数据传输带宽等因素，以确保数据传输和通信的效率和稳定性。</p></li><li><p>容错能力：调度器还会考虑节点之间的负载均衡和容错能力等因素，以确保整个查询任务的性能和可靠性。例如，调度器可能会选择多个计算节点来处理同一个Split，以提高计算性能和容错能力。
Presto的调度器是动态的，会根据集群的负载和资源情况等因素实时调整计算节点的选择策略，以最大程度地提高查询的性能和效率。</p></li></ol><h2 id=动态编译执行计划>动态编译执行计划</h2><p>Presto会将执行计划中的ScanFilterAndProjectOperator和FilterAndProjectOperator动态编译为字节码（Bytecode），并交给JIT去编译为本地机器码（Native Code）。Presto也使用了Google Guava提供的LoadingCache缓存生成的Byte Code。Presto将生成的本地机器码加载到内存中，并使用它来执行操作符。</p><p>Presto采用了延迟编译的策略，即只有在需要执行操作符时才会进行编译。这种策略可以减少不必要的编译开销，并提高查询的性能。</p><h2 id=优化内存数据结构>优化内存数据结构</h2><p>使用 Slice 进行内存操作，Slice使用Unsafe#copyMemory实现了高效的内存拷贝。Slice仓库：<a href=https://github.com/airlift/slice>https://github.com/airlift/slice</a>。写性能提高20%-30%。（<a href=https://engineering.fb.com/2014/04/10/core-data/scaling-the-facebook-data-warehouse-to-300-pb/>https://engineering.fb.com/2014/04/10/core-data/scaling-the-facebook-data-warehouse-to-300-pb/</a>）</p><h2 id=近似查询算法>近似查询算法</h2><p>为了加快avg、count distinct、percentile等聚合函数的查询速度，与BlinkDB合作引入了一些近似查询函数approx_avg、approx_distinct、approx_percentile。approx_distinct使用HyperLogLog Counting算法实现。</p><h2 id=gc控制>GC控制</h2><p>Presto团队在使用hotspot java7时发现了一个JIT的BUG，当代码缓存快要达到上限时，JIT可能会停止工作，从而无法将使用频率高的代码动态编译为native代码。</p><p>Presto团队使用了一个比较Hack的方法去解决这个问题，增加一个线程在代码缓存达到70%以上时进行显式GC，使得已经加载的Class从perm中移除，避免JIT无法正常工作的BUG。</p><h1 id=reference>Reference</h1><p><a href=https://github.com/airlift/slice>https://github.com/airlift/slice</a></p><p><a href=https://engineering.fb.com/2014/04/10/core-data/scaling-the-facebook-data-warehouse-to-300-pb/>https://engineering.fb.com/2014/04/10/core-data/scaling-the-facebook-data-warehouse-to-300-pb/</a></p><p><a href=https://tech.meituan.com/2014/06/16/presto.html>Presto实现原理和美团的使用实践</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-25d0fe449057e0f0f6bfe7f9d5f135fb>6 - PostgreSQL</h1><h1 id=introduction>Introduction</h1><p>PostgreSQL</p></div><div class=td-content><h1 id=pg-0d82a348ae5eecde6b38ed1859d66c02>6.1 - PostgreSQL基础使用入门</h1><h1 id=简介>简介</h1><p>PostgreSQL是一个功能非常强大的、源代码开放的客户/服务器关系型数据库管理系统（RDBMS），在BSD许可证下发型。PostgreSQL简称PG。</p><p>Slogan 是“世界上最先进的开源关系型数据库”。“开源界的Oracle”。</p><p>PostgreSQL 官网：<a href=https://www.postgresql.org/>https://www.postgresql.org/</a></p><p>PostgreSQL 中文社区：<a href=http://www.postgres.cn/v2/home>http://www.postgres.cn/v2/home</a></p><p>另外再数据库排行榜中也可以看到 PG 的受欢迎程度。</p><p>全球数据库排行：<a href=https://db-engines.com/en/ranking>https://db-engines.com/en/ranking</a></p><p>国产数据库排行：<a href=https://www.modb.pro/dbrank>https://www.modb.pro/dbrank</a></p><h2 id=历史>历史</h2><p>PostgreSQL 最初设想于1986年，当时被叫做Berkley Postgres Project。该项目一直到1994年都处于演进和修改中，直到开发人员Andrew Yu和Jolly Chen在Postgres中添加了一个SQL（Structured Query Language，结构化查询语言）翻译程序，该版本叫做Postgres95，在开放源代码社区发放。</p><p>1996年，再次对Postgres95做了较大的改动，并将其作为PostgresSQL6.0版发布。该版本的Postgres提高了后端的速度，包括增强型SQL92标准以及重要的后端特性（包括子选择、默认值、约束和触发器）。</p><p>2005年，发布8.0版本，开始支持Windows系统环境。</p><p>2010年9月20日发布了PostgreSQL 9.0，大大增强了复制的功能(replication)，比如增加了流复制功能(stream replicaction)和HOT standby功能。</p><p>PostgreSQL 9.0：支持64位Windows系统，异步流数据复制、Hot Standby。</p><p>PostgreSQL 9.1：支持数据同步复制，unlogged tables、serializable snapshot isolation、FDW外部表等。此版本后，开始得到中国多个行业用户的关注，开始应用于电信、保险、制造业等边缘系统。</p><p>2019年，PostgreSQL 12 版本发布，这也是目前生产环境主流的版本。2021年，PostgreSQL 14 版本发布。</p><h2 id=社区>社区</h2><h3 id=纯社区>纯社区</h3><p>纯社区，没有被商业公司控制</p><p><img src=../imgs/20230109_postgresql_1.png alt=20230109_postgresql_1.png></p><p>最终用户都希望社区长久，期望可以享受免费的、可持续发展、开源的、不被任何商业公司或国家控制的企业级数据库，不靠数据库赚钱。</p><p>云厂商基于PG的好处：</p><ul><li>免去自己培养生态</li><li>避免重复造轮子</li><li>PG代码基础非常不错</li><li>防止其他厂商控制PG失去市场主导能力（赞助商：AWS/google/IBM/微软）</li></ul><h3 id=开源许可独特性>开源许可独特性</h3><p>PostgreSQL遵守BSD许可证发型，使得开发者们得以获取源代码进一步开发系统。</p><p>BSD许可协议（Berkeley Software Distribution license）是自由软件中使用最广泛的许可协议之一。BSD遵照该许可证来发布，BSD许可证比较宽松，甚至跟共有领域更为接近。BSD的后续版本可以选择要继续是BSD或其他自由软件条款或封闭软件等。</p><p>众所周知，MySQL倍Oracle所控制，MySQL同时使用了GPL和一种商业许可（称为双重许可）。</p><p>GPL(General Public License)是公共许可，遵循了GPL的软件是公共的。如果某软件使用GPL软件，那么该软件也需要开源，如果不开源就不能使用GPL软件，这和是否把该软件商用与否没有关系。</p><p>如果无法满足GPL，就需要获得商业许可，通过与Oracle公司联系，指定解决方案，受Oracle公司约束。</p><p>同为开源软件，PostgreSQL源码使用自由友好，商业应用不受任何公司实体所控制，而MySQL在一定程度上有所限制。</p><h2 id=与mysql比较>与MySQL比较</h2><p>PostgreSQL的优势：</p><ul><li><p>在SQL的标准实现上要比MySQL完善，而且功能实现比较严谨</p></li><li><p>对表链接支持较完整，优化器功能较完整，支持的索引类很多，复杂查询能力较强</p></li><li><p>PG主表采用堆表存放，MySQL采用索引组织表，能够支持MySQL更大的数据量</p></li><li><p>PG主备复制属于物理复制，相对MySQL基于binlog的逻辑复制，数据的一致性更加可靠，复制性能更高，对主机性能影响更小</p></li><li><p>PostgreSQL支持JSON和其他NoSQL功能，如本机XML支持和使用HSTORE的键值对。还支持索引JSON数据以加快访问速度，特别是10版本JSONB更强大</p></li><li><p>PostgreSQL基于BSD协议完全免费，在其基础上修改然后商用也是可以的，使得PG不会被其它公司控制。而MySQL主要被Oracle公司控制
PostgreSQL的劣势：</p></li><li><p>innodb 基于回滚段实现的 MVCC 机制，相对 PG 新老数据一起存放的基于 XID 的 MVCC 机制是更好的。新老数据一起存放需要定时触发 VACUUM，会带来多余的IO和数据库对象加锁开销，引起整体并发能力下降。且 VACUUM 清理不及时回引发数据膨胀。</p></li><li><p>MySQL采用索引组织表，这种存储方式适合基于主键匹配的查询、删改操作，但对表结构设计存在约束。</p></li><li><p>MySQL优化器较简单，系统表、运算符、数据类型的实现都很精简，非常适合简单的查询操作。</p></li><li><p>MySQL相比PG在国内的流行度更高。</p></li><li><p>MySQL存储引擎插件化机制，使得应用场景更加广泛，如innodb适合事务处理场景外，myisam适合静态数据的查询场景。
从应用场景来说，PG更加适合严格的企业应用场景（比如金融、电信、ERP、CRM），且其 json、jsonb、hstore 等数据格式，特别适用于一些大数据格式的分析。而 MySQL 更加适合业务逻辑相对简单、数据可靠性要求较低的互联网场景（如google、alibaba等），当然MySQL在innodb引擎的大力发展下功能表现良好。</p></li></ul><h2 id=特性>特性</h2><p>PG拥有众多开放特性：</p><ul><li>开放的数据类型接口：除了传统数据库支持的类型，还支持GIS，JSON，RANGE，IP，ISBN，图像特征值，化学，DNA等等扩展的类型，还可以根据实际业务扩展更多的类型。</li><li>开放的操作符接口：不仅支持常见的类型操作符，还支持扩展的操作符，例如距离符，逻辑并、交、差符号，图像相似符号，几何计算符号等等扩展的符号，用户还可以根据实际业务扩展更多的操作符。</li><li>开放的外部数据源接口：PG支持丰富的外部数据源，例如可以通过FDW读写mysql, redis, mongo, oracle, sqlserver, hive, www, hbase, ldap等等，只要你能想到的数据源都可以通过FDW接口读写。</li><li>开放的语言接口：使得PG支持几乎地球上所有的编程语言作为数据库的函数、存储过程语言，例如plpython , plperl , pljava , plR , plCUDA , plshell等等。用户可以通过language handler扩展PG的语言支持。</li><li>开放的索引接口：使得PG支持非常丰富的索引方法，例如btree , hash , gin , gist , sp-gist , brin , bloom , rum , zombodb , bitmap (greenplum extend)，用户可以根据不同的数据类型，以及查询的场景，选择不同的索引。</li><li>PG内部还支持BitmapAnd, BitmapOr的优化方法，可以合并多个索引的扫描操作，从而提升多个索引数据访问的效率。</li></ul><h1 id=安装>安装</h1><h2 id=下载>下载</h2><p>官网下载地址：<a href=https://www.postgresql.org/download/>https://www.postgresql.org/download/</a></p><h2 id=安装-1>安装</h2><h3 id=windows>Windows</h3><p>直接下载安装，安装过程中设置密码，用户名默认为 postgres。</p><h3 id=linux>Linux</h3><p>参考官方文档安装，添加源、执行脚本等等，不同发型版本有些许差别。</p><p>如 Debian 系统安装：<a href=https://www.postgresql.org/download/linux/debian/>https://www.postgresql.org/download/linux/debian/</a></p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>sudo sh -c <span style=color:#c41a16>&#39;echo &#34;deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main&#34; &gt; /etc/apt/sources.list.d/pgdg.list&#39;</span>
</span></span><span style=display:flex><span>wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
</span></span><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get -y install postgresql
</span></span><span style=display:flex><span><span style=color:#177500># sudo apt-get -y install postgresql-14  # 指定版本</span>
</span></span></code></pre></td></tr></table></div></div></div><p>如 CentOS 系统安装：<a href=https://www.postgresql.org/download/linux/redhat/>https://www.postgresql.org/download/linux/redhat/</a><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-6-x86_64/pgdg-redhat-repo-latest.noarch.rpm
</span></span><span style=display:flex><span>sudo yum install -y postgresql14-server
</span></span><span style=display:flex><span>sudo service postgresql-14 initdb
</span></span><span style=display:flex><span>sudo chkconfig postgresql-14 on
</span></span><span style=display:flex><span>sudo service postgresql-14 start
</span></span></code></pre></td></tr></table></div></div></div></p><h2 id=使用>使用</h2><h3 id=windows-1>Windows</h3><p>界面工具：</p><p>官方自带的 pgAdmin 工具。</p><p>命令行工具：</p><p>官方自带的 SQL Shell (psql) 终端工具。</p><p>三方界面工具：</p><p>如Navicat，PG默认端口为 5432。</p><p>注意：PG默认不允许远程连接，需要修改安装目录下 data/pg_hba 文件配置：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span># IPv4 local connections:
</span></span><span style=display:flex><span>host all  all 127.0.0.1/32  scram-sha-256
</span></span><span style=display:flex><span>host all  all 0.0.0.0/32  scram-sha-256 # 增加一行
</span></span></code></pre></td></tr></table></div></div></div><p>然后重启服务。</p><blockquote><p>windows打开服务管理界面（可通过services.msc），重启 postgresql-x64-xx。
注意防火墙也需要关闭。</p></blockquote><h3 id=linux-1>Linux</h3><p>初始化数据库：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>sudo yum install -y postgresql14-server
</span></span></code></pre></td></tr></table></div></div></div><p>启动服务：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 设置开机启动</span>
</span></span><span style=display:flex><span>sudo systemctl <span style=color:#a90d91>enable</span> postgresql-14
</span></span><span style=display:flex><span><span style=color:#177500># 启动服务</span>
</span></span><span style=display:flex><span>sudo systemctl start postgresql-14
</span></span></code></pre></td></tr></table></div></div></div></p><p>修改密码：</p><p>安装成功后会默认创建一个名为 postgres 的 Linux 用户，初始化数据库后会有名为 postgres 的数据库（相当于MySQL中的名为mysql的数据库）。</p><p>进入PG命令行：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>su postgres
</span></span><span style=display:flex><span><span style=color:#177500># 启动 SQL Shell</span>
</span></span><span style=display:flex><span>psql
</span></span><span style=display:flex><span><span style=color:#177500># 修改密码</span>
</span></span><span style=display:flex><span>ALTER USER postgres WITH PASSWORD <span style=color:#c41a16>&#39;NewPassword&#39;</span>
</span></span><span style=display:flex><span><span style=color:#c41a16>\q</span> <span style=color:#177500># 退出</span>
</span></span><span style=display:flex><span><span style=color:#177500># 重新进入 SQL Shell</span>
</span></span><span style=display:flex><span>psql
</span></span></code></pre></td></tr></table></div></div></div><p>配置远程访问：</p><p>1、开放端口</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>sudo firewall-cmd --add-port<span style=color:#000>=</span>5432/tcp --permanent
</span></span><span style=display:flex><span>sudo firewall-cmd --reload
</span></span></code></pre></td></tr></table></div></div></div><p>2、修改IP绑定<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 修改配置文件</span>
</span></span><span style=display:flex><span>vi /var/lib/pgsql/14/data/postgresql.conf
</span></span><span style=display:flex><span><span style=color:#177500># 修改监听地址</span>
</span></span><span style=display:flex><span><span style=color:#177500># 默认 listen_addresses 配置是注释掉的，可以直接在配置文件开头加入该行</span>
</span></span><span style=display:flex><span><span style=color:#000>listen_addresses</span><span style=color:#000>=</span><span style=color:#c41a16>&#39;*&#39;</span>
</span></span></code></pre></td></tr></table></div></div></div></p><p>3、允许所有IP访问<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 修改配置文件</span>
</span></span><span style=display:flex><span>vi /var/lib/pgsql/14/data/pg_hba.conf
</span></span><span style=display:flex><span><span style=color:#177500># 在文件尾部加入</span>
</span></span><span style=display:flex><span>host  all  all 0.0.0.0/0 md5
</span></span></code></pre></td></tr></table></div></div></div></p><p>4、重启服务<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl restart postgresql-14
</span></span></code></pre></td></tr></table></div></div></div></p><h1 id=数据类型>数据类型</h1><p>创建表时必须使用数据类型，PG主要有以下几类数据类型：</p><ul><li>数值数据类型<ul><li>smallint：2字节</li><li>integer：4字节</li><li>bigint：8字节</li><li>decimal：可变长</li><li>numeric：可变长</li><li>real：4字节</li><li>double：8字节</li></ul></li><li>字符串数据类型<ul><li>char</li><li>varchar</li><li>text</li></ul></li><li>日期/时间数据类型<ul><li>timestamp：日期和时间</li><li>date：日期</li><li>time：时间</li></ul></li><li>数组类型<ul><li>int[]</li><li>text[]</li><li>int[][]</li></ul></li><li>json/jsonb类型<ul><li>json</li><li>jsonb</li></ul></li><li>xml类型</li><li>货币类型<ul><li>money</li></ul></li><li>布尔<ul><li>boolean</li></ul></li><li>空间几何类型<ul><li>point</li><li>line</li><li>box</li><li>path</li><li>circle</li></ul></li><li>网络地址类型<ul><li>inet</li><li>macaddr</li></ul></li><li>位串<ul><li>bit</li></ul></li><li>uuid类型</li><li>复合类型<ul><li>CREATE TYPE complex AS(a int, b int)</li></ul></li><li>范围类型<ul><li>int4range</li><li>numrange</li><li>daterange</li></ul></li></ul><h1 id=基本使用>基本使用</h1><h2 id=控制台常用命令>控制台常用命令</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#c41a16>\p</span>assword命令（设置密码）
</span></span><span style=display:flex><span><span style=color:#c41a16>\q</span>命令（退出）
</span></span><span style=display:flex><span><span style=color:#c41a16>\h</span>：查看SQL命令的解释，比如<span style=color:#c41a16>\h</span> <span style=color:#a90d91>select</span>
</span></span><span style=display:flex><span><span style=color:#c41a16>\?</span>：查看psql命令列表
</span></span><span style=display:flex><span><span style=color:#c41a16>\l</span>：列出所有数据库
</span></span><span style=display:flex><span><span style=color:#c41a16>\c</span> <span style=color:#000>[</span>database_name<span style=color:#000>]</span>：连接其他数据库
</span></span><span style=display:flex><span><span style=color:#c41a16>\d</span>：列出当前数据库的所有表格
</span></span><span style=display:flex><span><span style=color:#c41a16>\d</span> <span style=color:#000>[</span>table_name<span style=color:#000>]</span>：列出某一张表格的结构
</span></span><span style=display:flex><span><span style=color:#c41a16>\d</span>u：列出所有用户
</span></span></code></pre></td></tr></table></div></div></div><h2 id=登录>登录</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#000>psql</span> <span style=color:#000>-</span><span style=color:#000>h</span> <span style=color:#000>服务器</span> <span style=color:#000>-</span><span style=color:#000>U</span> <span style=color:#000>用户名</span> <span style=color:#000>-</span><span style=color:#000>d</span> <span style=color:#000>数据库</span> <span style=color:#000>-</span><span style=color:#000>p</span> <span style=color:#000>端口地址</span> <span style=color:#000>#</span> <span style=color:#000>-</span><span style=color:#000>U</span> <span style=color:#000>大写</span>
</span></span><span style=display:flex><span><span style=color:#000>$</span> <span style=color:#000>psql</span> <span style=color:#000>-</span><span style=color:#000>U</span> <span style=color:#000>dbuser</span> <span style=color:#000>-</span><span style=color:#000>d</span> <span style=color:#000>example</span> <span style=color:#000>-</span><span style=color:#000>h</span> <span style=color:#1c01ce>127</span>.<span style=color:#1c01ce>0</span>.<span style=color:#1c01ce>01</span> <span style=color:#000>-</span><span style=color:#000>p</span> <span style=color:#1c01ce>5432</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>#</span> (<span style=color:#000>连接数据库，默认用户名和数据库都是</span> <span style=color:#000>postgres</span>)
</span></span><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#000>相当于系统用户</span><span style=color:#000>postgres以同名数据库用户的身份登录数据库</span><span style=color:#000>，不用输入密码，</span>
</span></span><span style=display:flex><span><span style=color:#000>#</span> <span style=color:#000>提示符变为</span> <span style=color:#000>postgres</span><span style=color:#000>=#</span> <span style=color:#000>表示成功进入</span>
</span></span><span style=display:flex><span><span style=color:#000>$</span> <span style=color:#000>psql</span> 
</span></span></code></pre></td></tr></table></div></div></div><h2 id=数据库操作>数据库操作</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 创建数据库</span>
</span></span><span style=display:flex><span>CREATE DATABASE mydb;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500># 查看所有数据库</span>
</span></span><span style=display:flex><span><span style=color:#c41a16>\l</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500># 切换当前数据库</span>
</span></span><span style=display:flex><span><span style=color:#c41a16>\c</span> mydb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500># 删除数据库</span>
</span></span><span style=display:flex><span>drop database &lt;dbname&gt;
</span></span></code></pre></td></tr></table></div></div></div><h2 id=数据库表操作>数据库表操作</h2><p>初级用法：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500>#创建表</span>
</span></span><span style=display:flex><span>CREATE TABLE test<span style=color:#000>(</span>id int,body varchar<span style=color:#000>(</span>100<span style=color:#000>))</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#在表中插入数据</span>
</span></span><span style=display:flex><span>insert into test<span style=color:#000>(</span>id,body<span style=color:#000>)</span> values<span style=color:#000>(</span>1,<span style=color:#c41a16>&#39;hello,postgresql&#39;</span><span style=color:#000>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#查看当前数据库下所有表</span>
</span></span><span style=display:flex><span><span style=color:#c41a16>\d</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#查看表结构，相当于desc</span>
</span></span><span style=display:flex><span><span style=color:#c41a16>\d</span> <span style=color:#a90d91>test</span>
</span></span></code></pre></td></tr></table></div></div></div><p>增加属性：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500>#创建表</span>
</span></span><span style=display:flex><span>CREATE TABLE COMPANY<span style=color:#000>(</span>
</span></span><span style=display:flex><span>   ID  SERIAL PRIMARY KEY,
</span></span><span style=display:flex><span>   NAME           TEXT      NOT NULL,
</span></span><span style=display:flex><span>   AGE            INT       NOT NULL,
</span></span><span style=display:flex><span>   ADDRESS        CHAR<span style=color:#000>(</span>50<span style=color:#000>)</span>,
</span></span><span style=display:flex><span>   SALARY         REAL
</span></span><span style=display:flex><span><span style=color:#000>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#插入数据</span>
</span></span><span style=display:flex><span>INSERT INTO COMPANY <span style=color:#000>(</span>NAME,AGE,ADDRESS,SALARY<span style=color:#000>)</span>
</span></span><span style=display:flex><span>VALUES <span style=color:#000>(</span> <span style=color:#c41a16>&#39;Paul&#39;</span>, 32, <span style=color:#c41a16>&#39;California&#39;</span>, 20000.00 <span style=color:#000>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>INSERT INTO COMPANY <span style=color:#000>(</span>NAME,AGE,ADDRESS,SALARY<span style=color:#000>)</span>
</span></span><span style=display:flex><span>VALUES <span style=color:#000>(</span><span style=color:#c41a16>&#39;Allen&#39;</span>, 25, <span style=color:#c41a16>&#39;Texas&#39;</span>, 15000.00 <span style=color:#000>)</span>;
</span></span></code></pre></td></tr></table></div></div></div></p><h2 id=schema>Schema</h2><p>PG模式（SCHEMA）可以看着是一个表的集合。</p><p>一个模式可以包含视图、索引、数据类型、函数和操作符等。</p><p>相同的对象名称可以被用于不同的模式中不会出现冲突，例如 schema1 和 schema2 都可以包含名为 table1 的表。</p><p>使用模式的优势：</p><ul><li>允许多个用户使用一个数据库且互相不干扰</li><li>将数据库对象组织成逻辑组以便更容易管理</li><li>第三方应用的对象可以放在独立的模式中，不会与其他对象的名称发生冲突
模式类似于操作系统层的目录，但是模式不能嵌套。</li></ul><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500>#创建schema： </span>
</span></span><span style=display:flex><span>create schema schema1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>create table schema1.company<span style=color:#000>(</span>
</span></span><span style=display:flex><span>   ID   INT              NOT NULL,
</span></span><span style=display:flex><span>   NAME VARCHAR <span style=color:#000>(</span>20<span style=color:#000>)</span>     NOT NULL,
</span></span><span style=display:flex><span>   AGE  INT              NOT NULL,
</span></span><span style=display:flex><span>   ADDRESS  CHAR <span style=color:#000>(</span>25<span style=color:#000>)</span>,
</span></span><span style=display:flex><span>   SALARY   DECIMAL <span style=color:#000>(</span>18, 2<span style=color:#000>)</span>,
</span></span><span style=display:flex><span>   PRIMARY KEY <span style=color:#000>(</span>ID<span style=color:#000>)</span>
</span></span><span style=display:flex><span><span style=color:#000>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#删除schema： </span>
</span></span><span style=display:flex><span>drop schema schema1；
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#删除一个模式以及其中包含的所有对象：</span>
</span></span><span style=display:flex><span>DROP SCHEMA schema1 CASCADE;
</span></span></code></pre></td></tr></table></div></div></div><h2 id=备份数据库>备份数据库</h2><h3 id=单数据库>单数据库</h3><p>PG提供了 pg_dump 来简化备份单个数据库的过程。前提：用户必须有数据库的读取权限：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 以 postgres 用户登录</span>
</span></span><span style=display:flex><span>sudo su - postgres
</span></span><span style=display:flex><span><span style=color:#177500># 备份到文件</span>
</span></span><span style=display:flex><span>pg_dump mydbname &gt; mydbname.bak
</span></span><span style=display:flex><span><span style=color:#177500># 可以使用 scp 等命令将文件拷贝到其它机器，</span>
</span></span><span style=display:flex><span>然后使用 psql 恢复数据库
</span></span><span style=display:flex><span>psql <span style=color:#a90d91>test</span> &lt; mydbname.bak
</span></span></code></pre></td></tr></table></div></div></div><p>备份格式：</p><ul><li>.bak：压缩二进制格式</li><li>.sql：明文转储</li><li>.tar：</li></ul><h3 id=多数据库>多数据库</h3><p>pg_dump 一次只创建一个数据库的备份，不会存储有关数据库角色或其他群集范围配置的信息。 要存储此信息并同时备份所有数据库，可以使用 pg_dumpall。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>pg_dumpall &gt; pg_backup.bak
</span></span><span style=display:flex><span><span style=color:#177500># 从备份还原数据库</span>
</span></span><span style=display:flex><span>psql -f pg_backup.bak postgres
</span></span></code></pre></td></tr></table></div></div></div><p>Demo：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500>#备份数据库</span>
</span></span><span style=display:flex><span>$ pg_dump -U postgres -f /tmp/postgres.sql postgres <span style=color:#000>(</span>导出postgres数据库保存为postgres.sql<span style=color:#000>)</span>
</span></span><span style=display:flex><span>$ pg_dump -U postgres -f /tmp/postgres.sql -t <span style=color:#a90d91>test</span> postgres <span style=color:#000>(</span>导出postgres数据库中表test的数据<span style=color:#000>)</span>
</span></span><span style=display:flex><span>$ pg_dump -U postgres -F t -f /tmp/postgres.tar postgres <span style=color:#000>(</span>导出postgres数据库以tar形式压缩保存为postgres.tar<span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#恢复数据库</span>
</span></span><span style=display:flex><span>$ psql -U postgres -f /tmp/postgres.sql bk01 <span style=color:#000>(</span>恢复postgres.sql数据到bk01数据库<span style=color:#000>)</span>
</span></span><span style=display:flex><span><span style=color:#177500>#pg_restore --  从pg_dump创建的备份文件中恢复PostgreSQL数据库,用于恢复由pg_dump 转储的任何非纯文本格式中的PostgreSQL数据库。</span>
</span></span><span style=display:flex><span>$ pg_restore -U postgres -d bk01 /tmp/postgres.tar  <span style=color:#000>(</span>恢复postgres.tar数据到bk01数据库<span style=color:#000>)</span>
</span></span></code></pre></td></tr></table></div></div></div></p><h2 id=用户操作>用户操作</h2><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500>#创建用户并设置密码</span>
</span></span><span style=display:flex><span>CREATE USER <span style=color:#c41a16>&#39;username&#39;</span> WITH PASSWORD <span style=color:#c41a16>&#39;password&#39;</span>;
</span></span><span style=display:flex><span>CREATE USER <span style=color:#a90d91>test</span> WITH PASSWORD <span style=color:#c41a16>&#39;test&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#修改用户密码</span>
</span></span><span style=display:flex><span>$ ALTER USER <span style=color:#c41a16>&#39;username&#39;</span> WITH PASSWORD <span style=color:#c41a16>&#39;password&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#数据库授权,赋予指定账户指定数据库所有权限</span>
</span></span><span style=display:flex><span>$ GRANT ALL PRIVILEGES ON DATABASE <span style=color:#c41a16>&#39;dbname&#39;</span> TO <span style=color:#c41a16>&#39;username&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#将数据库 mydb 权限授权于 test</span>
</span></span><span style=display:flex><span>GRANT ALL PRIVILEGES ON DATABASE mydb TO test;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#但此时用户还是没有读写权限，需要继续授权表</span>
</span></span><span style=display:flex><span>GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO xxx;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#注意，该sql语句必须在所要操作的数据库里执行</span>
</span></span><span style=display:flex><span><span style=color:#177500>#移除指定账户指定数据库所有权限</span>
</span></span><span style=display:flex><span>REVOKE ALL PRIVILEGES ON DATABASE mydb from <span style=color:#a90d91>test</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>#删除用户</span>
</span></span><span style=display:flex><span>drop user <span style=color:#a90d91>test</span>
</span></span><span style=display:flex><span><span style=color:#177500># 查看用户</span>
</span></span><span style=display:flex><span><span style=color:#c41a16>\d</span>u
</span></span></code></pre></td></tr></table></div></div></details><br><p>pg_hba.conf配置中的第一项设置表示：本地用户通过unix socket登陆时，使用peer方式认证。<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span># &#34;local&#34; is for Unix domain socket connections only
</span></span><span style=display:flex><span>local   all             all                                     peer
</span></span></code></pre></td></tr></table></div></div></div></p><p>在peer方式中，client必须和PG在同一台机器上。peer使用PostgreSQL所在的操作系统上的用户登陆，只要当前系统用户和登录PG的用户名相同就可以正常登录。</p><blockquote><p>部署PG后，切换到系统的postgres用户，直接执行psql就能进入PG就是这个原因。</p></blockquote><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 创建没有密码的用户</span>
</span></span><span style=display:flex><span>create user user1;
</span></span><span style=display:flex><span><span style=color:#177500># 创建同名用户</span>
</span></span><span style=display:flex><span>useradd user1;
</span></span><span style=display:flex><span><span style=color:#177500># 切换用户</span>
</span></span><span style=display:flex><span>su - user1
</span></span><span style=display:flex><span><span style=color:#177500># 登录</span>
</span></span><span style=display:flex><span>psql postgres <span style=color:#177500># 指定用户名，否则默认使用与用户同名的数据库</span>
</span></span></code></pre></td></tr></table></div></div></div><p>注意：peer不是常用的方式，最常用的方式是通过密码远程登陆。</p><h2 id=角色管理>角色管理</h2><p>PG中没有区分用户和角色， <code>CREATE USER</code> 为 <code>CREATE ROLE</code> 的别名，两个命令几乎相同。唯一的区别是前者创建的用户默认带有 login 属性，而后者创建的默认不带。</p><h3 id=创建用户-角色>创建用户/角色</h3><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># CREATE ROLE zhangsan;　　//默认不带LOGIN属性</span>
</span></span><span style=display:flex><span>CREATE ROLE
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># CREATE USER lisi;　　//默认具有LOGIN属性</span>
</span></span><span style=display:flex><span>CREATE ROLE
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># \du</span>
</span></span><span style=display:flex><span>                             List of roles
</span></span><span style=display:flex><span> Role name |                   Attributes                   | Member of 
</span></span><span style=display:flex><span>-----------+------------------------------------------------+-----------
</span></span><span style=display:flex><span> zhangsan  | Cannot login                                   | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> postgres  | Superuser, Create role, Create DB, Replication | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> lisi      |                                                | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># </span>
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># SELECT rolname from pg_roles ;</span>
</span></span><span style=display:flex><span> rolname  
</span></span><span style=display:flex><span>----------
</span></span><span style=display:flex><span> postgres
</span></span><span style=display:flex><span> zhangsan
</span></span><span style=display:flex><span> lisi
</span></span><span style=display:flex><span><span style=color:#000>(</span><span style=color:#1c01ce>3</span> rows<span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># SELECT usename from pg_user;         //角色 zhangsan 创建时没有分配login权限，所以没有创建用户</span>
</span></span><span style=display:flex><span> usename  
</span></span><span style=display:flex><span>----------
</span></span><span style=display:flex><span> postgres
</span></span><span style=display:flex><span> lisi
</span></span><span style=display:flex><span><span style=color:#000>(</span><span style=color:#1c01ce>2</span> rows<span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500>#</span>
</span></span></code></pre></td></tr></table></div></div></details><br><h3 id=角色属性>角色属性</h3><table><thead><tr><th style=text-align:left>属性</th><th style=text-align:left> 说明</th></tr></thead><tbody><tr><td style=text-align:left>login</td><td style=text-align:left>只有具有 LOGIN 属性的角色可以用做数据库连接的初始角色名。</td></tr><tr><td style=text-align:left>superuser</td><td style=text-align:left>数据库超级用户</td></tr><tr><td style=text-align:left>createdb</td><td style=text-align:left>创建数据库权限</td></tr><tr><td style=text-align:left>createrole</td><td style=text-align:left>允许其创建或删除其他普通的用户角色(超级用户除外)</td></tr><tr><td style=text-align:left>replication</td><td style=text-align:left>做流复制的时候用到的一个用户属性，一般单独设定。</td></tr><tr><td style=text-align:left>password</td><td style=text-align:left>在登录时要求指定密码时才会起作用，比如md5或者password模式，跟客户端的连接认证方式有关</td></tr><tr><td style=text-align:left>inherit</td><td style=text-align:left>用户组对组员的一个继承标志，成员可以继承用户组的权限特性</td></tr></tbody></table><h3 id=创建用户赋予角色属性>创建用户赋予角色属性</h3><p>创建角色 wangwu 并赋予其 CREATEDB 的权限：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 首先切到postgres</span>
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># CREATE ROLE wangwu CREATEDB ;</span>
</span></span><span style=display:flex><span>CREATE ROLE
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># \du</span>
</span></span><span style=display:flex><span>                             List of roles
</span></span><span style=display:flex><span> Role name |                   Attributes                   | Member of 
</span></span><span style=display:flex><span>-----------+------------------------------------------------+-----------
</span></span><span style=display:flex><span> wangwu    | Create DB, Cannot login                        | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> zhangsan  |                                                | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> postgres  | Superuser, Create role, Create DB, Replication | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> lisi      |                                                | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500>#</span>
</span></span></code></pre></td></tr></table></div></div></div><p>创建角色 zhaoliu 并赋予其创建数据库及带有密码登录的属性：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># CREATE ROLE zhaoliu CREATEDB PASSWORD &#39;zhaoliu123&#39; LOGIN;</span>
</span></span><span style=display:flex><span>CREATE ROLE
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># \du</span>
</span></span><span style=display:flex><span>                             List of roles
</span></span><span style=display:flex><span> Role name |                   Attributes                   | Member of 
</span></span><span style=display:flex><span>-----------+------------------------------------------------+-----------
</span></span><span style=display:flex><span> wangwu    | Create DB, Cannot login                        | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> zhangsan  |                                                | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> postgres  | Superuser, Create role, Create DB, Replication | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> zhaoliu   | Create DB                                      | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> lisi      |                                                | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500>#</span>
</span></span></code></pre></td></tr></table></div></div></div></p><p>测试 zhaoliu 角色：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>psql -U zhaoliu -d postgres
</span></span></code></pre></td></tr></table></div></div></div></p><h3 id=为用户赋予权限>为用户赋予权限</h3><p>给存在的用户赋予各种权限。</p><p>赋予 wangwu 登录权限：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># ALTER ROLE wangwu WITH LOGIN;</span>
</span></span><span style=display:flex><span>ALTER ROLE
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># \du</span>
</span></span><span style=display:flex><span>                             List of roles
</span></span><span style=display:flex><span> Role name |                   Attributes                   | Member of 
</span></span><span style=display:flex><span>-----------+------------------------------------------------+-----------
</span></span><span style=display:flex><span> wangwu    | Create DB                                      | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> zhangsan  |                                                | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> postgres  | Superuser, Create role, Create DB, Replication | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> zhaoliu   | Create DB                                      | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> lisi      |                                                | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500>#</span>
</span></span></code></pre></td></tr></table></div></div></div><p>赋予 zhaoliu 创建角色的权限：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># ALTER ROLE zhaoliu WITH CREATEROLE;</span>
</span></span><span style=display:flex><span>ALTER ROLE
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500># \du</span>
</span></span><span style=display:flex><span>                             List of roles
</span></span><span style=display:flex><span> Role name |                   Attributes                   | Member of 
</span></span><span style=display:flex><span>-----------+------------------------------------------------+-----------
</span></span><span style=display:flex><span> wangwu    | Create DB                                      | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> zhangsan  |                                                | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> postgres  | Superuser, Create role, Create DB, Replication | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> zhaoliu   | Create role, Create DB                         | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span> lisi      |                                                | <span style=color:#000>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>postgres</span><span style=color:#000>=</span><span style=color:#177500>#</span>
</span></span></code></pre></td></tr></table></div></div></div></p><h1 id=reference>Reference</h1><p><a href=https://cloud.tencent.com/developer/article/1847734>PostgreSQL 是中国第一的开源数据库？</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-807cfd58d53ca9f5ebe339e2098feffc>7 - 图</h1><h1 id=introduction>Introduction</h1><p>图</p></div><div class=td-content><h1 id=pg-e4b76c76c83e7d334295b0cf83d00cba>7.1 - 图数据库基本介绍</h1><h1 id=简介>简介</h1><h2 id=简介-1>简介</h2><p>世间万物都是存在普遍联系的，人们的生产活动中，时时刻刻都在产生大量的数据，形成了一个个庞大且复杂的关系网。传统的数据库对于这种庞大复杂的关系网无法高效准确地表达，因此诞生了图数据库，它可以更加高效、准确地表达出这种关联关系，且有助于进一步挖掘出更深层次的关系。</p><h2 id=场景>场景</h2><h3 id=社交网络>社交网络</h3><p>精准营销、好友推荐、舆情追踪。</p><h3 id=金融>金融</h3><p>信用卡反欺诈、资金流向识别。</p><h3 id=零售>零售</h3><p>用户360画像、商品实时推荐、反薅羊毛等。</p><h3 id=电力>电力</h3><p>电网调度仿真、故障分析、电碳因子计算。</p><h3 id=电信>电信</h3><p>防骚扰、防诈骗。</p><h3 id=政企>政企</h3><p>道路规划、智能交通、疫情精准防控。</p><h3 id=制造>制造</h3><p>供应链管理、物流优化、产品溯源。</p><h3 id=网络安全>网络安全</h3><p>攻击溯源、调用链分析。</p><h2 id=挑战>挑战</h2><ul><li>数据规模大</li><li>关联跳数深</li><li>实时要求高</li></ul><h2 id=基本概念>基本概念</h2><h1 id=核心目标>核心目标</h1><h2 id=核心语义>核心语义</h2><p>数据规模大、关联跳数深、实时要求高的场景下，完成一个图查询或者图分析，核心的操作是：<strong>邻居的迭代遍历</strong>。</p><p>关系型数据库中，边（即实体之间的关系）不是直接存储的，而是以外键的形式来表示。它的问题在于性能无法满足要求，即使在主键和外键上都建立索引，在面临大规模数据和查询跳数较深时，索引对性能的提升也非常有限。</p><h2 id=查询性能对比>查询性能对比</h2><h2 id=免索引邻接>免索引邻接</h2><p>定义</p><p>免索引邻接（Index Free Adjacency）</p><p>写入时：保证一个点和它直接相连的边总是存储在一起</p><p>查询时：迭代遍历一个点的所有邻居可以直接进行，而不需要依赖其他数据结构</p><p><strong>图数据库存储的核心目标是实现免索引邻接</strong>。</p><p>写入时，免索引邻接可以保证一个点和与它相邻的边总是存储在一起。因此查询时迭代遍历一个点的所有邻居就可以直接进行，而不需要依赖其它索引类的数据结构。与全局索引对比，查询操作的时间复杂度是 O(1) vs O(log(n))。</p><p>因为免索引邻接迭代一个点的所有邻居的时间，就是这个点的邻居数量乘以O(1)，仅与这个点的邻居数量有关，而与整个图中全体的点边数量无关。</p><p>而使用全局索引，那么每次定位都需要一个 O(log(n)) 的时间复杂度。n 指参与全局索引的数据规模，可以理解为整体的边数量。因此迭代一个点的所有邻接时间就是这个点的邻居数量乘以 O(log(n))。</p><p>从算法的时间度复杂度上看，O(log(n)) 已经非常快，当处理巨大规模数据量时，这个值也会非常可观。但是需要注意的是，log(n)的值会随着n的增大而不断增大。假设点只有一个邻居，使用全局索引，会随着图中的总边数增加而越来越慢。如果具备了免索引邻接的能力，那么获取这个邻居的时间就是一个恒定值，而与全局的图规模无关。这个特点会带来巨大的性能提升。所以可以明确，图数据库存储的核心目标就是实现免索引邻接。</p><h1 id=技术方案>技术方案</h1><h2 id=数据模型>数据模型</h2><h3 id=点-vertex>点(Vertex)</h3><h3 id=边-edge>边(Edge)</h3><h3 id=边的方向>边的方向</h3><h2 id=数组存储>数组存储</h2><p>数组存储结构图</p><p><img src=../imgs/20221127-graph-base_1.png alt=20221127-graph-base_1.png></p><p><strong>最直接的方法就是用一个数组，把每一个点上面的所有边，按照顺序一起存储</strong>。点文件就是一系列的点组成，每个点的存储，包括点的ID、META信息，以及这个点的一系列属性。每个边文件中，按照起始点的顺序存储点上对应的边。每条边的存储包括终止点ID、META信息，以及边的属性。META信息包括点边类型、边方向、实现事务的额外字段等。在这个存储里，可以直接从起始点遍历所有的边数据，<strong>读取性能非常高</strong>。</p><h3 id=变长数组>变长数组</h3><p>存在的问题：变长数组。</p><p>可能有很多因素导致。如：两个点的属性数量不同、属性本身内容不同、属性值是字符串也是变长的（属性长度不一样导致每个点的存储空间变长）。点文件和边文件都会面临变长数组的问题。</p><p>解决思路：</p><p>1、用额外的 offset 来记住存储位置</p><p>2、预先划分好部分预留空间</p><p>数组存储结构图（处理变长）</p><p><img src=../imgs/20221127-graph-base_2.png alt=20221127-graph-base_2.png></p><h2 id=链表存储>链表存储</h2><p>链表存储结构图</p><p><img src=../imgs/20221127-graph-base_3.png alt=20221127-graph-base_3.png></p><p>链表的存储方式中，点文件和边文件里面存储的都是ID，每个ID都是固定长度的，通过ID可以计算偏移量位置，通过偏移量位置直接读取数据。因为它能够通过位置计算ID，偏移量和ID是一一对应的，所以每个点也不用保存自身的ID。</p><h3 id=边迭代>边迭代</h3><p>链表存储结构图（迭代边示意）</p><p><img src=../imgs/20221127-graph-base_4.png alt=20221127-graph-base_4.png></p><p>边迭代的过程：</p><p>首先从点A出发，在点文件中找到首个边ID：α，去边文件中找到α对应的偏移量，就能把整条边数据读出来。边数据里，有起始点和终止点，比如这条边的起始点A、终止点B。下一条边的偏移量是θ，那么就再找到θ的位置。θ边读出来，它是从起始点C到终止点A。这时候点A是处于终止点的位置上，我们找对应终止点的下一条边，是ω。然后再找ω的偏移量，读出来，是一个A到D的边，A在起始点的位置上，下一条边是NULL，迭代遍历结束。我们可以看到，链表存储的方式很好地解决了变长的问题。</p><h3 id=随机读操作>随机读操作</h3><p>链表存储下，每次迭代时offset的位置是随机的，不是连续存储的，因此会有大量的随机读操作。而磁盘对随机读操作是很不友好的，也就是说虽然时间复杂度是O(1)，但是这个O(1)的单位是磁盘随机读的时间。而前面数组方案中的O(1)的单位是磁盘顺序读的时间，这两者在性能上差别非常大。所以使用链表的存储方法，非常依赖一个高效实现的缓存机制。如果我们能把这个存储结构在内存中缓存起来，那么在内存中进行随机访问的性能会非常高。</p><h2 id=lsm树存储>LSM树存储</h2><p>LSM树存储示意图</p><p><img src=../imgs/20221127-graph-base_5.png alt=20221127-graph-base_5.png></p><p><strong>LSM树存储是一种基于顺序写盘、多层结构的KV存储</strong>。</p><p>上图展示了LSM树读写操作的核心流程：</p><p>在写请求时，直接写入内存中的MemTable。如果这个MemTable没满，这个写请求就直接返回了，所以写请求性能是很高的。当这个MemTable满了的时候，把它变成Immutable MemTable，同时生成一个新的MemTable供后续的写请求使用。同时，把Immutable MemTable的内容写到磁盘上，形成SSTable文件。内存中的MemTable和Immutable MemTable都是按Key排序的，所以SSTable也是按Key排序的。SSTable文件是分层组织的，直接从内存中写出来的是第0层，当第0层数据达到一定大小之后，就把它跟第1层合并，类似归并排序。合并出来的第1层文件也是顺序写排的，当第1层达到一定大小也会继续和下层合并，以此类推。在合并的时候，会清除重复的数据或者被删除的数据。</p><p>在读取请求时，首先去内存中的MemTable查找，查到就直接返回。没查到就去第0层的文件中查找，第0层没有再到第1层，这样逐层查找。</p><h3 id=key设计>Key设计</h3><p>关键点：合理地设计边的Key，使一个点的所有边在排序后是相邻的。</p><p><img src=../imgs/20221127-graph-base_6.png alt=20221127-graph-base_6.png></p><p>因为在SSTable文件的存储中，key是有序排列的，所以我们只要通过LSM树实现免索引邻接的能力。关键点在于合理地设计边的Key，要让一个点的所有边在排序后是相邻的。</p><p>上图中例1，只要把边Key的最高位放起始点ID，那么排序之后，从这个起点出发的边自然就会排在一起。这里还可以有一个编号字段，加入编号字段就可以支持在两点之间的同类型多条边的共存。因为LSM树是KV结构，所以如果只有起始点、终止点和META的话，那么两点之间同类型的边只有一个Key，所以只能存一条。对于像转账交易、访问记录这样具有事件性质的边来说，两点之间肯定会有多条同类型的边，在这样的场景下，这个能力就是非常重要的。</p><p>在某些场景下边的Key也可以不以起始点开始，比如例2的场景下。可以先放边的类型，再放起始点ID。这样做的目的是为了能够通过边类型直接做分片。因为在分布式环境下，做这样的分片可能会有更好的性能。这样虽然一个点的所有边是分散存储的，但是一个点某个类型的所有边还是顺序存储在一起的。如果业务场景是边查群总是按照类型分别迭代的，那么它也能提供很好的免索引邻接的能力。</p><p>难点：</p><p>1、读性能</p><p>2、Compaction的影响</p><p>3、依赖第三方存储</p><p>首先，SSTable文件是分层的，在查询时的最坏情况下，需要找遍所有层才能知道找得到或者找不到，因此读性能是没有直接使用数组的方式那么高的。另外，Compaction对它的影响是很大的，Compaction是个后台操作，会占用大量的磁盘IO，势必对前台读写性能造成影响。第三是，使用LSM方案通常都要依赖第三方存储，对于一些特定的需求，必须要改动第三方存储项目才能实现。</p><h2 id=优化之路>优化之路</h2><p><img src=../imgs/20221127-graph-base_7.png alt=20221127-graph-base_7.png></p><p>可以看到，几种常见的实现免索引邻接的存储方式，都不是一劳永逸的方案，而是各有各的优势和短板：</p><p>通过数组的方式读取速度快，但写入速度慢；通过LSM树的方式写入速度快，但是读取速度慢。通过链表的方式，读取和写入的速度都不占优，但却是灵活性最高的方式。</p><p>在实际实现一个图数据库的过程中，要根据我们的设计理念去做取舍。</p><p>实现一个完整的图数据库产品，还有很多功能和性能的问题需要考虑。比如图数据库特有的反向边一致性的问题，还有分布式条件下怎样做分区分片，怎样处理分布式事务，是否支持mvcc快照，实时副本怎么做，WAL怎么做，属性索引怎么做，以及是否支持数据过期等。这些都是一个成熟的图数据库产品需要解决的问题。解决这些问题的同时，也要兼顾底层存储的特性。</p><h1 id=图算法>图算法</h1><h2 id=路径搜索类>路径搜索类</h2><p>路径搜索是搜索途中节点通过边建立的直接或间接的联系。</p><h2 id=中心性分析类>中心性分析类</h2><p>中心新分析是指分析特定节点在途中的重要程度及其影响力。</p><h2 id=社区发现类>社区发现类</h2><p>社区发现意在发现图中联系更紧密的群体结构。</p><h1 id=查询语言>查询语言</h1><p>Germlin Cypher</p><h1 id=应用实践>应用实践</h1><h2 id=开源图数据库杂谈>开源图数据库杂谈</h2><p>目前比较成熟的大部分都是面对传统行业较小的数据集和较低的访问吞吐场景，开源的 Neo4j 是单机架构；因此，在互联网场景下，通常都是基于已有的基础设施定制系统：比如 Facebook 基于 MySQL 系统封装了 Social Graph 系统 TAO，几乎承载了 Facebook 所有数据逻辑；Linkedln 在 KV 之上构建了 Social Graph 服务；微博是基于 Redis 构建了粉丝和关注关系。</p><h2 id=neo4j>Neo4j</h2><h3 id=简介-2>简介</h3><p>Neo4j是图数据库中一个主要代表，其开源，且用Java实现（需安装JDK）。经过几年的发展，已经可以用于生产环境。其有两种运行方式，一种是服务的方式，对外提供REST接口；另外一种是嵌入式模式，数据以文件的形式存放在本地，可以直接对本地文件进行操作。</p><h3 id=neo4j相关特性>Neo4j相关特性</h3><h3 id=数据模型-1>数据模型</h3><p>Neo4j被称为property graph，除了顶点（Node）和边(Relationship，其包含一个类型)，还有一种重要的部分——属性。无论是顶点还是边，都可以有任意多的属性。属性的存放类似于一个hashmap，key为一个字符串，而value必须是Java基本类型、或者是基本类型数组，比如说String、int或者int[]都是合法的。</p><h4 id=索引>索引</h4><p>Neo4j支持索引，其内部实际上通过Lucene实现。</p><h4 id=事务>事务</h4><p>Neo4j完整支持事务，即满足ACID性质。</p><h2 id=neo4j优缺点>Neo4j优缺点</h2><p>优点：</p><ol><li><p>数据的插入，查询操作很直观，不用再像之前要考虑各个表之间的关系。</p></li><li><p>提供的图搜索和图遍历方法很方便，速度也是比较快的。</p></li><li><p>更快的数据库操作。当然，有一个前提条件，那就是数据量较大，在MySql中存储的话需要许多表，并且表之间联系较多（即有不少的操作需要join表）。
缺点：</p></li><li><p>当数据过大时插入速度可能会越来越慢。.</p></li><li><p>超大节点。当有一个节点的边非常多时（常见于大V），有关这个节点的操作的速度将大大下降。这个问题很早就有了，官方也说过会处理，然而现在仍然不能让人满意。</p></li><li><p>提高数据库速度的常用方法就是多分配内存，然而看了官方操作手册，貌似无法直接设置数据库内存占用量，而是需要计算后为其”预留“内存…
注：鉴于其明显的优缺点，Neo4j适合存储”修改较少，查询较多，没有超大节点“的图数据。</p></li></ol><h2 id=bytegraph>ByteGraph</h2><h3 id=简介-3>简介</h3><p>字节跳动的 Graph 在线存储场景， 其需求也是有自身特点的，可以总结为：</p><ul><li>海量数据存储：百亿点、万亿边的数据规模；并且图符合幂律分布，比如少量大 V 粉丝达到几千万；</li><li>海量吞吐：最大集群 QPS 达到数千万；</li><li>低延迟：要求访问延迟 pct99 需要限制在毫秒级；</li><li>读多写少：读流量是写流量的接近百倍之多；</li><li>轻量查询多，重量查询少：90%查询是图上二度以内查询；</li><li>容灾架构演进：要能支持字节跳动城域网、广域网、洲际网络之间主备容灾、异地多活等不同容灾部署方案。
面对字节跳动世界级的海量数据和海量并发请求，用万亿级分布式存储、千万高并发、低延迟、稳定可控这三个条件一起去筛选，业界在线上被验证稳定可信赖的开源图存储系统基本没有满足的了。</li></ul><p>在 18 年 8 月份，开始从第一行代码开始踏上图数据库的漫漫征程，从解决一个最核心的抖音社交关系问题入手，逐渐演变为支持有向属性图数据模型、支持写入原子性、部分 Gremlin 图查询语言的通用图数据库系统，在公司所有产品体系落地称之为 ByteGraph。</p><h3 id=场景-1>场景</h3><ul><li>记录关注关系A关注B</li><li>查询A关注的且关注了C的所有用户</li><li>查询A的好友的好友（二度关系）</li></ul><h3 id=系统架构>系统架构</h3><p>下面这张图展示了 ByteGraph 的内部架构，其中 bg 是 ByteGraph 的缩写。</p><p>就像 MySQL 通常可以分为 SQL 层和引擎层两层一样，ByteGraph 自上而下分为查询层 (bgdb)、存储/事务引擎层（bgkv）、磁盘存储层三层，每层都是由多个进程实例组成。其中 bgdb 层与 bgkv 层混合部署，磁盘存储层独立部署，我们详细介绍每一层的关键设计。</p><p><img src=../imgs/20221127-graph-base_8.png alt=20221127-graph-base_8.png></p><h3 id=查询层-bgdb>查询层(bgdb)</h3><p>bgdb 层和 MySQL 的 SQL 层一样，主要工作是做读写请求的解析和处理；其中，所谓“处理”可以分为以下三个步骤：</p><ol><li>将客户端发来的 Gremlin 查询语句做语法解析，生成执行计划；</li><li>并根据一定的路由规则（例如一致性哈希）找到目标数据所在的存储节点（bgkv），将执行计划中的读写请求发送给 多个 bgkv；</li><li>将 bgkv 读写结果汇总以及过滤处理，得到最终结果，返回给客户端。
bgdb 层没有状态，可以水平扩容，用 Go 语言开发。</li></ol><p><img src=../imgs/20221127-graph-base_9.png alt=20221127-graph-base_9.png></p><h3 id=存储-事务引擎层-bgkv>存储/事务引擎层(bgkv)</h3><p>bgkv 层是由多个进程实例组成，每个实例管理整个集群数据的一个子集（shard / partition)。</p><p>bgkv 层的实现和功能有点类似内存数据库，提供高性能的数据读写功能，其特点是：</p><p>接口不同：只提供点边读写接口；支持算子下推：通过把计算(算子)移动到存储（bgkv）上，能够有效提升读性能；举例：比如某个大 V 最近一年一直在涨粉，bgkv 支持查询最近的 100 个粉丝，则不必读出所有的百万粉丝。</p><p>缓存存储有机结合：其作为 KV store 的缓存层，提供缓存管理的功能，支持缓存加载、换出、缓存和磁盘同步异步 sync 等复杂功能。</p><p>从上述描述可以看出，bgkv 的性能和内存使用效率是非常关键的，因此采用 C++ 编写。</p><h3 id=磁盘存储层-kv-cluster>磁盘存储层(KV Cluster)</h3><p>为了能够提供海量存储空间和较高的可靠性、可用性，数据必须最终落入磁盘，我们底层存储是选择了公司自研的分布式 KV store。</p><p>问题：如何把动辄百万粉丝的图数据存储在KV数据库中？</p><p>在字节跳动的业务场景中，存在很多访问热度和“数据密度”极高的场景，比如抖音的大 V、热门的文章等，其粉丝数或者点赞数会超过千万级别；但作为 KV store，希望业务方的 KV 对的大小（Byte 数）是控制在 KB 量级的，且最好是大小均匀的：对于太大的 value，是会瞬间打满 I/O 路径的，无法保证线上稳定性；对于特别小的 value，则存储效率比较低。事实上，数据大小不均匀这个问题困扰了很多业务团队，在线上也会经常爆出事故。</p><p>对于一个有千万粉丝的抖音大 V，相当于图中的某个点有千万条边的出度，不仅要能存储下来，而且要能满足线上毫秒级的增删查改，ByteGraph 是如何解决这个问题？</p><p>思路其实很简单，总结来说，就是采用灵活的边聚合方式，使得 KV store 中的 value 大小是均匀的，具体可以用以下四条来描述：</p><ol><li>一个点（Vertex）和其所有相连的边组成了一数据组（Group）；不同的起点和及其终点是属于不同的 Group，是存储在不同的 KV 对的；比如用户 A 的粉丝和用户 B 的粉丝，就是分成不同 KV 存储；</li><li>对于某一个点的及其出边，当出度数量比较小（KB 级别），将其所有出度即所有终点序列化为一个 KV 对，我们称之为一级存储方式（后面会展开描述）；</li><li>当一个点的出度逐渐增多，比如一个普通用户逐渐成长为抖音大 V，我们则采用分布式 B-Tree 组织这百万粉丝，我们称之为二级存储；</li><li>一级存储和二级存储之间可以在线并发安全的互相切换；
一级存储</li></ol><p>一级存储格式中，只有一个 KV 对，key 和 value 的编码：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>-  key: 某个起点 id + 起点 type + 边 type
</span></span><span style=display:flex><span>-  value: 此起点的所有出边（Edge）及其边上属性聚合作为 value，但不包括终点的属性
</span></span></code></pre></td></tr></table></div></div></div><p>二级存储（点的出度大于阈值）
如果一个大 V 疯狂涨粉，则存储粉丝的 value 就会越来越大，解决这个问题的思路也很朴素：拆成多个 KV 对。</p><p>ByteGraph 的方式就是把所有出度和终点拆成多个 KV 对，所有 KV 对形成一棵逻辑上的分布式 B-Tree，之所以说“逻辑上的”，是因为树中的节点关系是靠 KV 中 key 来指向的，并非内存指针； B-Tree 是分布式的，是指构成这棵树的各级节点是分布在集群多个实例上的，并不是单机索引关系。具体关系如下图所示：</p><p><img src=../imgs/20221127-graph-base_10.png alt=20221127-graph-base_10.png></p><p>其中，整棵 B-Tree 由多组 KV 对组成，按照关系可以分为三种数据：</p><ul><li>根节点：根节点本质是一个 KV 系统中的一个 key，其编码方式和一级存储中的 key 相同</li><li>Meta 数据：<ul><li>Meta 数据本质是一个 KV 中的 value，和根节点组成了 KV 对；</li><li>Meta 内部存储了多个 PartKey，其中每个 PartKey 都是一个 KV 对中的 key，其对应的 value 数据就是下面介绍的 Part 数据；</li></ul></li><li>Part 数据<ul><li>对于二级存储格式，存在多个 Part，每个 Part 存储部分出边的属性和终点 ID</li><li>每个 Part 都是一个 KV 对的 value，其对应的 key 存储在 Meta 中。
从上述描述可以看出，对于一个出度很多的点和其边的数据（比如大 V 和其粉丝），在 ByteGraph 中，是存储为多个 KV 的，面对增删查改的需求，都需要在 B-Tree 上做二分查找。相比于一条边一个 KV 对或者所有边存储成一个 KV 对的方式，B-Tree 的组织方式能够有效的在读放大和写放大之间做一些动态调整。</li></ul></li></ul><p>但在实际业务场景下，粉丝会处于动态变化之中：新诞生的大 V 会快速新增粉丝，有些大 V 会持续掉粉；因此，存储方式会在一级存储和二级存储之间转换，并且 B-Tree 会持续的分裂或者合并；这就会引发分布式的并发增删查改以及分裂合并等复杂的问题，有机会可以再单独分享下这个有趣的设计。</p><p>ByteGraph 和 KV store 的关系，类似文件系统和块设备的关系，块设备负责将存储资源池化并提供 Low Level 的读写接口，文件系统在块设备上把元数据和数据组织成各种树的索引结构，并封装丰富的 POSIX 接口，便于外部使用。</p><h3 id=一些问题深入讨论>一些问题深入讨论</h3><h4 id=热点数据读写解决>热点数据读写解决</h4><p>热点数据在字节跳动的线上业务中广泛存在：热点视频、热点文章、大 V 用户、热点广告等等；热点数据可能会出现瞬时出现大量读写。ByteGraph 在线上业务的实践中，打磨出一整套应对性方案。</p><ul><li><p>热点读
热点读的场景随处可见，比如线上实际场景：某个热点视频被频繁刷新，查看点赞数量等。在这种场景下，意味着访问有很强的数据局部性，缓存命中率会很高，因此，我们设计实现了多级的 Query Cache 机制以及热点请求转发机制；在 bgdb 查询层缓存查询结果， bgdb 单节点缓存命中读性能 20w QPS 以上，而且多个 bgdb 可以并发处理同一个热点的读请求，则系统整体应对热点度的“弹性”是非常充足的。</p></li><li><p>热点写
热点读和热点写通常是相伴而生的，热点写的例子也是随处可见，比如：热点新闻被疯狂转发， 热点视频被疯狂点赞等等。对于数据库而言，热点写入导致的性能退化的背后原因通常有两个：行锁冲突高或者磁盘写入 IOPS 被打满，我们分别来分析：</p><ul><li>行锁冲突高：目前 ByteGraph 是单行事务模型，只有内存结构锁，这个锁的并发量是每秒千万级，基本不会构成写入瓶颈；</li><li>磁盘 IOPS 被打满：</li><li>IOPS（I/O Count Per Second）的概念：磁盘每秒的写入请求数量是有上限的，不同型号的固态硬盘的 IOPS 各异，但都有一个上限，当上游写入流量超过这个阈值时候，请求就会排队，造成整个数据通路堵塞，延迟就会呈现指数上涨最终服务变成不可用。</li><li>Group Commit 解决方案：Group Commit 是数据库中的一个成熟的技术方案，简单来讲，就是多个写请求在 bgkv 内存中汇聚起来，聚成一个 Batch 写入 KV store，则对外体现的写入速率就是 BatchSize * IOPS。
<img src=../imgs/20221127-graph-base_11.png alt=20221127-graph-base_11.png></li></ul></li></ul><p>对于某个独立数据源来说，一般热点写的请求比热点读会少很多，一般不会超过 10K QPS，目前 ByteGraph 线上还没有出现过热点写问题问题。</p><h4 id=图的索引>图的索引</h4><p>就像关系型数据库一样，图数据库也可以构建索引。默认情况下，对于同一个起点，我们会采用边上的属性（时间戳）作为主键索引；但为了加速查询，我们也支持其他元素（终点、其他属性）来构建二级的聚簇索引，这样很多查找就从全部遍历优化成了二分查找，使得查询速度大幅提升。</p><p>ByteGraph 默认按照边上的时间戳（ts）来排序存储，因此对于以下请求，查询效率很高：</p><p>查询最近的若干个点赞查询某个指定时间范围窗口内加的好友</p><p>方向的索引可能有些费解，举个例子说明下：给定两个用户来查询是否存在粉丝关系，其中一个用户是大 V，另一个是普通用户，大 V 的粉丝可达千万，但普通用户的关注者一般不会很多；因此，如果用普通用户作为起点大 V 作为终点，查询代价就会低很多。其实，很多场景下，我们还需要用户能够根据任意一个属性来构建索引，这个也是我们正在支持的重要功能之一。</p><h3 id=未来探索>未来探索</h3><p>过去的一年半时间里，ByteGraph 都是在有限的人力情况下，优先满足业务需求，在系统能力构建方面还是有些薄弱的，有大量问题都需要在未来突破解决：</p><p>从图存储到图数据库：对于一个数据库系统，是否支持 ACID 的事务，是一个核心问题，目前 ByteGraph 只解决了原子性和一致性，对于最复杂的隔离性还完全没有触碰，这是一个非常复杂的问题；另外，中国信通院发布了国内图数据库功能白皮书，以此标准，如果想做好一个功能完备的“数据库”系统，我们面对的还是星辰大海；标准的图查询语言：目前，图数据库的查询语言业界还未形成标准（GQL 即将在 2020 年发布），ByteGraph 选择 Apache、AWS 、阿里云的 Gremlin 语言体系，但目前也只是支持了一个子集，更多的语法支持、更深入的查询优化还未开展；Cloud Native 存储架构演进：现在 ByteGraph 还是构建与 KV 存储之上，独占物理机全部资源；从资源弹性部署、运维托管等角度是否有其他架构演进的探索可能，从查询到事务再到磁盘存储是否有深度垂直整合优化的空间，也是一个没有被回答的问题；现在 ByteGraph 是在 OLTP 场景下承载了大量线上数据，这些数据同时也会应用到推荐、风控等复杂分析和图计算场景，如何把 TP 和轻量 AP 查询融合在一起，具备部分 HTAP 能力，也是一个空间广阔的蓝海领域。</p><h2 id=galaxybase>Galaxybase</h2><h3 id=特点>特点</h3><p>Galaxybase是一个国产高性能分布式图数据库。它具有如下特点：</p><ul><li>速度快：原生分布式并行图存储，毫秒级完成传统方案无法实现的深链分析, 较同类技术百倍提升。</li><li>高扩展：完全分布式架构，动态在线扩容，高效支持万亿级超级大图。</li><li>实时计算：内置丰富分布式图算法、无ETL实现实时图分析。</li><li>高效数据压缩：优化资源利用，节省硬件和维护成本。</li><li>全自主可控、兼容国际开源生态与国产底层硬件。</li></ul><h3 id=技术方案-1>技术方案</h3><p><img src=../imgs/20221127-graph-base_12.png alt=20221127-graph-base_12.png></p><ul><li>自研分布式原生图存储，不依赖第三方存储引擎</li><li>使用数据分片，支持热备</li><li>支持动态压缩，节省存储空间</li></ul><h3 id=性能优势>性能优势</h3><p>和中山大学携手共建的一个国家重点研发图计算项目。它依托国家超算广州中心的环境，仅用50台机器的集群就完成了5万亿规模交易数据的智能挖掘系统，实现了当前全球商业图数据支持的最大规模图数据处理。打破了之前用1000台机器集群创造了1.2万亿规模的大图处理的世界记录。我们涵盖的出入度，最大有超过1000万的超级节点。六跳深链查询平均耗时仅6.7秒。</p><h3 id=优异的查询性能>优异的查询性能</h3><p><img src=../imgs/20221127-graph-base_13.png alt=20221127-graph-base_13.png></p><p>Galaxybase图数据库具有优异的查询性能。上图是LDBC-SNB官方对Galaxybase进行测试的结果。测试由国外权威机构进行，首先进行了结果正确性验证确保图数据库返回正确结果；随后进行了系统稳定性、可用性、事务支持性和可恢复性验证，均达到官方标准；最后进行了各项性能测试。Galaxybase表现优异，达到国际领先水平。在使用完全相同系统配置前置下，Galaxybase较LDBC之前公布的最高记录吞吐量提升了70%，平均查询性能达6倍以上提升，最高查询性能提升72倍。</p><h3 id=丰富的图算法支持>丰富的图算法支持</h3><p><img src=../imgs/20221127-graph-base_14.png alt=20221127-graph-base_14.png></p><p>Galaxybase也提供了丰富的算法支持，提供了包括像图遍历、路径发现、中心性分析、社群发现、相似度分析、子图模式匹配等几个大类的上百种图算法。不久前率先通过了信通院图计算平台的一个产品基础能力评测，涉及五个能力域，34个能力项的评测，全方位覆盖了图平台的基本能力、兼容能力、管理能力、高可用和扩展能力。</p><h1 id=reference>Reference</h1><p><a href=https://zhuanlan.zhihu.com/p/551466845>图数据库存储技术及实践</a></p><p><a href=https://zhuanlan.zhihu.com/p/109401046>字节跳动自研万亿级图数据库 & 图计算实践</a></p><p><a href=https://zhuanlan.zhihu.com/p/373446678>人人都在谈的图数据库到底是个啥</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-e45f3f93acd03eb19581a69d28cdebd2>8 - LevelDB</h1><h1 id=introduction>Introduction</h1><p>LevelDB</p></div><div class=td-content><h1 id=pg-618d30a5d90efc2d9c3168dfb863e4f4>8.1 - LevelDB-01基本介绍</h1><h1 id=简介>简介</h1><h2 id=简介-1>简介</h2><p>LevelDB 是一个key/value型的单机存储引擎，由google开发，并宣布在BSD许可下开放源代码。它是 leveling+ 分区实现的LSM典型代表。</p><h2 id=特性>特性</h2><ul><li>key、value支持任意的byte类型数组，不单单支持字符串</li><li>LevelDB 是一个持久化存储的KV系统，将大部分数据存储到磁盘上</li><li>按照记录key值顺序存储数据，并且LevleDb支持按照用户定义的比较函数进行排序</li><li>操作接口简单，包括写/读记录以及删除记录，也支持针对多条操作的原子批量操作。</li><li>支持数据快照（snapshot）功能，使得读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。</li><li>支持数据压缩（snappy压缩）操作，有效减小存储空间、并增快IO效率。</li><li>LSM典型实现，适合写多读少。</li></ul><h2 id=限制>限制</h2><p>LevelDB 只是一个 C/C++ 编程语言的库，需要封装自己的网络服务器，无法像一般意义的存储服务器（如 MySQL）那样直接用客户端来连接。非关系型数据模型（NoSQL），不支持sql语句，也不支持索引，且一次只允许一个进程访问一个特定的数据库。</p><h2 id=编译与使用>编译与使用</h2><h3 id=源码>源码</h3><p>源码下载</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>git clone https://github.com/google/leveldb.git
</span></span><span style=display:flex><span>git submodule update --init
</span></span></code></pre></td></tr></table></div></div></div><p>安装三方模块
直接编译因为 third_party 中缺少 googletest 和 benchmark 子模块，需要单独安装。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a90d91>cd</span> third_party
</span></span><span style=display:flex><span>git clone git@github.com:google/googletest.git
</span></span><span style=display:flex><span>git clone git@github.com:google/benchmark.git
</span></span></code></pre></td></tr></table></div></div></div><p>安装 sqlite3：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get install sqlite3
</span></span></code></pre></td></tr></table></div></div></div><p>编译</p><blockquote><p>注意避免修改了源码文件导致编译失败。</p></blockquote><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a90d91>cd</span> leveldb
</span></span><span style=display:flex><span>mkdir -p build <span style=color:#000>&amp;&amp;</span> <span style=color:#a90d91>cd</span> build 
</span></span><span style=display:flex><span><span style=color:#177500># release版</span>
</span></span><span style=display:flex><span>cmake -DCMAKE_BUILD_TYPE<span style=color:#000>=</span>Release .. <span style=color:#000>&amp;&amp;</span> cmake --build .
</span></span><span style=display:flex><span><span style=color:#177500># 或debug版</span>
</span></span><span style=display:flex><span>cmake -DCMAKE_BUILD_TYPE<span style=color:#000>=</span>Debug .. <span style=color:#000>&amp;&amp;</span> cmake --build .
</span></span></code></pre></td></tr></table></div></div></div><p>编译Demo<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#177500># 头文件加入系统目录(可选)</span>
</span></span><span style=display:flex><span>cp -r ./include/leveldb /usr/include/
</span></span><span style=display:flex><span>cp build/libleveldb.a /usr/local/lib/
</span></span><span style=display:flex><span><span style=color:#177500># 编写demo</span>
</span></span><span style=display:flex><span><span style=color:#177500># 编译demo</span>
</span></span><span style=display:flex><span>g++ -o xxx xxx.cpp libleveldb.a -lpthread
</span></span></code></pre></td></tr></table></div></div></div></p><h2 id=压测>压测</h2><p>参照源码中的 benchmarks 目录</p><h1 id=整体架构>整体架构</h1><p><img src=../imgs/20230108_leveldb01_1.png alt=20230108_leveldb01_1.png></p><p>LevelDB 作为存储系统，数据记录的存储介质包括内存以及磁盘文件。写数据时，接口会同时写入 MemTable（内存）和 Log 文件。当 MemTable 达到阈值时，MemTable 会冻结变成 Immutable MemTable（内存），并将数据写入 SSTable（磁盘上）中，在此同时会生成新的 MemTable 及 Log 文件供新的数据写入。</p><h2 id=log文件>Log文件</h2><p>LevelDB 写操作不是直接写入磁盘，而是先写入内存。加入写入到内存的数据还未来得及持久化，发生异常或者服务器宕机等会造成写入的数据丢失。因此，在写入内存之前会首先将所有的写操作写入日志文件中（其它存储系统都是这种通用做法）。每次写操作都是通过 append 方式顺序写入，整体写入性能好效率高。</p><h2 id=memtable>Memtable</h2><p>写入操作并不是直接将数据写入到磁盘文件，而是采用先将数据写入内存的方式。memtable 就是使用跳表实现的内存数据结构。数据按用户定义的方法排序之后按序存储，等到其存储内容到达阈值时（4MB）时，便将其转换成一个不可修改的 memtable，与此同时创建一个新的memtable 来供用户进行读写操作。因为使用跳表，它的大多数操作都是O(logn)。</p><h2 id=immutable-memtable>Immutable Memtable</h2><p>达到 Memtable 设置的容量上限后，Memtable 会变为 Immutable 为之后向SST文件的归并做准备。 同 Memtable 的结构定义一样。两者的区别只是 Immutable Memtable 是只读的。Immutable Memtable 被创建时，LevelDB 的后台压缩进程便会利用其中的内容创建一个sstable，然后持久化到磁盘中。Immutable Mumtable不再接受用户写入，同时生成新的 Memtable、Log 文件供新数据写入。</p><h2 id=sstable文件>SSTable文件</h2><p>磁盘数据存储文件。SSTable(Sorted String Table) 就是由内存中的数据不断导出并进行Compaction 操作后形成的，而且 SSTable 的所有文件是一种层级结构，第一层为Level 0，第二层为 Level 1，依次类推，层级逐渐增高，这也是为何称之为 LevelDB 的原因。此外，Compact 动作会将多个 SSTable 合并成少量的几个 SSTable，以剔除无效数据，保证数据访问效率并降低磁盘占用。</p><h3 id=manifest文件>Manifest文件</h3><p>Manifest 文件中记录SST文件在不同Level的分布，单个SST文件的最大最小key，以及其他一些LevelDB需要的元信息。</p><h2 id=current文件>Current文件</h2><p>主要是记录当前 Manifest 的文件名。LevelDB 启动时的首要任务就是找到当前的 Manifest，而 Manifest 文件可能有多个。Current 文件记录了当前 Manifest 的文件名，从而让 LevelDB 启动时能够找到当前的 Manifest。</p><h1 id=reference>Reference</h1><p><a href=https://github.com/google/leveldb>https://github.com/google/leveldb</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-69cc4c260e3e001ff652a81d39c0f9cf>8.2 - LevelDB-02基础数据结构</h1><h1 id=slice>Slice</h1><h2 id=作用>作用</h2><p>Slice 是 leveldb 中自定义的字符串处理类，主要是因为标准库中的 string 存在如下问题：</p><ul><li><p>默认语义为拷贝，会损失性能。（在可预期的条件下，可以通过指针传递）</p></li><li><p>使用不太方便，不支持 remove_prefix 和 starts_with 等函数
Slice 的作用：</p></li><li><p>数据结构简单，包括length和一个指向外部字节数组的指针。</p></li><li><p>相比返回 std::string，返回 Slice的开销小很多（没有拷贝，Slice 没有实际数据只有指向数据的指针）</p></li><li><p>允许key和value包含’\0’</p></li></ul><h2 id=兼容性>兼容性</h2><p>可以方便实现与 std::string 的互相转换</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// string 转slice：
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>leveldb</span><span style=color:#000>::</span><span style=color:#000>Slice</span> <span style=color:#000>s1</span> <span style=color:#000>=</span> <span style=color:#c41a16>&#34;hello&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span> <span style=color:#000>str</span>(<span style=color:#c41a16>&#34;world&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#000>leveldb</span><span style=color:#000>::</span><span style=color:#000>Slice</span> <span style=color:#000>s2</span> <span style=color:#000>=</span> <span style=color:#000>str</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// slice转string:
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span> <span style=color:#000>str</span> <span style=color:#000>=</span> <span style=color:#000>s1</span>.<span style=color:#000>ToString</span>();
</span></span><span style=display:flex><span><span style=color:#000>assert</span>(<span style=color:#000>str</span> <span style=color:#000>==</span> <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span>(<span style=color:#c41a16>&#34;hello&#34;</span>));
</span></span></code></pre></td></tr></table></div></div></div><h2 id=源码>源码</h2><p>在 include/leveldb/slice.h 中，较简单。</p><h1 id=key>Key</h1><p>Key 的代码都在 dbformat.cc / dbformat.h</p><p>Key 的关系图如下：</p><p><img src=../imgs/20230108_leveldb02_1.png alt=20230108_leveldb02_1.png></p><h2 id=internalkey>InternalKey</h2><h3 id=作用-1>作用</h3><p>用户输入的数据 key 使用 slice ，LevelDB 则使用 InternalKey 作为 内部key，常用来比较 key 等场景。</p><h3 id=结构>结构</h3><p>[Slice user_key] + [SequenceNumber&lt;&lt;8 + ValueType]，后半部分固定64位，即8字节。</p><h2 id=lookupkey>LookupKey</h2><h3 id=作用-2>作用</h3><p>查找对象的时候，查找顺序是从第0层到第n层遍历查找，找到为止(最新的修改或者删除的数据会优先被找到)。由于不同层的键值不同，所以 LookupKey 提供了不同层所需的键值。（用于 DBImpl:Get）</p><h3 id=结构-1>结构</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>private</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span> <span style=color:#177500>// We construct a char array of the form:
</span></span></span><span style=display:flex><span><span style=color:#177500></span> <span style=color:#177500>//    klength  varint32               &lt;-- start_
</span></span></span><span style=display:flex><span><span style=color:#177500></span> <span style=color:#177500>//    userkey  char[klength]          &lt;-- kstart_
</span></span></span><span style=display:flex><span><span style=color:#177500></span> <span style=color:#177500>//    tag      uint64
</span></span></span><span style=display:flex><span><span style=color:#177500></span> <span style=color:#177500>//                                    &lt;-- end_
</span></span></span><span style=display:flex><span><span style=color:#177500></span> <span style=color:#177500>// The array is a suitable MemTable key.
</span></span></span><span style=display:flex><span><span style=color:#177500></span> <span style=color:#177500>// The suffix starting with &#34;userkey&#34; can be used as an InternalKey.
</span></span></span><span style=display:flex><span><span style=color:#177500></span> <span style=color:#a90d91>const</span> <span style=color:#a90d91>char</span><span style=color:#000>*</span> <span style=color:#000>start_</span>;  <span style=color:#177500>// user_key.size() + 8 变长编码后的值
</span></span></span><span style=display:flex><span><span style=color:#177500></span> <span style=color:#a90d91>const</span> <span style=color:#a90d91>char</span><span style=color:#000>*</span> <span style=color:#000>kstart_</span>; <span style=color:#177500>// userkey
</span></span></span><span style=display:flex><span><span style=color:#177500></span> <span style=color:#a90d91>const</span> <span style=color:#a90d91>char</span><span style=color:#000>*</span> <span style=color:#000>end_</span>;    <span style=color:#177500>// 64位整型顺序号&lt;&lt;8+值类型 64位定长编码后的值
</span></span></span><span style=display:flex><span><span style=color:#177500></span> <span style=color:#a90d91>char</span> <span style=color:#000>space_</span>[<span style=color:#1c01ce>200</span>];  <span style=color:#177500>// Avoid allocation for short keys
</span></span></span></code></pre></td></tr></table></div></div></div><p>memtable_key = start_ + kstart_ + end_</p><p>internal_key = kstart_ + end_</p><p>user_key = kstart_</p><h2 id=parsedinternalkey>ParsedInternalKey</h2><h3 id=作用-3>作用</h3><p>对 InternalKey 的解析，InternalKey 是一个字符串</p><h3 id=结构-2>结构</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>struct ParsedInternalKey {
</span></span><span style=display:flex><span>  Slice user_key;
</span></span><span style=display:flex><span>  SequenceNumber sequence;
</span></span><span style=display:flex><span>  ValueType type;
</span></span></code></pre></td></tr></table></div></div></div><h1 id=skiplist>SkipList</h1><h2 id=定义>定义</h2><p>跳跃表：可以代替平衡树的数据结构，可以看成并联的有序链表。跳跃表通过概率保证平衡，而平衡树通过严格的旋转来保证平衡，因此跳跃表实现比较容易，相比平衡树有较高的运行效率。</p><blockquote><p>Redis 中默认的最大 level 为 64。</p></blockquote><h2 id=实现>实现</h2><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">71
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">72
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">73
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">74
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">75
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">76
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">77
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">78
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">79
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">80
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">81
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">82
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">83
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">84
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">85
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">86
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// skiplist.h
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>template</span> <span style=color:#000>&lt;</span><span style=color:#a90d91>typename</span> <span style=color:#000>Key</span>, <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Comparator</span><span style=color:#000>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>SkipList</span> {
</span></span><span style=display:flex><span> <span style=color:#a90d91>private</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>struct</span> <span style=color:#3f6e75>Node</span>;
</span></span><span style=display:flex><span> <span style=color:#a90d91>public</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>   <span style=color:#a90d91>private</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>    <span style=color:#a90d91>const</span> <span style=color:#000>SkipList</span><span style=color:#000>*</span> <span style=color:#000>list_</span>;
</span></span><span style=display:flex><span>    <span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#000>node_</span>;
</span></span><span style=display:flex><span>    <span style=color:#177500>// Intentionally copyable
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  };
</span></span><span style=display:flex><span> <span style=color:#a90d91>private</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>enum</span> { <span style=color:#000>kMaxHeight</span> <span style=color:#000>=</span> <span style=color:#1c01ce>12</span> };
</span></span><span style=display:flex><span>  <span style=color:#a90d91>inline</span> <span style=color:#a90d91>int</span> <span style=color:#000>GetMaxHeight</span>() <span style=color:#a90d91>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#000>max_height_</span>.<span style=color:#000>load</span>(<span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>memory_order_relaxed</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#000>NewNode</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Key</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#a90d91>int</span> <span style=color:#000>height</span>);
</span></span><span style=display:flex><span>  <span style=color:#a90d91>int</span> <span style=color:#000>RandomHeight</span>();
</span></span><span style=display:flex><span>  <span style=color:#a90d91>bool</span> <span style=color:#000>Equal</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Key</span><span style=color:#000>&amp;</span> <span style=color:#000>a</span>, <span style=color:#a90d91>const</span> <span style=color:#000>Key</span><span style=color:#000>&amp;</span> <span style=color:#000>b</span>) <span style=color:#a90d91>const</span> { <span style=color:#a90d91>return</span> (<span style=color:#000>compare_</span>(<span style=color:#000>a</span>, <span style=color:#000>b</span>) <span style=color:#000>==</span> <span style=color:#1c01ce>0</span>); }
</span></span><span style=display:flex><span>  <span style=color:#177500>// Return true if key is greater than the data stored in &#34;n&#34;
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>bool</span> <span style=color:#000>KeyIsAfterNode</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Key</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#000>n</span>) <span style=color:#a90d91>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// Return the earliest node that comes at or after key.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// Return nullptr if there is no such node.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>//
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// If prev is non-null, fills prev[level] with pointer to previous
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// node at &#34;level&#34; for every level in [0..max_height_-1].
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#000>FindGreaterOrEqual</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Key</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#000>Node</span><span style=color:#000>**</span> <span style=color:#000>prev</span>) <span style=color:#a90d91>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// Return the latest node with a key &lt; key.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// Return head_ if there is no such node.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#000>FindLessThan</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Key</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>) <span style=color:#a90d91>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// Return the last node in the list.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// Return head_ if list is empty.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#000>FindLast</span>() <span style=color:#a90d91>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// Immutable after construction
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Comparator</span> <span style=color:#a90d91>const</span> <span style=color:#000>compare_</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>Arena</span><span style=color:#000>*</span> <span style=color:#a90d91>const</span> <span style=color:#000>arena_</span>;  <span style=color:#177500>// Arena used for allocations of nodes
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#a90d91>const</span> <span style=color:#000>head_</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// Modified only by Insert().  Read racily by readers, but stale
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// values are ok.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>atomic</span><span style=color:#000>&lt;</span><span style=color:#a90d91>int</span><span style=color:#000>&gt;</span> <span style=color:#000>max_height_</span>;  <span style=color:#177500>// Height of the entire list
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// Read/written only by Insert().
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Random</span> <span style=color:#000>rnd_</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#177500>// Implementation details follow
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>template</span> <span style=color:#000>&lt;</span><span style=color:#a90d91>typename</span> <span style=color:#000>Key</span>, <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Comparator</span><span style=color:#000>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>struct</span> <span style=color:#3f6e75>SkipList</span><span style=color:#000>&lt;</span><span style=color:#000>Key</span>, <span style=color:#000>Comparator</span><span style=color:#000>&gt;::</span><span style=color:#000>Node</span> {
</span></span><span style=display:flex><span>  <span style=color:#a90d91>explicit</span> <span style=color:#000>Node</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Key</span><span style=color:#000>&amp;</span> <span style=color:#000>k</span>) <span style=color:#000>:</span> <span style=color:#000>key</span>(<span style=color:#000>k</span>) {}
</span></span><span style=display:flex><span>  <span style=color:#000>Key</span> <span style=color:#a90d91>const</span> <span style=color:#000>key</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// Accessors/mutators for links.  Wrapped in methods so we can
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// add the appropriate barriers as necessary.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#000>Next</span>(<span style=color:#a90d91>int</span> <span style=color:#000>n</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000>assert</span>(<span style=color:#000>n</span> <span style=color:#000>&gt;=</span> <span style=color:#1c01ce>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#177500>// Use an &#39;acquire load&#39; so that we observe a fully initialized
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#177500>// version of the returned Node.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>return</span> <span style=color:#000>next_</span>[<span style=color:#000>n</span>].<span style=color:#000>load</span>(<span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>memory_order_acquire</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a90d91>void</span> <span style=color:#000>SetNext</span>(<span style=color:#a90d91>int</span> <span style=color:#000>n</span>, <span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#000>x</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000>assert</span>(<span style=color:#000>n</span> <span style=color:#000>&gt;=</span> <span style=color:#1c01ce>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#177500>// Use a &#39;release store&#39; so that anybody who reads through this
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#177500>// pointer observes a fully initialized version of the inserted node.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>next_</span>[<span style=color:#000>n</span>].<span style=color:#000>store</span>(<span style=color:#000>x</span>, <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>memory_order_release</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#177500>// No-barrier variants that can be safely used in a few locations.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#000>NoBarrier_Next</span>(<span style=color:#a90d91>int</span> <span style=color:#000>n</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000>assert</span>(<span style=color:#000>n</span> <span style=color:#000>&gt;=</span> <span style=color:#1c01ce>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#000>next_</span>[<span style=color:#000>n</span>].<span style=color:#000>load</span>(<span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>memory_order_relaxed</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a90d91>void</span> <span style=color:#000>NoBarrier_SetNext</span>(<span style=color:#a90d91>int</span> <span style=color:#000>n</span>, <span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#000>x</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000>assert</span>(<span style=color:#000>n</span> <span style=color:#000>&gt;=</span> <span style=color:#1c01ce>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#000>next_</span>[<span style=color:#000>n</span>].<span style=color:#000>store</span>(<span style=color:#000>x</span>, <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>memory_order_relaxed</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span> <span style=color:#a90d91>private</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#177500>// Array of length equal to the node height.  next_[0] is lowest level link.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 提前使用声明分配1个对象的内存，因为第0层数据肯定都有
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 使用数组的方式，后续分配的内存都是连续的，atomic 保证原子性
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>atomic</span><span style=color:#000>&lt;</span><span style=color:#000>Node</span><span style=color:#000>*&gt;</span> <span style=color:#000>next_</span>[<span style=color:#1c01ce>1</span>];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a90d91>template</span> <span style=color:#000>&lt;</span><span style=color:#a90d91>typename</span> <span style=color:#000>Key</span>, <span style=color:#a90d91>class</span> <span style=color:#3f6e75>Comparator</span><span style=color:#000>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#a90d91>typename</span> <span style=color:#000>SkipList</span><span style=color:#000>&lt;</span><span style=color:#000>Key</span>, <span style=color:#000>Comparator</span><span style=color:#000>&gt;::</span><span style=color:#000>Node</span><span style=color:#000>*</span> <span style=color:#000>SkipList</span><span style=color:#000>&lt;</span><span style=color:#000>Key</span>, <span style=color:#000>Comparator</span><span style=color:#000>&gt;::</span><span style=color:#000>NewNode</span>(
</span></span><span style=display:flex><span>    <span style=color:#a90d91>const</span> <span style=color:#000>Key</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#a90d91>int</span> <span style=color:#000>height</span>) {
</span></span><span style=display:flex><span>  <span style=color:#177500>// 前面已经分配了一层，所以 level-1
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>char</span><span style=color:#000>*</span> <span style=color:#a90d91>const</span> <span style=color:#000>node_memory</span> <span style=color:#000>=</span> <span style=color:#000>arena_</span><span style=color:#000>-&gt;</span><span style=color:#000>AllocateAligned</span>(
</span></span><span style=display:flex><span>      <span style=color:#a90d91>sizeof</span>(<span style=color:#000>Node</span>) <span style=color:#000>+</span> <span style=color:#a90d91>sizeof</span>(<span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>atomic</span><span style=color:#000>&lt;</span><span style=color:#000>Node</span><span style=color:#000>*&gt;</span>) <span style=color:#000>*</span> (<span style=color:#000>height</span> <span style=color:#000>-</span> <span style=color:#1c01ce>1</span>));
</span></span><span style=display:flex><span>  <span style=color:#a90d91>return</span> <span style=color:#000>new</span> (<span style=color:#000>node_memory</span>) <span style=color:#000>Node</span>(<span style=color:#000>key</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></details><br><h1 id=compare>Compare</h1><h2 id=作用-4>作用</h2><p>LevelDB 抽象了一个基类 Comparator 用于各种 key 之间的比较，毕竟数据是按照键有序存储的。且必须要支持线程安全。</p><h2 id=源码-1>源码</h2><p>在 include/leveldb/comparator.h 中</p><h2 id=结构-3>结构</h2><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>LEVELDB_EXPORT</span> <span style=color:#000>Comparator</span> {
</span></span><span style=display:flex><span> <span style=color:#a90d91>public</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>virtual</span> <span style=color:#000>~</span><span style=color:#000>Comparator</span>();
</span></span><span style=display:flex><span>  <span style=color:#177500>// Three-way comparison.  Returns value:
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>//   &lt; 0 iff &#34;a&#34; &lt; &#34;b&#34;,
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>//   == 0 iff &#34;a&#34; == &#34;b&#34;,
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>//   &gt; 0 iff &#34;a&#34; &gt; &#34;b&#34;
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 支持 &gt;、=、&lt; 三种操作
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#a90d91>int</span> <span style=color:#000>Compare</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>a</span>, <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>b</span>) <span style=color:#a90d91>const</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 比较器名字，以 leveldb. 开头
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#a90d91>const</span> <span style=color:#a90d91>char</span><span style=color:#000>*</span> <span style=color:#000>Name</span>() <span style=color:#a90d91>const</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 如果 *start &lt; limit, 将 *start 更改为 [start,limit) 中的短字符串
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 简单的比较器实现可能以 *start 不变返回。
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#a90d91>void</span> <span style=color:#000>FindShortestSeparator</span>(<span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span><span style=color:#000>*</span> <span style=color:#000>start</span>,
</span></span><span style=display:flex><span>                                     <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>limit</span>) <span style=color:#a90d91>const</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 将 *key 更改为 string &gt;= *key.Simple 比较器实现可能会在 *key 不变的情况下返回                                  
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#a90d91>void</span> <span style=color:#000>FindShortSuccessor</span>(<span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span><span style=color:#000>*</span> <span style=color:#000>key</span>) <span style=color:#a90d91>const</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div></div><p>具体实现有：</p><ul><li>BytewiseComparatorImpl</li><li>InternalKeyComparator</li></ul><h2 id=bytewisecomparatorimpl>BytewiseComparatorImpl</h2><h3 id=作用-5>作用</h3><ul><li>Slice并没有规定Key具体类型，LevelDB 支持用户自定义比较器，创建数据库对象时可以通过Option 指定。</li><li>默认的比较器，基于二进制比较</li></ul><h3 id=源码-2>源码</h3><p>在 util/comparator.cc 中。</p><h2 id=internalkeycomparator>InternalKeyComparator</h2><h3 id=作用-6>作用</h3><ul><li>用于内部的Key比较器。</li><li>内部调用的也是 BytewiseComparatorImpl</li><li>cmp原则：<ul><li>userkey</li><li>seq 越大越新</li></ul></li><li>FindShortestSeparator / FindShortSuccessor<ul><li>提取 userkey，通过 userkey 查找</li><li>追加 kMaxSequenceNumber + kValueTypeForSeek</li></ul></li></ul><h3 id=源码-3>源码</h3><p>在 db/dbformat.h 中。</p><h1 id=env>Env</h1><p>LevelDB 是跨平台的，因此 Env 封装了跨平台的内容。</p><p>Env 是一个纯虚类，有三个实现版本：</p><ul><li>PosixEnv：封装了 <a href=https://zhuanlan.zhihu.com/p/526876127>posix</a> 标准下所有接口</li><li>WindowsEnv：封装了 win 相关接口</li><li>EnvWrapper：对 Env 的扩展，将所有调用转发到其他的 Env 实现</li></ul><h2 id=envwrapper>EnvWrapper</h2><p>EnvWrapper 可以理解成对 Env 的扩展，使用了代理模式来实现扩展。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0508025ca5882f41d7056dc7b99a92ba>8.3 - LevelDB-03Log</h1><h2 id=log作用>Log作用</h2><p>对于DB最怕的就是数据的丢失。当服务挂掉时，应尽可能的减少数据丢失。在 leveldb 中引入了 WAL 日志。</p><h2 id=基本组成>基本组成</h2><p>每个 Log 被划分成了很多 32K 大小的物理 block，写入、读取操作都是以 block 为单位进行。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// log_format.h
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>enum</span> <span style=color:#3f6e75>RecordType</span> {
</span></span><span style=display:flex><span>  <span style=color:#177500>// Zero is reserved for preallocated files
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>kZeroType</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>kFullType</span> <span style=color:#000>=</span> <span style=color:#1c01ce>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#177500>// For fragments
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>kFirstType</span> <span style=color:#000>=</span> <span style=color:#1c01ce>2</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>kMiddleType</span> <span style=color:#000>=</span> <span style=color:#1c01ce>3</span>,
</span></span><span style=display:flex><span>  <span style=color:#000>kLastType</span> <span style=color:#000>=</span> <span style=color:#1c01ce>4</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a90d91>static</span> <span style=color:#a90d91>const</span> <span style=color:#a90d91>int</span> <span style=color:#000>kMaxRecordType</span> <span style=color:#000>=</span> <span style=color:#000>kLastType</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>static</span> <span style=color:#a90d91>const</span> <span style=color:#a90d91>int</span> <span style=color:#000>kBlockSize</span> <span style=color:#000>=</span> <span style=color:#1c01ce>32768</span>;
</span></span><span style=display:flex><span><span style=color:#177500>// Header is checksum (4 bytes), length (2 bytes), type (1 byte).
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>static</span> <span style=color:#a90d91>const</span> <span style=color:#a90d91>int</span> <span style=color:#000>kHeaderSize</span> <span style=color:#000>=</span> <span style=color:#1c01ce>4</span> <span style=color:#000>+</span> <span style=color:#1c01ce>2</span> <span style=color:#000>+</span> <span style=color:#1c01ce>1</span>;
</span></span></code></pre></td></tr></table></div></div></div><h2 id=写入流程>写入流程</h2><p>入口：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// db_impl.cc
</span></span></span><span style=display:flex><span><span style=color:#177500>// Status DBImpl::Write(const WriteOptions&amp; options, WriteBatch* updates)
</span></span></span><span style=display:flex><span><span style=color:#177500></span>{
</span></span><span style=display:flex><span>  <span style=color:#000>mutex_</span>.<span style=color:#000>Unlock</span>();
</span></span><span style=display:flex><span>  <span style=color:#000>status</span> <span style=color:#000>=</span> <span style=color:#000>log_</span><span style=color:#000>-&gt;</span><span style=color:#000>AddRecord</span>(<span style=color:#000>WriteBatchInternal</span><span style=color:#000>::</span><span style=color:#000>Contents</span>(<span style=color:#000>write_batch</span>));
</span></span><span style=display:flex><span>  <span style=color:#a90d91>bool</span> <span style=color:#000>sync_error</span> <span style=color:#000>=</span> <span style=color:#a90d91>false</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>if</span> (<span style=color:#000>status</span>.<span style=color:#000>ok</span>() <span style=color:#000>&amp;&amp;</span> <span style=color:#000>options</span>.<span style=color:#000>sync</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000>status</span> <span style=color:#000>=</span> <span style=color:#000>logfile_</span><span style=color:#000>-&gt;</span><span style=color:#000>Sync</span>();
</span></span><span style=display:flex><span>    <span style=color:#a90d91>if</span> (<span style=color:#000>!</span><span style=color:#000>status</span>.<span style=color:#000>ok</span>()) {
</span></span><span style=display:flex><span>      <span style=color:#000>sync_error</span> <span style=color:#000>=</span> <span style=color:#a90d91>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a90d91>if</span> (<span style=color:#000>status</span>.<span style=color:#000>ok</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#000>status</span> <span style=color:#000>=</span> <span style=color:#000>WriteBatchInternal</span><span style=color:#000>::</span><span style=color:#000>InsertInto</span>(<span style=color:#000>write_batch</span>, <span style=color:#000>mem_</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#000>mutex_</span>.<span style=color:#000>Lock</span>();
</span></span></code></pre></td></tr></table></div></div></div><h3 id=addrecord>AddRecord</h3><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// log_writer.cc
</span></span></span><span style=display:flex><span><span style=color:#177500>// Status Writer::AddRecord(const Slice&amp; slice)
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>bool</span> <span style=color:#000>begin</span> <span style=color:#000>=</span> <span style=color:#a90d91>true</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>do</span> {
</span></span><span style=display:flex><span>  <span style=color:#177500>// 检查剩余可以写的空间
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>const</span> <span style=color:#a90d91>int</span> <span style=color:#000>leftover</span> <span style=color:#000>=</span> <span style=color:#000>kBlockSize</span> <span style=color:#000>-</span> <span style=color:#000>block_offset_</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>assert</span>(<span style=color:#000>leftover</span> <span style=color:#000>&gt;=</span> <span style=color:#1c01ce>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// 小于kHeaderSize，则需要开启新的block，因为kHeaderSize是必须要写的
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>if</span> (<span style=color:#000>leftover</span> <span style=color:#000>&lt;</span> <span style=color:#000>kHeaderSize</span>) {
</span></span><span style=display:flex><span>    <span style=color:#177500>// Switch to a new block
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#177500>// 剩余空间使用0填充
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>if</span> (<span style=color:#000>leftover</span> <span style=color:#000>&gt;</span> <span style=color:#1c01ce>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#177500>// Fill the trailer (literal below relies on kHeaderSize being 7)
</span></span></span><span style=display:flex><span><span style=color:#177500></span>      <span style=color:#a90d91>static_assert</span>(<span style=color:#000>kHeaderSize</span> <span style=color:#000>==</span> <span style=color:#1c01ce>7</span>, <span style=color:#c41a16>&#34;&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#000>dest_</span><span style=color:#000>-&gt;</span><span style=color:#000>Append</span>(<span style=color:#000>Slice</span>(<span style=color:#c41a16>&#34;</span><span style=color:#c41a16>\x00\x00\x00\x00\x00\x00</span><span style=color:#c41a16>&#34;</span>, <span style=color:#000>leftover</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#177500>// 开启新的block，重置
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>block_offset_</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#177500>// Invariant: we never leave &lt; kHeaderSize bytes in a block.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>assert</span>(<span style=color:#000>kBlockSize</span> <span style=color:#000>-</span> <span style=color:#000>block_offset_</span> <span style=color:#000>-</span> <span style=color:#000>kHeaderSize</span> <span style=color:#000>&gt;=</span> <span style=color:#1c01ce>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#a90d91>const</span> <span style=color:#000>size_t</span> <span style=color:#000>avail</span> <span style=color:#000>=</span> <span style=color:#000>kBlockSize</span> <span style=color:#000>-</span> <span style=color:#000>block_offset_</span> <span style=color:#000>-</span> <span style=color:#000>kHeaderSize</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>const</span> <span style=color:#000>size_t</span> <span style=color:#000>fragment_length</span> <span style=color:#000>=</span> (<span style=color:#000>left</span> <span style=color:#000>&lt;</span> <span style=color:#000>avail</span>) <span style=color:#000>?</span> <span style=color:#000>left</span> : <span style=color:#000>avail</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>RecordType</span> <span style=color:#000>type</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 计算是否刚好填满该block
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>const</span> <span style=color:#a90d91>bool</span> <span style=color:#000>end</span> <span style=color:#000>=</span> (<span style=color:#000>left</span> <span style=color:#000>==</span> <span style=color:#000>fragment_length</span>);
</span></span><span style=display:flex><span>  <span style=color:#a90d91>if</span> (<span style=color:#000>begin</span> <span style=color:#000>&amp;&amp;</span> <span style=color:#000>end</span>) { <span style=color:#177500>// 新block且刚好装下
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>type</span> <span style=color:#000>=</span> <span style=color:#000>kFullType</span>;
</span></span><span style=display:flex><span>  } <span style=color:#a90d91>else</span> <span style=color:#000>if</span> (<span style=color:#000>begin</span>) { <span style=color:#177500>// 新block，一个装不下
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>type</span> <span style=color:#000>=</span> <span style=color:#000>kFirstType</span>;
</span></span><span style=display:flex><span>  } <span style=color:#a90d91>else</span> <span style=color:#000>if</span> (<span style=color:#000>end</span>) { <span style=color:#177500>// 上一份数据到该block
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>type</span> <span style=color:#000>=</span> <span style=color:#000>kLastType</span>;
</span></span><span style=display:flex><span>  } <span style=color:#a90d91>else</span> {    <span style=color:#177500>// 其它场景
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>type</span> <span style=color:#000>=</span> <span style=color:#000>kMiddleType</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#000>s</span> <span style=color:#000>=</span> <span style=color:#000>EmitPhysicalRecord</span>(<span style=color:#000>type</span>, <span style=color:#000>ptr</span>, <span style=color:#000>fragment_length</span>);
</span></span><span style=display:flex><span>  <span style=color:#000>ptr</span> <span style=color:#000>+=</span> <span style=color:#000>fragment_length</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>left</span> <span style=color:#000>-=</span> <span style=color:#000>fragment_length</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>begin</span> <span style=color:#000>=</span> <span style=color:#a90d91>false</span>;
</span></span><span style=display:flex><span>} <span style=color:#a90d91>while</span> (<span style=color:#000>s</span>.<span style=color:#000>ok</span>() <span style=color:#000>&amp;&amp;</span> <span style=color:#000>left</span> <span style=color:#000>&gt;</span> <span style=color:#1c01ce>0</span>);
</span></span></code></pre></td></tr></table></div></div></details><br><h3 id=emitphysicalrecord>EmitPhysicalRecord</h3><p>接着查看 EmitPhysicalRecord 函数</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr,
</span></span><span style=display:flex><span>                                  size_t length) {
</span></span><span style=display:flex><span>  assert(length &lt;= 0xffff);  // Must fit in two bytes
</span></span><span style=display:flex><span>  assert(block_offset_ + kHeaderSize + length &lt;= kBlockSize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  // Format the header
</span></span><span style=display:flex><span>  char buf[kHeaderSize];
</span></span><span style=display:flex><span>  // 序列化长度和recordtype信息
</span></span><span style=display:flex><span>  buf[4] = static_cast&lt;char&gt;(length &amp; 0xff);
</span></span><span style=display:flex><span>  buf[5] = static_cast&lt;char&gt;(length &gt;&gt; 8);
</span></span><span style=display:flex><span>  buf[6] = static_cast&lt;char&gt;(t);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  // Compute the crc of the record type and the payload.
</span></span><span style=display:flex><span>  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, length);
</span></span><span style=display:flex><span>  crc = crc32c::Mask(crc);  // Adjust for storage
</span></span><span style=display:flex><span>  EncodeFixed32(buf, crc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  // Write the header and the payload
</span></span><span style=display:flex><span>  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));
</span></span><span style=display:flex><span>  if (s.ok()) {
</span></span><span style=display:flex><span>    s = dest_-&gt;Append(Slice(ptr, length));
</span></span><span style=display:flex><span>    if (s.ok()) {
</span></span><span style=display:flex><span>      s = dest_-&gt;Flush();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  block_offset_ += kHeaderSize + length;
</span></span><span style=display:flex><span>  return s;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></details><br><h3 id=sync>Sync</h3><p>注意 DBImpl::Write 函数中调用完 AddRecord 后立马调用了 Sync 函数进行了同步。</p><h2 id=删除日志>删除日志</h2><p>doc(<strong>doc/impl.md</strong>)文档里面讲解了，在打开数据库以及compact之后，会将不再使用的文件删除，使用的函数是 RemoveObsoleteFiles。可以通过添加日志或者 gdb 来查看。</p><h3 id=打开数据库>打开数据库</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// db_impl.cc
</span></span></span><span style=display:flex><span><span style=color:#177500>// Status DB::Open(const Options&amp; options, const std::string&amp; dbname, DB** dbptr)
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>if</span> (<span style=color:#000>s</span>.<span style=color:#000>ok</span>()) {
</span></span><span style=display:flex><span>  <span style=color:#000>impl</span><span style=color:#000>-&gt;</span><span style=color:#000>RemoveObsoleteFiles</span>();
</span></span><span style=display:flex><span>  <span style=color:#000>impl</span><span style=color:#000>-&gt;</span><span style=color:#000>MaybeScheduleCompaction</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#000>impl</span><span style=color:#000>-&gt;</span><span style=color:#000>mutex_</span>.<span style=color:#000>Unlock</span>();
</span></span></code></pre></td></tr></table></div></div></div><h3 id=数据压缩>数据压缩</h3><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// void DBImpl::CompactMemTable() 
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>if</span> (<span style=color:#000>s</span>.<span style=color:#000>ok</span>()) {
</span></span><span style=display:flex><span>  <span style=color:#177500>// Commit to the new state
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>imm_</span><span style=color:#000>-&gt;</span><span style=color:#000>Unref</span>();
</span></span><span style=display:flex><span>  <span style=color:#000>imm_</span> <span style=color:#000>=</span> <span style=color:#a90d91>nullptr</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>has_imm_</span>.<span style=color:#000>store</span>(<span style=color:#a90d91>false</span>, <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>memory_order_release</span>);
</span></span><span style=display:flex><span>  <span style=color:#000>RemoveObsoleteFiles</span>();
</span></span><span style=display:flex><span>} <span style=color:#a90d91>else</span> {
</span></span><span style=display:flex><span>  <span style=color:#000>RecordBackgroundError</span>(<span style=color:#000>s</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></div></div><div class=td-content style=page-break-before:always><h1 id=pg-eb58a0144226b02120405fa607fe5c26>8.4 - LevelDB-04数据读写</h1><h1 id=数据写入>数据写入</h1><h2 id=基本原理>基本原理</h2><h3 id=新增记录>新增记录</h3><p>一个插入操作 Put(key, value) 包含两个具体步骤：</p><ol><li>追加写入 log</li></ol><blockquote><p>以顺序写的方式追加到 log 文件末尾。磁盘顺序写的方式效率很高，不会导致写入速度的急剧降低。</p></blockquote><ol start=2><li>写入 memtable</li></ol><blockquote><p>如果写入 log 文件成功，那么记录也会插入内存的 Memtable 中，Memtable 是一个 key 有序的跳表。</p></blockquote><p>正是因为一个插入操作涉及一次磁盘文件追加写和内存跳表的插入操作，所以 LevelDB 写入速度很高效。</p><h3 id=删除记录>删除记录</h3><p>删除一条记录并不是立即执行删除操作，而是与插入操作相同，只不过插入操作是插入 key:value 值，而删除操作是插入 key:删除标记，等后台 Compaction 时才执行真正的删除操作。</p><h2 id=writebatch>WriteBatch</h2><p>WriteBatch 使用批量写来提高性能，支持 put 和 delete。</p><h3 id=结构>结构</h3><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// include/leveldb/write_batch.h
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>LEVELDB_EXPORT</span> <span style=color:#000>WriteBatch</span> {
</span></span><span style=display:flex><span> <span style=color:#a90d91>public</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#177500>// Store the mapping &#34;key-&gt;value&#34; in the database.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>void</span> <span style=color:#000>Put</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>value</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// If the database contains a mapping for &#34;key&#34;, erase it.  Else do nothing.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>void</span> <span style=color:#000>Delete</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// Clear all updates buffered in this batch.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>void</span> <span style=color:#000>Clear</span>();
</span></span><span style=display:flex><span>  <span style=color:#177500>// 内存状态信息
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>size_t</span> <span style=color:#000>ApproximateSize</span>() <span style=color:#a90d91>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 多个 WriteBatch 还可以继续合并
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>void</span> <span style=color:#000>Append</span>(<span style=color:#a90d91>const</span> <span style=color:#000>WriteBatch</span><span style=color:#000>&amp;</span> <span style=color:#000>source</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// Support for iterating over the contents of a batch.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Status</span> <span style=color:#000>Iterate</span>(<span style=color:#000>Handler</span><span style=color:#000>*</span> <span style=color:#000>handler</span>) <span style=color:#a90d91>const</span>;
</span></span><span style=display:flex><span> <span style=color:#a90d91>private</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#177500>//内部工具性质的辅助类
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>friend</span> <span style=color:#a90d91>class</span> <span style=color:#3f6e75>WriteBatchInternal</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 具体数据
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span> <span style=color:#000>rep_</span>;  <span style=color:#177500>// See comment in write_batch.cc for the format of rep_
</span></span></span><span style=display:flex><span><span style=color:#177500></span>};
</span></span><span style=display:flex><span>}  <span style=color:#177500>// namespace leveldb
</span></span></span><span style=display:flex><span><span style=color:#177500></span>
</span></span><span style=display:flex><span><span style=color:#177500>// db/write_batch.cc
</span></span></span><span style=display:flex><span><span style=color:#177500>// WriteBatch header has an 8-byte sequence number followed by a 4-byte count.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>static</span> <span style=color:#a90d91>const</span> <span style=color:#000>size_t</span> <span style=color:#000>kHeader</span> <span style=color:#000>=</span> <span style=color:#1c01ce>12</span>;
</span></span></code></pre></td></tr></table></div></div></details><br><h3 id=写入数据>写入数据</h3><p>代码：include/leveldb/write_batch.h；db/write_batch_internal.h</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span> <span style=color:#000>value</span>;
</span></span><span style=display:flex><span><span style=color:#000>leveldb</span><span style=color:#000>::</span><span style=color:#000>Status</span> <span style=color:#000>s</span> <span style=color:#000>=</span> <span style=color:#000>db</span><span style=color:#000>-&gt;</span><span style=color:#000>Get</span>(<span style=color:#000>leveldb</span><span style=color:#000>::</span><span style=color:#000>ReadOptions</span>(), <span style=color:#000>key1</span>, <span style=color:#000>&amp;</span><span style=color:#000>value</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>if</span> (<span style=color:#000>s</span>.<span style=color:#000>ok</span>()) <span style=color:#000>s</span> <span style=color:#000>=</span> <span style=color:#000>db</span><span style=color:#000>-&gt;</span><span style=color:#000>Put</span>(<span style=color:#000>leveldb</span><span style=color:#000>::</span><span style=color:#000>WriteOptions</span>(), <span style=color:#000>key2</span>, <span style=color:#000>value</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>if</span> (<span style=color:#000>s</span>.<span style=color:#000>ok</span>()) <span style=color:#000>s</span> <span style=color:#000>=</span> <span style=color:#000>db</span><span style=color:#000>-&gt;</span><span style=color:#000>Delete</span>(<span style=color:#000>leveldb</span><span style=color:#000>::</span><span style=color:#000>WriteOptions</span>(), <span style=color:#000>key1</span>);
</span></span></code></pre></td></tr></table></div></div></div><p>调用 db->Put(WriteOptions(),&key,&value); 写入数据。WriteOptions 只有一个变量 sync，默认初始值为 false，因此默认写数据方式是异步。即每次写操作只要将数据写入到内存中就返回，而将数据从内存写到磁盘的方式是异步的。
异步写的效率比同步写高很多，问题是系统故障时可能会导致最近的写入丢失。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#633820>#include</span> <span style=color:#633820>&#34;leveldb/write_batch.h&#34;</span><span style=color:#633820>
</span></span></span><span style=display:flex><span><span style=color:#633820></span>...
</span></span><span style=display:flex><span><span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span> <span style=color:#000>value</span>;
</span></span><span style=display:flex><span><span style=color:#000>leveldb</span><span style=color:#000>::</span><span style=color:#000>Status</span> <span style=color:#000>s</span> <span style=color:#000>=</span> <span style=color:#000>db</span><span style=color:#000>-&gt;</span><span style=color:#000>Get</span>(<span style=color:#000>leveldb</span><span style=color:#000>::</span><span style=color:#000>ReadOptions</span>(), <span style=color:#000>key1</span>, <span style=color:#000>&amp;</span><span style=color:#000>value</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>if</span> (<span style=color:#000>s</span>.<span style=color:#000>ok</span>()) {
</span></span><span style=display:flex><span>  <span style=color:#000>leveldb</span><span style=color:#000>::</span><span style=color:#000>WriteBatch</span> <span style=color:#000>batch</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>batch</span>.<span style=color:#000>Delete</span>(<span style=color:#000>key1</span>);
</span></span><span style=display:flex><span>  <span style=color:#000>batch</span>.<span style=color:#000>Put</span>(<span style=color:#000>key2</span>, <span style=color:#000>value</span>);
</span></span><span style=display:flex><span>  <span style=color:#000>s</span> <span style=color:#000>=</span> <span style=color:#000>db</span><span style=color:#000>-&gt;</span><span style=color:#000>Write</span>(<span style=color:#000>leveldb</span><span style=color:#000>::</span><span style=color:#000>WriteOptions</span>(), <span style=color:#000>&amp;</span><span style=color:#000>batch</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></div><p>LevelDB 使用 WriteBatch 替代简单的异步写操作。首先将所有的写操作记录到一个 batch 中，然后执行同步写，这样同步写的开销就被分散到多个写操作中。</p><h2 id=写操作>写操作</h2><h3 id=写接口>写接口</h3><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>LEVELDB_EXPORT</span> <span style=color:#000>DB</span> {
</span></span><span style=display:flex><span> <span style=color:#a90d91>public</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#177500>// Open the database with the specified &#34;name&#34;.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// Stores a pointer to a heap-allocated database in *dbptr and returns
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// OK on success.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// Stores nullptr in *dbptr and returns a non-OK status on error.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// Caller should delete *dbptr when it is no longer needed.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>static</span> <span style=color:#000>Status</span> <span style=color:#000>Open</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Options</span><span style=color:#000>&amp;</span> <span style=color:#000>options</span>, <span style=color:#a90d91>const</span> <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span><span style=color:#000>&amp;</span> <span style=color:#000>name</span>,
</span></span><span style=display:flex><span>                     <span style=color:#000>DB</span><span style=color:#000>**</span> <span style=color:#000>dbptr</span>);
</span></span><span style=display:flex><span>  <span style=color:#000>DB</span>() <span style=color:#000>=</span> <span style=color:#a90d91>default</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>DB</span>(<span style=color:#a90d91>const</span> <span style=color:#000>DB</span><span style=color:#000>&amp;</span>) <span style=color:#000>=</span> <span style=color:#a90d91>delete</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>DB</span><span style=color:#000>&amp;</span> <span style=color:#a90d91>operator</span><span style=color:#000>=</span>(<span style=color:#a90d91>const</span> <span style=color:#000>DB</span><span style=color:#000>&amp;</span>) <span style=color:#000>=</span> <span style=color:#a90d91>delete</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>virtual</span> <span style=color:#000>~</span><span style=color:#000>DB</span>();
</span></span><span style=display:flex><span>  <span style=color:#177500>// Set the database entry for &#34;key&#34; to &#34;value&#34;.  Returns OK on success,
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// and a non-OK status on error.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// Note: consider setting options.sync = true.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#000>Status</span> <span style=color:#000>Put</span>(<span style=color:#a90d91>const</span> <span style=color:#000>WriteOptions</span><span style=color:#000>&amp;</span> <span style=color:#000>options</span>, <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>,
</span></span><span style=display:flex><span>                     <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>value</span>) <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>virtual</span> <span style=color:#000>Status</span> <span style=color:#000>Delete</span>(<span style=color:#a90d91>const</span> <span style=color:#000>WriteOptions</span><span style=color:#000>&amp;</span> <span style=color:#000>options</span>, <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>) <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>virtual</span> <span style=color:#000>Status</span> <span style=color:#000>Write</span>(<span style=color:#a90d91>const</span> <span style=color:#000>WriteOptions</span><span style=color:#000>&amp;</span> <span style=color:#000>options</span>, <span style=color:#000>WriteBatch</span><span style=color:#000>*</span> <span style=color:#000>updates</span>) <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span></code></pre></td></tr></table></div></div></details><br><h3 id=写实现>写实现</h3><p>代码：db/db_impl.h</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>DBImpl</span> <span style=color:#000>:</span> <span style=color:#a90d91>public</span> <span style=color:#000>DB</span> {
</span></span><span style=display:flex><span> <span style=color:#a90d91>public</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#177500>// 更新一条记录
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// leveldb::DBImpl::Put =&gt; leveldb::DB::Put =&gt; leveldb::DBImpl::Write
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Status</span> <span style=color:#000>Put</span>(<span style=color:#a90d91>const</span> <span style=color:#000>WriteOptions</span><span style=color:#000>&amp;</span>, <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>,
</span></span><span style=display:flex><span>             <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>value</span>) <span style=color:#a90d91>override</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 删除一条记录
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// leveldb::DBImpl::Delete =&gt; leveldb::DB::Delete =&gt; leveldb::DBImpl::Write
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Status</span> <span style=color:#000>Delete</span>(<span style=color:#a90d91>const</span> <span style=color:#000>WriteOptions</span><span style=color:#000>&amp;</span>, <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>) <span style=color:#a90d91>override</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 更新多条记录
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Status</span> <span style=color:#000>Write</span>(<span style=color:#a90d91>const</span> <span style=color:#000>WriteOptions</span><span style=color:#000>&amp;</span> <span style=color:#000>options</span>, <span style=color:#000>WriteBatch</span><span style=color:#000>*</span> <span style=color:#000>updates</span>) <span style=color:#a90d91>override</span>;
</span></span></code></pre></td></tr></table></div></div></div><p>注意调用流程：leveldb::DBImpl::Put => leveldb::DB::Put => leveldb::DBImpl::Write</p><h3 id=dbimpl-write>DBImpl::Write</h3><p>代码：db/db_impl.cc</p><p>基本流程：</p><ul><li>构造 Writer</li><li>将 writebatch 存入到一个 Writer 中，</li><li>将 Writer 存入 deque 中。（levedb支持多线程，需要加互斥锁保护writers_）</li><li>每个生产者在向 writers_ 队列中添加任务之后，都会进入一个 while 循环在里面等待。只有当该生产者加入的任务已经被处理或位于队列的头部，线程才会被唤醒。注意线程被唤醒后会继续检查循环条件，满足条件会继续睡眠。<ul><li>加入的任务被其他任务处理，线程直接退出。</li><li>加入的任务排在了队列的头部且未处理，当前线程将消费者进行后续处理。<style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// Writer 结构
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>struct</span> <span style=color:#3f6e75>DBImpl</span><span style=color:#000>::</span><span style=color:#000>Writer</span> {
</span></span><span style=display:flex><span>  <span style=color:#a90d91>explicit</span> <span style=color:#000>Writer</span>(<span style=color:#000>port</span><span style=color:#000>::</span><span style=color:#000>Mutex</span><span style=color:#000>*</span> <span style=color:#000>mu</span>)
</span></span><span style=display:flex><span>      <span style=color:#000>:</span> <span style=color:#000>batch</span>(<span style=color:#a90d91>nullptr</span>), <span style=color:#000>sync</span>(<span style=color:#a90d91>false</span>), <span style=color:#000>done</span>(<span style=color:#a90d91>false</span>), <span style=color:#000>cv</span>(<span style=color:#000>mu</span>) {}
</span></span><span style=display:flex><span>  <span style=color:#000>Status</span> <span style=color:#000>status</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>WriteBatch</span><span style=color:#000>*</span> <span style=color:#000>batch</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>bool</span> <span style=color:#000>sync</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>bool</span> <span style=color:#000>done</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>port</span><span style=color:#000>::</span><span style=color:#000>CondVar</span> <span style=color:#000>cv</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#000>Status</span> <span style=color:#000>DBImpl</span><span style=color:#000>::</span><span style=color:#000>Write</span>(<span style=color:#a90d91>const</span> <span style=color:#000>WriteOptions</span><span style=color:#000>&amp;</span> <span style=color:#000>options</span>, <span style=color:#000>WriteBatch</span><span style=color:#000>*</span> <span style=color:#000>updates</span>) {
</span></span><span style=display:flex><span>  <span style=color:#177500>// 构造 Writer
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Writer</span> <span style=color:#000>w</span>(<span style=color:#000>&amp;</span><span style=color:#000>mutex_</span>);
</span></span><span style=display:flex><span>  <span style=color:#000>w</span>.<span style=color:#000>batch</span> <span style=color:#000>=</span> <span style=color:#000>updates</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>w</span>.<span style=color:#000>sync</span> <span style=color:#000>=</span> <span style=color:#000>options</span>.<span style=color:#000>sync</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>w</span>.<span style=color:#000>done</span> <span style=color:#000>=</span> <span style=color:#a90d91>false</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>MutexLock</span> <span style=color:#000>l</span>(<span style=color:#000>&amp;</span><span style=color:#000>mutex_</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// 将 Writer push 到 deque 中
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>writers_</span>.<span style=color:#000>push_back</span>(<span style=color:#000>&amp;</span><span style=color:#000>w</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// 构造 Writer 未执行完时(如合并操作，可能会被其它线程执行完成)，
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 且未到队列头(没有获得调度)时，则等待
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>while</span> (<span style=color:#000>!</span><span style=color:#000>w</span>.<span style=color:#000>done</span> <span style=color:#000>&amp;&amp;</span> <span style=color:#000>&amp;</span><span style=color:#000>w</span> <span style=color:#000>!=</span> <span style=color:#000>writers_</span>.<span style=color:#000>front</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#000>w</span>.<span style=color:#000>cv</span>.<span style=color:#000>Wait</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#177500>// 如果Writer任务被其它writer执行完成，则返回。
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>if</span> (<span style=color:#000>w</span>.<span style=color:#000>done</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#000>w</span>.<span style=color:#000>status</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#177500>// 真正执行调度
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  ...
</span></span><span style=display:flex><span>  <span style=color:#177500>// 将处理完的任务从队列中取出，设置状态为 true，然后通知对应的 port::CondVar
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>while</span> (<span style=color:#a90d91>true</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000>Writer</span><span style=color:#000>*</span> <span style=color:#000>ready</span> <span style=color:#000>=</span> <span style=color:#000>writers_</span>.<span style=color:#000>front</span>();
</span></span><span style=display:flex><span>    <span style=color:#000>writers_</span>.<span style=color:#000>pop_front</span>();
</span></span><span style=display:flex><span>    <span style=color:#a90d91>if</span> (<span style=color:#000>ready</span> <span style=color:#000>!=</span> <span style=color:#000>&amp;</span><span style=color:#000>w</span>) {
</span></span><span style=display:flex><span>      <span style=color:#000>ready</span><span style=color:#000>-&gt;</span><span style=color:#000>status</span> <span style=color:#000>=</span> <span style=color:#000>status</span>;
</span></span><span style=display:flex><span>      <span style=color:#000>ready</span><span style=color:#000>-&gt;</span><span style=color:#000>done</span> <span style=color:#000>=</span> <span style=color:#a90d91>true</span>;
</span></span><span style=display:flex><span>      <span style=color:#000>ready</span><span style=color:#000>-&gt;</span><span style=color:#000>cv</span>.<span style=color:#000>Signal</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a90d91>if</span> (<span style=color:#000>ready</span> <span style=color:#000>==</span> <span style=color:#000>last_writer</span>) <span style=color:#a90d91>break</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#177500>// 通知队列中的首 Writer
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>if</span> (<span style=color:#000>!</span><span style=color:#000>writers_</span>.<span style=color:#000>empty</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#000>writers_</span>.<span style=color:#000>front</span>()<span style=color:#000>-&gt;</span><span style=color:#000>cv</span>.<span style=color:#000>Signal</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a90d91>return</span> <span style=color:#000>status</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></details><br></li></ul></li></ul><h1 id=数据读取>数据读取</h1><h2 id=数据读取流程>数据读取流程</h2><ul><li>Memtable 查找：首先会去查看内存中的 Memtable，如果 Memtable 中包含key及其对应的value，则直接返回；</li><li>Immutable Memtable 查找：接下来会到内存中的 Immutable Memtable 中查找，读到则返回；</li><li>SSTable 查找：SSTable数量较多且分成多个 level。首先从属于 level 0 的文件中查找，如果找到则直接返回，如果没有找到则到下一个 level 的文件中查找，如此循环往复直到找到或查遍所有 level 没有仍然找到返回不存在为止。</li></ul><h2 id=sst>SST</h2><h3 id=数据分布>数据分布</h3><ul><li>level 0下的不同文件可能key的范围有重叠，某个要查询的key有可能多个文件都包含。</li></ul><blockquote><p>策略是先找出 level 0 中哪些文件包含这个key（manifest文件中记载了level和对应的文件及文件里key的范围信息，内存中保存该映射表），之后按照文件的新鲜程度排序，新的文件排在前面，之后依次查找，读出key对应的value。</p></blockquote><ul><li>非level 0下的不同文件之间key是不重叠的，所以只从一个文件就可以找到key对应的value。</li></ul><h3 id=查询过程>查询过程</h3><p>如果命中了 SST，那么查询过程如下：</p><ul><li>一般先在内存中的 Cache 中查找是否包含这个文件的缓存记录，找到则从缓存中读取；</li><li>然后打开 SSTable 文件，同时将文件的索引部分加载到内存中存入 Cache（只有索引部分在 Cache中）；</li><li>根据索引定位到哪个 Block 包含 key，从文件中读出 Block 的内容，然后根据记录逐一比较，找到则返回，没有找到则到下一级别的 SSTable 中查找。</li></ul><h2 id=读操作>读操作</h2><h3 id=读接口>读接口</h3><p>代码：include/leveldb/db.h</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>virtual</span> <span style=color:#000>Status</span> <span style=color:#000>Get</span>(<span style=color:#a90d91>const</span> <span style=color:#000>ReadOptions</span><span style=color:#000>&amp;</span> <span style=color:#000>options</span>, <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>,
</span></span><span style=display:flex><span>                   <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span><span style=color:#000>*</span> <span style=color:#000>value</span>) <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span></code></pre></td></tr></table></div></div></div><h3 id=读实现>读实现</h3><p>代码：db/db_impl.h</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>DBImpl</span> <span style=color:#000>:</span> <span style=color:#a90d91>public</span> <span style=color:#000>DB</span> {
</span></span><span style=display:flex><span> <span style=color:#a90d91>public</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#177500>// 读取记录
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Status</span> <span style=color:#000>Get</span>(<span style=color:#a90d91>const</span> <span style=color:#000>ReadOptions</span><span style=color:#000>&amp;</span> <span style=color:#000>options</span>, <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>,
</span></span><span style=display:flex><span>           <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span><span style=color:#000>*</span> <span style=color:#000>value</span>) <span style=color:#a90d91>override</span>;
</span></span></code></pre></td></tr></table></div></div></div><h3 id=dbimpl-get>DBImpl::Get</h3><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>Status</span> <span style=color:#000>DBImpl</span><span style=color:#000>::</span><span style=color:#000>Get</span>(<span style=color:#a90d91>const</span> <span style=color:#000>ReadOptions</span><span style=color:#000>&amp;</span> <span style=color:#000>options</span>, <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>,
</span></span><span style=display:flex><span>                   <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>string</span><span style=color:#000>*</span> <span style=color:#000>value</span>) {
</span></span><span style=display:flex><span>  <span style=color:#000>Status</span> <span style=color:#000>s</span>; 
</span></span><span style=display:flex><span>  <span style=color:#177500>// 获取互斥锁
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>MutexLock</span> <span style=color:#000>l</span>(<span style=color:#000>&amp;</span><span style=color:#000>mutex_</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// 获取本地读操作的 Sequence Number
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>SequenceNumber</span> <span style=color:#000>snapshot</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 如果 ReadOptions 的 snapshot 不为空，则使用这个 Sequence Number
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 否则，默认使用 LastSequence
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>if</span> (<span style=color:#000>options</span>.<span style=color:#000>snapshot</span> <span style=color:#000>!=</span> <span style=color:#a90d91>nullptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000>snapshot</span> <span style=color:#000>=</span>
</span></span><span style=display:flex><span>        <span style=color:#a90d91>static_cast</span><span style=color:#000>&lt;</span><span style=color:#a90d91>const</span> <span style=color:#000>SnapshotImpl</span><span style=color:#000>*&gt;</span>(<span style=color:#000>options</span>.<span style=color:#000>snapshot</span>)<span style=color:#000>-&gt;</span><span style=color:#000>sequence_number</span>();
</span></span><span style=display:flex><span>  } <span style=color:#a90d91>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#000>snapshot</span> <span style=color:#000>=</span> <span style=color:#000>versions_</span><span style=color:#000>-&gt;</span><span style=color:#000>LastSequence</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#177500>// MemTable、Immutable Memtable 和 Current Version 增加引用计数，
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 避免在读取过程中被后台线程 Compaction 时垃圾回收
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>MemTable</span><span style=color:#000>*</span> <span style=color:#000>mem</span> <span style=color:#000>=</span> <span style=color:#000>mem_</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>MemTable</span><span style=color:#000>*</span> <span style=color:#000>imm</span> <span style=color:#000>=</span> <span style=color:#000>imm_</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// Version 主要用来维护 SST 文件的版本信息
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Version</span><span style=color:#000>*</span> <span style=color:#000>current</span> <span style=color:#000>=</span> <span style=color:#000>versions_</span><span style=color:#000>-&gt;</span><span style=color:#000>current</span>();
</span></span><span style=display:flex><span>  <span style=color:#000>mem</span><span style=color:#000>-&gt;</span><span style=color:#000>Ref</span>();
</span></span><span style=display:flex><span>  <span style=color:#a90d91>if</span> (<span style=color:#000>imm</span> <span style=color:#000>!=</span> <span style=color:#a90d91>nullptr</span>) <span style=color:#000>imm</span><span style=color:#000>-&gt;</span><span style=color:#000>Ref</span>();
</span></span><span style=display:flex><span>  <span style=color:#000>current</span><span style=color:#000>-&gt;</span><span style=color:#000>Ref</span>();
</span></span><span style=display:flex><span>  <span style=color:#a90d91>bool</span> <span style=color:#000>have_stat_update</span> <span style=color:#000>=</span> <span style=color:#a90d91>false</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>Version</span><span style=color:#000>::</span><span style=color:#000>GetStats</span> <span style=color:#000>stats</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// Unlock while reading from files and memtables
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  {
</span></span><span style=display:flex><span>    <span style=color:#000>mutex_</span>.<span style=color:#000>Unlock</span>();
</span></span><span style=display:flex><span>    <span style=color:#177500>// First look in the memtable, then in the immutable memtable (if any).
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>LookupKey</span> <span style=color:#000>lkey</span>(<span style=color:#000>key</span>, <span style=color:#000>snapshot</span>);
</span></span><span style=display:flex><span>    <span style=color:#177500>// 查找过程：
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#177500>// 1、从 MemTable 查找
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#a90d91>if</span> (<span style=color:#000>mem</span><span style=color:#000>-&gt;</span><span style=color:#000>Get</span>(<span style=color:#000>lkey</span>, <span style=color:#000>value</span>, <span style=color:#000>&amp;</span><span style=color:#000>s</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#177500>// Done
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#177500>// 从 Immutable Memtable 查找
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    } <span style=color:#a90d91>else</span> <span style=color:#000>if</span> (<span style=color:#000>imm</span> <span style=color:#000>!=</span> <span style=color:#a90d91>nullptr</span> <span style=color:#000>&amp;&amp;</span> <span style=color:#000>imm</span><span style=color:#000>-&gt;</span><span style=color:#000>Get</span>(<span style=color:#000>lkey</span>, <span style=color:#000>value</span>, <span style=color:#000>&amp;</span><span style=color:#000>s</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#177500>// Done
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#177500>// 从 SSTable 文件中查找
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    } <span style=color:#a90d91>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#000>s</span> <span style=color:#000>=</span> <span style=color:#000>current</span><span style=color:#000>-&gt;</span><span style=color:#000>Get</span>(<span style=color:#000>options</span>, <span style=color:#000>lkey</span>, <span style=color:#000>value</span>, <span style=color:#000>&amp;</span><span style=color:#000>stats</span>);
</span></span><span style=display:flex><span>      <span style=color:#000>have_stat_update</span> <span style=color:#000>=</span> <span style=color:#a90d91>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#000>mutex_</span>.<span style=color:#000>Lock</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#177500>// 更新 SST 文件的统计信息，根据统计结果决定是否调度后台 Compaction
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>if</span> (<span style=color:#000>have_stat_update</span> <span style=color:#000>&amp;&amp;</span> <span style=color:#000>current</span><span style=color:#000>-&gt;</span><span style=color:#000>UpdateStats</span>(<span style=color:#000>stats</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#000>MaybeScheduleCompaction</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#177500>// MemTable、Immutable Memtable 和 Current Version 减少引用计数
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>mem</span><span style=color:#000>-&gt;</span><span style=color:#000>Unref</span>();
</span></span><span style=display:flex><span>  <span style=color:#a90d91>if</span> (<span style=color:#000>imm</span> <span style=color:#000>!=</span> <span style=color:#a90d91>nullptr</span>) <span style=color:#000>imm</span><span style=color:#000>-&gt;</span><span style=color:#000>Unref</span>();
</span></span><span style=display:flex><span>  <span style=color:#000>current</span><span style=color:#000>-&gt;</span><span style=color:#000>Unref</span>();
</span></span><span style=display:flex><span>  <span style=color:#a90d91>return</span> <span style=color:#000>s</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></details><br><p>注意：MemTable、Immutable Memtable 和 Current Version 查找不需要加锁，因为前两个是 SkipList，其读操作是线程安全的，只需要通过引用计数保证数据结构不被回收即可。Current Version 内部是 SSTable 文件，都是只读操作，也无需加锁。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0fbcf3acb82df1e77d1d85e0d7e0bead>8.5 - LevelDB-05Cache</h1><h2 id=简介>简介</h2><p>为了读取效率使用了 Cache 机制。主要是 Table Cache 和 Block Cache 两类。</p><p>Table Cache 主要是缓存 SST 文件的 data block index，Block Cache 主要是缓存 data block。</p><h2 id=通用接口>通用接口</h2><p>代码：include/leveldb/cache.h</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>LEVELDB_EXPORT</span> <span style=color:#000>Cache</span> {
</span></span><span style=display:flex><span> <span style=color:#a90d91>public</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#000>Cache</span>() <span style=color:#000>=</span> <span style=color:#a90d91>default</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>Cache</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Cache</span><span style=color:#000>&amp;</span>) <span style=color:#000>=</span> <span style=color:#a90d91>delete</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>Cache</span><span style=color:#000>&amp;</span> <span style=color:#a90d91>operator</span><span style=color:#000>=</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Cache</span><span style=color:#000>&amp;</span>) <span style=color:#000>=</span> <span style=color:#a90d91>delete</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// Destroys all existing entries by calling the &#34;deleter&#34;
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 调用 deleter 删除所有 entries
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#000>~</span><span style=color:#000>Cache</span>();
</span></span><span style=display:flex><span>  <span style=color:#177500>// Opaque handle to an entry stored in the cache.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 存储的 entry，除了kv还有一些维护信息，这里是通用接口所以没有定义
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>struct</span> <span style=color:#3f6e75>Handle</span> {};
</span></span><span style=display:flex><span>  <span style=color:#177500>// 插入kv，charge 表示本次插入操作对cache容量的消耗
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// entry 被淘汰是，使用 deleter 进行删除
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#000>Handle</span><span style=color:#000>*</span> <span style=color:#000>Insert</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#a90d91>void</span><span style=color:#000>*</span> <span style=color:#000>value</span>, <span style=color:#000>size_t</span> <span style=color:#000>charge</span>,
</span></span><span style=display:flex><span>                         <span style=color:#a90d91>void</span> (<span style=color:#000>*</span><span style=color:#000>deleter</span>)(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#a90d91>void</span><span style=color:#000>*</span> <span style=color:#000>value</span>)) <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 查找接口
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#000>Handle</span><span style=color:#000>*</span> <span style=color:#000>Lookup</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>) <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 释放 handle
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#a90d91>void</span> <span style=color:#000>Release</span>(<span style=color:#000>Handle</span><span style=color:#000>*</span> <span style=color:#000>handle</span>) <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 获取 handle 的 value
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#a90d91>void</span><span style=color:#000>*</span> <span style=color:#000>Value</span>(<span style=color:#000>Handle</span><span style=color:#000>*</span> <span style=color:#000>handle</span>) <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 删除对应 key 记录
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 真正的存储记录，所有相关的 handles 都释放了才会被删除
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#a90d91>void</span> <span style=color:#000>Erase</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>) <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 生成 cacheid
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#a90d91>uint64_t</span> <span style=color:#000>NewId</span>() <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 删除 lru_ 链上的记录
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#a90d91>void</span> <span style=color:#000>Prune</span>() {}
</span></span><span style=display:flex><span>  <span style=color:#177500>// cache 的开销，Insert 接口传入 charge 之和
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>virtual</span> <span style=color:#000>size_t</span> <span style=color:#000>TotalCharge</span>() <span style=color:#a90d91>const</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div></details><br><h2 id=lruhandle>LRUHandle</h2><p>代码：util/cache.cc</p><p>LRUHandle 类主要用于自定义的 hashtable 和 LRU 中的节点。</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>struct</span> <span style=color:#3f6e75>LRUHandle</span> {
</span></span><span style=display:flex><span>  <span style=color:#a90d91>void</span><span style=color:#000>*</span> <span style=color:#000>value</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 删除器，refs==0 调用deleter完成value对象释放
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>void</span> (<span style=color:#000>*</span><span style=color:#000>deleter</span>)(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span>, <span style=color:#a90d91>void</span><span style=color:#000>*</span> <span style=color:#000>value</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// HashTable 节点，指向hash值相同的节点（采用链地址法解决hash冲突）
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>next_hash</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// LRUCache 节点，指向后继
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>next</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// LRUCache 节点，指向前驱
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>prev</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 用户指定占用缓存的大小
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>size_t</span> <span style=color:#000>charge</span>;  <span style=color:#177500>// TODO(opt): Only allow uint32_t?
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>size_t</span> <span style=color:#000>key_length</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>bool</span> <span style=color:#000>in_cache</span>;     <span style=color:#177500>// Whether entry is in the cache.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>uint32_t</span> <span style=color:#000>refs</span>;     <span style=color:#177500>// References, including cache reference, if present.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>uint32_t</span> <span style=color:#000>hash</span>;     <span style=color:#177500>// Hash of key(); used for fast sharding and comparisons
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>char</span> <span style=color:#000>key_data</span>[<span style=color:#1c01ce>1</span>];  <span style=color:#177500>// Beginning of key
</span></span></span></code></pre></td></tr></table></div></div></div><h2 id=lrucache>LRUCache</h2><h3 id=数据结构>数据结构</h3><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>LRUCache</span> {
</span></span><span style=display:flex><span> <span style=color:#a90d91>public</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#000>LRUCache</span>(); <span style=color:#177500>// 初始化双向链表
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>~</span><span style=color:#000>LRUCache</span>();
</span></span><span style=display:flex><span>  <span style=color:#177500>// Separate from constructor so caller can easily make an array of LRUCache
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>void</span> <span style=color:#000>SetCapacity</span>(<span style=color:#000>size_t</span> <span style=color:#000>capacity</span>) { <span style=color:#000>capacity_</span> <span style=color:#000>=</span> <span style=color:#000>capacity</span>; }
</span></span><span style=display:flex><span>  <span style=color:#177500>// Like Cache methods, but with an extra &#34;hash&#34; parameter.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 插入数据到 Cache 中，这里保存节点的 hash 值，方便快速比对
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Cache</span><span style=color:#000>::</span><span style=color:#000>Handle</span><span style=color:#000>*</span> <span style=color:#000>Insert</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#a90d91>uint32_t</span> <span style=color:#000>hash</span>, <span style=color:#a90d91>void</span><span style=color:#000>*</span> <span style=color:#000>value</span>,
</span></span><span style=display:flex><span>                        <span style=color:#000>size_t</span> <span style=color:#000>charge</span>,
</span></span><span style=display:flex><span>                        <span style=color:#a90d91>void</span> (<span style=color:#000>*</span><span style=color:#000>deleter</span>)(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#a90d91>void</span><span style=color:#000>*</span> <span style=color:#000>value</span>));
</span></span><span style=display:flex><span>  <span style=color:#177500>// 查询目标节点
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>Cache</span><span style=color:#000>::</span><span style=color:#000>Handle</span><span style=color:#000>*</span> <span style=color:#000>Lookup</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#a90d91>uint32_t</span> <span style=color:#000>hash</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// 释放句柄(操作引用)
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>void</span> <span style=color:#000>Release</span>(<span style=color:#000>Cache</span><span style=color:#000>::</span><span style=color:#000>Handle</span><span style=color:#000>*</span> <span style=color:#000>handle</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// 从缓存中删除节点
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>void</span> <span style=color:#000>Erase</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#a90d91>uint32_t</span> <span style=color:#000>hash</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// 手动检测是否有需要删除的节点，发生在节点超过容量之后
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>void</span> <span style=color:#000>Prune</span>();
</span></span><span style=display:flex><span>  <span style=color:#177500>// 当前缓存中数据所占用的内存
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>size_t</span> <span style=color:#000>TotalCharge</span>() <span style=color:#a90d91>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#000>MutexLock</span> <span style=color:#000>l</span>(<span style=color:#000>&amp;</span><span style=color:#000>mutex_</span>);
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#000>usage_</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span> <span style=color:#a90d91>private</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#a90d91>void</span> <span style=color:#000>LRU_Remove</span>(<span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>e</span>);
</span></span><span style=display:flex><span>  <span style=color:#a90d91>void</span> <span style=color:#000>LRU_Append</span>(<span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>list</span>, <span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>e</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// 增加引用
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>void</span> <span style=color:#000>Ref</span>(<span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>e</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// 节点引用为0，调用 free 函数，否则只能移动
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>void</span> <span style=color:#000>Unref</span>(<span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>e</span>);
</span></span><span style=display:flex><span>  <span style=color:#a90d91>bool</span> <span style=color:#000>FinishErase</span>(<span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>e</span>) <span style=color:#000>EXCLUSIVE_LOCKS_REQUIRED</span>(<span style=color:#000>mutex_</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// Initialized before use.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// LRU 容量
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>size_t</span> <span style=color:#000>capacity_</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// mutex_ protects the following state.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// id 生成锁，保护 LRUCache 操作
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>mutable</span> <span style=color:#000>port</span><span style=color:#000>::</span><span style=color:#000>Mutex</span> <span style=color:#000>mutex_</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 获取 LRUCache 已经使用的内存
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>size_t</span> <span style=color:#000>usage_</span> <span style=color:#000>GUARDED_BY</span>(<span style=color:#000>mutex_</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// Dummy head of LRU list.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// lru.prev is newest entry, lru.next is oldest entry.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// Entries have refs==1 and in_cache==true.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 只存在缓存中的节点
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>LRUHandle</span> <span style=color:#000>lru_</span> <span style=color:#000>GUARDED_BY</span>(<span style=color:#000>mutex_</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// Dummy head of in-use list.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// Entries are in use by clients, and have refs &gt;= 2 and in_cache==true.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 既存在缓存中，又被外部引用的节点
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>LRUHandle</span> <span style=color:#000>in_use_</span> <span style=color:#000>GUARDED_BY</span>(<span style=color:#000>mutex_</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// 用户快速获取某个节点
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>HandleTable</span> <span style=color:#000>table_</span> <span style=color:#000>GUARDED_BY</span>(<span style=color:#000>mutex_</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div></details><br><p>注意事项：</p><ul><li>LRU 中元素不仅在 cache 中，也可能会被外部引用，不能直接删除节点</li><li>某个节点被修改或引用，空间不足不能参与 LRU 计算</li><li>in_use 表示既在 cache 中，也被外部引用</li><li>table_ 记录 key 和节点的映射关系，通过key可以快速定位到某个节点</li><li>调用 insert/LookUp 之后，必须使用 Release 释放句柄</li></ul><h3 id=insert函数>Insert函数</h3><p>代码：util/cache.cc</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>Cache</span><span style=color:#000>::</span><span style=color:#000>Handle</span><span style=color:#000>*</span> <span style=color:#000>LRUCache</span><span style=color:#000>::</span><span style=color:#000>Insert</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>, <span style=color:#a90d91>uint32_t</span> <span style=color:#000>hash</span>, <span style=color:#a90d91>void</span><span style=color:#000>*</span> <span style=color:#000>value</span>,
</span></span><span style=display:flex><span>                                <span style=color:#000>size_t</span> <span style=color:#000>charge</span>,
</span></span><span style=display:flex><span>                                <span style=color:#a90d91>void</span> (<span style=color:#000>*</span><span style=color:#000>deleter</span>)(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>key</span>,
</span></span><span style=display:flex><span>                                                <span style=color:#a90d91>void</span><span style=color:#000>*</span> <span style=color:#000>value</span>)) {
</span></span><span style=display:flex><span>  <span style=color:#177500>// 加锁
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>MutexLock</span> <span style=color:#000>l</span>(<span style=color:#000>&amp;</span><span style=color:#000>mutex_</span>);
</span></span><span style=display:flex><span>  <span style=color:#177500>// 创建节点
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>e</span> <span style=color:#000>=</span>
</span></span><span style=display:flex><span>      <span style=color:#a90d91>reinterpret_cast</span><span style=color:#000>&lt;</span><span style=color:#000>LRUHandle</span><span style=color:#000>*&gt;</span>(<span style=color:#000>malloc</span>(<span style=color:#a90d91>sizeof</span>(<span style=color:#000>LRUHandle</span>) <span style=color:#000>-</span> <span style=color:#1c01ce>1</span> <span style=color:#000>+</span> <span style=color:#000>key</span>.<span style=color:#000>size</span>()));
</span></span><span style=display:flex><span>  <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>value</span> <span style=color:#000>=</span> <span style=color:#000>value</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>deleter</span> <span style=color:#000>=</span> <span style=color:#000>deleter</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>charge</span> <span style=color:#000>=</span> <span style=color:#000>charge</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>key_length</span> <span style=color:#000>=</span> <span style=color:#000>key</span>.<span style=color:#000>size</span>();
</span></span><span style=display:flex><span>  <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>hash</span> <span style=color:#000>=</span> <span style=color:#000>hash</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>in_cache</span> <span style=color:#000>=</span> <span style=color:#a90d91>false</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// 引用数
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>refs</span> <span style=color:#000>=</span> <span style=color:#1c01ce>1</span>;  <span style=color:#177500>// for the returned handle.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>memcpy</span>(<span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>key_data</span>, <span style=color:#000>key</span>.<span style=color:#000>data</span>(), <span style=color:#000>key</span>.<span style=color:#000>size</span>());
</span></span><span style=display:flex><span>  <span style=color:#177500>// 容量大于0时开启缓存
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>if</span> (<span style=color:#000>capacity_</span> <span style=color:#000>&gt;</span> <span style=color:#1c01ce>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#177500>// 会放入缓存中，因此存在两个地方，引用数加1
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>refs</span><span style=color:#000>++</span>;  <span style=color:#177500>// for the cache&#39;s reference.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>in_cache</span> <span style=color:#000>=</span> <span style=color:#a90d91>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#177500>// 外部会引用，所以节点需要放在 in_use_ 链上
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>LRU_Append</span>(<span style=color:#000>&amp;</span><span style=color:#000>in_use_</span>, <span style=color:#000>e</span>);
</span></span><span style=display:flex><span>    <span style=color:#177500>// 加上新增的字节数
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>usage_</span> <span style=color:#000>+=</span> <span style=color:#000>charge</span>;
</span></span><span style=display:flex><span>    <span style=color:#177500>// 如果存在该节点，需要将老的节点释放
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>FinishErase</span>(<span style=color:#000>table_</span>.<span style=color:#000>Insert</span>(<span style=color:#000>e</span>));
</span></span><span style=display:flex><span>  } <span style=color:#a90d91>else</span> {  <span style=color:#177500>// don&#39;t cache. (capacity_==0 is supported and turns off caching.)
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#177500>// next is read by key() in an assert, so it must be initialized
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>next</span> <span style=color:#000>=</span> <span style=color:#a90d91>nullptr</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#177500>// 当cache容量不够，有空余的节点需要进行 LRU 策略淘汰
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#177500>// 注意 in_use_ 中的节点不能被淘汰，因为被外部引用了
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>while</span> (<span style=color:#000>usage_</span> <span style=color:#000>&gt;</span> <span style=color:#000>capacity_</span> <span style=color:#000>&amp;&amp;</span> <span style=color:#000>lru_</span>.<span style=color:#000>next</span> <span style=color:#000>!=</span> <span style=color:#000>&amp;</span><span style=color:#000>lru_</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>old</span> <span style=color:#000>=</span> <span style=color:#000>lru_</span>.<span style=color:#000>next</span>;
</span></span><span style=display:flex><span>    <span style=color:#000>assert</span>(<span style=color:#000>old</span><span style=color:#000>-&gt;</span><span style=color:#000>refs</span> <span style=color:#000>==</span> <span style=color:#1c01ce>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#a90d91>bool</span> <span style=color:#000>erased</span> <span style=color:#000>=</span> <span style=color:#000>FinishErase</span>(<span style=color:#000>table_</span>.<span style=color:#000>Remove</span>(<span style=color:#000>old</span><span style=color:#000>-&gt;</span><span style=color:#000>key</span>(), <span style=color:#000>old</span><span style=color:#000>-&gt;</span><span style=color:#000>hash</span>));
</span></span><span style=display:flex><span>    <span style=color:#a90d91>if</span> (<span style=color:#000>!</span><span style=color:#000>erased</span>) {  <span style=color:#177500>// to avoid unused variable when compiled NDEBUG
</span></span></span><span style=display:flex><span><span style=color:#177500></span>      <span style=color:#000>assert</span>(<span style=color:#000>erased</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a90d91>return</span> <span style=color:#a90d91>reinterpret_cast</span><span style=color:#000>&lt;</span><span style=color:#000>Cache</span><span style=color:#000>::</span><span style=color:#000>Handle</span><span style=color:#000>*&gt;</span>(<span style=color:#000>e</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></details><br><h3 id=ref-unref函数>ref/Unref函数</h3><p>代码：util/cache.cc</p><p>Ref</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>void</span> <span style=color:#000>LRUCache</span><span style=color:#000>::</span><span style=color:#000>Ref</span>(<span style=color:#000>LRUHandle</span><span style=color:#000>*</span> <span style=color:#000>e</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a90d91>if</span> (<span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>refs</span> <span style=color:#000>==</span> <span style=color:#1c01ce>1</span> <span style=color:#000>&amp;&amp;</span> <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>in_cache</span>) {  <span style=color:#177500>// If on lru_ list, move to in_use_ list.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>    <span style=color:#000>LRU_Remove</span>(<span style=color:#000>e</span>);
</span></span><span style=display:flex><span>    <span style=color:#000>LRU_Append</span>(<span style=color:#000>&amp;</span><span style=color:#000>in_use_</span>, <span style=color:#000>e</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#000>e</span><span style=color:#000>-&gt;</span><span style=color:#000>refs</span><span style=color:#000>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></div><p>Unref<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>void LRUCache::Unref(LRUHandle* e) {
</span></span><span style=display:flex><span>  assert(e-&gt;refs &gt; 0);
</span></span><span style=display:flex><span>  // 引用减1
</span></span><span style=display:flex><span>  e-&gt;refs--;
</span></span><span style=display:flex><span>  if (e-&gt;refs == 0) {  // Deallocate.
</span></span><span style=display:flex><span>    assert(!e-&gt;in_cache);
</span></span><span style=display:flex><span>    (*e-&gt;deleter)(e-&gt;key(), e-&gt;value);
</span></span><span style=display:flex><span>    free(e);
</span></span><span style=display:flex><span>  } else if (e-&gt;in_cache &amp;&amp; e-&gt;refs == 1) {
</span></span><span style=display:flex><span>    // No longer in use; move to lru_ list.
</span></span><span style=display:flex><span>    // 仅在缓存中且引用数为1，将其从 in_use_ 中删除，放到 LRU 中
</span></span><span style=display:flex><span>    LRU_Remove(e);
</span></span><span style=display:flex><span>    LRU_Append(&amp;lru_, e);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></div></p></div><div class=td-content style=page-break-before:always><h1 id=pg-de0e0325e2b6d74aef3411cef8176277>8.6 - LevelDB-06Compaction</h1><h2 id=分类>分类</h2><p>LevelDB 中，compaction 有两种：</p><ul><li>minor compaction</li></ul><blockquote><p>immutable memtable 持久化为 sst 文件</p></blockquote><ul><li>major compaction</li></ul><blockquote><p>sst 文件之间的 compaction</p></blockquote><pre><code>* Manual Compaction：人工触发，外部接口调用产生
* Size Compaction：每个 level 文件大小超过一定阈值就会触发
* Seek Compaction：一个文件的 seek miss 次数超过阈值就会触发
</code></pre><p>优先级：Minor > Manual > Size > Seek</p><h2 id=成员变量>成员变量</h2><p>代码：</p><p>db/version_set.h</p><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// 需要压缩的 level
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>int</span> <span style=color:#000>level_</span>;
</span></span><span style=display:flex><span><span style=color:#177500>// 压缩之后最大的文件大小，等于 options-&gt;max_file_size
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>uint64_t</span> <span style=color:#000>max_output_file_size_</span>;
</span></span><span style=display:flex><span><span style=color:#177500>// 当前操作的版本
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>Version</span><span style=color:#000>*</span> <span style=color:#000>input_version_</span>;
</span></span><span style=display:flex><span><span style=color:#177500>// 版本变化
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>VersionEdit</span> <span style=color:#000>edit_</span>;
</span></span><span style=display:flex><span><span style=color:#177500>// Each compaction reads inputs from &#34;level_&#34; and &#34;level_+1&#34;
</span></span></span><span style=display:flex><span><span style=color:#177500>// level 和 level 两层需要参与压缩的文件元数据
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>vector</span><span style=color:#000>&lt;</span><span style=color:#000>FileMetaData</span><span style=color:#000>*&gt;</span> <span style=color:#000>inputs_</span>[<span style=color:#1c01ce>2</span>];  <span style=color:#177500>// The two sets of inputs
</span></span></span><span style=display:flex><span><span style=color:#177500>// State used to check for number of overlapping grandparent files
</span></span></span><span style=display:flex><span><span style=color:#177500>// (parent == level_ + 1, grandparent == level_ + 2)
</span></span></span><span style=display:flex><span><span style=color:#177500>// grandparents元数据
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>std</span><span style=color:#000>::</span><span style=color:#000>vector</span><span style=color:#000>&lt;</span><span style=color:#000>FileMetaData</span><span style=color:#000>*&gt;</span> <span style=color:#000>grandparents_</span>;
</span></span><span style=display:flex><span><span style=color:#177500>// grandparent下标索引
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>size_t</span> <span style=color:#000>grandparent_index_</span>;  <span style=color:#177500>// Index in grandparent_starts_
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>bool</span> <span style=color:#000>seen_key_</span>;             <span style=color:#177500>// Some output key has been seen
</span></span></span><span style=display:flex><span><span style=color:#177500>// 当前压缩与grandparent元数据重叠的字节数
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>int64_t</span> <span style=color:#000>overlapped_bytes_</span>;  <span style=color:#177500>// Bytes of overlap between current output
</span></span></span><span style=display:flex><span><span style=color:#177500></span>                            <span style=color:#177500>// and grandparent files
</span></span></span><span style=display:flex><span><span style=color:#177500>// State for implementing IsBaseLevelForKey
</span></span></span><span style=display:flex><span><span style=color:#177500>// level_ptrs_ holds indices into input_version_-&gt;levels_: our state
</span></span></span><span style=display:flex><span><span style=color:#177500>// is that we are positioned at one of the file ranges for each
</span></span></span><span style=display:flex><span><span style=color:#177500>// higher level than the ones involved in this compaction (i.e. for
</span></span></span><span style=display:flex><span><span style=color:#177500>// all L &gt;= level_ + 2).
</span></span></span><span style=display:flex><span><span style=color:#177500>// 记录某个 user_key 与 &gt;= level+2 中每一层不重叠的文件个数
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>size_t</span> <span style=color:#000>level_ptrs_</span>[<span style=color:#000>config</span><span style=color:#000>::</span><span style=color:#000>kNumLevels</span>];
</span></span></code></pre></td></tr></table></div></div></details><br><h2 id=主要函数>主要函数</h2><style>.highlight{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:130%}.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}</style><details class=code-collapse><summary>Expand/Collapse Code Block</summary><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// Return the level that is being compacted.  Inputs from &#34;level&#34;
</span></span></span><span style=display:flex><span><span style=color:#177500>// and &#34;level+1&#34; will be merged to produce a set of &#34;level+1&#34; files.
</span></span></span><span style=display:flex><span><span style=color:#177500>// 返回将要压缩的 level 文件
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>int</span> <span style=color:#000>level</span>() <span style=color:#a90d91>const</span> { <span style=color:#a90d91>return</span> <span style=color:#000>level_</span>; }
</span></span><span style=display:flex><span><span style=color:#177500>// Return the object that holds the edits to the descriptor done
</span></span></span><span style=display:flex><span><span style=color:#177500>// by this compaction.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>VersionEdit</span><span style=color:#000>*</span> <span style=color:#000>edit</span>() { <span style=color:#a90d91>return</span> <span style=color:#000>&amp;</span><span style=color:#000>edit_</span>; }
</span></span><span style=display:flex><span><span style=color:#177500>// &#34;which&#34; must be either 0 or 1
</span></span></span><span style=display:flex><span><span style=color:#177500>// 返回对应层级参与压缩的文件
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>int</span> <span style=color:#000>num_input_files</span>(<span style=color:#a90d91>int</span> <span style=color:#000>which</span>) <span style=color:#a90d91>const</span> { <span style=color:#a90d91>return</span> <span style=color:#000>inputs_</span>[<span style=color:#000>which</span>].<span style=color:#000>size</span>(); }
</span></span><span style=display:flex><span><span style=color:#177500>// Return the ith input file at &#34;level()+which&#34; (&#34;which&#34; must be 0 or 1).
</span></span></span><span style=display:flex><span><span style=color:#177500>// 获取某一层第 i 个文件的 sst 元数据
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>FileMetaData</span><span style=color:#000>*</span> <span style=color:#000>input</span>(<span style=color:#a90d91>int</span> <span style=color:#000>which</span>, <span style=color:#a90d91>int</span> <span style=color:#000>i</span>) <span style=color:#a90d91>const</span> { <span style=color:#a90d91>return</span> <span style=color:#000>inputs_</span>[<span style=color:#000>which</span>][<span style=color:#000>i</span>]; }
</span></span><span style=display:flex><span><span style=color:#177500>// Maximum size of files to build during this compaction.
</span></span></span><span style=display:flex><span><span style=color:#177500>// 本次压缩产生的最大文件大小
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>uint64_t</span> <span style=color:#000>MaxOutputFileSize</span>() <span style=color:#a90d91>const</span> { <span style=color:#a90d91>return</span> <span style=color:#000>max_output_file_size_</span>; }
</span></span><span style=display:flex><span><span style=color:#177500>// Is this a trivial compaction that can be implemented by just
</span></span></span><span style=display:flex><span><span style=color:#177500>// moving a single input file to the next level (no merging or splitting)
</span></span></span><span style=display:flex><span><span style=color:#177500>// 表示本地是否可以将本次 sst 直接移动到上一层
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>bool</span> <span style=color:#000>IsTrivialMove</span>() <span style=color:#a90d91>const</span>;
</span></span><span style=display:flex><span><span style=color:#177500>// Add all inputs to this compaction as delete operations to *edit.
</span></span></span><span style=display:flex><span><span style=color:#177500>// 添加所有需要删除 sst 文件到 *edit
</span></span></span><span style=display:flex><span><span style=color:#177500>// input 经过变化生成 output，input对应 deleted_file 容器，output进入 added_file 容器
</span></span></span><span style=display:flex><span><span style=color:#177500>// add时先忽略 deleted
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>void</span> <span style=color:#000>AddInputDeletions</span>(<span style=color:#000>VersionEdit</span><span style=color:#000>*</span> <span style=color:#000>edit</span>);
</span></span><span style=display:flex><span><span style=color:#177500>// Returns true if the information we have available guarantees that
</span></span></span><span style=display:flex><span><span style=color:#177500>// the compaction is producing data in &#34;level+1&#34; for which no data exists
</span></span></span><span style=display:flex><span><span style=color:#177500>// in levels greater than &#34;level+1&#34;.
</span></span></span><span style=display:flex><span><span style=color:#177500>// 判断当前user_key在 &gt;=(level+2) 层中是否存在。
</span></span></span><span style=display:flex><span><span style=color:#177500>// 主要用于key的 type=deletion 时是否将该 key 删除
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>bool</span> <span style=color:#000>IsBaseLevelForKey</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>user_key</span>);
</span></span><span style=display:flex><span><span style=color:#177500>// Returns true iff we should stop building the current output
</span></span></span><span style=display:flex><span><span style=color:#177500>// before processing &#34;internal_key&#34;.
</span></span></span><span style=display:flex><span><span style=color:#177500>// 是否需要停止输出，生成新的SST，
</span></span></span><span style=display:flex><span><span style=color:#177500>// 避免合并到 level+1 层之后和 level+2 层重叠太多，导致下次合并level+1时间太久
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>bool</span> <span style=color:#000>ShouldStopBefore</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span><span style=color:#000>&amp;</span> <span style=color:#000>internal_key</span>);
</span></span><span style=display:flex><span><span style=color:#177500>// Release the input version for the compaction, once the compaction
</span></span></span><span style=display:flex><span><span style=color:#177500>// is successful.
</span></span></span><span style=display:flex><span><span style=color:#177500>// 释放内存
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>void</span> <span style=color:#000>ReleaseInputs</span>();
</span></span></code></pre></td></tr></table></div></div></details><br><h2 id=minor-compaction>Minor Compaction</h2><h3 id=定义>定义</h3><p>immutable memtable 持久化为 sst 文件。</p><h3 id=触发条件>触发条件</h3><p>Wirte 新数据进入 LevelDB 时，会在适当的时机检查内存中 Memtable 占用内存大小，一旦超过 options_.write_buffer_size (默认4M)，就会尝试 Minor Compaction。</p><h3 id=执行过程>执行过程</h3><ul><li>DBImpl::BackgroundCompaction -> DBImpl::CompactMemTable -> DBImpl::WriteLevel0Table<ul><li>BuildTable：将 immutable memtable 格式化成 sstable 文件。</li><li>PickLevelForMemTableOutput：计算新生成的sstable所属的层级。</li><li>edit->AddFile()：将新sst文件放置到第2步选出的level中。
策略上尽量将新 compact 文件推至高 level。因为如果 level0 需要控制的文件过多，compaction IO 和查找都比较耗费。另一方面也不能推至过高level，某些范围的key更新比较频繁，后续往高层 compaction IO 消耗也很大。</li></ul></li></ul><h3 id=层级选择>层级选择</h3><ul><li><p>新 sst key 范围和 level0 的某个或某几个 sst 文件是否有重叠</p><ul><li>是，level = 0</li></ul></li><li><p>否，新 sst key 范围和 level1 的某个或某几个 sst 文件是否有重叠</p><ul><li>是，level = 0</li></ul></li><li><p>否，level2 文件中与新 sst 有重叠文件个数过多，size之和是否超过阈值</p><ul><li>是，level = 0</li></ul></li><li><p>否，新 sst key 范围和 level2 的某个或某几个 sst 文件是否有重叠</p><ul><li>是，level = 1</li></ul></li><li><p>否，level3 文件与新 sst 重叠文件个数过多，size之和是否超过阈值</p><ul><li>是，level = 1</li></ul></li><li><p>否，level = 2
基本判断原则：</p></li><li><p>当前level n，推向下一层level的条件是：与 level n+1 不能重叠，与 level n+2 重叠的文件大小不能超过阈值</p></li><li><p>level 最大不超过2</p></li></ul><h2 id=major-compaction>Major Compaction</h2><p>Major compaction 是将不同层级的 sst 的文件进行合并。</p><p>作用：</p><ul><li>将不活跃的数据下沉，均衡各个level的数据，保证 read 的性能</li><li>合并 delete 数据，释放磁盘空间，因为删除是标记删除</li><li>合并 update 数据，例如put同一个key，类似于 delete，是采用的标记插入新的数据，实际的update是在compact中完成，并实现空间的释放</li></ul><h3 id=size-compaction>Size Compaction</h3><h4 id=定义-1>定义</h4><p>LevelDB 的核心 Compact 过程，其主要是为了均衡各个level的数据，从而保证读写的性能均衡。</p><p>主要是指某一层 sst 文件不能太大，这个大对 level0 层来说是 sst 文件过多，因为 level0 层会被频繁访问，而对于其他层表示字节数太大，具体见Builder类的Finalize函数。</p><h4 id=触发条件-1>触发条件</h4><p>LevelDB 会计算每个level的总的文件大小，并根据此计算出一个score，最后会根据这个score来选择合适level和文件进行Compact。具体得分原则见：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>VersionSet</span><span style=color:#000>::</span><span style=color:#000>Finalize</span>
</span></span></code></pre></td></tr></table></div></div></div><p>进行 Compation 时，判断得分是否大于 1，是则进行 Size Compaction。代码见：<style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>VersionSet</span><span style=color:#000>::</span><span style=color:#000>PickCompaction</span>
</span></span></code></pre></td></tr></table></div></div></div></p><h4 id=执行过程-1>执行过程</h4><ul><li>score计算：各 level 触发得分，得到 compaction 层级（VersionSet::Finalize）<ul><li>level0: level0文件总数 / 4</li><li>其它 level：当前level所有文件size之和 / 当前 level 阈值</li></ul></li><li>寻找 compaction 的文件，如 level n：<ul><li>确定 level n 参与 compation 的文件列表 ，存入inputs_[0] （核心函数：VersionSet::PickCompaction）</li><li>确定 level n+1 参与 compation 的文件列表，存入inputs_[1]（核心函数：VersionSet::SetupOtherInputs）</li></ul></li></ul><h3 id=seek-compaction>Seek Compaction</h3><h4 id=定义-2>定义</h4><p>主要记录的是某个 sst seek 次数到达阈值之后，将会参与下一次压缩。</p><p>LevelDB 认为如果一个 sst 文件在 level i 中总是没总到，而是在 level i+1 中找到，这说明两层之间key的范围重叠很严重。当这种 seek miss 积累到一定次数之后，就考虑将其从 level i 中合并到 level i+1 中，这样可以避免不必要的 seek miss 消耗 read I/O。</p><h4 id=触发条件-2>触发条件</h4><p>当 allowed_seeks 递减到小于0了，将标记为需要 compation 的文件。但是由于 Size Compaction 优先级高于 Seek Compaction，所以在不存在 Size Compaction 时且触发了Compaction，Seek Compaction 就能执行。</p><h4 id=执行过程-2>执行过程</h4><ul><li>获取 compaction 文件（Version::UpdateStats）</li><li>寻找 compaction 的文件，如 level n：<ul><li>确定 level n 参与 compation 的文件列表 ，存入inputs_[0] （核心函数：VersionSet::PickCompaction）</li><li>确定 level n+1 参与 compation 的文件列表，存入inputs_[1]（核心函数：VersionSet::SetupOtherInputs）
具体代码见：DBImpl::DoCompactionWork</li></ul></li></ul><h3 id=manual-compact>Manual Compact</h3><h4 id=定义-3>定义</h4><p>人工触发的Compaction，由外部接口调用产生。实际内部触发调用的接口是 DBImpl 中的</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#177500>// begin/end 表示 compaction 的范围
</span></span></span><span style=display:flex><span><span style=color:#177500>// begin/end 为 null 时，表示尝试 compact 所有文件
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>void</span> <span style=color:#000>DBImpl</span><span style=color:#000>::</span><span style=color:#000>CompactRange</span>(<span style=color:#a90d91>const</span> <span style=color:#000>Slice</span> <span style=color:#000>begin</span>, <span style=color:#a90d91>const</span> <span style=color:#000>Slice</span> <span style=color:#000>end</span>)
</span></span></code></pre></td></tr></table></div></div></div><p>Manual Compaction 中会指定 begin 和 end。它将会逐个 level 分次的 Compact 所有level 中与 begin 和 end 有重叠（overlap）的 sst 文件。</p><h4 id=触发条件-3>触发条件</h4><p>人工触发，由外部调用。</p><h4 id=执行过程-3>执行过程</h4><ul><li>遍历所有level，获取到最大重叠的层级（核心函数：OverlapInLevel）</li><li>强制将当前的 memtable 进行 minor compation。（核心函数：TEST_CompactMemTable）</li><li>遍历重叠的层级进行 major compation（核心函数：TEST_CompactRange）</li><li>真正的 compation（核心函数：VersionSet::CompactRange）</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-90eb8f9f061ff2dabeca8888b56b5a78>9 - ClickHouse</h1><h1 id=introduction>Introduction</h1><p>ClickHouse介绍</p></div><div class=td-content><h1 id=pg-035c4e69a1451d145c4d6de85264c30f>9.1 - 01.ClickHouse基本介绍</h1><h1 id=简介>简介</h1><p>ClickHouse是一个快速、可扩展的用于联机分析(OLAP)的列式数据库管理系统(DBMS)，专门用于在线分析处理（OLAP）工作负载。它是一个开源项目，由Yandex团队开发和维护。ClickHouse的设计目标是提供高性能的数据分析能力，是一个高性能、可扩展、实时数据分析的列式数据库系统，非常适合需要处理大量数据和高并发查询的场景。</p><h2 id=特点>特点</h2><p>以下是ClickHouse的一些主要特点：</p><ul><li>列式存储：ClickHouse采用列式存储结构，这意味着它将相同类型的数据存储在一起，以便更高效地压缩和查询。这使得它在需要扫描和聚合大量数据时非常快。</li><li>可扩展性：ClickHouse可以水平扩展，允许在多个节点上分布数据和负载。它可以处理PB级别的数据，并能够自动管理数据分片、复制和故障转移。</li><li>高性能：ClickHouse的查询速度非常快，尤其是在需要执行聚合操作时。它支持高并发查询和低延迟查询，并可以处理几百万行数据每秒的查询吞吐量。</li><li>支持SQL：ClickHouse支持SQL语言，包括各种聚合函数、子查询、JOIN操作和分组。它还支持分布式SQL查询。</li><li>实时数据分析：ClickHouse可以实时处理和分析数据，支持近实时查询和数据导入。它还支持流数据处理，可以与Kafka、Spark Streaming等实时数据处理系统集成。</li></ul><h2 id=应用场景>应用场景</h2><p>ClickHouse适用于需要处理大型数据集和高并发查询的场景，例如电商网站的用户行为分析、金融交易数据分析、游戏数据分析等。</p><h1 id=核心特性>核心特性</h1><pre><code>MPP (Massively Parallel Processing)，即大规模并行处理，将任务并行的分散到多个服务器和节点上，在每个节点上计算完成后，将各自部分的结果汇总在一起得到最终的结果（与hadoop相似）。
</code></pre><ul><li>多个节点通过网络进行连接协同工作，完成相同的任务（分布式计算+分布式存储）</li><li>每个节点只访问自己的本地资源（内存、存储等）</li><li>完全无共享（Share Nothing）结构，因而扩展能力非常好
ClickHouse是一款MPP架构的列式存储数据库，吸取了其他优秀技术的精髓，将每个细节做到极致，从而在性能上远远超过其他技术。</li></ul><h2 id=dbms功能>DBMS功能</h2><p>ClickHouse拥有DBMS完备的管理功能，但它不仅仅是一个数据库。作为DBMS，它具备以下基本功能。</p><ol><li>DDL（数据定义语言）：可以动态地创建、修改删除数据库、表和视图，而无须重启服务。</li><li>DML（数据操作语言）：可以动态查询、插入、修改或者删除数据。</li><li>权限控制：可以按照用户粒度设置数据库或者表的操作权限，保障数据的安全性。</li><li>数据备份与恢复：提供了数据备份导出与导入恢复机制，满足生产环境的要求。</li><li>分布式管理：提供集群模式，能够自动管理多个数据库节点。</li></ol><h2 id=支持sql>支持SQL</h2><pre><code>ClickHouse使用关系型模型描述数据，并提供了传统数据库的概念，如数据库、表、视图和函数等。ClickHouse可以使用SQL作为查询语言。
</code></pre><ul><li>Hive  <ul><li>Impala是Cloudera公司主导开发的新型查询系统，它提供SQL语义，能查询存储在Hadoop的HDFS和HBase中的PB级大数据。</li></ul></li><li>Spark SQL<ul><li>Druid 是一个分布式的数据分析平台，预聚合算是 Druid 的一个非常大的亮点，通过预聚合可以减少数据的存储以及避免查询时很多不必要的计算。</li><li>Apache Kylin™是一个开源的、分布式的分析型数据仓库，提供Hadoop/Spark 之上的 SQL 查询接口及多维分析（OLAP）能力以支持超大规模数据，最初由 eBay 开发并贡献至开源社区。它能在亚秒内查询巨大的表。</li></ul></li></ul><h2 id=表引擎>表引擎</h2><p>与MySQL类似ClickHouse将存储部分进行了抽象，把存储引擎作为一层独立的接口。ClickHouse目前拥有合并树、内存、文件、接口和其他6大类等20多种表引擎，用户可以根据实际应用场景，选择合适的表引擎使用。</p><p>通用的表引擎可以有更广泛的适用性，能适应更多的应用场景，但这种通用性可能造成它无法在所有应用场景内性能做到极致，也是一种平庸的表现。</p><p>将表引擎独立设计，可以通过特定的表引擎支撑特定的场景，用法十分灵活。对于简单的应用场景，可以直接使用简单的引擎降低成本，而复杂的应用场景也有合适的表引擎。</p><h2 id=列式存储>列式存储</h2><pre><code>行式存储和列式存储，数据在磁盘上的组织结构有着根本不同，数据分析计算时，行式存储需要遍历整表，列式存储只需要遍历单个列，所以列式库更适合做大宽表，用来做数据分析计算。
</code></pre><p>列式存储和数据压缩，是高性能数据库必不可少的重要特性。如果想让查询变得更快，最简单且最有效的方法就是减少数据扫描范围和数据传输时的大小。</p><h2 id=向量化执行>向量化执行</h2><pre><code>向量化执行，就是利用寄存器硬件层面的特性，为上层应用程序的性能带来了指数级的提升。
</code></pre><p>为了实现向量化执行，需要利用CPU的SIMD（Single Instruction Multiple Data，即用单条指令操作多条数据）命令，通过数据并行来提高性能。即在CPU寄存器层面实现数据的并行操作。</p><h2 id=并行计算>并行计算</h2><pre><code>向量化执行是通过数据级并行的方式提升了性能，多线程处理是通过线程级并行的方式实现了性能的提升。
</code></pre><p>ClickHouse在数据存取方面，既支持分区（纵向扩展，利用多线程技术），也支持分片（横向扩展，利用分布式技术）。ClickHouse将多线程和分布式的技术应用到了极致。</p><h2 id=实时查询>实时查询</h2><p>ClickHouse支持实时查询，即便是在复杂查询的场景下，也能够做到极快响应，且无需对数据进行任何预处理加工。</p><p>与其他类似产品对比优势：</p><ul><li>SparkSQL和Hive无法保障90%的查询在1秒内容返回，在海量数据的复杂查询可能需要分钟级别的响应时间</li><li>ElasticSearch在处理亿级数据聚合查询的时候，会显得力不从心</li></ul><h2 id=多主架构>多主架构</h2><p>ClickHouse则采用Multi-Master多主架构，集群中每个节点角色对等，客户端访问任意一个节点都能得到相同的效果。 规避了单点故障的问题，非常适合用于多数据中心、异地多活的场景。（对比Hadoop生态系统技术都采用了Master-Slave主从架构）</p><h2 id=数据分片>数据分片</h2><p>ClickHouse支持分片，采用分治思想，将数据进行横向切分，解决存储和查询的瓶颈。ClickHouse分片依赖集群，每个集群由1个到多个分片组成，而每个分片则对应ClickHouse的1台服务器节点，分片的数量取决于节点数量（一个分片只能对应一台服务器节点）。</p><p>ClickHouse的分片功能没有那么自动化，它提供了一个本地表（Local Table）和分布式表（Distribute Table）的概念。</p><ul><li>一张本地表等同于一份数据分片。</li><li>分布式表本身不存储任何数据，它是本地表的访问代理，作用类似分库中间件。借助分布式表，能够代理访问多个数据分片，从而实现分布式查询。
这种设计非常灵活，业务上线初期数据量不大，采用单节点的本地表即可，随着数据量增大， 新增分片的方式分流数据，通过分布式表实现分布式查询。</li></ul><h1 id=架构>架构</h1><p>ClickHouse的架构包括多个节点，每个节点可以担任多个角色，例如数据存储、数据计算、查询处理等。ClickHouse支持多种数据分片和副本策略，可以在多个节点上分布数据和负载。</p><p><img src=../imgs/clickhouse01_1.png alt=clickhouse01_1.png></p><h2 id=column和field>Column和Field</h2><p>Column和Field是ClickHouse数据最基础的映射单元。内存中的一列数据由一个Column对象表示。如果需要操作单个具体的数值（也就是单列中的一行数据），则需要使用Field对象，Field对象代表一个单值。IColumn接口对象中，定义了对数据进行各种关系运算的方法。</p><h2 id=datatype>DataType</h2><p>数据的序列化和反序列化工作由DataType负责。但并不直接负责数据的读取，而是转由从Column或Field对象获取。IDataType接口定义了许多正反序列化的方法，成对出现。</p><h2 id=block与block流>Block与Block流</h2><p>ClickHouse内部的数据操作是面向Block对象进行的，并且采用了流的形式。Block对象可以看作数据表的子集，包含了数据的类型及列的名称。</p><p>Block并没有直接聚合Column和DataType对象，而是通过ColumnWithTypeAndName对象进行间接引用。</p><p>Block流操作有两组顶层接口：IBlockInputStream负责数据的读取和关系运算，IBlockOutputStream负责将数据输出到下一环节。</p><h2 id=table>Table</h2><p>数据表的底层设计中并没有所谓的Table对象，直接使用IStorage接口指代数据表。</p><h2 id=parser和interpreter>Parser和Interpreter</h2><p>Parser分析器负责创建AST对象；Interpreter解释器则负责解释AST，并进一步创建查询的执行管道。它们与IStorage一起，串联起了整个数据查询的过程。</p><h2 id=function>Function</h2><p>ClickHouse主要提供两类函数——普通函数和聚合函数。普通函数由IFunction接口定义。</p><p>聚合函数由IAggregateFunction接口定义，相比无状态的普通函数，聚合函数是有状态的。</p><h2 id=cluster与replication>Cluster与Replication</h2><p>ClickHouse的集群由分片（Shard）组成，而每个分片又通过副本（Replica）组成。</p><p>ClickHouse的分片与其他系统有所区别：</p><ul><li>ClickHouse的1个节点只能拥有1个分片</li><li>分片只是一个逻辑概念，其物理承载还是由副本承担的</li></ul><h1 id=数据模型>数据模型</h1><p>ClickHouse支持多种数据类型和表引擎，可以存储结构化和非结构化数据。它支持多种聚合函数、子查询、JOIN操作和分组，还支持分布式SQL查询。</p><h2 id=逻辑数据模型>逻辑数据模型</h2><p>一个数据库有若干个分布式表组成，每张表会有多个分片，每个分片会有多个副本。</p><p><img src=../imgs/clickhouse01_2.png alt=clickhouse01_2.png></p><h2 id=物理数据模型>物理数据模型</h2><p><img src=../imgs/clickhouse01_3.png alt=clickhouse01_3.png></p><p>数据分区：每个分片副本的内部，数据按照 PARTITION BY 列进行分区，分区以目录的方式管理，本文样例中表按照时间进行分区。</p><p>列式存储：每个数据分区内部，采用列式存储，每个列涉及两个文件，分别是存储数据的 .bin 文件和存储偏移等索引信息的 .mrk2 文件。</p><p>数据排序：每个数据分区内部，所有列的数据是按照 ORDER BY 列进行排序的。可以理解为：对于生成这个分区的原始记录行，先按 ORDER BY 列进行排序，然后再按列拆分存储。</p><p>数据分块：每个列的数据文件中，实际是分块存储的，方便数据压缩及查询裁剪，每个块中的记录数不超过 index_granularity，默认 8192。</p><p>主键索引：主键默认与 ORDER BY 列一致，或为 ORDER BY 列的前缀。由于整个分区内部是有序的，且切割为数据块存储，ClickHouse 抽取每个数据块第一行的主键，生成一份稀疏的排序索引，可在查询时结合过滤条件快速裁剪数据块。</p><h1 id=索引>索引</h1><p>索引结构是用于加速数据查询的关键组件之一。ClickHouse的索引结构通常是用于辅助查询的，而不是强制性的。ClickHouse支持全表扫描，因此即使没有索引也可以快速查询大量数据。但是，对于大型数据集和复杂的查询，索引结构可以显著提高查询性能并减少查询时间。</p><h2 id=索引结构>索引结构</h2><p>ClickHouse支持多种不同的索引结构，包括以下几种：</p><h3 id=哈希索引>哈希索引</h3><p>哈希索引（Hash Index）将数据列中的每个唯一值映射到一个桶中，从而加快查找特定值的速度。哈希索引适用于等值查询，但不适用于范围查询或排序操作。</p><h3 id=b-树索引>B+树索引</h3><p>B+树索引（B+Tree Index）是一种常见的树状结构，可以支持范围查询和排序操作。在ClickHouse中，B+树索引被广泛用于处理时间序列数据等常见场景。</p><h3 id=倒排索引>倒排索引</h3><p>倒排索引（Inverted Index）将每个值映射到包含该值的行号列表中。倒排索引适用于文本搜索等场景，但在处理大量数据时可能会消耗大量内存。</p><h3 id=bloom过滤器>Bloom过滤器</h3><p>Bloom过滤器（Bloom Filter）是一种用于快速确定元素是否在集合中的概率型数据结构。Bloom过滤器可以用于加速查询过滤，但可能会导致一定的误判率。</p><h3 id=空间索引>空间索引</h3><p>空间索引（Spatial Index）是一种用于处理空间数据（例如地理坐标）的索引结构。ClickHouse支持多种空间索引结构，包括KD树、R树和Hilbert曲线等。</p><h2 id=索引查询流程>索引查询流程</h2><p>在 ClickHouse 中，索引结构是用于加速数据查询的关键组件。当执行查询时，ClickHouse会使用索引结构来定位数据并返回查询结果。下面是 ClickHouse 索引如何找到对应的数据的简要过程：</p><ol><li>首先，ClickHouse会根据查询条件选择合适的索引结构，例如哈希索引、B+树索引等等。</li><li>接着，ClickHouse会使用查询条件中的值在索引结构中进行查找。例如，如果是哈希索引，ClickHouse会将查询条件中的值通过哈希函数计算得到一个桶号，然后在对应的桶中查找是否存在对应的值。</li><li>如果在索引结构中找到了匹配的数据，ClickHouse会返回对应的行号（在数据文件中的位置），然后通过行号在数据文件中读取对应的数据。</li><li>如果索引结构无法找到匹配的数据，ClickHouse会返回空结果。
在某些情况下，ClickHouse可能会选择不使用索引结构而是直接进行全表扫描来查找数据。这通常发生在索引结构不适用于查询条件的情况下（例如，如果查询条件使用了某个列的范围查询，而哈希索引只适用于等值查询）或者数据集较小时。</li></ol><h1 id=工作流程>工作流程</h1><h2 id=查询流程>查询流程</h2><p>查询的处理过程可以分为以下几个步骤：</p><ol><li>语法解析和查询构建：当用户发出一个查询请求时，ClickHouse首先会解析查询语句并构建一个查询执行计划。这个计划将指定查询的所有步骤，包括要使用的表、列、索引和函数，以及查询如何被处理和优化。</li><li>查询优化：在查询执行计划构建完成后，ClickHouse会对它进行一系列优化操作，以使查询尽可能高效。这些优化操作包括推迟计算、重写查询、选择索引和预取等。</li><li>查询执行：一旦查询执行计划和优化都完成，ClickHouse将开始执行查询。查询执行过程包括在所有分片和节点上扫描数据、聚合和过滤数据、使用索引来优化查询等。</li><li>数据合并和排序：当查询执行完成后，ClickHouse会将分布式的查询结果合并成一个单一的结果集。如果查询包括排序操作，ClickHouse还将进行排序操作以获得最终的结果集。</li><li>结果返回：最后，ClickHouse将查询结果返回给客户端，客户端将获得一个包含查询结果的响应。
需要注意的是，ClickHouse是一个分布式的数据库系统，因此上述查询流程将在多个节点和分片上并行执行。在查询执行过程中，ClickHouse会自动将查询分发到多个节点上，并对结果进行合并和排序。这使得ClickHouse能够高效地处理大量的数据，并在秒级甚至亚秒级别提供响应。</li></ol><h2 id=写入流程>写入流程</h2><p>ClickHouse 数据写入的基本流程：</p><ol><li>客户端向 ClickHouse 发送一个 INSERT 查询，包含要写入的数据。</li><li>ClickHouse 的负责接收数据的进程（通常称为“数据节点”）接收到这个查询，并检查表结构和数据类型是否匹配。</li><li>如果数据类型不匹配，ClickHouse 会将数据转换为正确的类型，或者拒绝写入数据。</li><li>数据节点将接收到的数据暂时存储在一个名为“内存表”的数据结构中。内存表是一个类似于缓存的数据结构，可以快速地接收、处理和存储数据。</li><li>当内存表的数据量达到一个预定义的阈值（通常是几百万或几千万行），ClickHouse 将内存表中的数据写入到磁盘上的数据文件中。这个过程被称为“刷盘(flushing)”。</li><li>写入数据的过程是异步的，这意味着数据可以在后台写入，而不会阻塞正在进行的查询。当写入完成后，ClickHouse 将会通知客户端写入成功。</li><li>一旦数据被写入到数据文件中，它就可以被查询和聚合。为了提高查询性能，ClickHouse 将数据文件划分成多个小的数据块，每个数据块称为一个“分区(partition)”。每个分区包含一个或多个<strong>桶(bucket)</strong>，可以根据需要进行读取和处理。
ClickHouse 的数据写入流程是一个非常高效和灵活的过程，可以快速地接收、处理和存储大量的数据。通过将数据存储在内存表中，并使用异步写入和分区等技术，ClickHouse 可以在处理大规模数据时实现卓越的性能和效率。</li></ol><h2 id=更新流程>更新流程</h2><p>ClickHouse 更新数据的流程与传统的关系型数据库有所不同。由于 ClickHouse 的设计目标是高效地处理大规模数据，因此并不支持像传统数据库中那样的“原地更新”(in-place update)操作。更新操作被视为删除旧数据并插入新数据的组合操作。以下是 ClickHouse 中更新数据的基本流程：</p><ol><li>客户端向 ClickHouse 发送一个 UPDATE 查询，包含要更新的数据。</li><li>ClickHouse 的数据节点接收到这个查询，并检查表结构和数据类型是否匹配。</li><li>如果数据类型不匹配，ClickHouse 会将数据转换为正确的类型，或者拒绝更新数据。</li><li>ClickHouse 执行一个 DELETE 查询来删除符合更新条件的旧数据。删除操作的效率非常高，因为 ClickHouse 可以将需要删除的数据的位置记录在特殊的“删除列表”(delete list)中，而不是实际删除数据。</li><li>ClickHouse 接着执行一个 INSERT 查询，将更新后的数据插入到表中。插入操作的效率也非常高，因为 ClickHouse 可以将插入的数据暂时存储在内存表中，并在内存表中有足够的数据时一次性写入到磁盘上的数据文件中。</li><li>更新操作的效率受多个因素影响，包括更新条件的复杂度、数据文件大小、磁盘读写速度等等。
ClickHouse 中的数据更新操作是一种删除旧数据并插入新数据的组合操作。这种设计可以帮助 ClickHouse 在高效处理大规模数据时保持高性能和效率。由于更新操作的效率受多个因素影响，因此在实际使用中需要仔细考虑更新数据的策略。</li></ol><h1 id=性能优化>性能优化</h1><p>ClickHouse使用多种性能优化技术来提高查询效率和扩展性，例如使用多种压缩算法和编码技术来减少存储空间，使用数据预取和批量读取技术来提高查询效率，使用多种查询优化技术来加速查询等。</p><p>其性能优化主要包括以下几个方面：</p><ol><li>列式存储：ClickHouse 采用列式存储，将同一列的数据存储在一起，避免了传统行式存储的随机读写，大大提高了数据的读取效率。此外，列式存储还可以压缩相同列中重复的数据，从而减少了磁盘存储和传输数据的大小。</li><li><strong>多级索引</strong>：ClickHouse 采用多级索引，可以在不完全扫描所有数据的情况下进行快速的过滤和聚合操作，从而提高了查询效率。</li><li>数据分区：ClickHouse 可以将数据分为多个分区，每个分区包含一组连续的数据，可以加快查询和聚合操作的速度。</li><li><strong>向量化计算</strong>：ClickHouse 在进行聚合计算时使用向量化计算，将多个计算任务组合成一个单一的指令，减少了CPU指令执行的次数，从而提高了计算效率。</li><li><strong>异步写入</strong>：ClickHouse 将数据写入到磁盘上的数据文件时采用异步写入的方式，可以将写入操作放入后台执行，避免了写入操作对查询性能的影响。</li><li>数据压缩：ClickHouse 支持多种数据压缩算法，可以将数据文件的大小压缩到原来的几分之一或几十分之一，从而减少了磁盘存储和传输数据的大小。
这些技术的应用使得 ClickHouse 可以高效地处理大规模的数据，并在查询和聚合等操作中保持卓越的性能和效率。</li></ol><h1 id=文件组织>文件组织</h1><p>大部分的DBMS中，数据库本质上就是一个由各种子目录和文件组成的文件目录，clickhouse也不例外。下图展示了clickhouse对数据文件的组织。</p><p><img src=../imgs/clickhouse01_4.png alt=clickhouse01_4.png></p><h2 id=数据库目录>数据库目录</h2><p>clickhouse默认数据目录在 <code>/var/lib/clickhouse/data</code> 目录中。所有的数据库都会在该目录中创建一个子文件夹。</p><p>每一个数据库都会在clickhouse的data目录中创建一个子目录，clickhouse默认携带default和system两个数据库。default顾名思义就是默认数据库，system是存储clickhouse服务器相关信息的数据库，例如连接数、资源占用等。</p><h2 id=表目录>表目录</h2><p>每个表都有一个对应的表目录，用于存储该表的所有数据块。表目录的默认路径为 <code>/var/lib/clickhouse/data/&lt;database_name>/&lt;table_name>/</code></p><h2 id=分区目录>分区目录</h2><p>ClickHouse支持按照分区进行数据存储和查询，数据表的分区数据存储在该目录下。分区（Partition）是指将表按照某个列或表达式进行划分，将同一分区中的数据存储在相同的数据块中，以便更高效地查询和管理数据。</p><p>每个分区目录包含一些文件，其中包括数据文件、索引文件等。分区目录的名称可以是任何字符串，但是建议使用可以表示时间的字符串，这样可以方便地按时间范围查询数据。</p><h2 id=数据文件和索引文件>数据文件和索引文件</h2><p>分区目录下就能看到真实存储的数据文件和索引文件：</p><ul><li>columns.txt：存储表结构信息。</li><li>count.txt：存储该分区下的行数。执行select count(*) from table即返回该内容，而不是遍历数据。</li><li>primary.idx：主键索引。</li><li>checksums.txt：二进制文件，校验和。用于快速校验数据是否被篡改。</li><li>default_compression_codec.txt：（新版本增加的文件）存储数据文件中使用的压缩编码器。默认使用LZ4。</li><li>[column].mrk3：列的标记文件。</li><li>[column].bin：真正存储数据的数据文件。每一列都会生成一个单独的bin文件。</li><li>skp_idx_[column].idx：跳数索引，使用二级索引时会生成。</li><li>skp_idx_[column].mrk：条数索引标记文件，使用二级索引时会生成。</li></ul><h1 id=数据组织>数据组织</h1><p>bin文件是二进制文件，在读取时需要借助工具，无法使用文本文件进行读取。在windows操作系统下建议使用winhex，mac系统推荐hex friend。</p><h2 id=数据文件结构>数据文件结构</h2><p><img src=../imgs/clickhouse01_5.png alt=clickhouse01_5.png></p><p>bin文件使用小端字节序存储。bin文件中按block为单位排列数据，每个block文件有16字节校验和，1字节压缩方式，4字节压缩后大小和4字节的压缩前大小组成。每个block起始地址由如下公式确定：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-plain data-lang=plain><span style=display:flex><span>offset(n)=offset(n-1)+25+压缩后大小 （n&gt;=2)
</span></span><span style=display:flex><span>offset(1)=0
</span></span></code></pre></td></tr></table></div></div></div><h2 id=校验和>校验和</h2><p>前16为检验和区域用于快速验证数据是否完整。</p><h2 id=压缩方式>压缩方式</h2><p>默认为0x82。clickhouse共支持4种压缩方式，分别为LZ4(0x82)、ZSTD(0x90)、Multiple(0x91)、Delta(0x92)。</p><h2 id=压缩后大小>压缩后大小</h2><p>存储在data区域的数据的大小。需要依据此大小计算下一个BLOCK的偏移量。</p><h2 id=压缩前大小>压缩前大小</h2><p>data区域存储的数据在压缩前的大小。可以依据此计算压缩比。</p><h2 id=data区>data区</h2><p>data区存储数据，大小为头信息第18～21字节表示的大小。拿到data区数据后，由于是压缩后的，因此无法直接识别，需要按照压缩方式进行解压缩后，才能识别。</p><h1 id=reference>Reference</h1><p><a href=https://clickhouse.com/docs/zh/>https://clickhouse.com/docs/zh/</a></p><p><a href=https://clickhouse.com/docs/zh/development/architecture>https://clickhouse.com/docs/zh/development/architecture</a></p><p><a href=https://juejin.cn/post/7035791936145326111>字节跳动广告场景使用的“ClickHouse”介绍</a></p><p><a href=https://zhuanlan.zhihu.com/p/358821358>ClickHouse作用及应用场景</a></p><p><a href=https://www.modb.pro/db/467020>https://www.modb.pro/db/467020</a></p><p><a href=https://developer.aliyun.com/article/1133873>https://developer.aliyun.com/article/1133873</a></p><p><a href=https://zhuanlan.zhihu.com/p/398187357>https://zhuanlan.zhihu.com/p/398187357</a></p></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2023 The Herb 保留所有权利</small>
<small class=ml-1><a href=# target=_blank rel=noopener>隐私政策</a></small><p class=mt-2><a href=/about/>Herbdocs</a></p></div></div></div></footer></div><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA==" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script>
<script src=/js/main.min.91798a335c881f1b6b805085ba4aa22d1dbd2b0b18d105d05189fa104ddae350.js integrity="sha256-kXmKM1yIHxtrgFCFukqiLR29KwsY0QXQUYn6EE3a41A=" crossorigin=anonymous></script></body></html>