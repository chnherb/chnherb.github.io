<!doctype html><html lang=zh-cn class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.101.0"><link rel=canonical type=text/html href=/docs/21.Java/03.JVM/><link rel=alternate type=application/rss+xml href=/docs/21.Java/03.JVM/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>JVM | Herbdocs</title><meta name=description content="Introduction
JVM
"><meta property="og:title" content="JVM"><meta property="og:description" content="Herb's blog"><meta property="og:type" content="website"><meta property="og:url" content="/docs/21.Java/03.JVM/"><meta property="og:site_name" content="Herbdocs"><meta itemprop=name content="JVM"><meta itemprop=description content="Herb's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="JVM"><meta name=twitter:description content="Herb's blog"><link rel=preload href=/scss/main.min.dcab2c3dae6e6fefb7672f19e4b612cc4e75ca208740f642aa2f1fe378478a8f.css as=style><link href=/scss/main.min.dcab2c3dae6e6fefb7672f19e4b612cc4e75ca208740f642aa2f1fe378478a8f.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-00000000-0","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><img width=6% style=margin-bottom:1% src=/favicons/favicon.ico></span><span class=font-weight-bold>&nbsp;Herbdocs</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/about/><span>About</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class="nav-link active" href=/docs/><span class=active>Documentation</span></a></li><li class="nav-item dropdown mr-4 d-none d-lg-block"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Chinese</a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/en/>English</a></div></li></ul></div><div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label=站内搜索… autocomplete=off></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/docs/21.Java/03.JVM/>返回本页常规视图</a>.</p></div><h1 class=title>JVM</h1><ul><li>1: <a href=#pg-2d01121d927ead454a6d7c9563858a23>垃圾回收算法</a></li><li>2: <a href=#pg-bbeac0863d613f8c11dcf2b3ba74405a>JVM调优</a></li></ul><div class=content><h1 id=introduction>Introduction</h1><p>JVM</p></div></div><div class=td-content><h1 id=pg-2d01121d927ead454a6d7c9563858a23>1 - 垃圾回收算法</h1><h1 id=概述>概述</h1><p>当进行系统调优与线上问题排查时，深入理解 Java 虚拟机垃圾回收机制的底层原理是非常有必要的。Java 垃圾回收器的种类繁多，其设计主要在吞吐量（内存空间）与实时性（用户线程中断）进行权衡，适应场景也有所区别。本文主要针对 JDK8 进行分析。</p><h1 id=内存-堆结构>内存/堆结构</h1><p>新生代和老年代默认分配空间比为 1:2。</p><p>新生代又可以分为：</p><ul><li>Eden 区</li><li>两个 Survial 区（S0/S1）
空间占比：Eden（8/10）、S0（1/10）、S1（1/10）</li></ul><p><img src=../imgs/java_garbage_collection_1.png alt=java_garbage_collection_1.png></p><p>一块独立的内存区域只能使用一种垃圾回收算法，根据对象生命周期特征，将其划到不同区域，再对特定区域使用特定的垃圾回收算法，将垃圾回收算法的优点发挥到极致。这种组合的垃圾回收算法成为<strong>分代垃圾回收算法</strong>。如：新生代使用<strong>标记复制算法</strong>，老年代使用<strong>标记整理算法</strong>。</p><h1 id=对象回收算法>对象回收算法</h1><p>判断对象回收一般有两种方法。</p><h2 id=引用计数器算法>引用计数器算法</h2><p>对象被引用一次计数器加 1，对象取消被引用计数器减 1，计数器为 0 时则表示对象不被引用，可以被销毁。</p><p>该算法简单高效。但对于循环引用或者其它复杂情况，需要更多的开销，所以一般不使用该方法。</p><h2 id=可达性分析算法>可达性分析算法</h2><p>顺着 GCRoot 根向下搜索，只要在引用链上的对象就是可达的，在这之外的对象则不可达，不可达的对象就是可回收的。GCRoots 对象一般包括：</p><ul><li>虚拟机栈帧上本地变量表中的引用对象（方法参数、局部变量、临时变量）</li><li>方法区中的静态属性引用类型对象、常量引用对象</li><li>本地方法栈中的引用对象（Native方法的引用对象）</li><li>Java虚拟机内部的引用对象，如异常对象、系统类加载器等</li><li>被同步锁（synchronize）持有的对象</li><li>Java 虚拟机内部情况的注册回调、本地缓存等
<img src=../imgs/java_garbage_collection_2.png alt=java_garbage_collection_2.png></li></ul><h1 id=垃圾回收算法>垃圾回收算法</h1><p>垃圾具体如何回收涉及到垃圾回收算法。垃圾回收算法可分为3种：</p><ul><li>标记清除算法</li><li>标记复制算法</li><li>标记整理算法</li></ul><h2 id=标记清除算法>标记清除算法</h2><h3 id=流程>流程</h3><ol><li>标记出所有需要被回收的对象</li><li>对标记对象进行统一清除</li></ol><h3 id=优点>优点</h3><ul><li>效率高</li></ul><h3 id=缺点>缺点</h3><ul><li>执行效率不可控（如大部分对象都可回收，收集器需要一一大量执行标记、收集操作）</li><li>产生大量内存碎片</li></ul><h2 id=标记复制算法>标记复制算法</h2><h3 id=流程-1>流程</h3><p>标记复制算法将内存分为大小相同的两个区域：</p><ul><li>运行区域</li><li>预留区域
所有创建的新对象都分配到运行区域，当该区域内存不足时，则将该区域全部存活对象复制到预留区域，然后再清空整个运行区域内存。此时这两个区域的角色也互相调换。</li></ul><p>标记复制算法在存在大量垃圾对象时，只需要复制较少的存活对象，不会产生内存碎片，新内存的分配只需要移动堆顶指针顺序分配即可，很好地兼顾了效率与内存碎片的问题。</p><h3 id=优点-1>优点</h3><ul><li>兼顾效率</li><li>避免内存碎片</li></ul><h3 id=缺点-1>缺点</h3><ul><li>预留一半空间造成浪费</li><li>少量垃圾大量存活对象时效果很差，复制操作很多但回收空间少</li></ul><h2 id=标记整理算法>标记整理算法</h2><p>基于前两种算法的优缺点，又提出了标记整理算法。</p><ul><li>标记阶段：和其他算法一样</li><li>整理阶段：将存活的对象向内存空间一端移动，然后将存活对象边界以外的空间全部清空</li></ul><h1 id=堆内存回收过程>堆内存回收过程</h1><h2 id=第一次minorgc>第一次MinorGC</h2><ul><li>Eden 区空间不足时，触发 MinorGC</li><li>垃圾回收器首先将 Eden 区中存活对象复制到 S0 区中（S0或S1，互备）</li><li>清空 Eden 区空间</li></ul><h2 id=第二次minorgc>第二次MinorGC</h2><ul><li>Eden 区空间不足时，再次触发 MinorGC</li><li>将 Eden 区存活对象复制到 S1 区</li><li>清空 Eden 区空间</li><li>将 S0 区存活对象复制到 S1 区并将对象的年龄加 1</li><li>清空 S0 区
第三次及之后 MinorGC 同理。</li></ul><p>这里为了减少复制算法空白区域的空间浪费，不是将内存一分为二，而是巧妙地将内存分为三个区域，预留的空白区域只占整个年轻代的空间的 1/10。</p><h2 id=进入老年代>进入老年代</h2><p>进入老年代空间的条件：</p><ul><li>从年轻代晋升<ul><li>年轻代分配担保：Survivor 区只有年轻代空间的 2/10 且一分为二，空间不足以分配所有存活对象时，将无法容纳的对象分配到老年代中</li><li>对象年龄超过虚拟机 MaxTenuringThreshold 参数大小的对象（Parallel Scavenge:å 15，CMS: 6, G1: 15）</li><li>Survivor 空间中相同年龄所有对象大小的总和大于Survivor空间的一半（TargetSurvivorRatio），大于或等于该年龄的对象直接进入老年代</li></ul></li><li>直接分配<ul><li>超过虚拟机 PretenureSizeThreshold 参数大小的大对象</li><li>超过 Eden 大小的对象</li><li>新生代分配失败，如大字符串或者大数组</li></ul></li></ul><h2 id=fullgc>FullGC</h2><p>老年代空间不足时就会触发 FullGC，FullGC 触发的条件一般有：</p><ul><li>调用 System.gc()（建议虚拟机执行 FullGC，不一定真正去执行）</li><li>老年代空间不足</li><li>空间分配担保失败</li><li>JDK 1.7 及以前的永久代空间不足</li><li>CMS GC 时出现 Concurrent Mode Failure</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bbeac0863d613f8c11dcf2b3ba74405a>2 - JVM调优</h1><h1 id=优化系统思路>优化系统思路</h1><ol><li><p>首先排查 DB 的问题
如评估索引是否合理，是否需要引入分布式缓存、是否需要分库分表等</p></li><li><p>扩容
横向和纵向扩容，解决系统压力过大导致的硬件能力不足出现的问题</p></li><li><p>代码优化
检查代码上是否存在资源浪费的情况，或者逻辑上有优化的空间，比如通过并行的方式处理请求等等）</p></li><li><p>JVM排查并优化
观察是否存在多次GC问题或者GC时间过长等等</p></li><li><p>网络和操作系统层面优化
查看内存/CPU/网络/硬盘读写指标是否正常等</p></li></ol><h1 id=jvm调优>JVM调优</h1><h2 id=参考指标>参考指标</h2><ul><li>吞吐量</li><li>停顿时间</li><li>垃圾回收频率</li></ul><h2 id=调优方法>调优方法</h2><h3 id=内存分配策略>内存分配策略</h3><p>内存区域大小以及相关策略（比如整块堆内存占多少、年轻代占多少、老年代占多少、Sur<a href="https://www.zhihu.com/search?q=vivo&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2760498114%7D">vivo</a>r占多少、晋升老年代的条件等等）</p><p>比如 -Xmx：设置堆的最大值、-Xms：设置堆的初始值、-Xmn：表示年轻代的大小、-XX:SurvivorRatio：伊甸区和幸存区的比例等等</p><p>按经验来说：IO密集型的可以稍微把「年轻代」空间加大些，因为大多数对象都是在年轻代就会灭亡。内存计算密集型的可以稍微把「老年代」空间加大些，对象存活时间会更长些</p><h3 id=垃圾回收器>垃圾回收器</h3><blockquote><p>选择合适的垃圾回收器，以及各个垃圾回收器的各种调优参数</p></blockquote><p>比如（-XX:+UseG1GC：指定 JVM 使用的垃圾回收器为 G1、-XX:MaxGCPauseMillis：设置目标停顿时间、-XX:InitiatingHeapOccupancyPercent：当整个堆内存使用达到一定比例，全局并发标记阶段 就会被启动等等）</p><h2 id=调优步骤>调优步骤</h2><ol><li>监控GC状态</li><li>生成dump文件</li><li>分析dump文件</li><li>调整GC类型/内存分配</li></ol><h1 id=调优参数参考>调优参数参考</h1><h2 id=堆大小>堆大小</h2><p>参数-Xms -Xmx标志限定堆的最小、最大值。<strong>为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值。</strong></p><h2 id=堆内存分配比例>堆内存分配比例</h2><p>年轻代和老年代默认比例是 1:2 分配堆内存，可以通过调整二者之间的比例 NewRadio 来调整二者之间的大小。</p><p>年轻代通过 -XX:newSize -XX:MaxNewSize 来设置其绝对大小。同样为了防止堆收缩，通常将二者设置成同样大小。</p><h2 id=年轻代-老年代大小>年轻代/老年代大小</h2><ul><li><p>更大的年轻代必然导致更小的老年代：大的年轻代会延长普通GC的周期，且增加每次 YGC 的时间。小的老年代导致更频繁的 FullGC。</p></li><li><p>更小的年轻代必然导致更大的老年代：小的年轻代会导致 YGC 很频繁，但每次 GC 时间会很短。大的老年代会减少 FullGC 的频率。
如何选择应该依赖应用程序的对象生命周期分布情况：</p></li><li><p>如果应用存在大量的临时对象，应该选择更大的年轻代</p></li><li><p>如果应用存在相对较多的持久对象，老年代应该适当增大
但是很多应用都没有这样明显的特征。所以抉择时应该根据以下几点：</p></li></ul><ol><li>本着 FullGC 尽量少的原则，让老年代尽量缓存常用对象（默认比例1:2也是基于这个原则）</li><li>观察一段时间，查看峰值时老年代占用内存大小，在不影响 FullGC 的前提下，适当加大年轻代，比如将比例控制成 1:1。但应该给老年代至少预留三分之一的增长空间。</li></ol><h2 id=垃圾回收算法>垃圾回收算法</h2><p>在配置较好的机器上（如多核、大内存），可以为老年代选择并行回收算法：-XX:+UseParallelOldGC。</p><h2 id=线程堆栈大小>线程堆栈大小</h2><p>每个线程默认开启 1M 的堆栈，用于存放栈帧、调用参数、局部变量等。可以根据实际情况调小，理论上总内存大小不变的情况下，这样可以开启更多的线程。当然也受限于操作系统。</p><h1 id=调优策略>调优策略</h1><h2 id=fullgc>FullGC</h2><p>FullGC 会对整个堆进行整理，包括 年轻代、老年代、永久代，所以会比较慢，因此应该尽可能减少 FullGC 的次数。</p><p>可能的原因：</p><ul><li>老年代被写满</li><li>永久代空间不足</li><li>System.gc() 被显示调用</li></ul><h1 id=工具>工具</h1><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><h2 id=jconsole>jconsole</h2><p>JMX的可视化管理工具。</p><p>用于对 JVM 中的内存、线程和类等进行监控；</p><h2 id=jvisualvm>jvisualvm</h2><p>JDK 自带的全能分析工具。</p><p>可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p><h2 id=jps>jps</h2><p>虚拟机进程状况工具。</p><p>用来输出JVM中运行的进程状态「基础」信息（进程号、主类）。这个命令很常用的就是用来看当前服务器有多少Java进程在运行，它们的进程号和加载主类是什么。</p><h2 id=jstat>jstat</h2><p>虚拟机统计信息监控工具。</p><p>监视虚拟机各种运行状态信息，可以显示本地或者是远程虚拟机进程中「统计类」信息，如类装载、编译相关信息统计、各个内存区域GC概况和统计、垃圾收集、JIT编译等运行数据。这个命令很常用于看GC的情况。</p><h2 id=jinfo>jinfo</h2><p>通过jinfo命令来查看和调整Java进程的「运行参数」。</p><h2 id=jmap>jmap</h2><p>通过jmap命令来查看Java进程的「内存信息」。可以生成虚拟机的内存转储快照（heapdump文件）。常用于将JVM内存信息dump到文件，然后用MAT( Memory Analyzer tool 内存解析工具)对文件进行分析。</p><h2 id=jstack>jstack</h2><p>堆栈跟踪工具。</p><p>查看JVM「线程信息」，用于生成虚拟机当前时刻的线程快照。这个命令用常用语排查死锁相关的问题。</p><h2 id=jhat>jhat</h2><p>分析内存转储快照，不推荐使用，而且慢</p><h2 id=arthas>Arthas</h2><p>还有近期比较热门的Arthas（阿里开源的诊断工具），涵盖了上面很多命令的功能且自带图形化界面。这也是常用的排查和分析工具。</p><h1 id=jit优化技术>JIT优化技术</h1><p>JIT优化技术比较出名的有两种：方法内联和逃逸分析。</p><h2 id=方法内联>方法内联</h2><p>把「目标方法」的代码复制到「调用的方法」中，避免发生真实的方法调用。</p><p>因为每次方法调用都会生成栈帧（压栈出栈记录方法调用位置等等）会带来一定的性能损耗，所以「方法内联」的优化可以提高一定的性能。</p><p>在JVM中也有相关的参数来指定（-XX:MaxFreqInlineSize、-XX:MaxInlineSize）。</p><h2 id=逃逸分析>逃逸分析</h2><p>判断一个对象是否被外部方法引用或外部线程访问的分析技术，如果「没有被引用」，就可以对其进行优化，如：</p><ol><li><p>锁消除（同步忽略）
该对象只在方法内部被访问，不会被别的地方引用，那么就一定是线程安全的，可以把锁相关的代码给忽略掉</p></li><li><p>栈上分配
该对象只会在方法内部被访问，直接将对象分配在「栈」中</p></li></ol><blockquote><p>Java默认是将对象分配在「堆」中，是需要通过JVM垃圾回收期进行回收，需要损耗一定的性能，而栈内分配则快很多</p></blockquote><ol start=3><li>标量替换/分离对象
当程序真正执行的时候可以不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。</li></ol><h1 id=调优案例>调优案例</h1><h2 id=内存分配大小>内存分配大小</h2><p>现象：</p><blockquote><p>部分机器出现异常：GC overhead limit exceeded</p></blockquote><p>该异常代表GC为了释放很小的空间却耗费了太多的时间，原因一般有两个：</p><ol><li>堆太小</li><li>有死循环或大对象
因为是部分机器，所以排查原因2，怀疑是部分机器中堆设置太小，通过 <code>ps -ef | grep java</code> 查看内存分配大小（如堆-Xms -Xmx），如果太小而该应用又比较吃内存，适当调大堆中各区域大小。</li></ol><h2 id=内存分配比例>内存分配比例</h2><p>现象：</p><blockquote><p>系统经常出现卡顿</p></blockquote><p>查看GC情况：</p><style>.td-content .highlight{margin-top:.5rem;margin-bottom:.5rem}.code-collapse1{overflow-y:auto;max-height:500px;overflow-x:auto;max-width:100%}</style><div class=code-collapse1><div class=highlight><div style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>$ jstat -gcutil
</span></span><span style=display:flex><span>S0 S1 E O P YGC YGCT FGC FGCT GCT
</span></span><span style=display:flex><span>13.01 0.00 5.19 62.67 20.76 <span style=color:#1c01ce>56</span> 2.032 <span style=color:#1c01ce>6</span> 7.012 9.026
</span></span></code></pre></td></tr></table></div></div></div><p>可以看到不同GC耗时和次数，Young GC 执行了 56 次，耗时 2.032 秒，平均耗时 36 ms 在正常范围内。FullGC 执行了 6 次，耗时 7.012 秒，平均耗时超过1秒。可以判断是 FullGC 耗时较长导致的。进一步查询年轻代和老年代的大小比例 NewRatio=9，可以得出原因：</p><ol><li>年轻代太小，导致对象提前进入老年代，触发老年代发生 FullGC</li><li>老年代太大，进行 FullGC 耗时较大
优化方法：调整 NewRatio 大小。</li></ol><p>这样就是把对象控制在年轻代就清理掉，防止进入老年代。</p><h2 id=对象未释放>对象未释放</h2><p>现象：</p><blockquote><p>性能测试过程中，发现内存占用率高，Full GC 频繁。</p></blockquote><p>使用 <code>sudo -u admin -H jmap -dump:format=b,file=FileName.hprof pid</code> 来 dump 内存生成 dump 文件，并使用 MAT 进行分析。</p><p>可能得问题：内存泄漏</p><p>1、某数据结构（列表、队列等）引用的大量对象未被释放，导致整个线程占用内存过高（几百兆）。优化相关代码即可。</p><p>2、匿名对象引用的对象未被释放</p><h2 id=元数据空间太小>元数据空间太小</h2><p>查看GC log，发现 FullGC 时，老年代占据的内存比例很小（如低于60%）却发生了 FullGC，metaspace 占用的空间远大于默认的分配值。</p><h1 id=reference>Reference</h1><p><a href=https://mp.weixin.qq.com/s/RFwXYdzeRkTG5uaebVoLQw>美团：Java中9种常见的CMS GC问题分析与解决</a></p><p><a href=https://zhuanlan.zhihu.com/p/373853432>优化 FullGC</a></p><p><a href=https://mikechen.cc/3321.html>JVM性能调优6大步骤</a></p></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2023 The Herb 保留所有权利</small>
<small class=ml-1><a href=# target=_blank rel=noopener>隐私政策</a></small><p class=mt-2><a href=/about/>Herbdocs</a></p></div></div></div></footer></div><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA==" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script>
<script src=/js/main.min.91798a335c881f1b6b805085ba4aa22d1dbd2b0b18d105d05189fa104ddae350.js integrity="sha256-kXmKM1yIHxtrgFCFukqiLR29KwsY0QXQUYn6EE3a41A=" crossorigin=anonymous></script></body></html>