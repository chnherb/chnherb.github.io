# 简述

守护进程（daemon）是生存期长的一种进程，没有控制终端。它们常常在系统引导装入时启动，仅在系统关闭时才终止。UNIX系统有很多守护进程，守护进程程序的名称通常以字母“d”结尾：例如，[syslogd](https://zh.wikipedia.org/wiki/Syslog) 就是指管理系统日志的守护进程。通过ps进程查看器 `ps -efj` 的输出实例，内核守护进程的名字出现在方括号中，大致输出如下：


# 基本概念

进程组

* 每个进程除了有一个进程ID之外，还属于一个进程组
* 进程组是一个或多个进程的集合，同一进程组中的各进程接收来自同一终端的各种信号
* 每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID

会话（session）是一个或多个进程组的集合，进程调用 setsid 函数（原型：`pid_t setsid(void)` ）建立一个会话。 

进程调用 setsid 函数建立一个新会话，如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下3件事：

* 该进程变成新会话的会话首进程（session leader，会话首进程是创建该会话的进程）。此时，该进程是新会话的唯一进程。
* 该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID
* 该进程没有控制终端。如果调用setsid之前该进程有一个控制终端，那么这种联系也被切断

控制终端（Controlling Terminal）

每个会话可以有一个单独的控制终端，与控制终端连接的 Leader 就是控制进程（Controlling Process）。

## 进程分类

**子进程**`child thread`：

相对父进程而言， 父进程创建的进程， 子进程只能对应一个父进程。如果没有标记为daemon ， 则杀死父进程不会对子进程的运行状态有丝毫影响。

**守护进程**`daemon thread`：

即daemon thread，是子进程的一种状态，标记子进程与父进程一起结束。

**僵尸进程**：

本该结束，但仍在后台运行的子进程。因为某些子进程没有设置daemon 属性，如果杀死父进程，其子进程将会变成“僵尸进程”。僵尸进程的父进程将成为init 进程的子进程。


## 基本操作

查看守护进程

```plain
ps -axj
-a表示显示由其他用户所拥有的进程的状态
-x显示没有控制终端的进程状态
-j显示与作业有关的信息：会话ID、进程组ID等 
```

如何编写守护进程

可参考《unix环境高级编程》第13章 守护进程

 

如何使普通进程达到守护进程的部分效果

参考 Linux后台进程 专栏

```plain
nohup ./a.out &
```
nohup忽略SIGHUP信号，&忽略SIGINT信号。
# 守护进程的创建

## fork

守护进程的父进程是 init 进程，在创建时先从父进程 fork 出来一个子进程，退出父进程，这时子进程变成孤儿，就成了 init 的子进程。

子进程会继承父进程的会话，进程组，控制终端，文件描述符等。

## setid

通过`setid()`来创建新会话，同时也脱离了原来的进程组，会话以及控制终端，成为新的会话的组长。此时它可能会再申请一个控制终端，所以我们再 fork 一下，并只保留新的子进程，这样就不是会话组长了，就不能申请控制终端了。 

### close(fd)

之后再关闭从父进程继承的文件描述符。至少要关闭 0,1,2 这三个文件描述符，分别对应了 stdin, stdout, 和 stderr。不过通常用 `sysconf(_SC_OPEN_MAX)` 获取系统允许的最大文件描述符个数，然后全部 close 掉。

 关闭之后我们要将文件描述符 0，1，2 重新定向到 "/dev/null"，防止新打开的文件的文件描述符为 0，1，2。

### umask(0)

设置文件掩码是为了不受父进程的 umask 的影响，能自由创建读写文件和目录。

### chdir("/")

守护进程一般是一直执行到系统关机，在它运行过程中，它所在的目录就不能卸载（unmounted）。通过将它的工作目录转移到根目录，用来的目录就允许卸载了。也不一定要根目录（这种情况，运行需要超级权限），可以选择一个不需要卸载的路径。 

# 对比

## 守护进程与后台进程的区别

1、守护进程已经完全脱离终端控制台了，而后台程序并未完全脱离终端(在终端未关闭前还是会往终端输出结果);

2、守护进程在关闭终端控制台时不会受影响，而后台程序会随用户退出而停止，需要在启动命令后加上“&”格式运行才能避免影响;

3、守护进程的会话组和当前目录、文件描述符都是独立的。后台进程运行只是终端进行了一次fork，仅仅让程序在后台执行而已。


# Reference

[守护进程（Daemon）](https://cloud.tencent.com/developer/article/1635805)

 

