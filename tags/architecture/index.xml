<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Herbdocs – architecture</title><link>/tags/architecture/</link><description>Recent content in architecture on Herbdocs</description><generator>Hugo -- gohugo.io</generator><atom:link href="/tags/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 架构设计01-基础架构</title><link>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A101-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A101-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;h3 id="架构的特性">架构的特性&lt;/h3>
&lt;p>架构设计的思维和程序设计的思维差异很大。&lt;/p>
&lt;p>&lt;strong>架构设计的关键思维是判断和取舍，程序设计的关键思维是逻辑和实现。&lt;/strong>&lt;/p>
&lt;h2 id="架构的定义">架构的定义&lt;/h2>
&lt;p>3个问题：&lt;/p>
&lt;p>1、微信有架构，微信的登录系统也有架构，微信的支付系统也有架构，当谈微信架构时，到底是在谈什么架构？&lt;/p>
&lt;p>2、Linux 有架构，MySQL 有架构，JVM 也有架构，使用 Java 开发、MySQL 存储、跑在 Linux 上的业务系统也有架构，应该关注哪个架构呢？&lt;/p>
&lt;p>3、架构和框架是什么关系？有什么区别？&lt;/p>
&lt;p>要想准确地理解架构的定义，关键就在于把三组容易混淆的概念梳理清楚：&lt;/p>
&lt;p>1、系统与子系统&lt;/p>
&lt;p>2、模块与组件&lt;/p>
&lt;p>3、框架与架构&lt;/p>
&lt;h3 id="系统与子系统">系统与子系统&lt;/h3>
&lt;p>维基百科定义的“&lt;strong>系统&lt;/strong>”：系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。&lt;/p>
&lt;p>&lt;strong>关联&lt;/strong>：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统。例如，把一个发动机和一台 PC 放在一起不能称之为一个系统，把发动机、底盘、轮胎、车架组合起来才能成为一台汽车。&lt;/p>
&lt;p>&lt;strong>规则&lt;/strong>：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。例如，汽车发动机负责产生动力，然后通过变速器和传动轴，将动力输出到车轮上，从而驱动汽车前进。&lt;/p>
&lt;p>&lt;strong>能力&lt;/strong>：系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力。例如，汽车能够载重前进，而发动机、变速器、传动轴、车轮本身都不具备这样的能力。&lt;/p>
&lt;p>&lt;strong>子系统&lt;/strong>的定义：子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。&lt;/p>
&lt;p>问题1：&lt;/p>
&lt;p>架构定义：只包含顶层这一层级的架构，不包含子系统层级的架构。所以微信架构，就是指微信系统这个层级的架构。当然，微信的子系统，比如支付系统，也有它自己的架构，同样只包括顶层。&lt;/p>
&lt;h3 id="模块与组件">模块与组件&lt;/h3>
&lt;p>软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。&lt;/p>
&lt;p>软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。&lt;/p>
&lt;p>&lt;strong>模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。&lt;/strong>&lt;/p>
&lt;p>从业务逻辑的角度来拆分系统后，得到的单元就是“模块”；从物理部署的角度来拆分系统后，得到的单元就是“组件”。划分&lt;strong>模块&lt;/strong>的主要目的是&lt;strong>职责分离&lt;/strong>；划分&lt;strong>组件&lt;/strong>的主要目的是&lt;strong>单元复用&lt;/strong>。&lt;/p>
&lt;p>以一个最简单的网站系统来为例。假设我们要做一个学生信息管理系统，这个系统从逻辑的角度来拆分，可以分为“登录注册模块”“个人信息模块”和“个人成绩模块”；从物理的角度来拆分，可以拆分为 Nginx、Web 服务器和 MySQL。&lt;/p>
&lt;p>问题2：&lt;/p>
&lt;p>业务系统的架构师，首先需要思考怎么从业务逻辑的角度把系统拆分成一个个模块角色，其次需要思考怎么从物理部署的角度把系统拆分成组件角色，例如选择 MySQL 作为存储系统。但是对于 MySQL 内部的体系架构（Parser、Optimizer、Caches&amp;amp;Buffers 和 Storage Engines 等），其实是可以不用关注的，也不需要在你的业务系统架构中展现这些内容。&lt;/p>
&lt;h3 id="框架与架构">框架与架构&lt;/h3>
&lt;p>软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。&lt;/p>
&lt;p>提炼一下其中关键部分：&lt;/p>
&lt;p>1、框架是组件规范：例如，MVC 就是一种最常见的开发规范，类似的还有 MVP、MVVM、J2EE 等框架。&lt;/p>
&lt;p>2、框架提供基础功能的产品：例如，Spring MVC 是 MVC 的开发框架，除了满足 MVC 的规范，Spring 提供了很多基础功能来帮助我们实现功能，包括注解（@Controller 等）、Spring Security、Spring JPA 等很多基础功能。&lt;/p>
&lt;p>软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。&lt;/p>
&lt;p>&lt;strong>框架关注的是“规范”，架构关注的是“结构”。&lt;/strong>&lt;/p>
&lt;p>框架的英文是 Framework，架构的英文是 Architecture，Spring MVC 的英文文档标题就是“Web MVC framework”。&lt;/p>
&lt;p>举例：学生管理系统&lt;/p>
&lt;p>从业务逻辑的角度分解，架构是 登录注册模块、个人信息模块、个人成绩模块……&lt;/p>
&lt;p>从物理部署的角度分解，架构是 Nginx、Web服务器、MySQL&lt;/p>
&lt;p>从开发规范的角度分解，架构是 MVC 架构（Controller、View、Model）&lt;/p>
&lt;p>问题3：&lt;/p>
&lt;p>框架是一整套开发规范，架构是某一套开发规范下的具体落地方案，包括各个模块之间的组合关系以及它们协同起来完成功能的运作规则。&lt;/p>
&lt;h3 id="重新定义架构-4r架构">重新定义架构：4R架构&lt;/h3>
&lt;p>参考维基百科的定义，再结合自己的一些理解和思考，将软件架构重新定义为：软件架构指软件系统的顶层（Rank）结构，它定义了系统由哪些角色（Role）组成，角色之间的关系（Relation）和运作规则（Rule）。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_1.png" alt="architecture-base_1.png">&lt;/p>
&lt;h4 id="rank">Rank&lt;/h4>
&lt;p>它是指软件架构是分层的，对应“系统”和“子系统”的分层关系。通常情况下，只需要关注某一层的架构，最多展示相邻两层的架构，而不需要把每一层的架构全部糅杂在一起。无论是架构设计还是画架构图，都应该采取“自顶向下，逐步细化”的方式。以微信为例，Rank 的含义如下所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_2.png" alt="architecture-base_2.png">&lt;/p>
&lt;h4 id="role">Role&lt;/h4>
&lt;p>它是指软件系统包含哪些角色，每个角色都会负责系统的一部分功能。架构设计最重要的工作之一就是将系统拆分为多个角色。最常见的微服务拆分其实就是将整体复杂的业务系统按照业务领域的方式，拆分为多个微服务，每个微服务就是系统的一个角色。&lt;/p>
&lt;h4 id="relation">Relation&lt;/h4>
&lt;p>它是指软件系统的角色之间的关系，对应到架构图中其实就是连接线，角色之间的关系不能乱连，任何关系最后都需要代码来实现，包括连接方式（HTTP、TCP、UDP 和串口等）、数据协议（JSON、XML 和二进制等）以及具体的接口等。&lt;/p>
&lt;h4 id="rule">Rule&lt;/h4>
&lt;p>它是指软件系统角色之间如何协作来完成系统功能。在前面解读什么是“系统”的时候提到过：系统能力不是个体能力之和，而是产生了新的能力。那么这个新能力具体如何完成的呢？具体哪些角色参与了这个新能力呢？这就是 Rule 所要表达的内容。在架构设计的时候，核心的业务场景都需要设计 Rule。&lt;/p>
&lt;p>实际工作中，为了方便理解，Rank、Role 和 Relation 是通过系统架构图来展示的，而 Rule 是通过系统序列图（System Sequence Diagram）来展示的。&lt;/p>
&lt;p>以一个简化的支付系统为例，支付系统架构图如下所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_3.png" alt="architecture-base_3.png">&lt;/p>
&lt;p>“扫码支付”这个核心场景的系统序列图如下所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_4.png" alt="architecture-base_4.png">&lt;/p>
&lt;h2 id="结构设计的历史背景">结构设计的历史背景&lt;/h2>
&lt;h3 id="第一次软件危机与结构化程序设计">第一次软件危机与结构化程序设计&lt;/h3>
&lt;p>20 世纪 60 年代~20 世纪 70 年代。&lt;/p>
&lt;p>高级语言的出现，解放了程序员，但好景不长，随着软件的规模和复杂度的大大增加，20 世纪 60 年代中期开始爆发了第一次软件危机，典型表现有软件质量低下、项目无法如期完成、项目严重超支等，因为软件而导致的重大事故时有发生。例如，1963 年美国（&lt;a href="http://en.wikipedia.org/wiki/Mariner_1">http://en.wikipedia.org/wiki/Mariner_1&lt;/a>）的水手一号火箭发射失败事故，就是因为一行 FORTRAN 代码错误导致的。&lt;/p>
&lt;p>“结构化程序设计”作为另外一种解决软件危机的方案被提了出来。艾兹赫尔·戴克斯特拉（Edsger Dijkstra）于 1968 年发表了著名的《GOTO 有害论》论文，引起了长达数年的论战，并由此产生了结构化程序设计方法。同时，第一个结构化的程序语言 Pascal 也在此时诞生，并迅速流行起来。&lt;/p>
&lt;p>结构化程序设计的主要特点是抛弃 goto 语句，采取“自顶向下、逐步细化、模块化”的指导思想。结构化程序设计本质上还是一种面向过程的设计思想，但通过“自顶向下、逐步细化、模块化”的方法，将软件的复杂度控制在一定范围内，从而从整体上降低了软件开发的复杂度。结构化程序方法成为了 20 世纪 70 年代软件开发的潮流。&lt;/p>
&lt;h3 id="第二次软件危机与面向对象">第二次软件危机与面向对象&lt;/h3>
&lt;p>结构化编程的风靡在一定程度上缓解了软件危机，然而随着硬件的快速发展，业务需求越来越复杂，以及编程应用领域越来越广泛，第二次软件危机很快就到来了。&lt;/p>
&lt;p>第二次软件危机的根本原因还是在于软件生产力远远跟不上硬件和业务的发展。第一次软件危机的根源在于软件的“逻辑”变得非常复杂，而第二次软件危机主要体现在软件的“扩展”变得非常复杂。结构化程序设计虽然能够解决（也许用“缓解”更合适）软件逻辑的复杂性，但是对于业务变化带来的软件扩展却无能为力，软件领域迫切希望找到新的银弹来解决软件危机，在这种背景下，面向对象的思想开始流行起来。&lt;/p>
&lt;p>面向对象的思想并不是在第二次软件危机后才出现的，早在 1967 年的 Simula 语言中就开始提出来了，但第二次软件危机促进了面向对象的发展。面向对象真正开始流行是在 20 世纪 80 年代，主要得益于 C++ 的功劳，后来的 Java、C# 把面向对象推向了新的高峰。到现在为止，面向对象已经成为了主流的开发思想。&lt;/p>
&lt;h3 id="软件架构的历史背景">软件架构的历史背景&lt;/h3>
&lt;p>虽然早在 20 世纪 60 年代，戴克斯特拉这位上古大神就已经涉及软件架构这个概念了，但软件架构真正流行却是从 20 世纪 90 年代开始的，由于在 Rational 和 Microsoft 内部的相关活动，软件架构的概念开始越来越流行了。&lt;/p>
&lt;p>卡内基·梅隆大学的玛丽·肖（Mary Shaw）和戴维·加兰（David Garlan）对软件架构做了很多研究，他们在 1994 年的一篇文章《软件架构介绍》（An Introduction to Software Architecture）中写到：“When systems are constructed from many components, the organization of the overall system-the software architecture-presents a new set of design problems.”&lt;/p>
&lt;p>简单翻译一下：随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题；当系统由许多部分组成时，整个系统的组织，也就是所说的“软件架构”，导致了一系列新的设计问题。&lt;/p>
&lt;p>这段话很好地解释了“软件架构”为何先在 Rational 或者 Microsoft 这样的大公司开始逐步流行起来。因为只有大公司开发的软件系统才具备较大规模，而只有规模较大的软件系统才会面临软件架构相关的问题，例如：&lt;/p>
&lt;p>1、系统规模庞大，内部耦合严重，开发效率低；&lt;/p>
&lt;p>2、系统耦合严重，牵一发动全身，后续修改和扩展困难；&lt;/p>
&lt;p>3、系统逻辑复杂，容易出问题，出问题后很难排查和修复。&lt;/p>
&lt;p>软件架构的出现有其历史必然性。20 世纪 60 年代第一次软件危机引出了“结构化编程”，创造了“模块”概念；20 世纪 80 年代第二次软件危机引出了“面向对象编程”，创造了“对象”概念；到了 20 世纪 90 年代“软件架构”开始流行，创造了“组件”概念。我们可以看到，“模块”“对象”“组件”本质上都是对达到一定规模的软件进行拆分，差别只是在于随着软件的复杂度不断增加，拆分的粒度越来越粗，拆分的层次越来越高。&lt;/p>
&lt;p>为何结构化编程、面向对象编程、软件工程、架构设计最后都没有成为软件领域的银弹？&lt;/p>
&lt;h2 id="架构设计的目的">架构设计的目的&lt;/h2>
&lt;h3 id="架构设计的误区">架构设计的误区&lt;/h3>
&lt;p>关于架构设计的目的，常见的误区有：&lt;/p>
&lt;p>1、因为架构很重要，所以要做架构设计&lt;/p>
&lt;p>2、不是每个系统都要做架构设计吗&lt;/p>
&lt;p>3、公司流程要求系统开发过程中必须有架构设计&lt;/p>
&lt;p>4、为了高性能、高可用、可扩展，所以要做架构设计&lt;/p>
&lt;p>但往往持有这类观点的架构师和设计师会给项目带来巨大的灾难，这绝不是危言耸听，而是很多实际发生的事情，为什么会这样呢？因为这类架构师或者设计师不管三七二十一，不管什么系统，也不管什么业务，上来就要求“高性能、高可用、高扩展”，结果就会出现架构设计复杂无比，项目落地遥遥无期，团队天天吵翻天……等各种让人抓狂的现象，费尽九牛二虎之力将系统整上线，却发现运行不够稳定，经常出问题，出了问题很难解决，加个功能要改 1 个月……等各种继续让人抓狂的事件。&lt;/p>
&lt;h3 id="架构设计的真正目的">架构设计的真正目的&lt;/h3>
&lt;p>&lt;strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题。&lt;/strong>&lt;/p>
&lt;p>通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。&lt;/p>
&lt;p>架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。&lt;/p>
&lt;p>理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。（有的放矢，而不是贪大求全）&lt;/p>
&lt;p>如果系统的复杂度不是在性能这部分，TPS 做到 10 万并没有什么用。&lt;/p>
&lt;p>淘宝的架构是为了解决淘宝业务的复杂度而设计的，淘宝的业务复杂度并不就是我们的业务复杂度，绝大多数业务的用户量都不可能有淘宝那么大。&lt;/p>
&lt;p>Docker 不是万能的，只是为了解决资源重用和动态分配而设计的，如果我们的系统复杂度根本不是在这方面，引入 Docker 没有什么意义。&lt;/p>
&lt;h3 id="简单的复杂度分析案例">简单的复杂度分析案例&lt;/h3>
&lt;p>分析一个简单的案例，一起来看看如何将“架构设计的真正目的是为了解决软件系统复杂度带来的问题”这个指导思想应用到实践中。&lt;/p>
&lt;p>假设需要设计一个大学的学生管理系统，其基本功能包括登录、注册、成绩管理、课程管理等。当我们对这样一个系统进行架构设计的时候，首先应识别其复杂度到底体现在哪里。&lt;/p>
&lt;p>性能：一个学校的学生大约 1 ~ 2 万人，学生管理系统的访问频率并不高，平均每天单个学生的访问次数平均不到 1 次，因此性能这部分并不复杂，存储用 MySQL 完全能够胜任，缓存都可以不用，Web 服务器用 Nginx 绰绰有余。&lt;/p>
&lt;p>可扩展性：学生管理系统的功能比较稳定，可扩展的空间并不大，因此可扩展性也不复杂。&lt;/p>
&lt;p>高可用：学生管理系统即使宕机 2 小时，对学生管理工作影响并不大，因此可以不做负载均衡，更不用考虑异地多活这类复杂的方案了。但是，如果学生的数据全部丢失，修复是非常麻烦的，只能靠人工逐条修复，这个很难接受，因此需要考虑存储高可靠，这里就有点复杂了。需要考虑多种异常情况：机器故障、机房故障，针对机器故障，需要设计 MySQL 同机房主备方案；针对机房故障，需要设计 MySQL 跨机房同步方案。&lt;/p>
&lt;p>安全性：学生管理系统存储的信息有一定的隐私性，例如学生的家庭情况，但并不是和金融相关的，也不包含强隐私（例如玉照、情感）的信息，因此安全性方面只要做 3 个事情就基本满足要求了：Nginx 提供 ACL 控制、用户账号密码管理、数据库访问权限控制。&lt;/p>
&lt;p>成本：由于系统很简单，基本上几台服务器就能够搞定，对于一所大学来说完全不是问题，可以无需太多关注。&lt;/p>
&lt;p>学生管理系统虽然简单，但麻雀虽小五脏俱全，基本上能涵盖软件系统复杂度分析的各个方面，而且绝大部分技术人员都曾经自己设计或者接触过类似的系统，如果将这个案例和自己的经验对比，相信会有更多的收获。&lt;/p>
&lt;h2 id="复杂度来源-高性能">复杂度来源：高性能&lt;/h2>
&lt;p>技术发展带来了性能上的提升，不一定带来复杂度的提升。例如，硬件存储从纸带→磁带→磁盘→SSD，并没有显著带来系统复杂度的增加。因为新技术会逐步淘汰旧技术，这种情况下我们直接用新技术即可，不用担心系统复杂度会随之提升。只有那些并不是用来取代旧技术，而是开辟了一个全新领域的技术，才会给软件系统带来复杂度，因为软件系统在设计的时候就需要在这些技术之间进行判断选择或者组合。就像汽车的发明无法取代火车，飞机的出现也并不能完全取代火车，所以我们在出行的时候，需要考虑选择汽车、火车还是飞机，这个选择的过程就比较复杂了，要考虑价格、时间、速度、舒适度等各种因素。&lt;/p>
&lt;p>软件系统中高性能带来的复杂度主要体现在两方面，一方面是&lt;strong>单台计算机内部为了高性能带来的复杂度&lt;/strong>；另一方面是&lt;strong>多台计算机集群为了高性能带来的复杂度&lt;/strong>。&lt;/p>
&lt;h3 id="单机复杂度">单机复杂度&lt;/h3>
&lt;p>计算机内部复杂度最关键的地方就是操作系统。计算机性能的发展本质上是由硬件发展驱动的，尤其是 CPU 的性能发展。著名的“摩尔定律”表明了 CPU 的处理能力每隔 18 个月就翻一番；而将硬件性能充分发挥出来的关键就是操作系统，所以操作系统本身其实也是跟随硬件的发展而发展的，操作系统是软件系统的运行环境，操作系统的复杂度直接决定了软件系统的复杂度。&lt;/p>
&lt;p>操作系统和性能最相关的就是进程和线程。&lt;/p>
&lt;p>多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能做到时间上真正的并行。解决这个问题的方式显而易见，就是让多个 CPU 能够同时执行计算任务，从而实现真正意义上的多任务并行。目前这样的解决方案有 3 种：SMP（Symmetric Multi-Processor，对称多处理器结构）、NUMA（Non-Uniform Memory Access，非一致存储访问结构）、MPP（Massive Parallel Processing，海量并行处理结构）。其中 SMP 是我们最常见的，目前流行的多核处理器就是 SMP 方案。操作系统发展到现在，如果我们要完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等技术点，而且这些技术并不是最新的就是最好的，也不是非此即彼的选择。在做架构设计的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程同样很复杂。举一个最简单的例子：Nginx 可以用多进程也可以用多线程，JBoss 采用的是多线程；Redis 采用的是单进程，Memcache 采用的是多线程，这些系统都实现了高性能，但内部实现差异却很大。&lt;/p>
&lt;h3 id="集群复杂度">集群复杂度&lt;/h3>
&lt;p>通过大量机器来提升性能，并不仅仅是增加机器这么简单，让多台机器配合起来达到高性能的目的，是一个复杂的任务，我针对常见的几种方式简单分析一下。&lt;/p>
&lt;h3 id="任务分配">任务分配&lt;/h3>
&lt;p>1 台服务器演变为 2 台服务器后，架构上明显要复杂多了，主要体现在：&lt;/p>
&lt;p>1、需要增加一个任务分配器，这个分配器可能是硬件网络设备（例如，F5、交换机等），可能是软件网络设备（例如，LVS），也可能是负载均衡软件（例如，Nginx、HAProxy），还可能是自己开发的系统。选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面的因素。&lt;/p>
&lt;p>2、任务分配器和真正的业务服务器之间有连接和交互（即图中任务分配器到业务服务器的连接线），需要选择合适的连接方式，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。&lt;/p>
&lt;p>3、任务分配器需要增加分配算法。例如，是采用轮询算法，还是按权重分配，又或者按照负载进行分配。如果按照服务器的负载进行分配，则业务服务器还要能够上报自己的状态给任务分配器。&lt;/p>
&lt;h3 id="任务分解">任务分解&lt;/h3>
&lt;p>通过这种任务分解的方式，能够把原来大一统但复杂的业务系统，拆分成小而简单但需要多个系统配合的业务系统。从业务的角度来看，任务分解既不会减少功能，也不会减少代码量（事实上代码量可能还会增加，因为从代码内部调用改为通过服务器之间的接口调用），那为何通过任务分解就能够提升性能呢？&lt;/p>
&lt;p>主要有几方面的因素：&lt;/p>
&lt;p>1、简单的系统更加容易做到高性能&lt;/p>
&lt;p>2、可以针对单个任务进行扩展&lt;/p>
&lt;h2 id="复杂度来源-高可用">复杂度来源：高可用&lt;/h2>
&lt;p>高可用的定义。系统&lt;strong>无中断&lt;/strong>地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。&lt;/p>
&lt;p>系统的高可用方案五花八门，但万变不离其宗，本质上都是通过“冗余”来实现高可用。通俗点来讲，就是一台机器不够就两台，两台不够就四台；一个机房可能断电，那就部署两个机房；一条通道可能故障，那就用两条，两条不够那就用三条（移动、电信、联通一起上）。高可用的“冗余”解决方案，单纯从形式上来看，和之前讲的高性能是一样的，都是通过增加更多机器来达到目的，但其实本质上是有根本区别的：&lt;strong>高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。&lt;/strong>&lt;/p>
&lt;h3 id="计算高可用">计算高可用&lt;/h3>
&lt;p>这里的“计算”指的是业务的逻辑处理。计算有一个特点就是无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的。&lt;/p>
&lt;h3 id="存储高可用">存储高可用&lt;/h3>
&lt;p>对于需要存储数据的系统来说，整个系统的高可用设计关键点和难点就在于“存储高可用”。存储与计算相比，有一个本质上的区别：将数据从一台机器搬到到另一台机器，需要经过线路进行传输。&lt;/p>
&lt;p>存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。&lt;/p>
&lt;p>分布式领域里面有一个著名的 CAP 定理，从理论上论证了存储高可用的复杂度。也就是说，存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。&lt;/p>
&lt;h3 id="高可用状态决策">高可用状态决策&lt;/h3>
&lt;p>无论是计算高可用还是存储高可用，其基础都是“状态决策”，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。如果状态决策本身都是有错误或者有偏差的，那么后续的任何行动和处理无论多么完美也都没有意义和价值。但在具体实践的过程中，恰好存在一个本质的矛盾：通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。下面基于几种常见的决策方式进行详细分析。&lt;/p>
&lt;h4 id="独裁式">独裁式&lt;/h4>
&lt;p>独裁式决策指的是存在一个独立的决策主体，我们姑且称它为“决策者”，负责收集信息然后进行决策；所有冗余的个体，姑且称它为“上报者”，都将状态信息发送给决策者。&lt;/p>
&lt;p>独裁式的决策方式不会出现决策混乱的问题，因为只有一个决策者，但问题也正是在于只有一个决策者。当决策者本身故障时，整个系统就无法实现准确的状态决策。如果决策者本身又做一套状态决策，那就陷入一个递归的死循环了。&lt;/p>
&lt;h4 id="协商式">协商式&lt;/h4>
&lt;p>协商式决策指的是两个独立的个体通过交流信息，然后根据规则进行决策，最常用的协商式决策就是主备决策。&lt;/p>
&lt;h4 id="民主式">民主式&lt;/h4>
&lt;p>民主式决策指的是多个独立的个体通过投票的方式来进行状态决策。例如，ZooKeeper 集群在选举 leader 时就是采用这种方式。&lt;/p>
&lt;p>民主式决策和协商式决策比较类似，其基础都是独立的个体之间交换信息，每个个体做出自己的决策，然后按照“多数取胜”的规则来确定最终的状态。不同点在于民主式决策比协商式决策要复杂得多，ZooKeeper 的选举算法 ZAB，绝大部分人都看得云里雾里，更不用说用代码来实现这套算法了。&lt;/p>
&lt;h2 id="复杂度来源-可扩展">复杂度来源：可扩展&lt;/h2>
&lt;p>设计具备良好可扩展性的系统，有两个基本条件：&lt;/p>
&lt;p>1、正确预测变化&lt;/p>
&lt;p>2、完美应对变化&lt;/p>
&lt;h3 id="预测变化">预测变化&lt;/h3>
&lt;p>软件系统与硬件或者建筑相比，有一个很大的差异：软件系统在发布后，还可以不断地修改和演进。这就意味着不断有新的需求需要实现。&lt;/p>
&lt;p>作为架构师，我们总是试图去预测所有的变化，然后设计完美的方案来应对。&lt;/p>
&lt;p>如果每个点都考虑可扩展性，架构师会不堪重负，架构设计也会异常庞大且最终无法落地。但架构师也不能完全不做预测，否则可能系统刚上线，马上来新的需求就需要重构，这同样意味着前期很多投入的工作量也白费了。&lt;/p>
&lt;p>综合分析，预测变化的复杂性在于：&lt;/p>
&lt;p>1、不能每个设计点都考虑可扩展性。&lt;/p>
&lt;p>2、不能完全不考虑可扩展性。&lt;/p>
&lt;p>3、所有的预测都存在出错的可能性。&lt;/p>
&lt;p>对于架构师来说，如何把握预测的程度和提升预测结果的准确性，是一件很复杂的事情，而且没有通用的标准可以简单套上去，更多是靠自己的经验、直觉。所以架构设计评审的时候，经常会出现两个设计师对某个判断争得面红耳赤的情况，原因就在于没有明确标准，不同的人理解和判断有偏差，而最终又只能选择其中一个判断。&lt;/p>
&lt;h3 id="2年法则">2年法则&lt;/h3>
&lt;p>根据以往的职业经历和思考，提炼出一个“2 年法则”供你参考：只预测 2 年内的可能变化，不要试图预测 5 年甚至 10 年后的变化。&lt;/p>
&lt;p>之所以说要预测 2 年，是因为变化快的行业，能够预测 2 年已经足够了；而变化慢的行业，本身就变化慢，预测本身的意义不大，预测 5 年和预测 2 年的结果是差不多的。所以“2 年法则”在大部分场景下都是适用的。&lt;/p>
&lt;h3 id="应对法则">应对法则&lt;/h3>
&lt;h4 id="方案一-提炼出-变化层-和-稳定层">方案一：提炼出“变化层”和“稳定层”&lt;/h4>
&lt;p>第一种应对变化的常见方案是：将不变的部分封装在一个独立的“稳定层”，将“变化”封装在一个“变化层”（也叫“适配层”）。这种方案的核心思想是通过变化层来隔离变化。&lt;/p>
&lt;p>1、变化层和稳定层如何拆分？&lt;/p>
&lt;p>对于哪些属于变化层，哪些属于稳定层，很多时候并不是像前面的示例（不同接口协议或者不同数据库）那样明确，不同的人有不同的理解，导致架构设计评审的时候可能吵翻天。&lt;/p>
&lt;p>2、变化层和稳定层之间的接口如何设计？&lt;/p>
&lt;p>对于稳定层来说，接口肯定是越稳定越好；但对于变化层来说，在有差异的多个实现方式中找出共同点，并且还要保证当加入新的功能时，原有的接口不需要太大修改，这是一件很复杂的事情，所以接口设计同样至关重要。例如，MySQL 的 REPLACE INTO 和 Oracle 的 MERGE INTO 语法和功能有一些差异，那么存储层如何向稳定层提供数据访问接口呢？是采取 MySQL 的方式，还是采取 Oracle 的方式，还是自适应判断？如果再考虑 DB2 的情况呢？&lt;/p>
&lt;h4 id="方案二-提炼出-抽象层-和-实现层">方案二：提炼出“抽象层”和“实现层”&lt;/h4>
&lt;p>第二种常见的应对变化的方案是：提炼出一个“抽象层”和一个“实现层”。如果说方案一的核心思想是通过变化层来隔离变化，那么方案二的核心思想就是通过实现层来封装变化。&lt;/p>
&lt;p>方案二典型的实践就是设计模式和规则引擎。&lt;/p>
&lt;h3 id="1写2抄3重构原则">1写2抄3重构原则&lt;/h3>
&lt;p>在实际工作中具体如何来应对变化呢？Martin Fowler 在他的经典书籍《重构》中给出一个“Rule of three”的原则，原文是“Three Strikes And You Refactor”，中文一般翻译为“事不过三，三则重构”。&lt;/p>
&lt;p>假设创新业务要对接第三方钱包，按照这个原则，就可以这样做：&lt;/p>
&lt;p>1 写：最开始你们选择了微信钱包对接，此时不需要考虑太多可扩展性，直接快速对照微信支付的 API 对接即可，因为业务是否能做起来还不确定。&lt;/p>
&lt;p>2 抄：后来你们发现业务发展不错，决定要接入支付宝，此时还是可以不考虑可扩展，直接把原来微信支付接入的代码拷贝过来，然后对照支付宝的 API，快速修改上线。&lt;/p>
&lt;p>3 重构：因为业务发展不错，为了方便更多用户，你们决定接入银联云闪付，此时就需要考虑重构，参考设计模式的模板方法和策略模式将支付对接的功能进行封装。&lt;/p>
&lt;h2 id="复杂度来源-低成本">复杂度来源：低成本&lt;/h2>
&lt;h3 id="底成本">底成本&lt;/h3>
&lt;p>低成本给架构设计带来的主要复杂度体现在，往往只有“创新”才能达到低成本目标。这里的“创新”既包括开创一个全新的技术领域（这个要求对绝大部分公司太高），也包括引入新技术，如果没有找到能够解决自己问题的新技术，那么就真的需要自己创造新技术了。&lt;/p>
&lt;p>类似的新技术例子很多，如：&lt;/p>
&lt;p>1、NoSQL（Memcache、Redis 等）的出现是为了解决关系型数据库无法应对高并发访问带来的访问压力。&lt;/p>
&lt;p>2、全文搜索引擎（Sphinx、Elasticsearch、Solr）的出现是为了解决关系型数据库 like 搜索的低效的问题。&lt;/p>
&lt;p>3、Hadoop 的出现是为了解决传统文件系统无法应对海量数据存储和计算的问题。&lt;/p>
&lt;p>再来举几个业界类似的例子。&lt;/p>
&lt;p>1、Facebook 为了解决 PHP 的低效问题，刚开始的解决方案是 HipHop PHP，可以将 PHP 语言翻译为 C++ 语言执行，后来改为 HHVM，将 PHP 翻译为字节码然后由虚拟机执行，和 Java 的 JVM 类似。&lt;/p>
&lt;p>2、新浪微博将传统的 Redis/MC + MySQL 方式，扩展为 Redis/MC + SSD Cache + MySQL 方式，SSD Cache 作为 L2 缓存使用，既解决了 MC/Redis 成本过高，容量小的问题，也解决了穿透 DB 带来的数据库访问压力（来源：&lt;a href="http://www.infoq.com/cn/articles/weibo-platform-archieture">http://www.infoq.com/cn/articles/weibo-platform-archieture&lt;/a> ）。&lt;/p>
&lt;p>3、Linkedin 为了处理每天 5 千亿的事件，开发了高效的 Kafka 消息系统。其他类似将 Ruby on Rails 改为 Java、Lua + redis 改为 Go 语言实现的例子还有很多。&lt;/p>
&lt;h3 id="安全">安全&lt;/h3>
&lt;p>从技术的角度来讲，安全可以分为两类：一类是功能上的安全，一类是架构上的安全。&lt;/p>
&lt;h4 id="功能安全">功能安全&lt;/h4>
&lt;p>例如，常见的 XSS 攻击、CSRF 攻击、SQL 注入、Windows 漏洞、密码破解等，本质上是因为系统实现有漏洞，黑客有了可乘之机。黑客会利用各种漏洞潜入系统，这种行为就像小偷一样，黑客和小偷的手法都是利用系统或家中不完善的地方潜入，并进行破坏或者盗取。因此形象地说，功能安全其实就是“防小偷”。&lt;/p>
&lt;h4 id="架构安全">架构安全&lt;/h4>
&lt;p>如果说功能安全是“防小偷”，那么架构安全就是“防强盗”。强盗会直接用大锤将门砸开，或者用炸药将围墙炸倒；小偷是偷东西，而强盗很多时候就是故意搞破坏，对系统的影响也大得多。因此架构设计时需要特别关注架构安全，尤其是互联网时代，理论上来说系统部署在互联网上时，全球任何地方都可以发起攻击。&lt;/p>
&lt;p>传统的架构安全主要依靠防火墙，防火墙最基本的功能就是隔离网络，通过将网络划分成不同的区域，制定出不同区域之间的访问控制策略来控制不同信任程度区域间传送的数据流。&lt;/p>
&lt;p>防火墙的功能虽然强大，但性能一般，所以在传统的银行和企业应用领域应用较多。但在互联网领域，防火墙的应用场景并不多。因为互联网的业务具有海量用户访问和高并发的特点，防火墙的性能不足以支撑；尤其是互联网领域的 DDoS 攻击，轻则几 GB，重则几十 GB。2016 年知名安全研究人员布莱恩·克莱布斯（Brian Krebs）的安全博客网站遭遇 DDoS 攻击，攻击带宽达 665Gbps，是目前在网络犯罪领域已知的最大的拒绝服务攻击。这种规模的攻击，如果用防火墙来防，则需要部署大量的防火墙，成本会很高。例如，中高端一些的防火墙价格 10 万元，每秒能抗住大约 25GB 流量，那么应对这种攻击就需要将近 30 台防火墙，成本将近 300 万元，这还不包括维护成本，而这些防火墙设备在没有发生攻击的时候又没有什么作用。也就是说，如果花费几百万元来买这么一套设备，有可能几年都发挥不了任何作用。&lt;/p>
&lt;p>就算是公司对钱不在乎，一般也不会堆防火墙来防 DDoS 攻击，因为 DDoS 攻击最大的影响是大量消耗机房的出口总带宽。不管防火墙处理能力有多强，当出口带宽被耗尽时，整个业务在用户看来就是不可用的，因为用户的正常请求已经无法到达系统了。防火墙能够保证内部系统不受冲击，但用户也是进不来的。对于用户来说，业务都已经受到影响了，至于是因为用户自己进不去，还是因为系统出故障，用户其实根本不会关心。&lt;/p>
&lt;p>基于上述原因，互联网系统的架构安全目前并没有太好的设计手段来实现，更多地是依靠运营商或者云服务商强大的带宽和流量清洗的能力，较少自己来设计和实现。&lt;/p>
&lt;h3 id="规模">规模&lt;/h3>
&lt;p>很多企业级的系统，既没有高性能要求，也没有双中心高可用要求，也不需要什么扩展性，但往往我们一说到这样的系统，很多人都会脱口而出：这个系统好复杂！为什么这样说呢？关键就在于这样的系统往往功能特别多，逻辑分支特别多。特别是有的系统，发展时间比较长，不断地往上面叠加功能，后来的人由于不熟悉整个发展历史，可能连很多功能的应用场景都不清楚，或者细节根本无法掌握，面对的就是一个黑盒系统，看不懂、改不动、不敢改、修不了，复杂度自然就感觉很高了。&lt;/p>
&lt;p>&lt;strong>规模带来复杂度的主要原因就是“量变引起质变”&lt;/strong>，当数量超过一定的阈值后，复杂度会发生质的变化。常见的规模带来的复杂度有：&lt;/p>
&lt;p>1、功能越来越多，导致系统复杂度指数级上升&lt;/p>
&lt;p>2、数据越来越多，系统复杂度发生质变&lt;/p>
&lt;p>与功能类似，系统数据越来越多时，也会由量变带来质变，最近几年火热的“大数据”就是在这种背景下诞生的。大数据单独成为了一个热门的技术领域，主要原因就是数据太多以后，传统的数据收集、加工、存储、分析的手段和工具已经无法适应，必须应用新的技术才能解决。目前的大数据理论基础是 Google 发表的三篇大数据相关论文，其中 Google File System 是大数据文件存储的技术理论，Google Bigtable 是列式数据存储的技术理论，Google MapReduce 是大数据运算的技术理论，这三篇技术论文各自开创了一个新的技术领域。&lt;/p>
&lt;p>即使数据没有达到大数据规模，数据的增长也可能给系统带来复杂性。最典型的例子莫过于使用关系数据库存储数据，以 MySQL 为例，MySQL 单表的数据因不同的业务和应用场景会有不同的最优值，但不管怎样都肯定是有一定的限度的，一般推荐在 5000 万行左右。如果因为业务的发展，单表数据达到了 10 亿行，就会产生很多问题。（分库分表）&lt;/p>
&lt;h2 id="架构设计三原则">架构设计三原则&lt;/h2>
&lt;p>业务千变万化，技术层出不穷，设计理念也是百花齐放，看起来似乎很难有一套通用的规范来适用所有的架构设计场景。但是在研究了架构设计的发展历史、多个公司的架构发展过程（QQ、淘宝、Facebook 等）、众多的互联网公司架构设计后，发现有几个共性的原则隐含其中，这就是：合适原则、简单原则、演化原则，架构设计时遵循这几个原则，有助于你做出最好的选择。&lt;/p>
&lt;h3 id="合适原则">合适原则&lt;/h3>
&lt;p>&lt;strong>合适原则宣言：“合适优于业界领先”。&lt;/strong>&lt;/p>
&lt;p>再好的梦想，也需要脚踏实地实现！这里的“脚踏实地”主要体现在下面几个方面。&lt;/p>
&lt;p>1、将军难打无兵之仗&lt;/p>
&lt;p>没那么多人，却想干那么多活，是失败的第一个主要原因。&lt;/p>
&lt;p>2、罗马不是一天建成的&lt;/p>
&lt;p>双 11 做了多少优秀的系统，但经历了什么样的挑战、踩了什么样的坑，只有他们自己知道！这些挑战和踩坑，都是架构设计非常关键的促进因素，单纯靠拍脑袋或者头脑风暴，是不可能和真正实战相比的。&lt;/p>
&lt;p>没有那么多积累，却想一步登天，是失败的第二个主要原因。&lt;/p>
&lt;p>3、冰山下面才是关键&lt;/p>
&lt;p>业界领先的方案其实都是“逼”出来的！简单来说，“业务”发展到一定阶段，量变导致了质变，出现了新的问题，已有的方式已经不能应对这些问题，需要用一种新的方案来解决，通过创新和尝试，才有了业界领先的方案。&lt;/p>
&lt;p>没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。&lt;/p>
&lt;h3 id="简单原则">简单原则&lt;/h3>
&lt;p>&lt;strong>简单原则宣言：“简单优于复杂”。&lt;/strong>&lt;/p>
&lt;p>“复杂”在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。&lt;/p>
&lt;p>软件领域的复杂性体现在两个方面：&lt;/p>
&lt;p>1、结构的复杂性&lt;/p>
&lt;p>2、逻辑的复杂性&lt;/p>
&lt;p>为什么复杂的电路就意味更强大的功能，而复杂的架构却有很多问题呢？根本原因在于电路一旦设计好后进入生产，就不会再变，复杂性只是在设计时带来影响；而一个软件系统在投入使用后，后续还有源源不断的需求要实现，因此要不断地修改系统，复杂性在整个系统生命周期中都有很大影响。&lt;/p>
&lt;h3 id="演化原则">演化原则&lt;/h3>
&lt;p>&lt;strong>演化原则宣言：“演化优于一步到位”。&lt;/strong>&lt;/p>
&lt;p>软件架构从字面意思理解和建筑结构非常类似，事实上“架构”这个词就是建筑领域的专业名词，维基百科对“软件架构”的定义中有一段话描述了这种相似性：从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。&lt;/p>
&lt;p>&lt;strong>对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。&lt;/strong>&lt;/p>
&lt;p>如果没有把握“软件架构需要根据业务发展不断变化”这个本质，在做架构设计的时候就很容易陷入一个误区：试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石。&lt;/p>
&lt;p>考虑到软件架构需要根据业务发展不断变化这个本质特点，软件架构设计其实更加类似于大自然“设计”一个生物，通过演化让生物适应环境，逐步变得更加强大：&lt;/p>
&lt;p>首先，生物要适应当时的环境。&lt;/p>
&lt;p>其次，生物需要不断地繁殖，将有利的基因传递下去，将不利的基因剔除或者修复。&lt;/p>
&lt;p>第三，当环境变化时，生物要能够快速改变以适应环境变化；如果生物无法调整就被自然淘汰；新的生物会保留一部分原来被淘汰生物的基因。&lt;/p>
&lt;p>软件架构设计同样是类似的过程：&lt;/p>
&lt;p>首先，设计出来的架构要满足当时的业务需要。&lt;/p>
&lt;p>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。&lt;/p>
&lt;p>第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。&lt;/p>
&lt;h2 id="架构设计原则案例">架构设计原则案例&lt;/h2>
&lt;h3 id="淘宝">淘宝&lt;/h3>
&lt;p>淘宝技术发展主要经历了“个人网站”→“Oracle/ 支付宝 / 旺旺”→“Java 时代 1.0”→“Java 时代 2.0”→“Java 时代 3.0”→“分布式时代”。&lt;/p>
&lt;h4 id="个人网站">个人网站&lt;/h4>
&lt;p>淘宝当时在初创时，没有过多考虑技术是否优越、性能是否海量以及稳定性如何，主要的考虑因素就是：快！&lt;/p>
&lt;p>因为此时业务要求快速上线，时间不等人，等你花几个月甚至十几个月搞出一个强大的系统出来，可能市场机会就没有了，黄花菜都凉了。同样，在考虑如何买的时候，淘宝的决策依据主要也是“快”。&lt;/p>
&lt;p>买一个网站显然比做一个网站要省事一些，但是他们的梦想可不是做一个小网站而已，要做大，就不是随便买个就行的，要有比较低的维护成本，要能够方便地扩展和二次开发。&lt;/p>
&lt;p>那接下来就是第二个问题：买一个什么样的网站？答案是：轻量一点的，简单一点的。&lt;/p>
&lt;p>&lt;strong>买一个系统是为了“快速可用”，而买一个轻量级的系统是为了“快速开发”。&lt;/strong>&lt;/p>
&lt;p>淘宝最开始的时候业务要求就是“快”，因此反过来要求技术同样要“快”，业务决定技术，这里架构设计和选择主要遵循的是“合适原则”和“简单原则”。&lt;/p>
&lt;p>第一代技术架构&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_5.png" alt="architecture-base_5.png">&lt;/p>
&lt;h4 id="oracle-支付宝-旺旺">Oracle/支付宝/旺旺&lt;/h4>
&lt;p>淘宝网推出后，由于正好碰到“非典”，网购很火爆，加上采取了成功的市场运作，流量和交易量迅速上涨，业务发展很快，在 2003 年底，MySQL 已经撑不住了。&lt;/p>
&lt;p>一般人或者团队在这个时候，可能就开始优化系统、优化架构、分拆业务了，因为这些是大家耳熟能详也很拿手的动作。那我们来看看淘宝这个时候怎么采取的措施：技术的替代方案非常简单，就是换成 Oracle。换 Oracle 的原因除了它容量大、稳定、安全、性能高，还有人才方面的原因。&lt;/p>
&lt;p>除了购买 Oracle，后来为了优化，又买了更强大的存储：后来数据量变大了，本地存储不行了。买了 NAS（Network Attached Storage，网络附属存储），NetApp 的 NAS 存储作为了数据库的存储设备，加上 Oracle RAC（Real Application Clusters，实时应用集群）来实现负载均衡。&lt;/p>
&lt;p>为什么淘宝在这个时候继续采取“买”的方式来快速解决问题呢？我们可以从时间上看出端倪：此时离刚上线才半年不到，业务飞速发展，最快的方式支撑业务的发展还是去买。如果说第一阶段买的是“方案”，这个阶段买的就是“性能”，这里架构设计和选择主要遵循的还是“合适原则”和“简单原则”。&lt;/p>
&lt;p>第二代技术架构：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_6.png" alt="architecture-base_6.png">&lt;/p>
&lt;h4 id="脱胎换骨的-java-时代-1-0">脱胎换骨的 Java 时代 1.0&lt;/h4>
&lt;p>淘宝切换到 Java 的原因很有趣，主要因为找了一个 PHP 的开源连接池 SQL Relay 连接到 Oracle，而这个代理经常死锁，死锁了就必须重启，而数据库又必须用 Oracle，于是决定换个开发语言。最后淘宝挑选了 Java，而且当时挑选 Java，也是请 Sun 公司的人，这帮人很厉害，先是将淘宝网站从 PHP 热切换到了 Java，后来又做了支付宝。&lt;/p>
&lt;p>这次切换的最主要原因是因为技术影响了业务的发展，频繁的死锁和重启对用户业务产生了严重的影响，从业务的角度来看这是不得不解决的技术问题。&lt;/p>
&lt;p>最初选择 SQL Relay 的原因：但对于 PHP 语言来说，它是放在 Apache 上的，每一个请求都会对数据库产生一个连接，它没有连接池这种功能（Java 语言有 Servlet 容器，可以存放连接池）。那如何是好呢？这帮人打探到 eBay 在 PHP 下面用了一个连接池的工具，是 BEA 卖给他们的。我们知道 BEA 的东西都很贵，我们买不起，于是多隆在网上寻寻觅觅，找到一个开源的连接池代理服务 SQL Relay。&lt;/p>
&lt;p>不清楚当时到底有多贵，Oracle 都可以买，连接池买不起 ？所以个人感觉这次切换语言，更多是为以后业务发展做铺垫，毕竟当时 PHP 语言远远没有 Java 那么火、那么好招人。淘宝选择 Java 语言的理由可以从侧面验证这点：Java 是当时最成熟的网站开发语言，它有比较良好的企业开发框架，被世界上主流的大规模网站普遍采用，另外有 Java 开发经验的人才也比较多，后续维护成本会比较低。&lt;/p>
&lt;p>综合来看，这次架构的变化没有再简单通过“买”来解决，而是通过重构来解决，架构设计和选择遵循了“演化原则”。&lt;/p>
&lt;p>第三代技术架构：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_7.png" alt="architecture-base_7.png">&lt;/p>
&lt;h4 id="坚若磐石的-java-时代-2-0">坚若磐石的 Java 时代 2.0&lt;/h4>
&lt;p>Java 时代 2.0，淘宝做了很多优化工作：数据分库、放弃 EJB、引入 Spring、加入缓存、加入 CDN、采用开源的 JBoss。&lt;/p>
&lt;p>为什么在这个时候要做这些动作？原文作者很好地概括了做这些动作的原因：这些杂七杂八的修改，对数据分库、放弃 EJB、引入 Spring、加入缓存、加入 CDN、采用开源的 JBoss，看起来没有章法可循，其实都是围绕着提高容量、提高性能、节约成本来做的。&lt;/p>
&lt;p>此时的业务发展情况是这样的：随着数据量的继续增长，到了 2005 年，商品数有 1663 万，PV 有 8931 万，注册会员有 1390 万，这给数据和存储带来的压力依然很大，数据量大，性能就慢。所以“买”也搞不定了。&lt;/p>
&lt;p>原有的方案存在固有缺陷，随着业务的发展，已经不是靠“买”就能够解决问题了，此时必须从整个架构上去进行调整和优化。比如说 Oracle 再强大，在做 like 类搜索的时候，也不可能做到纯粹的搜索系统如 Solr、Sphinx 等的性能，因为这是机制决定的。&lt;/p>
&lt;p>另外，随着规模的增大，纯粹靠买的一个典型问题开始成为重要的考虑因素，那就是成本。当买一台两台 Oracle 的时候，可能对成本并不怎么关心，但如果要买 100 台 Oracle，成本就是一个关键因素了。这就是“量变带来质变”的一个典型案例，业务和系统发生质变后，架构设计遵循“演化原则”的思想，需要再一次重构甚至重写。&lt;/p>
&lt;p>第四代技术架构：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_8.png" alt="architecture-base_8.png">&lt;/p>
&lt;h4 id="java-时代-3-0-和分布式时代">Java 时代 3.0 和分布式时代&lt;/h4>
&lt;p>Java 时代 3.0 个人认为是淘宝技术飞跃的开始，简单来说就是淘宝技术从商用转为“自研”，典型的就是去 IOE 化。分布式时代个人认为是淘宝技术的修炼成功，到了这个阶段，自研技术已经自成一派，除了支撑本身的海量业务，也开始影响整个互联网的技术发展。&lt;/p>
&lt;p>到了这个阶段，业务规模急剧上升后，原来并不是主要复杂度的 IOE 成本开始成为了主要的问题，因此通过自研系统来降低 IOE 的成本，去 IOE 也是系统架构的再一次演化。&lt;/p>
&lt;h3 id="手机qq">手机QQ&lt;/h3>
&lt;p>注：以下部分内容摘自《QQ 1.4 亿在线背后的故事》。&lt;/p>
&lt;p>手机 QQ 的发展历程按照用户规模可以粗略划分为 4 个阶段：十万级、百万级、千万级、亿级，不同的用户规模，IM 后台的架构也不同，而且基本上都是用户规模先上去，然后产生各种问题，倒逼技术架构升级。&lt;/p>
&lt;h4 id="十万级-im-1-x">十万级 IM 1.X&lt;/h4>
&lt;p>最开始的手机 QQ 后台只有接入服务器和存储服务器，可以说是简单得不能再简单、普通得不能再普通的一个架构了，因为当时业务刚开始，架构设计遵循的是“合适原则”和“简单原则”。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_9.png" alt="architecture-base_9.png">&lt;/p>
&lt;h4 id="百万级-im-2-x">百万级 IM 2.X&lt;/h4>
&lt;p>随着业务发展到 2001 年，QQ 同时在线人数也突破了一百万。第一代架构很简单，明显不可能支撑百万级的用户规模，主要的问题有：&lt;/p>
&lt;p>1、以接入服务器的内存为例，单个在线用户的存储量约为 2KB，索引和在线状态为 50 字节，好友表 400 个好友 × 5 字节 / 好友 = 2000 字节，大致来说，2GB 内存只能支持一百万在线用户。&lt;/p>
&lt;p>2、CPU/ 网卡包量和流量 / 交换机流量等瓶颈。&lt;/p>
&lt;p>3、单台服务器支撑不下所有在线用户 / 注册用户。&lt;/p>
&lt;p>于是针对这些问题做架构改造，按照“演化原则”的指导进行了重构，重构的方案相比现在来说也还是简单得多，因此当时做架构设计时也遵循了“合适原则”和“简单原则”。IM 2.X 的最终架构如图所示。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_10.png" alt="architecture-base_10.png">&lt;/p>
&lt;h4 id="千万级-im-3-x">千万级 IM 3.X&lt;/h4>
&lt;p>业务发展到 2005 年，QQ 同时在线人数突破了一千万。第二代架构支撑百万级用户是没问题的，但支撑千万级用户又会产生新问题，表现有：&lt;/p>
&lt;p>1、同步流量太大，状态同步服务器遇到单机瓶颈。&lt;/p>
&lt;p>2、所有在线用户的在线状态信息量太大，单台接入服务器存不下，如果在线数进一步增加，甚至单台状态同步服务器也存不下。&lt;/p>
&lt;p>3、单台状态同步服务器支撑不下所有在线用户。&lt;/p>
&lt;p>4、单台接入服务器支撑不下所有在线用户的在线状态信息。&lt;/p>
&lt;p>针对这些问题，架构需要继续改造升级，再一次“演化”。IM 3.X 的最终架构如下图，可以看到这次的方案相比之前的方案来说并不简单了，这是业务特性决定的。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_11.png" alt="architecture-base_11.png">&lt;/p>
&lt;h4 id="亿级-im-4-x">亿级 IM 4.X&lt;/h4>
&lt;p>业务发展到 2010 年 3 月，QQ 同时在线人数过亿。第三代架构此时也不适应了，主要问题有：&lt;/p>
&lt;p>1、灵活性很差，比如“昵称”长度增加一半，需要两个月；增加“故乡”字段，需要两个月；最大好友数从 500 变成 1000，需要三个月。&lt;/p>
&lt;p>4、无法支撑某些关键功能，比如好友数上万、隐私权限控制、PC QQ 与手机 QQ 不可互踢、微信与 QQ 互通、异地容灾。&lt;/p>
&lt;p>除了不适应，还有一个更严重的问题：&lt;/p>
&lt;p>IM 后台从 1.0 到 3.5 都是在原来基础上做改造升级的，但是持续打补丁已经难以支撑亿级在线，IM 后台 4.0 必须从头开始，重新设计实现！&lt;/p>
&lt;p>这里再次遵循了“演化原则”，决定重新打造一个这么复杂的系统。&lt;/p>
&lt;p>重新设计的 IM 4.0 架构如图所示，和之前的架构相比，架构本身都拆分为两个主要的架构：存储架构和通信架构。&lt;/p>
&lt;p>存储架构&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_12.png" alt="architecture-base_12.png">&lt;/p>
&lt;p>通讯架构&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_13.png" alt="architecture-base_13.png">&lt;/p>
&lt;h2 id="架构设计流程-识别复杂度">架构设计流程：识别复杂度&lt;/h2>
&lt;p>架构设计的本质目的是为了解决软件系统的复杂性，所以在我们设计架构时，首先就要分析系统的复杂性。只有正确分析出了系统的复杂性，后续的架构设计方案才不会偏离方向；否则，如果对系统的复杂性判断错误，即使后续的架构设计方案再完美再先进，都是南辕北辙，做的越好，错的越多、越离谱。&lt;/p>
&lt;p>正确的做法是将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题。&lt;/p>
&lt;h3 id="识别复杂度实战">识别复杂度实战&lt;/h3>
&lt;p>假想一个创业公司，名称叫作“前浪微博”。前浪微博的业务发展很快，系统也越来越多，系统间协作的效率很低，例如：&lt;/p>
&lt;p>1、用户发一条微博后，微博子系统需要通知审核子系统进行审核，然后通知统计子系统进行统计，再通知广告子系统进行广告预测，接着通知消息子系统进行消息推送……一条微博有十几个通知，目前都是系统间通过接口调用的。每通知一个新系统，微博子系统就要设计接口、进行测试，效率很低，问题定位很麻烦，经常和其他子系统的技术人员产生分岐，微博子系统的开发人员不胜其烦。&lt;/p>
&lt;p>2、用户等级达到 VIP 后，等级子系统要通知福利子系统进行奖品发放，要通知客服子系统安排专属服务人员，要通知商品子系统进行商品打折处理……等级子系统的开发人员也是不胜其烦。&lt;/p>
&lt;p>新来的架构师在梳理这些问题时，结合自己的经验，敏锐地发现了这些问题背后的根源在于架构上各业务子系统强耦合，而消息队列系统正好可以完成子系统的解耦，于是提议要引入消息队列系统。经过一分析二讨论三开会四汇报五审批等一系列操作后，消息队列系统终于立项了。其他背景信息还有：&lt;/p>
&lt;p>1、中间件团队规模不大，大约 6 人左右。&lt;/p>
&lt;p>2、中间件团队熟悉 Java 语言，但有一个新同事 C/C++ 很牛。&lt;/p>
&lt;p>3、开发平台是 Linux，数据库是 MySQL。&lt;/p>
&lt;p>4、目前整个业务系统是单机房部署，没有双机房。&lt;/p>
&lt;p>针对前浪微博的消息队列系统，采用“排查法”来分析复杂度，具体分析过程是：&lt;/p>
&lt;h4 id="是否需要高性能">是否需要高性能&lt;/h4>
&lt;p>假设前浪微博系统用户每天发送 1000 万条微博，那么微博子系统一天会产生 1000 万条消息，我们再假设平均一条消息有 10 个子系统读取，那么其他子系统读取的消息大约是 1 亿次。&lt;/p>
&lt;p>1000 万和 1 亿看起来很吓人，但对于架构师来说，关注的不是一天的数据，而是 1 秒的数据，即 TPS 和 QPS。我们将数据按照秒来计算，一天内平均每秒写入消息数为 115 条，每秒读取的消息数是 1150 条；再考虑系统的读写并不是完全平均的，设计的目标应该以峰值来计算。峰值一般取平均值的 3 倍，那么消息队列系统的 TPS 是 345，QPS 是 3450，这个量级的数据意味着并不要求高性能。&lt;/p>
&lt;p>虽然根据当前业务规模计算的性能要求并不高，但业务会增长，因此系统设计需要考虑一定的性能余量。由于现在的基数较低，为了预留一定的系统容量应对后续业务的发展，我们将设计目标设定为峰值的 4 倍，因此最终的性能要求是：TPS 为 1380，QPS 为 13800。TPS 为 1380 并不高，但 QPS 为 13800 已经比较高了，因此高性能读取是复杂度之一。注意，这里的设计目标设定为峰值的 4 倍是根据业务发展速度来预估的，不是固定为 4 倍，不同的业务可以是 2 倍，也可以是 8 倍，但一般不要设定在 10 倍以上，更不要一上来就按照 100 倍预估。&lt;/p>
&lt;h4 id="是否需要高可用性">是否需要高可用性&lt;/h4>
&lt;p>对于微博子系统来说，如果消息丢了，导致没有审核，然后触犯了国家法律法规，则是非常严重的事情；对于等级子系统来说，如果用户达到相应等级后，系统没有给他奖品和专属服务，则 VIP 用户会很不满意，导致用户流失从而损失收入，虽然也比较关键，但没有审核子系统丢消息那么严重。&lt;/p>
&lt;p>综合来看，消息队列需要高可用性，包括消息写入、消息存储、消息读取都需要保证高可用性。&lt;/p>
&lt;h4 id="是否需要高可扩展性">是否需要高可扩展性&lt;/h4>
&lt;p>消息队列的功能很明确，基本无须扩展，因此可扩展性不是这个消息队列的复杂度关键。&lt;/p>
&lt;p>为了方便理解，这里只排查“高性能”“高可用”“扩展性”这 3 个复杂度，在实际应用中，不同的公司或者团队，可能还有一些其他方面的复杂度分析。例如，金融系统可能需要考虑安全性，有的公司会考虑成本等。&lt;/p>
&lt;h2 id="架构设计流程-设计备选方案">架构设计流程：设计备选方案&lt;/h2>
&lt;p>虽然软件技术经过几十年的发展，新技术层出不穷，但是经过时间考验，已经被各种场景验证过的成熟技术其实更多。例如，高可用的主备方案、集群方案，高性能的负载均衡、多路复用，可扩展的分层、插件化等技术，绝大部分时候我们有了明确的目标后，按图索骥就能够找到可选的解决方案。&lt;/p>
&lt;p>只有当这种方式完全无法满足需求的时候，才会考虑进行方案的创新，而事实上方案的创新绝大部分情况下也都是基于已有的成熟技术。&lt;/p>
&lt;p>NoSQL：Key-Value 的存储和数据库的索引其实是类似的，Memcache 只是把数据库的索引独立出来做成了一个缓存系统。&lt;/p>
&lt;p>Hadoop 大文件存储方案，基础其实是集群方案 + 数据复制方案。&lt;/p>
&lt;p>Docker 虚拟化，基础是 LXC（Linux Containers）。&lt;/p>
&lt;p>LevelDB 的文件存储结构是 Skip List。&lt;/p>
&lt;p>第一种常见的错误：设计最优秀的方案。&lt;/p>
&lt;p>第二种常见的错误：只做一个方案。&lt;/p>
&lt;p>合理的做法：&lt;/p>
&lt;p>1、备选方案的数量以 3 ~ 5 个为最佳。&lt;/p>
&lt;p>2、备选方案的差异要比较明显。&lt;/p>
&lt;p>3、备选方案的技术不要只局限于已经熟悉的技术。&lt;/p>
&lt;p>第三种常见的错误：备选方案过于详细。&lt;/p>
&lt;p>弊端显而易见：&lt;/p>
&lt;p>1、耗费了大量的时间和精力。&lt;/p>
&lt;p>2、将注意力集中到细节中，忽略了整体的技术设计，导致备选方案数量不够或者差异不大。&lt;/p>
&lt;p>3、评审的时候其他人会被很多细节给绕进去，评审效果很差。例如针对某个定时器应该是 1 分钟还是 30 秒，争论得不可开交。&lt;/p>
&lt;p>正确的做法是备选阶段关注的是技术选型，而不是技术细节，技术选型的差异要比较明显。例如，采用 ZooKeeper 和 Keepalived 两种不同的技术来实现主备，差异就很大；而同样都采用 ZooKeeper，一个方案的节点设计是 /service/node/master，另一个方案的节点设计是 /company/service/master，这两个方案并无明显差异，无须在备选方案设计阶段作为两个不同的备选方案，至于节点路径究竟如何设计，只要在最终的方案中挑选一个进行细化即可。&lt;/p>
&lt;h3 id="设计备选方案实战">设计备选方案实战&lt;/h3>
&lt;p>回到“前浪微博”的场景，之前通过“排查法”识别了消息队列的复杂性主要体现在：高性能消息读取、高可用消息写入、高可用消息存储、高可用消息读取。接下来进行第 2 步，设计备选方案。&lt;/p>
&lt;p>1、备选方案 1：采用开源的 Kafka&lt;/p>
&lt;p>Kafka 是成熟的开源消息队列方案，功能强大，性能非常高，而且已经比较成熟，很多大公司都在使用。&lt;/p>
&lt;p>2、备选方案 2：集群 + MySQL 存储&lt;/p>
&lt;p>简单描述一下方案：&lt;/p>
&lt;p>1、采用数据分散集群的架构，集群中的服务器进行分组，每个分组存储一部分消息数据。&lt;/p>
&lt;p>2、每个分组包含一台主 MySQL 和一台备 MySQL，分组内主备数据复制，分组间数据不同步。&lt;/p>
&lt;p>3、正常情况下，分组内的主服务器对外提供消息写入和消息读取服务，备服务器不对外提供服务；主服务器宕机的情况下，备服务器对外提供消息读取的服务。&lt;/p>
&lt;p>4、客户端采取轮询的策略写入和读取消息。&lt;/p>
&lt;p>3、备选方案 3：集群 + 自研存储方案&lt;/p>
&lt;p>在备选方案 2 的基础上，将 MySQL 存储替换为自研实现存储方案，因为 MySQL 的关系型数据库的特点并不是很契合消息队列的数据特点，参考 Kafka 的做法，可以自己实现一套文件存储和复制方案（此处省略具体的方案描述，实际设计时需要给出方案）&lt;/p>
&lt;h2 id="架构设计流程-评估和选择备选方案">架构设计流程：评估和选择备选方案&lt;/h2>
&lt;p>在完成备选方案设计后，如何挑选出最终的方案也是一个很大的挑战，主要原因有：&lt;/p>
&lt;p>1、每个方案都是可行的，如果方案不可行就根本不应该作为备选方案。&lt;/p>
&lt;p>2、没有哪个方案是完美的。例如，A 方案有性能的缺点，B 方案有成本的缺点，C 方案有新技术不成熟的风险。&lt;/p>
&lt;p>3、评价标准主观性比较强，比如设计师说 A 方案比 B 方案复杂，但另外一个设计师可能会认为差不多，因为比较难将“复杂”一词进行量化。因此，方案评审的时候经常会遇到几个设计师针对某个方案或者某个技术点争论得面红耳赤。&lt;/p>
&lt;p>正因为选择备选方案存在这些困难，所以实践中很多设计师或者架构师就采取了下面几种指导思想：&lt;/p>
&lt;p>1、最简派&lt;/p>
&lt;p>2、最牛派&lt;/p>
&lt;p>3、最熟派&lt;/p>
&lt;p>4、领导派&lt;/p>
&lt;p>前面提到了那么多指导思想，真正应该选择是“360 度环评”！具体的操作方式为：&lt;strong>列出需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。&lt;/strong>&lt;/p>
&lt;p>常见的方案质量属性点有：&lt;strong>性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性&lt;/strong>等。在评估这些质量属性时，需要遵循架构设计原则 1“合适原则”和原则 2“简单原则”，避免贪大求全，基本上某个质量属性能够满足一定时期内业务发展就可以了。&lt;/p>
&lt;p>有时候量变会引起质变，如团队人员增多，在同一个系统上开发效率会变低。单集群机房设计不满足业务需求了，需要升级为异地多活的架构。引入开源方案工作量小，但是可运维性和可扩展性差；自研工作量大，但是可运维和可维护性好；使用 C 语言开发性能高，但是目前团队 C 语言技术积累少；使用 Java 技术积累多，但是性能没有 C 语言开发高，成本会高一些……诸如此类。&lt;/p>
&lt;p>面临这种选择上的困难，有几种看似正确但实际错误的做法。&lt;/p>
&lt;p>1、数量对比法：简单地看哪个方案的优点多就选哪个。&lt;/p>
&lt;p>这种方案主要的问题在于把所有质量属性的重要性等同，而没有考虑质量属性的优先级。例如，对于 BAT 这类公司来说，方案的成本都不是问题，可用性和可扩展性比成本要更重要得多；但对于创业公司来说，成本可能就会变得很重要。&lt;/p>
&lt;p>2、加权法&lt;/p>
&lt;p>这种方案主要的问题是无法客观地给出每个质量属性的权重得分。&lt;/p>
&lt;p>正确的做法是按优先级选择，即架构师综合当前的业务发展情况、团队人员规模和技能、业务发展预测等因素，将质量属性按照优先级排序，首先挑选满足第一优先级的，如果方案都满足，那就再看第二优先级……以此类推。&lt;/p>
&lt;h3 id="评估和选择备选方案实战">评估和选择备选方案实战&lt;/h3>
&lt;p>再回到之前设计的场景“前浪微博”。针对上期提出的 3 个备选方案，架构师组织了备选方案评审会议，参加的人有研发、测试、运维、还有几个核心业务的主管。&lt;/p>
&lt;p>1、备选方案 1：采用开源 Kafka 方案&lt;/p>
&lt;p>2、备选方案 2：集群 + MySQL 存储&lt;/p>
&lt;p>3、备选方案 3：集群 + 自研存储系统&lt;/p>
&lt;p>针对 3 个备选方案的讨论初步完成后，架构师列出了 3 个方案的 360 度环评表：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-base_14.png" alt="architecture-base_14.png">&lt;/p>
&lt;p>列出这个表格后，无法一眼看出具体哪个方案更合适，于是大家都把目光投向架构师，决策的压力现在集中在架构师身上了。&lt;/p>
&lt;p>架构师经过思考后，给出了最终选择备选方案 2，原因有：&lt;/p>
&lt;p>1、排除备选方案 1 的主要原因是可运维性，因为再成熟的系统，上线后都可能出问题，如果出问题无法快速解决，则无法满足业务的需求；并且 Kafka 的主要设计目标是高性能日志传输，而我们的消息队列设计的主要目标是业务消息的可靠传输。&lt;/p>
&lt;p>2、排除备选方案 3 的主要原因是复杂度，目前团队技术实力和人员规模（总共 6 人，还有其他中间件系统需要开发和维护）无法支撑自研存储系统（参考架构设计原则 2：简单原则）。&lt;/p>
&lt;p>3、备选方案 2 的优点就是复杂度不高，也可以很好地融入现有运维体系，可靠性也有保障。&lt;/p>
&lt;p>针对备选方案 2 的缺点，架构师解释是：&lt;/p>
&lt;p>1、备选方案 2 的第一个缺点是性能，业务目前需要的性能并不是非常高，方案 2 能够满足，即使后面性能需求增加，方案 2 的数据分组方案也能够平行扩展进行支撑（参考架构设计原则 3：演化原则）。&lt;/p>
&lt;p>2、备选方案 2 的第二个缺点是成本，一个分组就需要 4 台机器，支撑目前的业务需求可能需要 12 台服务器，但实际上备机（包括服务器和数据库）主要用作备份，可以和其他系统并行部署在同一台机器上。&lt;/p>
&lt;p>3、备选方案 2 的第三个缺点是技术上看起来并不很优越，但我们的设计目的不是为了证明自己（参考架构设计原则 1：合适原则），而是更快更好地满足业务需求。&lt;/p>
&lt;p>通过这个案例可以看出，备选方案的选择和很多因素相关，并不单单考虑性能高低、技术是否优越这些纯技术因素。业务的需求特点、运维团队的经验、已有的技术体系、团队人员的技术水平都会影响备选方案的选择。因此，同样是上述 3 个备选方案，有的团队会选择引入 Kafka（例如，很多创业公司的初创团队，人手不够，需要快速上线支撑业务），有的会选择自研存储系统（例如，阿里开发了 RocketMQ，人多力量大，业务复杂是主要原因）。&lt;/p>
&lt;h2 id="架构设计流程-详细方案设计">架构设计流程：详细方案设计&lt;/h2>
&lt;p>简单来说，详细方案设计就是将方案涉及的关键技术细节给确定下来。&lt;/p>
&lt;p>1、假如我们确定使用 Elasticsearch 来做全文搜索，那么就需要确定 Elasticsearch 的索引是按照业务划分，还是一个大索引就可以了；副本数量是 2 个、3 个还是 4 个，集群节点数量是 3 个还是 6 个等。&lt;/p>
&lt;p>2、假如我们确定使用 MySQL 分库分表，那么就需要确定哪些表要分库分表，按照什么维度来分库分表，分库分表后联合查询怎么处理等。&lt;/p>
&lt;p>3、假如我们确定引入 Nginx 来做负载均衡，那么 Nginx 的主备怎么做，Nginx 的负载均衡策略用哪个（权重分配？轮询？ip_hash？）等。&lt;/p>
&lt;p>可以看到，详细设计方案里面其实也有一些技术点和备选方案类似。例如，Nginx 的负载均衡策略，备选有轮询、权重分配、ip_hash、fair、url_hash 五个，具体选哪个呢？看起来和备选方案阶段面临的问题类似，但实际上这里的技术方案选择是很轻量级的，我们无须像备选方案阶段那样操作，而只需要简单根据这些技术的适用场景选择就可以了。&lt;/p>
&lt;p>&lt;strong>详细设计方案阶段可能遇到的一种极端情况就是在详细设计阶段发现备选方案不可行，一般情况下主要的原因是备选方案设计时遗漏了某个关键技术点或者关键的质量属性。&lt;strong>例如一个项目，在备选方案阶段确定是可行的，但在详细方案设计阶段，发现由于细节点太多，方案非常庞大，整个项目可能要开发长达 1 年时间，最后只得废弃原来的备选方案，重新调整项目目标、计划和方案。这个项目的主要失误就是在备选方案评估时忽略了&lt;/strong>开发周期&lt;/strong>这个质量属性。&lt;/p>
&lt;p>幸运的是，这种情况可以通过下面方式有效地避免：&lt;/p>
&lt;p>1、架构师不但要进行备选方案设计和选型，还需要对备选方案的关键细节有较深入的理解。&lt;/p>
&lt;p>2、通过分步骤、分阶段、分系统等方式，尽量降低方案复杂度，方案本身的复杂度越高，某个细节推翻整个方案的可能性就越高，适当降低复杂性，可以减少这种风险。&lt;/p>
&lt;p>3、如果方案本身就很复杂，那就采取设计团队的方式来进行设计，博采众长，汇集大家的智慧和经验，防止只有 1~2 个架构师可能出现的思维盲点或者经验盲区。&lt;/p>
&lt;h3 id="详细方案设计实战">详细方案设计实战&lt;/h3>
&lt;p>下面针对上面的“前浪微博”列出一些备选方案 2 典型的需要细化的设计点供参考。&lt;/p>
&lt;h4 id="数据库表如何设计">数据库表如何设计&lt;/h4>
&lt;p>1、数据库设计两类表，一类是日志表，用于消息写入时快速存储到 MySQL 中；另一类是消息表，每个消息队列一张表。&lt;/p>
&lt;p>2、业务系统发布消息时，首先写入到日志表，日志表写入成功就代表消息写入成功；后台线程再从日志表中读取消息写入记录，将消息内容写入到消息表中。&lt;/p>
&lt;p>3、业务系统读取消息时，从消息表中读取。&lt;/p>
&lt;p>4、日志表表名为 MQ_LOG，包含的字段：日志 ID、发布者信息、发布时间、队列名称、消息内容。&lt;/p>
&lt;p>5、消息表表名就是队列名称，包含的字段：消息 ID（递增生成）、消息内容、消息发布时间、消息发布者。&lt;/p>
&lt;p>6、日志表需要及时清除已经写入消息表的日志数据，消息表最多保存 30 天的消息数据。&lt;/p>
&lt;h4 id="数据如何复制">数据如何复制&lt;/h4>
&lt;p>直接采用 MySQL 主从复制即可，只复制消息存储表，不复制日志表。&lt;/p>
&lt;h4 id="主备服务器如何倒换">主备服务器如何倒换&lt;/h4>
&lt;p>采用 ZooKeeper 来做主备决策，主备服务器都连接到 ZooKeeper 建立自己的节点，主服务器的路径规则为“/MQ/server/ 分区编号 /master”，备机为“/MQ/server/ 分区编号 /slave”，节点类型为 EPHEMERAL。&lt;/p>
&lt;p>备机监听主机的节点消息，当发现主服务器节点断连后，备服务器修改自己的状态，对外提供消息读取服务。&lt;/p>
&lt;h4 id="业务服务器如何写入消息">业务服务器如何写入消息&lt;/h4>
&lt;p>1、消息队列系统设计两个角色：生产者和消费者，每个角色都有唯一的名称。&lt;/p>
&lt;p>2、消息队列系统提供 SDK 供各业务系统调用，SDK 从配置中读取所有消息队列系统的服务器信息，SDK 采取轮询算法发起消息写入请求给主服务器。如果某个主服务器无响应或者返回错误，SDK 将发起请求发送到下一台服务器。&lt;/p>
&lt;h4 id="业务服务器如何读取消息">业务服务器如何读取消息&lt;/h4>
&lt;p>1、消息队列系统提供 SDK 供各业务系统调用，SDK 从配置中读取所有消息队列系统的服务器信息，轮流向所有服务器发起消息读取请求。&lt;/p>
&lt;p>2、消息队列服务器需要记录每个消费者的消费状态，即当前消费者已经读取到了哪条消息，当收到消息读取请求时，返回下一条未被读取的消息给消费者。&lt;/p>
&lt;h4 id="业务和消息队列之间的通信协议如何设计">业务和消息队列之间的通信协议如何设计&lt;/h4>
&lt;p>考虑到消息队列系统后续可能会对接多种不同编程语言编写的系统，为了提升兼容性，传输协议用 TCP，数据格式为 ProtocolBuffer。&lt;/p>
&lt;p>当然还有更多设计细节就不再一一列举，因此这还不是一个完整的设计方案，我希望可以通过这些具体实例来说明细化方案具体如何去做。&lt;/p></description></item><item><title>Docs: 架构设计02-高性能架构模式</title><link>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A102-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A102-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;h2 id="高性能数据集群-读写分离">高性能数据集群-读写分离&lt;/h2>
&lt;p>大部分情况下，我们做架构设计主要都是基于已有的成熟模式，结合业务和团队的具体情况，进行一定的优化或者调整；即使少部分情况我们需要进行较大的创新，前提也是需要对已有的各种架构模式和技术非常熟悉。&lt;/p>
&lt;p>虽然近十年来各种存储技术飞速发展，但关系数据库由于其 ACID 的特性和功能强大的 SQL 查询，目前还是各种业务系统中关键和核心的存储系统，很多场景下高性能的设计最核心的部分就是关系数据库的设计。&lt;/p>
&lt;p>不管是为了满足业务发展的需要，还是为了提升自己的竞争力，关系数据库厂商（Oracle、DB2、MySQL 等）在优化和提升单个数据库服务器的性能方面也做了非常多的技术优化和改进。但业务发展速度和数据增长速度，远远超出数据库厂商的优化速度，尤其是互联网业务兴起之后，海量用户加上海量数据的特点，单个数据库服务器已经难以满足业务需要，必须考虑数据库集群的方式来提升性能。&lt;/p>
&lt;p>高性能数据库集群的第一种方式是“读写分离”，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；第二种方式是“分库分表”，既可以分散访问压力，又可以分散存储压力。&lt;/p>
&lt;h3 id="读写分离原理">读写分离原理&lt;/h3>
&lt;p>&lt;strong>读写分离的基本原理是将数据库读写操作分散到不同的节点上。&lt;/strong>&lt;/p>
&lt;p>基本架构图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_1.png" alt="architecture-high-performance_1.png">&lt;/p>
&lt;p>读写分离的基本实现是：&lt;/p>
&lt;ul>
&lt;li>数据库服务器搭建主从集群，一主一从、一主多从都可以。&lt;/li>
&lt;li>数据库主机负责读写操作，从机只负责读操作。&lt;/li>
&lt;li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。&lt;/li>
&lt;li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机。&lt;/li>
&lt;/ul>
&lt;p>需要注意的是，这里用的是“主从集群”，而不是“主备集群”。“从机”的“从”可以理解为“仆从”，仆从是要帮主人干活的，“从机”是需要提供读数据的功能的；而“备机”一般被认为仅仅提供备份功能，不提供访问功能。所以使用“主从”还是“主备”，是要看场景的，这两个词并不是完全等同的。&lt;/p>
&lt;p>读写分离的实现逻辑并不复杂，但有两个细节点将引入设计复杂度：&lt;strong>主从复制延迟&lt;/strong>和&lt;strong>分配机制&lt;/strong>。&lt;/p>
&lt;h3 id="复制延迟">复制延迟&lt;/h3>
&lt;p>以 MySQL 为例，主从复制延迟可能达到 1 秒，如果有大量数据同步，延迟 1 分钟也是有可能的。主从复制延迟会带来业务上的问题。&lt;/p>
&lt;p>解决主从复制延迟有几种常见的方法：&lt;/p>
&lt;p>1、写操作后的读操作指定发给数据库主服务器&lt;/p>
&lt;p>2、读从机失败后再读一次主机&lt;/p>
&lt;p>这就是通常所说的“二次读取”，二次读取和业务无绑定，只需要对底层数据库访问的 API 进行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。例如，黑客暴力破解账号，会导致大量的二次读取操作，主机可能顶不住读操作的压力从而崩溃。&lt;/p>
&lt;p>3、关键业务读写操作全部指向主机，非关键业务采用读写分离&lt;/p>
&lt;h3 id="分配机制">分配机制&lt;/h3>
&lt;p>将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：&lt;strong>程序代码封装&lt;/strong>和&lt;strong>中间件封装&lt;/strong>。&lt;/p>
&lt;p>1、程序代码封装&lt;/p>
&lt;p>程序代码封装指在代码中抽象一个数据访问层（所以有的文章也称这种方式为“中间层封装”），实现读写操作分离和数据库服务器连接的管理。例如，基于 Hibernate 进行简单封装，就可以实现读写分离，基本架构是：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_2.png" alt="architecture-high-performance_2.png">&lt;/p>
&lt;p>程序代码封装的方式具备几个特点：&lt;/p>
&lt;ul>
&lt;li>实现简单，而且可以根据业务做较多定制化的功能。&lt;/li>
&lt;li>每个编程语言都需要自己实现一次，无法通用，如果一个业务包含多个编程语言写的多个子系统，则重复开发的工作量比较大。&lt;/li>
&lt;li>故障情况下，如果主从发生切换，则可能需要所有系统都修改配置并重启。&lt;/li>
&lt;/ul>
&lt;p>目前开源的实现方案中，淘宝的 TDDL（Taobao Distributed Data Layer，外号: 头都大了）是比较有名的。它是一个通用数据访问层，所有功能封装在 jar 包中提供给业务代码调用。其基本原理是一个基于集中式配置的 jdbc datasource 实现，具有主备、读写分离、动态数据库配置等功能，基本架构是：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_3.png" alt="architecture-high-performance_3.png">&lt;/p>
&lt;p>2、中间件封装&lt;/p>
&lt;p>中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。其基本架构是：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_4.png" alt="architecture-high-performance_4.png">&lt;/p>
&lt;p>数据库中间件的方式具备的特点是：&lt;/p>
&lt;ul>
&lt;li>能够支持多种编程语言，因为数据库中间件对业务服务器提供的是标准 SQL 接口。&lt;/li>
&lt;li>数据库中间件要支持完整的 SQL 语法和数据库服务器的协议（例如，MySQL 客户端和服务器的连接协议），实现比较复杂，细节特别多，很容易出现 bug，需要较长的时间才能稳定。&lt;/li>
&lt;li>数据库中间件自己不执行真正的读写操作，但所有的数据库操作请求都要经过中间件，中间件的性能要求也很高。&lt;/li>
&lt;li>数据库主从切换对业务服务器无感知，数据库中间件可以探测数据库服务器的主从状态。例如，向某个测试表写入一条数据，成功的就是主机，失败的就是从机。&lt;/li>
&lt;/ul>
&lt;p>由于数据库中间件的复杂度要比程序代码封装高出一个数量级，一般情况下建议采用程序语言封装的方式，或者使用成熟的开源数据库中间件。如果是大公司，可以投入人力去实现数据库中间件，因为这个系统一旦做好，接入的业务系统越多，节省的程序开发投入就越多，价值也越大。&lt;/p>
&lt;p>目前的开源数据库中间件方案中，MySQL 官方先是提供了 MySQL Proxy，但 MySQL Proxy 一直没有正式 GA，现在 MySQL 官方推荐 MySQL Router。MySQL Router 的主要功能有读写分离、故障自动切换、负载均衡、连接池等，其基本架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_5.png" alt="architecture-high-performance_5.png">&lt;/p>
&lt;p>奇虎 360 公司也开源了自己的数据库中间件 Atlas，Atlas 是基于 MySQL Proxy 实现的，基本架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_6.png" alt="architecture-high-performance_6.png">&lt;/p>
&lt;p>参考地址：&lt;a href="https://github.com/Qihoo360/Atlas/wiki/Atlas%E7%9A%84%E6%9E%B6%E6%9E%84">https://github.com/Qihoo360/Atlas/wiki/Atlas%E7%9A%84%E6%9E%B6%E6%9E%84&lt;/a>&lt;/p>
&lt;h2 id="高性能数据集群-分库分表">高性能数据集群-分库分表&lt;/h2>
&lt;p>读写分离分散了数据库读写操作的压力，但没有分散存储压力，当数据量达到千万甚至上亿条的时候，单台数据库服务器的存储能力会成为系统的瓶颈，主要体现在这几个方面：&lt;/p>
&lt;ul>
&lt;li>数据量太大，读写的性能会下降，即使有索引，索引也会变得很大，性能同样会下降。&lt;/li>
&lt;li>数据文件会变得很大，数据库备份和恢复需要耗费很长时间。&lt;/li>
&lt;li>数据文件越大，极端情况下丢失数据的风险越高（例如，机房火灾导致数据库主备机都发生故障）。&lt;/li>
&lt;/ul>
&lt;p>基于上述原因，单个数据库服务器存储的数据量不能太大，需要控制在一定的范围内。为了满足业务数据存储的需求，就需要将存储分散到多台数据库服务器上。&lt;/p>
&lt;p>常见的分散存储的方法“分库分表”，其中包括“分库”和“分表”两大类。&lt;/p>
&lt;h3 id="业务分库">业务分库&lt;/h3>
&lt;p>**业务分库指的是按照业务模块将数据分散到不同的数据库服务器。**例如，一个简单的电商网站，包括用户、商品、订单三个业务模块，我们可以将用户数据、商品数据、订单数据分开放到三台不同的数据库服务器上，而不是将所有数据都放在一台数据库服务器上。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_7.png" alt="architecture-high-performance_7.png">&lt;/p>
&lt;p>虽然业务分库能够分散存储和访问压力，但同时也带来了新的问题。&lt;/p>
&lt;p>1、join 操作问题&lt;/p>
&lt;p>业务分库后，原本在同一个数据库中的表分散到不同数据库中，导致无法使用 SQL 的 join 查询。&lt;/p>
&lt;p>2、事务问题&lt;/p>
&lt;p>原本在同一个数据库中不同的表可以在同一个事务中修改，业务分库后，表分散到不同的数据库中，无法通过事务统一修改。虽然数据库厂商提供了一些分布式事务的解决方案（例如，MySQL 的 XA），但性能实在太低，与高性能存储的目标是相违背的。&lt;/p>
&lt;p>3、成本问题&lt;/p>
&lt;p>业务分库同时也带来了成本的代价，本来 1 台服务器搞定的事情，现在要 3 台，如果考虑备份，那就是 2 台变成了 6 台。&lt;/p>
&lt;p>基于上述原因，对于小公司初创业务，并不建议一开始就这样拆分，主要有几个原因：&lt;/p>
&lt;ul>
&lt;li>初创业务存在很大的不确定性，业务不一定能发展起来，业务开始的时候并没有真正的存储和访问压力，业务分库并不能为业务带来价值。&lt;/li>
&lt;li>业务分库后，表之间的 join 查询、数据库事务无法简单实现了。&lt;/li>
&lt;li>业务分库后，因为不同的数据要读写不同的数据库，代码中需要增加根据数据类型映射到不同数据库的逻辑，增加了工作量。而业务初创期间最重要的是快速实现、快速验证，业务分库会拖慢业务节奏。&lt;/li>
&lt;/ul>
&lt;p>有的架构师可能会想：如果业务真的发展很快，岂不是很快就又要进行业务分库了？那为何不一开始就设计好呢？&lt;/p>
&lt;p>其实这个问题很好回答，按照前面提到的“架构设计三原则”，简单分析一下。&lt;/p>
&lt;p>首先，这里的“如果”事实上发生的概率比较低，做 10 个业务有 1 个业务能活下去就很不错了，更何况快速发展，和中彩票的概率差不多。如果我们每个业务上来就按照淘宝、微信的规模去做架构设计，不但会累死自己，还会害死业务。&lt;/p>
&lt;p>其次，如果业务真的发展很快，后面进行业务分库也不迟。因为业务发展好，相应的资源投入就会加大，可以投入更多的人和更多的钱，那业务分库带来的代码和业务复杂的问题就可以通过增加人来解决，成本问题也可以通过增加资金来解决。&lt;/p>
&lt;p>第三，单台数据库服务器的性能其实也没有想象的那么弱，一般来说，单台数据库服务器能够支撑 10 万用户量量级的业务，初创业务从 0 发展到 10 万级用户，并不是想象得那么快。&lt;/p>
&lt;p>而对于业界成熟的大公司来说，由于已经有了业务分库的成熟解决方案，并且即使是尝试性的新业务，用户规模也是海量的，这与前面提到的初创业务的小公司有本质区别，因此最好在业务开始设计时就考虑业务分库。例如，在淘宝上做一个新的业务，由于已经有成熟的数据库解决方案，用户量也很大，需要在一开始就设计业务分库甚至接下来介绍的分表方案。&lt;/p>
&lt;h3 id="分表">分表&lt;/h3>
&lt;p>将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进行拆分。&lt;/p>
&lt;p>单表数据拆分有两种方式：垂直分表和水平分表。示意图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_8.png" alt="architecture-high-performance_8.png">&lt;/p>
&lt;p>为了形象地理解垂直拆分和水平拆分的区别，可以想象手里拿着一把刀，面对一个蛋糕切一刀：&lt;/p>
&lt;ul>
&lt;li>从上往下切就是垂直切分，因为刀的运行轨迹与蛋糕是垂直的，这样可以把蛋糕切成高度相等（面积可以相等也可以不相等）的两部分，对应到表的切分就是表记录数相同但包含不同的列。例如，示意图中的垂直切分，会把表切分为两个表，一个表包含 ID、name、age、sex 列，另外一个表包含 ID、nickname、description 列。&lt;/li>
&lt;li>从左往右切就是水平切分，因为刀的运行轨迹与蛋糕是平行的，这样可以把蛋糕切成面积相等（高度可以相等也可以不相等）的两部分，对应到表的切分就是表的列相同但包含不同的行数据。例如，示意图中的水平切分，会把表分为两个表，两个表都包含 ID、name、age、sex、nickname、description 列，但是一个表包含的是 ID 从 1 到 999999 的行数据，另一个表包含的是 ID 从 1000000 到 9999999 的行数据。&lt;/li>
&lt;/ul>
&lt;p>上面这个示例比较简单，只考虑了一次切分的情况，实际架构设计过程中并不局限切分的次数，可以切两次，也可以切很多次，就像切蛋糕一样，可以切很多刀。&lt;/p>
&lt;p>单表进行切分后，是否要将切分后的多个表分散在不同的数据库服务器中，可以根据实际的切分效果来确定，并不强制要求单表切分为多表后一定要分散到不同数据库中。原因在于单表切分为多表后，新的表即使在同一个数据库服务器中，也可能带来可观的性能提升，如果性能能够满足业务要求，是可以不拆分到多台数据库服务器的，毕竟我们在上面业务分库的内容看到业务分库也会引入很多复杂性的问题；如果单表拆分为多表后，单台服务器依然无法满足性能要求，那就不得不再次进行业务分库的设计了。&lt;/p>
&lt;p>分表能够有效地分散存储压力和带来性能提升，但和分库一样，也会引入各种复杂性。&lt;/p>
&lt;h4 id="垂直分表">垂直分表&lt;/h4>
&lt;p>垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。&lt;/p>
&lt;p>垂直分表引入的复杂性主要体现在表操作的数量要增加。例如，原来只要一次查询就可以获取的值现在需要两次查询。&lt;/p>
&lt;p>不过相比接下来要讲的水平分表，这个复杂性就是小巫见大巫了。&lt;/p>
&lt;h4 id="水平分表">水平分表&lt;/h4>
&lt;p>水平分表适合表行数特别大的表，有的公司要求单表行数超过 5000 万就必须进行分表，这个数字可以作为参考，但并不是绝对标准，关键还是要看表的访问性能。对于一些比较复杂的表，可能超过 1000 万就要分表了；而对于一些简单的表，即使存储数据超过 1 亿行，也可以不分表。但不管怎样，当看到表的数据量达到千万级别时，作为架构师就要警觉起来，因为这很可能是架构的性能瓶颈或者隐患。&lt;/p>
&lt;p>水平分表相比垂直分表，会引入更多的复杂性，主要表现在下面几个方面：&lt;/p>
&lt;p>1）路由&lt;/p>
&lt;p>水平分表后，某条数据具体属于哪个切分后的子表，需要增加路由算法进行计算，这个算法会引入一定的复杂性。&lt;/p>
&lt;p>常见的路由算法有：&lt;/p>
&lt;p>&lt;strong>范围路由&lt;/strong>：选取有序的数据列（例如，整形、时间戳等）作为路由的条件，不同分段分散到不同的数据库表中。以最常见的用户 ID 为例，路由算法可以按照 1000000 的范围大小进行分段，1 ~ 999999 放到数据库 1 的表中，1000000 ~ 1999999 放到数据库 2 的表中，以此类推。&lt;/p>
&lt;p>范围路由设计的复杂点主要体现在分段大小的选取上，分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适的分段大小。&lt;/p>
&lt;p>范围路由的优点是可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，只需要增加新的表就可以了，原有的数据不需要动。&lt;/p>
&lt;p>范围路由的一个比较隐含的缺点是分布不均匀，假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1000 条，而另外一个分段实际存储的数据量有 900 万条。&lt;/p>
&lt;p>&lt;strong>Hash 路由&lt;/strong>：选取某个列（或者某几个列组合也可以）的值进行 Hash 运算，然后根据 Hash 结果分散到不同的数据库表中。同样以用户 ID 为例，假如我们一开始就规划了 10 个数据库表，路由算法可以简单地用 user_id % 10 的值来表示数据所属的数据库表编号，ID 为 985 的用户放到编号为 5 的子表中，ID 为 10086 的用户放到编号为 6 的字表中。&lt;/p>
&lt;p>Hash 路由设计的复杂点主要体现在初始表数量的选取上，表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。而用了 Hash 路由后，增加子表数量是非常麻烦的，所有数据都要重分布。&lt;/p>
&lt;p>Hash 路由的优缺点和范围路由基本相反，Hash 路由的优点是表分布比较均匀，缺点是扩充新的表很麻烦，所有数据都要重分布。&lt;/p>
&lt;p>&lt;strong>配置路由&lt;/strong>：配置路由就是路由表，用一张独立的表来记录路由信息。同样以用户 ID 为例，我们新增一张 user_router 表，这个表包含 user_id 和 table_id 两列，根据 user_id 就可以查询对应的 table_id。&lt;/p>
&lt;p>配置路由设计简单，使用起来非常灵活，尤其是在扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了。&lt;/p>
&lt;p>配置路由的缺点就是必须多查询一次，会影响整体性能；而且路由表本身如果太大（例如，几亿条数据），性能同样可能成为瓶颈，如果我们再次将路由表分库分表，则又面临一个死循环式的路由算法选择问题。&lt;/p>
&lt;p>2）join 操作&lt;/p>
&lt;p>水平分表后，数据分散在多个表中，如果需要与其他表进行 join 查询，需要在业务代码或者数据库中间件中进行多次 join 查询，然后将结果合并。&lt;/p>
&lt;p>3）count() 操作&lt;/p>
&lt;p>水平分表后，虽然物理上数据分散到多个表中，但某些业务逻辑上还是会将这些表当作一个表来处理。例如，获取记录总数用于分页或者展示，水平分表前用一个 count() 就能完成的操作，在分表后就没那么简单了。常见的处理方式有下面两种：&lt;/p>
&lt;p>&lt;strong>count() 相加&lt;/strong>：具体做法是在业务代码或者数据库中间件中对每个表进行 count() 操作，然后将结果相加。这种方式实现简单，缺点就是性能比较低。例如，水平分表后切分为 20 张表，则要进行 20 次 count(*) 操作，如果串行的话，可能需要几秒钟才能得到结果。&lt;/p>
&lt;p>&lt;strong>记录数表&lt;/strong>：具体做法是新建一张表，假如表名为“记录数表”，包含 table_name、row_count 两个字段，每次插入或者删除子表数据成功后，都更新“记录数表”。&lt;/p>
&lt;p>这种方式获取表记录数的性能要大大优于 count() 相加的方式，因为只需要一次简单查询就可以获取数据。缺点是复杂度增加不少，对子表的操作要同步操作“记录数表”，如果有一个业务逻辑遗漏了，数据就会不一致；且针对“记录数表”的操作和针对子表的操作无法放在同一事务中进行处理，异常的情况下会出现操作子表成功了而操作记录数表失败，同样会导致数据不一致。&lt;/p>
&lt;p>此外，记录数表的方式也增加了数据库的写压力，因为每次针对子表的 insert 和 delete 操作都要 update 记录数表，所以对于一些不要求记录数实时保持精确的业务，也可以通过后台定时更新记录数表。定时更新实际上就是“count() 相加”和“记录数表”的结合，即定时通过 count() 相加计算表的记录数，然后更新记录数表中的数据。&lt;/p>
&lt;p>4）order by 操作&lt;/p>
&lt;p>水平分表后，数据分散到多个子表中，排序操作无法在数据库中完成，只能由业务代码或者数据库中间件分别查询每个子表中的数据，然后汇总进行排序。&lt;/p>
&lt;h3 id="实现方式">实现方式&lt;/h3>
&lt;p>和数据库读写分离类似，分库分表具体的实现方式也是“程序代码封装”和“中间件封装”，但实现会更复杂。读写分离实现时只要识别 SQL 操作是读操作还是写操作，通过简单的判断 SELECT、UPDATE、INSERT、DELETE 几个关键字就可以做到，而分库分表的实现除了要判断操作类型外，还要判断 SQL 中具体需要操作的表、操作函数（例如 count 函数)、order by、group by 操作等，然后再根据不同的操作进行不同的处理。例如 order by 操作，需要先从多个库查询到各个库的数据，然后再重新 order by 才能得到最终的结果。&lt;/p>
&lt;h2 id="高性能nosql">高性能NoSQL&lt;/h2>
&lt;p>关系数据库经过几十年的发展后已经非常成熟，强大的 SQL 功能和 ACID 的属性，使得关系数据库广泛应用于各式各样的系统中，但这并不意味着关系数据库是完美的，关系数据库存在如下缺点。&lt;/p>
&lt;p>&lt;strong>1、关系数据库存储的是行记录，无法存储数据结构&lt;/strong>&lt;/p>
&lt;p>以微博的关注关系为例，“我关注的人”是一个用户 ID 列表，使用关系数据库存储只能将列表拆成多行，然后再查询出来组装，无法直接存储一个列表。&lt;/p>
&lt;p>&lt;strong>2、关系数据库的 schema 扩展很不方便&lt;/strong>&lt;/p>
&lt;p>关系数据库的表结构 schema 是强约束，操作不存在的列会报错，业务变化时扩充列也比较麻烦，需要执行 DDL（data definition language，如 CREATE、ALTER、DROP 等）语句修改，而且修改时可能会长时间锁表（例如，MySQL 可能将表锁住 1 个小时）。&lt;/p>
&lt;p>&lt;strong>3、关系数据库在大数据场景下 I/O 较高&lt;/strong>&lt;/p>
&lt;p>如果对一些大量数据的表进行统计之类的运算，关系数据库的 I/O 会很高，因为即使只针对其中某一列进行运算，关系数据库也会将整行数据从存储设备读入内存。&lt;/p>
&lt;p>&lt;strong>4、关系数据库的全文搜索功能比较弱&lt;/strong>&lt;/p>
&lt;p>关系数据库的全文搜索只能使用 like 进行整表扫描匹配，性能非常低，在互联网这种搜索复杂的场景下无法满足业务要求。&lt;/p>
&lt;p>针对上述问题，分别诞生了不同的 NoSQL 解决方案，这些方案与关系数据库相比，在某些应用场景下表现更好。但世上没有免费的午餐，NoSQL 方案带来的优势，本质上是牺牲 ACID 中的某个或者某几个特性，因&lt;strong>此不能盲目地迷信 NoSQL 是银弹，而应该将 NoSQL 作为 SQL 的一个有力补充&lt;/strong>，NoSQL != No SQL，而是 NoSQL = Not Only SQL。&lt;/p>
&lt;p>常见的 NoSQL 方案分为 4 类。&lt;/p>
&lt;ul>
&lt;li>K-V 存储：解决关系数据库无法存储数据结构的问题，以 Redis 为代表。&lt;/li>
&lt;li>文档数据库：解决关系数据库强 schema 约束的问题，以 MongoDB 为代表。&lt;/li>
&lt;li>列式数据库：解决关系数据库大数据场景下的 I/O 问题，以 HBase 为代表。&lt;/li>
&lt;li>全文搜索引擎：解决关系数据库的全文搜索性能问题，以 Elasticsearch 为代表。&lt;/li>
&lt;/ul>
&lt;p>这里介绍一下各种高性能 NoSQL 方案的典型特征和应用场景。&lt;/p>
&lt;h3 id="k-v-存储">K-V 存储&lt;/h3>
&lt;p>K-V 存储的全称是 Key-Value 存储，其中 Key 是数据的标识，和关系数据库中的主键含义一样，Value 就是具体的数据。&lt;/p>
&lt;p>Redis 是 K-V 存储的典型代表，它是一款开源（基于 BSD 许可）的高性能 K-V 缓存和存储系统。Redis 的 Value 是具体的数据结构，包括 string、hash、list、set、sorted set、bitmap 和 hyperloglog，所以常常被称为数据结构服务器。&lt;/p>
&lt;p>以 List 数据结构为例，Redis 提供了下面这些典型的操作（更多请参考链接：&lt;a href="http://redis.cn/commands.html#list">http://redis.cn/commands.html#list&lt;/a>）：&lt;/p>
&lt;ul>
&lt;li>LPOP key 从队列的左边出队一个元素。&lt;/li>
&lt;li>LINDEX key index 获取一个元素，通过其索引列表。&lt;/li>
&lt;li>LLEN key 获得队列（List）的长度。&lt;/li>
&lt;li>RPOP key 从队列的右边出队一个元素。&lt;/li>
&lt;/ul>
&lt;p>以上这些功能，如果用关系数据库来实现，就会变得很复杂。例如，LPOP 操作是移除并返回 key 对应的 list 的第一个元素。如果用关系数据库来存储，为了达到同样目的，需要进行下面的操作：&lt;/p>
&lt;p>1、每条数据除了数据编号（例如，行 ID），还要有位置编号，否则没有办法判断哪条数据是第一条。注意这里不能用行 ID 作为位置编号，因为我们会往列表头部插入数据。&lt;/p>
&lt;p>2、查询出第一条数据。&lt;/p>
&lt;p>3、删除第一条数据。&lt;/p>
&lt;p>4、更新从第二条开始的所有数据的位置编号。&lt;/p>
&lt;p>可以看出关系数据库的实现很麻烦，而且需要进行多次 SQL 操作，性能很低。&lt;/p>
&lt;p>Redis 的缺点主要体现在并不支持完整的 ACID 事务，Redis 虽然提供事务功能，但 Redis 的事务和关系数据库的事务不可同日而语，Redis 的事务只能保证隔离性和一致性（I 和 C），无法保证原子性和持久性（A 和 D）。&lt;/p>
&lt;p>虽然 Redis 并没有严格遵循 ACID 原则，但实际上大部分业务也不需要严格遵循 ACID 原则。以上面的微博关注操作为例，即使系统没有将 A 加入 B 的粉丝列表，其实业务影响也非常小，因此在设计方案时，需要根据业务特性和要求来确定是否可以用 Redis，而不能因为 Redis 不遵循 ACID 原则就直接放弃。&lt;/p>
&lt;h3 id="文档数据库">文档数据库&lt;/h3>
&lt;p>为了解决关系数据库 schema 带来的问题，文档数据库应运而生。文档数据库最大的特点就是 no-schema，可以存储和读取任意的数据。目前绝大部分文档数据库存储的数据格式是 JSON（或者 BSON），因为 JSON 数据是自描述的，无须在使用前定义字段，读取一个 JSON 中不存在的字段也不会导致 SQL 那样的语法错误。&lt;/p>
&lt;p>文档数据库的 no-schema 特性，给业务开发带来了几个明显的优势。&lt;/p>
&lt;p>1、新增字段简单&lt;/p>
&lt;p>业务上增加新的字段，无须再像关系数据库一样要先执行 DDL 语句修改表结构，程序代码直接读写即可。&lt;/p>
&lt;p>2、历史数据不会出错&lt;/p>
&lt;p>对于历史数据，即使没有新增的字段，也不会导致错误，只会返回空值，此时代码进行兼容处理即可。&lt;/p>
&lt;p>3、可以很容易存储复杂数据&lt;/p>
&lt;p>JSON 是一种强大的描述语言，能够描述复杂的数据结构。例如，我们设计一个用户管理系统，用户的信息有 ID、姓名、性别、爱好、邮箱、地址、学历信息。其中爱好是列表（因为可以有多个爱好）；地址是一个结构，包括省市区楼盘地址；学历包括学校、专业、入学毕业年份信息等。如果我们用关系数据库来存储，需要设计多张表，包括基本信息（列：ID、姓名、性别、邮箱）、爱好（列：ID、爱好）、地址（列：省、市、区、详细地址）、学历（列：入学时间、毕业时间、学校名称、专业），而使用文档数据库，一个 JSON 就可以全部描述。&lt;/p>
&lt;p>文档数据库的这个特点，特别适合电商和游戏这类的业务场景。以电商为例，不同商品的属性差异很大。例如，冰箱的属性和笔记本电脑的属性差异非常大。&lt;/p>
&lt;p>文档数据库 no-schema 的特性带来的这些优势也是有代价的，最主要的代价就是不支持事务。另外一个缺点就是无法实现关系数据库的 join 操作。&lt;/p>
&lt;h3 id="列式数据库">列式数据库&lt;/h3>
&lt;p>顾名思义，列式数据库就是按照列来存储数据的数据库，与之对应的传统关系数据库被称为“行式数据库”，因为关系数据库是按照行来存储数据的。关系数据库按照行式来存储数据，主要有以下几个优势：&lt;/p>
&lt;p>1、业务同时读取多个列时效率高，因为这些列都是按行存储在一起的，一次磁盘操作就能够把一行数据中的各个列都读取到内存中。&lt;/p>
&lt;p>2、能够一次性完成对一行中的多个列的写操作，保证了针对行数据写操作的原子性和一致性；否则如果采用列存储，可能会出现某次写操作，有的列成功了，有的列失败了，导致数据不一致。&lt;/p>
&lt;p>行式存储的优势是在特定的业务场景下才能体现，如果不存在这样的业务场景，那么行式存储的优势也将不复存在，甚至成为劣势，典型的场景就是海量数据进行统计。&lt;/p>
&lt;p>例如，计算某个城市体重超重的人员数据，实际上只需要读取每个人的体重这一列并进行统计即可，而行式存储即使最终只使用一列，也会将所有行数据都读取出来。如果单行用户信息有 1KB，其中体重只有 4 个字节，行式存储还是会将整行 1KB 数据全部读取到内存中，这是明显的浪费。而如果采用列式存储，每个用户只需要读取 4 字节的体重数据即可，I/O 将大大减少。&lt;/p>
&lt;p>除了节省 I/O，列式存储还具备更高的存储压缩比，能够节省更多的存储空间。普通的行式数据库一般压缩率在 3:1 到 5:1 左右，而列式数据库的压缩率一般在 8:1 到 30:1 左右，因为单个列的数据相似度相比行来说更高，能够达到更高的压缩率。&lt;/p>
&lt;p>同样，如果场景发生变化，列式存储的优势又会变成劣势。典型的场景是需要频繁地更新多个列。因为列式存储将不同列存储在磁盘上不连续的空间，导致更新多个列时磁盘是随机写操作；而行式存储时同一行多个列都存储在连续的空间，一次磁盘写操作就可以完成，列式存储的随机写效率要远远低于行式存储的写效率。此外，列式存储高压缩率在更新场景下也会成为劣势，因为更新时需要将存储数据解压后更新，然后再压缩，最后写入磁盘。&lt;/p>
&lt;p>基于上述列式存储的优缺点，一般将列式存储应用在离线的大数据分析和统计场景中，因为这种场景主要是针对部分列单列进行操作，且数据写入后就无须再更新删除。&lt;/p>
&lt;h3 id="全文搜索引擎">全文搜索引擎&lt;/h3>
&lt;p>传统的关系型数据库通过索引来达到快速查询的目的，但是在全文搜索的业务场景下，索引也无能为力，主要体现在：&lt;/p>
&lt;p>1、全文搜索的条件可以随意排列组合，如果通过索引来满足，则索引的数量会非常多。&lt;/p>
&lt;p>2、全文搜索的模糊匹配方式，索引无法满足，只能用 like 查询，而 like 查询是整表扫描，效率非常低。&lt;/p>
&lt;h4 id="全文搜索基本原理">全文搜索基本原理&lt;/h4>
&lt;p>全文搜索引擎的技术原理被称为“倒排索引”（Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，其基本原理是建立单词到文档的索引。之所以被称为“倒排”索引，是和“正排“索引相对的，“正排索引”的基本原理是建立文档到单词的索引。我们通过一个简单的样例来说明这两种索引的差异。&lt;/p>
&lt;h4 id="全文搜索的使用方式">全文搜索的使用方式&lt;/h4>
&lt;p>全文搜索引擎的索引对象是单词和文档，而关系数据库的索引对象是键和行，两者的术语差异很大，不能简单地等同起来。因此，为了让全文搜索引擎支持关系型数据的全文搜索，需要做一些转换操作，即将关系型数据转换为文档数据。&lt;/p>
&lt;p>目前常用的转换方式是将关系型数据按照对象的形式转换为 JSON 文档，然后将 JSON 文档输入全文搜索引擎进行索引。&lt;/p>
&lt;h2 id="高性能缓存架构">高性能缓存架构&lt;/h2>
&lt;p>虽然可以通过各种手段来提升存储系统的性能，但在某些复杂的业务场景下，单纯依靠存储系统的性能提升不够的，典型的场景有：&lt;/p>
&lt;p>1、需要经过复杂运算后得出的数据，存储系统无能为力&lt;/p>
&lt;p>例如，一个论坛需要在首页展示当前有多少用户同时在线，如果使用 MySQL 来存储当前用户状态，则每次获取这个总数都要“count(*)”大量数据，这样的操作无论怎么优化 MySQL，性能都不会太高。如果要实时展示用户同时在线数，则 MySQL 性能无法支撑。&lt;/p>
&lt;p>2、读多写少的数据，存储系统有心无力&lt;/p>
&lt;p>绝大部分在线业务都是读多写少。例如，微博、淘宝、微信这类互联网业务，读业务占了整体业务量的 90% 以上。以微博为例：一个明星发一条微博，可能几千万人来浏览。如果使用 MySQL 来存储微博，用户写微博只有一条 insert 语句，但每个用户浏览时都要 select 一次，即使有索引，几千万条 select 语句对 MySQL 数据库的压力也会非常大。&lt;/p>
&lt;p>缓存就是为了弥补存储系统在这些复杂业务场景下的不足，其基本原理是将可能重复使用的数据放到内存中，一次生成、多次使用，避免每次使用都去访问存储系统。&lt;/p>
&lt;p>缓存能够带来性能的大幅提升，以 Memcache 为例，单台 Memcache 服务器简单的 key-value 查询能够达到 TPS 50000 以上，其基本的架构是：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_9.png" alt="architecture-high-performance_9.png">&lt;/p>
&lt;p>缓存虽然能够大大减轻存储系统的压力，但同时也给架构引入了更多复杂性。架构设计时如果没有针对缓存的复杂性进行处理，某些场景下甚至会导致整个系统崩溃。&lt;/p>
&lt;h3 id="缓存穿透">缓存穿透&lt;/h3>
&lt;p>缓存穿透是指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。通常情况下有两种情况：&lt;/p>
&lt;p>1、存储数据不存在&lt;/p>
&lt;p>第一种情况是被访问的数据确实不存在。一般情况下，如果存储系统中没有某个数据，则不会在缓存中存储相应的数据，这样就导致用户查询的时候，在缓存中找不到对应的数据，每次都要去存储系统中再查询一遍，然后返回数据不存在。缓存在这个场景中并没有起到分担存储系统访问压力的作用。&lt;/p>
&lt;p>通常情况下，业务上读取不存在的数据的请求量并不会太大，但如果出现一些异常情况，例如被黑客攻击，故意大量访问某些读取不存在数据的业务，有可能会将存储系统拖垮。&lt;/p>
&lt;p>这种情况的解决办法比较简单，如果查询存储系统的数据没有找到，则直接设置一个默认值（可以是空值，也可以是具体的值）存到缓存中，这样第二次读取缓存时就会获取到默认值，而不会继续访问存储系统。&lt;/p>
&lt;p>2、缓存数据生成耗费大量时间或者资源&lt;/p>
&lt;p>第二种情况是存储系统中存在数据，但生成缓存数据需要耗费较长时间或者耗费大量资源。如果刚好在业务访问的时候缓存失效了，那么也会出现缓存没有发挥作用，访问压力全部集中在存储系统上的情况。&lt;/p>
&lt;p>典型的就是电商的商品分页，假设我们在某个电商平台上选择“手机”这个类别查看，由于数据巨大，不能把所有数据都缓存起来，只能按照分页来进行缓存，由于难以预测用户到底会访问哪些分页，因此业务上最简单的就是每次点击分页的时候按分页计算和生成缓存。通常情况下这样实现是基本满足要求的，但是如果被竞争对手用爬虫来遍历的时候，系统性能就可能出现问题。&lt;/p>
&lt;p>具体的场景有：&lt;/p>
&lt;ul>
&lt;li>分页缓存的有效期设置为 1 天，因为设置太长时间的话，缓存不能反应真实的数据。&lt;/li>
&lt;li>通常情况下，用户不会从第 1 页到最后 1 页全部看完，一般用户访问集中在前 10 页，因此第 10 页以后的缓存过期失效的可能性很大。&lt;/li>
&lt;li>竞争对手每周来爬取数据，爬虫会将所有分类的所有数据全部遍历，从第 1 页到最后 1 页全部都会读取，此时很多分页缓存可能都失效了。&lt;/li>
&lt;li>由于很多分页都没有缓存数据，从数据库中生成缓存数据又非常耗费性能（order by limit 操作），因此爬虫会将整个数据库全部拖慢。&lt;/li>
&lt;/ul>
&lt;p>这种情况并没有太好的解决方案，因为爬虫会遍历所有的数据，而且什么时候来爬取也是不确定的，可能是每天都来，也可能是每周，也可能是一个月来一次，也不可能为了应对爬虫而将所有数据永久缓存。通常的应对方案要么就是识别爬虫然后禁止访问，但这可能会影响 SEO 和推广；要么就是做好监控，发现问题后及时处理，因为爬虫不是攻击，不会进行暴力破坏，对系统的影响是逐步的，监控发现问题后有时间进行处理。&lt;/p>
&lt;h3 id="缓存雪崩">缓存雪崩&lt;/h3>
&lt;p>&lt;strong>缓存雪崩是指当缓存失效（过期）后引起系统性能急剧下降的情况&lt;/strong>。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统，再次进行运算，这个处理步骤耗时几十毫秒甚至上百毫秒。而对于一个高并发的业务系统来说，几百毫秒内可能会接到几百上千个请求。由于旧的缓存已经被清除，新的缓存还未生成，并且处理这些请求的线程都不知道另外有一个线程正在生成缓存，因此所有的请求都会去重新生成缓存，都会去访问存储系统，从而对存储系统造成巨大的性能压力。这些压力又会拖慢整个系统，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。&lt;/p>
&lt;p>缓存雪崩的常见解决方法有两种：&lt;strong>更新锁机制&lt;/strong>和&lt;strong>后台更新机制&lt;/strong>。&lt;/p>
&lt;p>1、更新锁&lt;/p>
&lt;p>对缓存更新操作进行加锁保护，保证只有一个线程能够进行缓存更新，未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。&lt;/p>
&lt;p>对于采用分布式集群的业务系统，由于存在几十上百台服务器，即使单台服务器只有一个线程更新缓存，但几十上百台服务器一起算下来也会有几十上百个线程同时来更新缓存，同样存在雪崩的问题。因此分布式集群的业务系统要实现更新锁机制，需要用到分布式锁，如 ZooKeeper。&lt;/p>
&lt;p>2、后台更新&lt;/p>
&lt;p>由后台线程来更新缓存，而不是由业务线程来更新缓存，缓存本身的有效期设置为永久，后台线程定时更新缓存。&lt;/p>
&lt;p>后台定时机制需要考虑一种特殊的场景，当缓存系统内存不够时，会“踢掉”一些缓存数据，从缓存被“踢掉”到下一次定时更新缓存的这段时间内，业务线程读取缓存返回空值，而业务线程本身又不会去更新缓存，因此业务上看到的现象就是数据丢了。解决的方式有两种：&lt;/p>
&lt;p>1）后台线程除了定时更新缓存，还要频繁地去读取缓存（例如，1 秒或者 100 毫秒读取一次），如果发现缓存被“踢了”就立刻更新缓存，这种方式实现简单，但读取时间间隔不能设置太长，因为如果缓存被踢了，缓存读取间隔时间又太长，这段时间内业务访问都拿不到真正的数据而是一个空的缓存值，用户体验一般。&lt;/p>
&lt;p>2）业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存。可能会出现多个业务线程都发送了缓存更新消息，但其实对后台线程没有影响，后台线程收到消息后更新缓存前可以判断缓存是否存在，存在就不执行更新操作。这种方式实现依赖消息队列，复杂度会高一些，但缓存更新更及时，用户体验更好&lt;/p>
&lt;p>后台更新既适应单机多线程的场景，也适合分布式集群的场景，相比更新锁机制要简单一些。&lt;/p>
&lt;p>后台更新机制还适合业务刚上线的时候进行缓存预热。缓存预热指系统上线后，将相关的缓存数据直接加载到缓存系统，而不是等待用户访问才来触发缓存加载。&lt;/p>
&lt;h3 id="缓存热点">缓存热点&lt;/h3>
&lt;p>虽然缓存系统本身的性能比较高，但对于一些特别热点的数据，如果大部分甚至所有的业务请求都命中同一份缓存数据，则这份数据所在的缓存服务器的压力也很大。例如，某明星微博发布“我们”来宣告恋爱了，短时间内上千万的用户都会来围观。&lt;/p>
&lt;p>&lt;strong>缓存热点的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力&lt;/strong>。以微博为例，对于粉丝数超过 100 万的明星，每条微博都可以生成 100 份缓存，缓存的数据是一样的，通过在缓存的 key 里面加上编号进行区分，每次读缓存时都随机读取其中某份缓存。&lt;/p>
&lt;p>缓存副本设计有一个细节需要注意，就是不同的缓存副本不要设置统一的过期时间，否则就会出现所有缓存副本同时生成同时失效的情况，从而引发缓存雪崩效应。正确的做法是设定一个过期时间范围，不同的缓存副本的过期时间是指定范围内的随机值。&lt;/p>
&lt;h3 id="实现方式-1">实现方式&lt;/h3>
&lt;p>由于缓存的各种访问策略和存储的访问策略是相关的，因此上面的各种缓存设计方案通常情况下都是集成在存储访问方案中，可以采用“程序代码实现”的中间层方式，也可以采用独立的中间件来实现。&lt;/p>
&lt;h2 id="单服务器高性能模式-ppc与tpc">单服务器高性能模式：PPC与TPC&lt;/h2>
&lt;p>高性能是每个程序员的追求，无论我们是做一个系统还是写一行代码，都希望能够达到高性能的效果，而高性能又是最复杂的一环，磁盘、操作系统、CPU、内存、缓存、网络、编程语言、架构等，每个都有可能影响系统达到高性能，一行不恰当的 debug 日志，就可能将服务器的性能从 TPS 30000 降低到 8000；一个 tcp_nodelay 参数，就可能将响应时间从 2 毫秒延长到 40 毫秒。因此，要做到高性能计算是一件很复杂很有挑战的事情，软件系统开发过程中的不同阶段都关系着高性能最终是否能够实现。&lt;/p>
&lt;p>站在架构师的角度，当然需要特别关注高性能架构的设计。高性能架构设计主要集中在两方面：&lt;/p>
&lt;ul>
&lt;li>尽量提升单服务器的性能，将单服务器的性能发挥到极致。&lt;/li>
&lt;li>如果单服务器无法支撑性能，设计服务器集群方案。&lt;/li>
&lt;/ul>
&lt;p>除了以上两点，最终系统能否实现高性能，还和具体的实现及编码相关。但架构设计是高性能的基础，如果架构设计没有做到高性能，则后面的具体实现和编码能提升的空间是有限的。形象地说，架构设计决定了系统性能的上限，实现细节决定了系统性能的下限。&lt;/p>
&lt;p>单服务器高性能的关键之一就是服务器采取的并发模型，并发模型有如下两个关键设计点：&lt;/p>
&lt;ul>
&lt;li>服务器如何管理连接。&lt;/li>
&lt;li>服务器如何处理请求。&lt;/li>
&lt;/ul>
&lt;p>以上两个设计点最终都和操作系统的 I/O 模型及进程模型相关。&lt;/p>
&lt;ul>
&lt;li>I/O 模型：阻塞、非阻塞、同步、异步。&lt;/li>
&lt;li>进程模型：单进程、多进程、多线程。&lt;/li>
&lt;/ul>
&lt;p>在下面详细介绍并发模型时会用到上面这些基础的知识点，建议先检测一下对这些基础知识的掌握情况，更多内容可以参考《UNIX 网络编程》三卷本。这里先来看看单服务器高性能模式：PPC 与 TPC。&lt;/p>
&lt;h3 id="ppc">PPC&lt;/h3>
&lt;p>PPC 是 Process Per Connection 的缩写，其含义是指每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的 UNIX 网络服务器所采用的模型。基本的流程图是：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_10.png" alt="architecture-high-performance_10.png">&lt;/p>
&lt;ul>
&lt;li>父进程接受连接（图中 accept）。&lt;/li>
&lt;li>父进程“fork”子进程（图中 fork）。&lt;/li>
&lt;li>子进程处理连接的读写请求（图中子进程 read、业务处理、write）。&lt;/li>
&lt;li>子进程关闭连接（图中子进程中的 close）。&lt;/li>
&lt;/ul>
&lt;p>注意，图中有一个小细节，父进程“fork”子进程后，直接调用了 close，看起来好像是关闭了连接，其实只是将连接的文件描述符引用计数减一，真正的关闭连接是等子进程也调用 close 后，连接对应的文件描述符引用计数变为 0 后，操作系统才会真正关闭连接，更多细节请参考《UNIX 网络编程：卷一》。&lt;/p>
&lt;p>PPC 模式实现简单，比较适合服务器的连接数没那么多的情况，例如数据库服务器。对于普通的业务服务器，在互联网兴起之前，由于服务器的访问量和并发量并没有那么大，这种模式其实运作得也挺好，世界上第一个 web 服务器 CERN httpd 就采用了这种模式（具体可以参考&lt;a href="https://en.wikipedia.org/wiki/CERN_httpd">https://en.wikipedia.org/wiki/CERN_httpd&lt;/a>）。互联网兴起后，服务器的并发和访问量从几十剧增到成千上万，这种模式的弊端就凸显出来了，主要体现在这几个方面：&lt;/p>
&lt;p>fork 代价高：站在操作系统的角度，创建一个进程的代价是很高的，需要分配很多内核资源，需要将内存映像从父进程复制到子进程。即使现在的操作系统在复制内存映像时用到了 Copy on Write（写时复制）技术，总体来说创建进程的代价还是很大的。父子进程通信复杂：父进程“fork”子进程时，文件描述符可以通过内存映像复制从父进程传到子进程，但“fork”完成后，父子进程通信就比较麻烦了，需要采用 IPC（Interprocess Communication）之类的进程通信方案。例如，子进程需要在 close 之前告诉父进程自己处理了多少个请求以支撑父进程进行全局的统计，那么子进程和父进程必须采用 IPC 方案来传递信息。支持的并发连接数量有限：如果每个连接存活时间比较长，而且新的连接又源源不断的进来，则进程数量会越来越多，操作系统进程调度和切换的频率也越来越高，系统的压力也会越来越大。因此，一般情况下，PPC 方案能处理的并发连接数量最大也就几百。&lt;/p>
&lt;h4 id="prefork">prefork&lt;/h4>
&lt;p>PPC 模式中，当连接进来时才 fork 新进程来处理连接请求，由于 fork 进程代价高，用户访问时可能感觉比较慢，prefork 模式的出现就是为了解决这个问题。&lt;/p>
&lt;p>顾名思义，prefork 就是提前创建进程（pre-fork）。系统在启动的时候就预先创建好进程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去 fork 进程的操作，让用户访问更快、体验更好。prefork 的基本示意图是：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_11.png" alt="architecture-high-performance_11.png">&lt;/p>
&lt;p>prefork 的实现关键就是多个子进程都 accept 同一个 socket，当有新的连接进入时，操作系统保证只有一个进程能最后 accept 成功。但这里也存在一个小小的问题：“惊群”现象，就是指虽然只有一个子进程能 accept 成功，但所有阻塞在 accept 上的子进程都会被唤醒，这样就导致了不必要的进程调度和上下文切换了。幸运的是，操作系统可以解决这个问题，例如 Linux 2.6 版本后内核已经解决了 accept 惊群问题。&lt;/p>
&lt;p>prefork 模式和 PPC 一样，还是存在父子进程通信复杂、支持的并发连接数量有限的问题，因此目前实际应用也不多。Apache 服务器提供了 MPM prefork 模式，推荐在需要可靠性或者与旧软件兼容的站点时采用这种模式，默认情况下最大支持 256 个并发连接。&lt;/p>
&lt;h3 id="tpc">TPC&lt;/h3>
&lt;p>TPC 是 Thread Per Connection 的缩写，其含义是指每次有新的连接就新建一个线程去专门处理这个连接的请求。与进程相比，线程更轻量级，创建线程的消耗比进程要少得多；同时多线程是共享进程内存空间的，线程通信相比进程通信更简单。因此，TPC 实际上是解决或者弱化了 PPC fork 代价高的问题和父子进程通信复杂的问题。&lt;/p>
&lt;p>TPC 的基本流程是：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_12.png" alt="architecture-high-performance_12.png">&lt;/p>
&lt;p>1、父进程接受连接（图中 accept）。&lt;/p>
&lt;p>2、父进程创建子线程（图中 pthread）。&lt;/p>
&lt;p>3、子线程处理连接的读写请求（图中子线程 read、业务处理、write）。&lt;/p>
&lt;p>4、子线程关闭连接（图中子线程中的 close）。&lt;/p>
&lt;p>注意，和 PPC 相比，主进程不用“close”连接了。原因是在于子线程是共享主进程的进程空间的，连接的文件描述符并没有被复制，因此只需要一次 close 即可。&lt;/p>
&lt;p>TPC 虽然解决了 fork 代价高和进程通信复杂的问题，但是也引入了新的问题，具体表现在：&lt;/p>
&lt;p>1、创建线程虽然比创建进程代价低，但并不是没有代价，高并发时（例如每秒上万连接）还是有性能问题。&lt;/p>
&lt;p>2、无须进程间通信，但是线程间的互斥和共享又引入了复杂度，可能一不小心就导致了死锁问题。&lt;/p>
&lt;p>3、多线程会出现互相影响的情况，某个线程出现异常时，可能导致整个进程退出（例如内存越界）。&lt;/p>
&lt;p>除了引入了新的问题，TPC 还是存在 CPU 线程调度和切换代价的问题。因此，TPC 方案本质上和 PPC 方案基本类似，在并发几百连接的场景下，反而更多地是采用 PPC 的方案，因为 PPC 方案不会有死锁的风险，也不会多进程互相影响，稳定性更高。&lt;/p>
&lt;h4 id="prethread">prethread&lt;/h4>
&lt;p>TPC 模式中，当连接进来时才创建新的线程来处理连接请求，虽然创建线程比创建进程要更加轻量级，但还是有一定的代价，而 prethread 模式就是为了解决这个问题。&lt;/p>
&lt;p>和 prefork 类似，prethread 模式会预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快、体验更好。&lt;/p>
&lt;p>由于多线程之间数据共享和通信比较方便，因此实际上 prethread 的实现方式相比 prefork 要灵活一些，常见的实现方式有下面几种：&lt;/p>
&lt;p>1、主进程 accept，然后将连接交给某个线程处理。&lt;/p>
&lt;p>2、子线程都尝试去 accept，最终只有一个线程 accept 成功，方案的基本示意图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_13.png" alt="architecture-high-performance_13.png">&lt;/p>
&lt;p>Apache 服务器的 MPM worker 模式本质上就是一种 prethread 方案，但稍微做了改进。Apache 服务器会首先创建多个进程，每个进程里面再创建多个线程，这样做主要是为了考虑稳定性，即：即使某个子进程里面的某个线程异常导致整个子进程退出，还会有其他子进程继续提供服务，不会导致整个服务器全部挂掉。&lt;/p>
&lt;p>prethread 理论上可以比 prefork 支持更多的并发连接，Apache 服务器 MPM worker 模式默认支持 16 × 25 = 400 个并发处理线程。&lt;/p>
&lt;h2 id="单服务器高性能模式-reactor与proactor">单服务器高性能模式：Reactor与Proactor&lt;/h2>
&lt;p>上一节介绍了单服务器高性能的 PPC 和 TPC 模式，它们的优点是实现简单，缺点是都无法支撑高并发的场景，尤其是互联网发展到现在，各种海量用户业务的出现，PPC 和 TPC 完全无能为力。这一节介绍可以应对高并发场景的单服务器高性能架构模式：Reactor 和 Proactor。&lt;/p>
&lt;h3 id="reactor">Reactor&lt;/h3>
&lt;p>PPC 模式最主要的问题就是每个连接都要创建进程（为了描述简洁，这里只以 PPC 和进程为例，实际上换成 TPC 和线程，原理是一样的），连接结束后进程就销毁了，这样做其实是很大的浪费。为了解决这个问题，一个自然而然的想法就是资源复用，即不再单独为每个连接创建进程，而是创建一个进程池，将连接分配给进程，一个进程可以处理多个连接的业务。&lt;/p>
&lt;p>引入资源池的处理方式后，会引出一个新的问题：进程如何才能高效地处理多个连接的业务？当一个连接一个进程时，进程可以采用“read -&amp;gt; 业务处理 -&amp;gt; write”的处理流程，如果当前连接没有数据可以读，则进程就阻塞在 read 操作上。这种阻塞的方式在一个连接一个进程的场景下没有问题，但如果一个进程处理多个连接，进程阻塞在某个连接的 read 操作上，此时即使其他连接有数据可读，进程也无法去处理，很显然这样是无法做到高性能的。&lt;/p>
&lt;p>解决这个问题的最简单的方式是将 read 操作改为非阻塞，然后进程不断地轮询多个连接。这种方式能够解决阻塞的问题，但解决的方式并不优雅。首先，轮询是要消耗 CPU 的；其次，如果一个进程处理几千上万的连接，则轮询的效率是很低的。&lt;/p>
&lt;p>为了能够更好地解决上述问题，很容易可以想到，只有当连接上有数据的时候进程才去处理，这就是 I/O 多路复用技术的来源。&lt;/p>
&lt;p>I/O 多路复用技术归纳起来有两个关键实现点：&lt;/p>
&lt;p>1、当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的实现方式有 select、epoll、kqueue 等。&lt;/p>
&lt;p>2、当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。&lt;/p>
&lt;p>I/O 多路复用结合线程池，完美地解决了 PPC 和 TPC 的问题，而且“大神们”给它取了一个很牛的名字：Reactor，中文是“反应堆”。联想到“核反应堆”，听起来就很吓人，实际上这里的“反应”不是聚变、裂变反应的意思，而是“&lt;strong>事件反应&lt;/strong>”的意思，可以通俗地理解为“来了一个事件我就有相应的反应”，这里的“我”就是 Reactor，具体的反应就是我们写的代码，Reactor 会根据事件类型来调用相应的代码进行处理。&lt;strong>Reactor 模式也叫 Dispatcher 模式&lt;/strong>（在很多开源的系统里面会看到这个名称的类，其实就是实现 Reactor 模式的），更加贴近模式本身的含义，即 I/O 多路复用统一监听事件，收到事件后分配（&lt;strong>Dispatch&lt;/strong>）给某个进程。&lt;/p>
&lt;p>Reactor 模式的核心组成部分包括 Reactor 和处理资源池（进程池或线程池），其中 Reactor 负责监听和分配事件，处理资源池负责处理事件。初看 Reactor 的实现是比较简单的，但实际上结合不同的业务场景，Reactor 模式的具体实现方案灵活多变，主要体现在：&lt;/p>
&lt;p>1、Reactor 的数量可以变化：可以是一个 Reactor，也可以是多个 Reactor。&lt;/p>
&lt;p>2、资源池的数量可以变化：以进程为例，可以是单个进程，也可以是多个进程（线程类似）。&lt;/p>
&lt;p>将上面两个因素排列组合一下，理论上可以有 4 种选择，但由于“多 Reactor 单进程”实现方案相比“单 Reactor 单进程”方案，既复杂又没有性能优势，因此“多 Reactor 单进程”方案仅仅是一个理论上的方案，实际没有应用。&lt;/p>
&lt;p>最终 Reactor 模式有这三种典型的实现方案：&lt;/p>
&lt;p>1、单 Reactor 单进程 / 线程。&lt;/p>
&lt;p>2、单 Reactor 多线程。&lt;/p>
&lt;p>3、多 Reactor 多进程 / 线程。&lt;/p>
&lt;p>以上方案具体选择进程还是线程，更多地是和编程语言及平台相关。例如，Java 语言一般使用线程（例如，Netty），C 语言使用进程和线程都可以。例如，Nginx 使用进程，Memcache 使用线程。&lt;/p>
&lt;h4 id="单reactor单进程-线程">单Reactor单进程/线程&lt;/h4>
&lt;p>单 Reactor 单进程 / 线程的方案示意图如下（以进程为例）：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_14.png" alt="architecture-high-performance_14.png">&lt;/p>
&lt;p>注意，select、accept、read、send 是标准的网络编程 API，dispatch 和“业务处理”是需要完成的操作，其他方案示意图类似。&lt;/p>
&lt;p>详细说明一下这个方案：&lt;/p>
&lt;p>1、Reactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行分发。&lt;/p>
&lt;p>2、如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。&lt;/p>
&lt;p>3、如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler（第 2 步中创建的 Handler）来进行响应。&lt;/p>
&lt;p>4、Handler 会完成 read-&amp;gt; 业务处理 -&amp;gt;send 的完整业务流程。&lt;/p>
&lt;p>单 Reactor 单进程的模式优点就是很简单，没有进程间通信，没有进程竞争，全部都在同一个进程内完成。但其缺点也是非常明显，具体表现有：&lt;/p>
&lt;p>1、只有一个进程，无法发挥多核 CPU 的性能；只能采取部署多个系统来利用多核 CPU，但这样会带来运维复杂度，本来只要维护一个系统，用这种方式需要在一台机器上维护多套系统。&lt;/p>
&lt;p>2、Handler 在处理某个连接上的业务时，整个进程无法处理其他连接的事件，很容易导致性能瓶颈。&lt;/p>
&lt;p>因此，单 Reactor 单进程的方案在实践中应用场景不多，只适用于业务处理非常快速的场景，目前比较著名的开源软件中使用单 Reactor 单进程的是 Redis。&lt;/p>
&lt;p>需要注意的是，C 语言编写系统的一般使用单 Reactor 单进程，因为没有必要在进程中再创建线程；而 Java 语言编写的一般使用单 Reactor 单线程，因为 Java 虚拟机是一个进程，虚拟机中有很多线程，业务线程只是其中的一个线程而已。&lt;/p>
&lt;h4 id="单reactor多进程">单Reactor多进程&lt;/h4>
&lt;p>为了克服单 Reactor 单进程 / 线程方案的缺点，引入多进程 / 多线程是显而易见的，这就产生了第 2 个方案：单 Reactor 多线程。&lt;/p>
&lt;p>单 Reactor 多线程方案示意图是：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_15.png" alt="architecture-high-performance_15.png">&lt;/p>
&lt;p>方案介绍：&lt;/p>
&lt;p>1、主线程中，Reactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行分发。&lt;/p>
&lt;p>2、如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。&lt;/p>
&lt;p>3、如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler（第 2 步中创建的 Handler）来进行响应。&lt;/p>
&lt;p>4、Handler 只负责响应事件，不进行业务处理；Handler 通过 read 读取到数据后，会发给 Processor 进行业务处理。&lt;/p>
&lt;p>5、Processor 会在独立的子线程中完成真正的业务处理，然后将响应结果发给主进程的 Handler 处理；Handler 收到响应后通过 send 将响应结果返回给 client。&lt;/p>
&lt;p>单 Reator 多线程方案能够充分利用多核多 CPU 的处理能力，但同时也存在下面的问题：&lt;/p>
&lt;p>1、多线程数据共享和访问比较复杂。例如，子线程完成业务处理后，要把结果传递给主线程的 Reactor 进行发送，这里涉及共享数据的互斥和保护机制。以 Java 的 NIO 为例，Selector 是线程安全的，但是通过 Selector.selectKeys() 返回的键的集合是非线程安全的，对 selected keys 的处理必须单线程处理或者采取同步措施进行保护。&lt;/p>
&lt;p>2、Reactor 承担所有事件的监听和响应，只在主线程中运行，瞬间高并发时会成为性能瓶颈。&lt;/p>
&lt;p>这里只列出了“单 Reactor 多线程”方案，没有列出“单 Reactor 多进程”方案，主要原因在于如果采用多进程，子进程完成业务处理后，将结果返回给父进程，并通知父进程发送给哪个 client，这是很麻烦的事情。因为父进程只是通过 Reactor 监听各个连接上的事件然后进行分配，子进程与父进程通信时并不是一个连接。如果要将父进程和子进程之间的通信模拟为一个连接，并加入 Reactor 进行监听，则是比较复杂的。而采用多线程时，因为多线程是共享数据的，因此线程间通信是非常方便的。虽然要额外考虑线程间共享数据时的同步问题，但这个复杂度比进程间通信的复杂度要低很多。&lt;/p>
&lt;h4 id="多reactor多进程-线程">多Reactor多进程/线程&lt;/h4>
&lt;p>为了解决单 Reactor 多线程的问题，最直观的方法就是将单 Reactor 改为多 Reactor，这就产生了第 3 个方案：多 Reactor 多进程 / 线程。&lt;/p>
&lt;p>多 Reactor 多进程 / 线程方案示意图是（以进程为例）：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_16.png" alt="architecture-high-performance_16.png">&lt;/p>
&lt;p>方案详细说明如下：&lt;/p>
&lt;p>1、父进程中 mainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 接收，将新的连接分配给某个子进程。&lt;/p>
&lt;p>2、子进程的 subReactor 将 mainReactor 分配的连接加入连接队列进行监听，并创建一个 Handler 用于处理连接的各种事件。&lt;/p>
&lt;p>4、当有新的事件发生时，subReactor 会调用连接对应的 Handler（即第 2 步中创建的 Handler）来进行响应。&lt;/p>
&lt;p>5、Handler 完成 read→业务处理→send 的完整业务流程。&lt;/p>
&lt;p>多 Reactor 多进程 / 线程的方案看起来比单 Reactor 多线程要复杂，但实际实现时反而更加简单，主要原因是：&lt;/p>
&lt;p>1、父进程和子进程的职责非常明确，父进程只负责接收新连接，子进程负责完成后续的业务处理。&lt;/p>
&lt;p>2、父进程和子进程的交互很简单，父进程只需要把新连接传给子进程，子进程无须返回数据。&lt;/p>
&lt;p>3、子进程之间是互相独立的，无须同步共享之类的处理（这里仅限于网络模型相关的 select、read、send 等无须同步共享，“业务处理”还是有可能需要同步共享的）。&lt;/p>
&lt;p>目前著名的开源系统 Nginx 采用的是多 Reactor 多进程，采用多 Reactor 多线程的实现有 Memcache 和 Netty。&lt;/p>
&lt;p>Nginx 采用的是多 Reactor 多进程的模式，但方案与标准的多 Reactor 多进程有差异。具体差异表现为主进程中仅仅创建了监听端口，并没有创建 mainReactor 来“accept”连接，而是由子进程的 Reactor 来“accept”连接，通过锁来控制一次只有一个子进程进行“accept”，子进程“accept”新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程，更多细节请查阅相关资料或阅读 Nginx 源码。&lt;/p>
&lt;h3 id="proactor">Proactor&lt;/h3>
&lt;p>Reactor 是非阻塞同步网络模型，因为真正的 read 和 send 操作都需要用户进程同步操作。这里的“同步”指用户进程在执行 read 和 send 这类 I/O 操作的时候是同步的，如果把 I/O 操作改为异步就能够进一步提升性能，这就是异步网络模型 Proactor。&lt;/p>
&lt;p>Proactor 中文翻译为“前摄器”比较难理解，与其类似的单词是 proactive，含义为“主动的”，因此我们照猫画虎翻译为“主动器”反而更好理解。Reactor 可以理解为“来了事件我通知你，你来处理”，而 Proactor 可以理解为“来了事件我来处理，处理完了我通知你”。这里的“我”就是操作系统内核，“事件”就是有新连接、有数据可读、有数据可写的这些 I/O 事件，“你”就是我们的程序代码。&lt;/p>
&lt;p>Proactor 模型示意图是：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_17.png" alt="architecture-high-performance_17.png">&lt;/p>
&lt;p>详细介绍一下 Proactor 方案：&lt;/p>
&lt;p>1、Proactor Initiator 负责创建 Proactor 和 Handler，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核。&lt;/p>
&lt;p>2、Asynchronous Operation Processor 负责处理注册请求，并完成 I/O 操作。&lt;/p>
&lt;p>3、Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor。&lt;/p>
&lt;p>4、Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理。&lt;/p>
&lt;p>5、Handler 完成业务处理，Handler 也可以注册新的 Handler 到内核进程。&lt;/p>
&lt;p>理论上 Proactor 比 Reactor 效率要高一些，异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠，但要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O，而在 Linux 系统下的 AIO 并不完善，因此在 Linux 下实现高并发网络编程时都是以 Reactor 模式为主。所以即使 Boost.Asio 号称实现了 Proactor 模型，其实它在 Windows 下采用 IOCP，而在 Linux 下是用 Reactor 模式（采用 epoll）模拟出来的异步模型。&lt;/p>
&lt;h2 id="高性能负载均衡-分类及架构">高性能负载均衡：分类及架构&lt;/h2>
&lt;p>单服务器无论如何优化，无论采用多好的硬件，总会有一个性能天花板，当单服务器的性能无法满足业务需求时，就需要设计高性能集群来提升系统整体的处理性能。&lt;/p>
&lt;p>高性能集群的本质很简单，通过增加更多的服务器来提升系统整体的计算能力。由于计算本身存在一个特点：同样的输入数据和逻辑，无论在哪台服务器上执行，都应该得到相同的输出。因此高性能集群设计的复杂度主要体现在任务分配这部分，需要设计合理的任务分配策略，将计算任务分配到多台服务器上执行。&lt;/p>
&lt;p>&lt;strong>高性能集群的复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法&lt;/strong>。对于任务分配器，现在更流行的通用叫法是“负载均衡器”。但这个名称有一定的误导性，会让人潜意识里认为任务分配的目的是要保持各个计算单元的负载达到均衡状态。而实际上任务分配并不只是考虑计算单元的负载均衡，不同的任务分配算法目标是不一样的，有的基于负载考虑，有的基于性能（吞吐量、响应时间）考虑，有的基于业务考虑。考虑到“负载均衡”已经成为了事实上的标准术语，这里我也用“负载均衡”来代替“任务分配”，但请时刻记住，&lt;strong>负载均衡不只是为了计算单元的负载达到均衡状态&lt;/strong>。&lt;/p>
&lt;h3 id="负载均衡分类">负载均衡分类&lt;/h3>
&lt;p>常见的负载均衡系统包括 3 种：DNS 负载均衡、硬件负载均衡和软件负载均衡。&lt;/p>
&lt;h4 id="dns-负载均衡">DNS 负载均衡&lt;/h4>
&lt;p>DNS 是最简单也是最常见的负载均衡方式，一般用来实现地理级别的均衡。例如，北方的用户访问北京的机房，南方的用户访问深圳的机房。DNS 负载均衡的本质是 DNS 解析同一个域名可以返回不同的 IP 地址。例如，同样是 &lt;a href="https://www.baidu.com">www.baidu.com&lt;/a>，北方用户解析后获取的地址是 61.135.165.224（这是北京机房的 IP），南方用户解析后获取的地址是 14.215.177.38（这是深圳机房的 IP）。&lt;/p>
&lt;p>下面是 DNS 负载均衡的简单示意图：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_18.png" alt="architecture-high-performance_18.png">&lt;/p>
&lt;p>DNS 负载均衡实现简单、成本低，但也存在粒度太粗、负载均衡算法少等缺点。仔细分析一下优缺点，其优点有：&lt;/p>
&lt;p>1、简单、成本低：负载均衡工作交给 DNS 服务器处理，无须自己开发或者维护负载均衡设备。&lt;/p>
&lt;p>2、就近访问，提升访问速度：DNS 解析时可以根据请求来源 IP，解析成距离用户最近的服务器地址，可以加快访问速度，改善性能。&lt;/p>
&lt;p>缺点有：&lt;/p>
&lt;p>1、更新不及时：DNS 缓存的时间比较长，修改 DNS 配置后，由于缓存的原因，还是有很多用户会继续访问修改前的 IP，这样的访问会失败，达不到负载均衡的目的，并且也影响用户正常使用业务。&lt;/p>
&lt;p>2、扩展性差：DNS 负载均衡的控制权在域名商那里，无法根据业务特点针对其做更多的定制化功能和扩展特性。&lt;/p>
&lt;p>3、分配策略比较简单：DNS 负载均衡支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）；也无法感知后端服务器的状态。&lt;/p>
&lt;p>针对 DNS 负载均衡的一些缺点，对于时延和故障敏感的业务，有一些公司自己实现了 HTTP-DNS 的功能，即使用 HTTP 协议实现一个私有的 DNS 系统。这样的方案和通用的 DNS 优缺点正好相反。&lt;/p>
&lt;h4 id="硬件负载均衡">硬件负载均衡&lt;/h4>
&lt;p>硬件负载均衡是通过单独的硬件设备来实现负载均衡功能，这类设备和路由器、交换机类似，可以理解为一个用于负载均衡的基础网络设备。目前业界典型的硬件负载均衡设备有两款：F5 和 A10。这类设备性能强劲、功能强大，但价格都不便宜，一般只有“土豪”公司才会考虑使用此类设备。普通业务量级的公司一是负担不起，二是业务量没那么大，用这些设备也是浪费。&lt;/p>
&lt;p>硬件负载均衡的优点是：&lt;/p>
&lt;p>1、功能强大：全面支持各层级的负载均衡，支持全面的负载均衡算法，支持全局负载均衡。&lt;/p>
&lt;p>2、性能强大：对比一下，软件负载均衡支持到 10 万级并发已经很厉害了，硬件负载均衡可以支持 100 万以上的并发。&lt;/p>
&lt;p>3、稳定性高：商用硬件负载均衡，经过了良好的严格测试，经过大规模使用，稳定性高。&lt;/p>
&lt;p>4、支持安全防护：硬件均衡设备除具备负载均衡功能外，还具备防火墙、防 DDoS 攻击等安全功能。&lt;/p>
&lt;p>硬件负载均衡的缺点是：&lt;/p>
&lt;p>1、价格昂贵：最普通的一台 F5 就是一台“马 6”，好一点的就是“Q7”了。&lt;/p>
&lt;p>2、扩展能力差：硬件设备，可以根据业务进行配置，但无法进行扩展和定制。&lt;/p>
&lt;h4 id="软件负载均衡">软件负载均衡&lt;/h4>
&lt;p>软件负载均衡通过负载均衡软件来实现负载均衡功能，常见的有 Nginx 和 LVS，其中 Nginx 是软件的 7 层负载均衡，LVS 是 Linux 内核的 4 层负载均衡。4 层和 7 层的区别就在于协议和灵活性，Nginx 支持 HTTP、E-mail 协议；而 LVS 是 4 层负载均衡，和协议无关，几乎所有应用都可以做，例如，聊天、数据库等。&lt;/p>
&lt;p>软件和硬件的最主要区别就在于性能，硬件负载均衡性能远远高于软件负载均衡性能。Nginx 的性能是万级，一般的 Linux 服务器上装一个 Nginx 大概能到 5 万 / 秒；LVS 的性能是十万级，据说可达到 80 万 / 秒；而 F5 性能是百万级，从 200 万 / 秒到 800 万 / 秒都有（数据来源网络，仅供参考，如需采用请根据实际业务场景进行性能测试）。当然，软件负载均衡的最大优势是便宜，一台普通的 Linux 服务器批发价大概就是 1 万元左右，相比 F5 的价格，那就是自行车和宝马的区别了。&lt;/p>
&lt;p>除了使用开源的系统进行负载均衡，如果业务比较特殊，也可能基于开源系统进行定制（例如，Nginx 插件），甚至进行自研。&lt;/p>
&lt;p>下面是 Nginx 的负载均衡架构示意图：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_19.png" alt="architecture-high-performance_19.png">&lt;/p>
&lt;p>软件负载均衡的优点：&lt;/p>
&lt;p>1、简单：无论是部署还是维护都比较简单。&lt;/p>
&lt;p>2、便宜：只要买个 Linux 服务器，装上软件即可。&lt;/p>
&lt;p>3、灵活：4 层和 7 层负载均衡可以根据业务进行选择；也可以根据业务进行比较方便的扩展，例如，可以通过 Nginx 的插件来实现业务的定制化功能。&lt;/p>
&lt;p>其实下面的缺点都是和硬件负载均衡相比的，并不是说软件负载均衡没法用。&lt;/p>
&lt;p>1、性能一般：一个 Nginx 大约能支撑 5 万并发。&lt;/p>
&lt;p>2、功能没有硬件负载均衡那么强大。&lt;/p>
&lt;p>3、一般不具备防火墙和防 DDoS 攻击等安全功能。&lt;/p>
&lt;h3 id="负载均衡典型架构">负载均衡典型架构&lt;/h3>
&lt;p>前面介绍了 3 种常见的负载均衡机制：DNS 负载均衡、硬件负载均衡、软件负载均衡，每种方式都有一些优缺点，但并不意味着在实际应用中只能基于它们的优缺点进行非此即彼的选择，反而是基于它们的优缺点进行组合使用。具体来说，组合的基本原则为：DNS 负载均衡用于实现地理级别的负载均衡；硬件负载均衡用于实现集群级别的负载均衡；软件负载均衡用于实现机器级别的负载均衡。&lt;/p>
&lt;p>以一个假想的实例来说明一下这种组合方式，如下图所示。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-performance_20.png" alt="architecture-high-performance_20.png">&lt;/p>
&lt;p>整个系统的负载均衡分为三层。&lt;/p>
&lt;p>1、地理级别负载均衡：&lt;a href="https://www.xxx.com">www.xxx.com&lt;/a> 部署在北京、广州、上海三个机房，当用户访问时，DNS 会根据用户的地理位置来决定返回哪个机房的 IP，图中返回了广州机房的 IP 地址，这样用户就访问到广州机房了。&lt;/p>
&lt;p>2、集群级别负载均衡：广州机房的负载均衡用的是 F5 设备，F5 收到用户请求后，进行集群级别的负载均衡，将用户请求发给 3 个本地集群中的一个，我们假设 F5 将用户请求发给了“广州集群 2”。&lt;/p>
&lt;p>3、机器级别的负载均衡：广州集群 2 的负载均衡用的是 Nginx，Nginx 收到用户请求后，将用户请求发送给集群里面的某台服务器，服务器处理用户的业务请求并返回业务响应。&lt;/p>
&lt;p>需要注意的是，上图只是一个示例，一般在大型业务场景下才会这样用，如果业务量没这么大，则没有必要严格照搬这套架构。例如，一个大学的论坛，完全可以不需要 DNS 负载均衡，也不需要 F5 设备，只需要用 Nginx 作为一个简单的负载均衡就足够了。&lt;/p>
&lt;h2 id="高性能负载均衡-算法">高性能负载均衡：算法&lt;/h2>
&lt;p>负载均衡算法数量较多，而且可以根据一些业务特性进行定制开发，抛开细节上的差异，根据算法期望达到的目的，大体上可以分为下面几类。&lt;/p>
&lt;p>1、任务平分类：负载均衡系统将收到的任务平均分配给服务器进行处理，这里的“平均”可以是绝对数量的平均，也可以是比例或者权重上的平均。&lt;/p>
&lt;p>2、负载均衡类：负载均衡系统根据服务器的负载来进行分配，这里的负载并不一定是通常意义上我们说的“CPU 负载”，而是系统当前的压力，可以用 CPU 负载来衡量，也可以用连接数、I/O 使用率、网卡吞吐量等来衡量系统的压力。&lt;/p>
&lt;p>3、性能最优类：负载均衡系统根据服务器的响应时间来进行任务分配，优先将新任务分配给响应最快的服务器。&lt;/p>
&lt;p>4、Hash 类：负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上。常见的有源地址 Hash、目标地址 Hash、session id hash、用户 ID Hash 等。&lt;/p>
&lt;p>接下来介绍一下负载均衡算法以及它们的优缺点。&lt;/p>
&lt;h3 id="轮询">轮询&lt;/h3>
&lt;p>负载均衡系统收到请求后，按照顺序轮流分配到服务器上。&lt;/p>
&lt;p>轮询是最简单的一个策略，无须关注服务器本身的状态，例如：&lt;/p>
&lt;p>1、某个服务器当前因为触发了程序 bug 进入了死循环导致 CPU 负载很高，负载均衡系统是不感知的，还是会继续将请求源源不断地发送给它。&lt;/p>
&lt;p>2、集群中有新的机器是 32 核的，老的机器是 16 核的，负载均衡系统也是不关注的，新老机器分配的任务数是一样的。&lt;/p>
&lt;p>需要注意的是负载均衡系统无须关注“服务器本身状态”，这里的关键词是“本身”。也就是说，只要服务器在运行，运行状态是不关注的。但如果服务器直接宕机了，或者服务器和负载均衡系统断连了，这时负载均衡系统是能够感知的，也需要做出相应的处理。例如，将服务器从可分配服务器列表中删除，否则就会出现服务器都宕机了，任务还不断地分配给它，这明显是不合理的。&lt;/p>
&lt;p>总而言之，“简单”是轮询算法的优点，也是它的缺点。&lt;/p>
&lt;h3 id="加权轮询">加权轮询&lt;/h3>
&lt;p>负载均衡系统根据服务器权重进行任务分配，这里的权重一般是根据硬件配置进行静态配置的，采用动态的方式计算会更加契合业务，但复杂度也会更高。&lt;/p>
&lt;p>加权轮询是轮询的一种特殊形式，其主要目的就是为了解决不同服务器处理能力有差异的问题。例如，集群中有新的机器是 32 核的，老的机器是 16 核的，那么理论上我们可以假设新机器的处理能力是老机器的 2 倍，负载均衡系统就可以按照 2:1 的比例分配更多的任务给新机器，从而充分利用新机器的性能。&lt;/p>
&lt;p>加权轮询解决了轮询算法中无法根据服务器的配置差异进行任务分配的问题，但同样存在无法根据服务器的状态差异进行任务分配的问题。&lt;/p>
&lt;h3 id="负载最低优先">负载最低优先&lt;/h3>
&lt;p>负载均衡系统将任务分配给当前负载最低的服务器，这里的负载根据不同的任务类型和业务场景，可以用不同的指标来衡量。例如：&lt;/p>
&lt;p>1、LVS 这种 4 层网络负载均衡设备，可以以“连接数”来判断服务器的状态，服务器连接数越大，表明服务器压力越大。&lt;/p>
&lt;p>2、Nginx 这种 7 层网络负载系统，可以以“HTTP 请求数”来判断服务器状态（Nginx 内置的负载均衡算法不支持这种方式，需要进行扩展）。&lt;/p>
&lt;p>3、如果自己开发负载均衡系统，可以根据业务特点来选择指标衡量系统压力。如果是 CPU 密集型，可以以“CPU 负载”来衡量系统压力；如果是 I/O 密集型，可以以“I/O 负载”来衡量系统压力。&lt;/p>
&lt;p>负载最低优先的算法解决了轮询算法中无法感知服务器状态的问题，由此带来的代价是复杂度要增加很多。例如：&lt;/p>
&lt;p>1、最少连接数优先的算法要求负载均衡系统统计每个服务器当前建立的连接，其应用场景仅限于负载均衡接收的任何连接请求都会转发给服务器进行处理，否则如果负载均衡系统和服务器之间是固定的连接池方式，就不适合采取这种算法。例如，LVS 可以采取这种算法进行负载均衡，而一个通过连接池的方式连接 MySQL 集群的负载均衡系统就不适合采取这种算法进行负载均衡。&lt;/p>
&lt;p>2、CPU 负载最低优先的算法要求负载均衡系统以某种方式收集每个服务器的 CPU 负载，而且要确定是以 1 分钟的负载为标准，还是以 15 分钟的负载为标准，不存在 1 分钟肯定比 15 分钟要好或者差。不同业务最优的时间间隔是不一样的，时间间隔太短容易造成频繁波动，时间间隔太长又可能造成峰值来临时响应缓慢。&lt;/p>
&lt;p>负载最低优先算法基本上能够比较完美地解决轮询算法的缺点，因为采用这种算法后，负载均衡系统需要感知服务器当前的运行状态。当然，其代价是复杂度大幅上升。通俗来讲，轮询可能是 5 行代码就能实现的算法，而负载最低优先算法可能要 1000 行才能实现，甚至需要负载均衡系统和服务器都要开发代码。负载最低优先算法如果本身没有设计好，或者不适合业务的运行特点，算法本身就可能成为性能的瓶颈，或者引发很多莫名其妙的问题。所以负载最低优先算法虽然效果看起来很美好，但实际上真正应用的场景反而没有轮询（包括加权轮询）那么多。&lt;/p>
&lt;h3 id="性能最优类">性能最优类&lt;/h3>
&lt;p>负载最低优先类算法是站在服务器的角度来进行分配的，而性能最优优先类算法则是站在客户端的角度来进行分配的，优先将任务分配给处理速度最快的服务器，通过这种方式达到最快响应客户端的目的。&lt;/p>
&lt;p>和负载最低优先类算法类似，性能最优优先类算法本质上也是感知了服务器的状态，只是通过响应时间这个外部标准来衡量服务器状态而已。因此性能最优优先类算法存在的问题和负载最低优先类算法类似，复杂度都很高，主要体现在：&lt;/p>
&lt;p>1、负载均衡系统需要收集和分析每个服务器每个任务的响应时间，在大量任务处理的场景下，这种收集和统计本身也会消耗较多的性能。&lt;/p>
&lt;p>2、为了减少这种统计上的消耗，可以采取采样的方式来统计，即不统计所有任务的响应时间，而是抽样统计部分任务的响应时间来估算整体任务的响应时间。采样统计虽然能够减少性能消耗，但使得复杂度进一步上升，因为要确定合适的采样率，采样率太低会导致结果不准确，采样率太高会导致性能消耗较大，找到合适的采样率也是一件复杂的事情。&lt;/p>
&lt;p>3、无论是全部统计还是采样统计，都需要选择合适的周期：是 10 秒内性能最优，还是 1 分钟内性能最优，还是 5 分钟内性能最优……没有放之四海而皆准的周期，需要根据实际业务进行判断和选择，这也是一件比较复杂的事情，甚至出现系统上线后需要不断地调优才能达到最优设计。&lt;/p>
&lt;h3 id="hash类">Hash类&lt;/h3>
&lt;p>负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上，这样做的目的主要是为了满足特定的业务需求。例如：&lt;/p>
&lt;p>1、源地址 Hash&lt;/p>
&lt;p>将来源于同一个源 IP 地址的任务分配给同一个服务器进行处理，适合于存在事务、会话的业务。&lt;/p>
&lt;p>2、ID Hash&lt;/p>
&lt;p>将某个 ID 标识的业务分配到同一个服务器中进行处理，这里的 ID 一般是临时性数据的 ID（如 session id）。&lt;/p></description></item><item><title>Docs: 架构设计03-高可用架构模式</title><link>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A103-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A103-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;h2 id="高可用架构-cap理论">高可用架构-CAP理论&lt;/h2>
&lt;p>CAP 定理（CAP theorem）又被称作布鲁尔定理（Brewer's theorem），是加州大学伯克利分校的计算机科学家埃里克·布鲁尔（Eric Brewer）在 2000 年的 ACM PODC 上提出的一个猜想。2002 年，麻省理工学院的赛斯·吉尔伯特（Seth Gilbert）和南希·林奇（Nancy Lynch）发表了布鲁尔猜想的证明，使之成为分布式计算领域公认的一个定理。&lt;strong>对于设计分布式系统的架构师来说，CAP 是必须掌握的理论。&lt;/strong>&lt;/p>
&lt;p>布鲁尔在提出 CAP 猜想的时候，并没有详细定义 Consistency、Availability、Partition Tolerance 三个单词的明确定义。不同资料对 CAP 的详细定义有一些细微的差别。&lt;/p>
&lt;p>为了更好地解释 CAP 理论，这里挑选了 Robert Greiner（&lt;a href="http://robertgreiner.com/about/">http://robertgreiner.com/about/&lt;/a>）的文章作为参考基础。Robert Greiner 对 CAP 的理解也经历了一个过程，他写了两篇文章来阐述 CAP 理论，第一篇被标记为“outdated”（有一些中文翻译文章正好参考了第一篇），这里将对比前后两篇解释的差异点，通过对比帮助更加深入地理解 CAP 理论。&lt;/p>
&lt;h3 id="cap理论">CAP理论&lt;/h3>
&lt;p>第一版解释：&lt;/p>
&lt;p>Any distributed system cannot guaranty C, A, and P simultaneously.（&lt;a href="http://robertgreiner.com/2014/06/cap-theorem-explained/">http://robertgreiner.com/2014/06/cap-theorem-explained/&lt;/a>）&lt;/p>
&lt;p>简单翻译为：对于一个分布式计算系统，不可能同时满足一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三个设计约束。&lt;/p>
&lt;p>第二版解释：&lt;/p>
&lt;p>In a distributed system (a collection of interconnected nodes that share data.), you can only have two out of the following three guarantees across a write/read pair: Consistency, Availability, and Partition Tolerance - one of them must be sacrificed.（&lt;a href="http://robertgreiner.com/2014/08/cap-theorem-revisited/">http://robertgreiner.com/2014/08/cap-theorem-revisited/&lt;/a>）&lt;/p>
&lt;p>简单翻译为：在一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。&lt;/p>
&lt;p>对比两个版本的定义，有几个很关键的差异点：&lt;/p>
&lt;p>1、第二版定义了什么才是 CAP 理论探讨的分布式系统，强调了两点：interconnected 和 share data，因为分布式系统并不一定会互联和共享数据。最简单的例如 Memcache 的集群，相互之间就没有连接和共享数据，因此 Memcache 集群这类分布式系统就不符合 CAP 理论探讨的对象；而 MySQL 集群就是互联和进行数据复制的，因此是 CAP 理论探讨的对象。&lt;/p>
&lt;p>2、第二版强调了 write/read pair，这点其实是和上一个差异点一脉相承的。也就是说，CAP 关注的是对数据的读写操作，而不是分布式系统的所有功能。例如，ZooKeeper 的选举机制就不是 CAP 探讨的对象。&lt;/p>
&lt;p>相对来说第二版的定义和解释更加严谨，但内容相比第一版来说更加难记一些，所以现在大部分技术人员谈论 CAP 理论时，更多还是按照第一版的定义和解释来说的，虽然第一版不严谨，但非常简单和容易记住。&lt;/p>
&lt;p>第二版除了基本概念，三个基本的设计约束也进行了重新阐述：&lt;/p>
&lt;h4 id="一致性">一致性&lt;/h4>
&lt;p>（Consistency）&lt;/p>
&lt;p>第一版解释：All nodes see the same data at the same time.（所有节点在同一时刻都能看到相同的数据。）&lt;/p>
&lt;p>第二版解释：A read is guaranteed to return the most recent write for a given client.（对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。）&lt;/p>
&lt;p>第一版解释和第二版解释的主要差异点表现在：&lt;/p>
&lt;p>1、第一版从节点 node 的角度描述，第二版从客户端 client 的角度描述。&lt;/p>
&lt;p>相比来说，第二版更加符合我们观察和评估系统的方式，即站在客户端的角度来观察系统的行为和特征。&lt;/p>
&lt;p>2、第一版的关键词是 see，第二版的关键词是 read。&lt;/p>
&lt;p>第一版解释中的 see，其实并不确切，因为节点 node 是拥有数据，而不是看到数据，即使要描述也是用 have；第二版从客户端 client 的读写角度来描述一致性，定义更加精确。&lt;/p>
&lt;p>3、第一版强调同一时刻拥有相同数据（same time + same data），第二版并没有强调这点。&lt;/p>
&lt;p>这就意味着实际上对于节点来说，可能同一时刻拥有不同数据（same time + different data），这和我们通常理解的一致性是有差异的，为何做这样的改动呢？其实在第一版的详细解释中已经提到了，具体内容如下：&lt;/p>
&lt;p>A system has consistency if a transaction starts with the system in a consistent state, and ends with the system in a consistent state. In this model, a system can (and does) shift into an inconsistent state during a transaction, but the entire transaction gets rolled back if there is an error during any stage in the process.&lt;/p>
&lt;p>参考上述的解释，对于系统执行事务来说，在事务执行过程中，系统其实处于一个不一致的状态，不同的节点的数据并不完全一致，因此第一版的解释“All nodes see the same data at the same time”是不严谨的。而第二版强调 client 读操作能够获取最新的写结果就没有问题，因为事务在执行过程中，client 是无法读取到未提交的数据的，只有等到事务提交后，client 才能读取到事务写入的数据，而如果事务失败则会进行回滚，client 也不会读取到事务中间写入的数据。&lt;/p>
&lt;h4 id="可用性">可用性&lt;/h4>
&lt;p>（Availability）&lt;/p>
&lt;p>第一版解释：Every request gets a response on success/failure.&lt;/p>
&lt;p>简单翻译为：每个请求都能得到成功或者失败的响应。&lt;/p>
&lt;p>第二版解释：A non-failing node will return a reasonable response within a reasonable amount of time (no error or timeout).&lt;/p>
&lt;p>简单翻译为：非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）。&lt;/p>
&lt;p>第一版解释和第二版解释主要差异点表现在：&lt;/p>
&lt;p>1、第一版是 every request，第二版强调了 A non-failing node。&lt;/p>
&lt;p>第一版的 every request 是不严谨的，因为只有非故障节点才能满足可用性要求，如果节点本身就故障了，发给节点的请求不一定能得到一个响应。&lt;/p>
&lt;p>2、第一版的 response 分为 success 和 failure，第二版用了两个 reasonable：reasonable response 和 reasonable time，而且特别强调了 no error or timeout。&lt;/p>
&lt;p>第一版的 success/failure 的定义太泛了，几乎任何情况，无论是否符合 CAP 理论，我们都可以说请求成功和失败，因为超时也算失败、错误也算失败、异常也算失败、结果不正确也算失败；即使是成功的响应，也不一定是正确的。例如，本来应该返回 100，但实际上返回了 90，这就是成功的响应，但并没有得到正确的结果。相比之下，第二版的解释明确了不能超时、不能出错，结果是合理的，注意没有说“正确”的结果。例如，应该返回 100 但实际上返回了 90，肯定是不正确的结果，但可以是一个合理的结果。&lt;/p>
&lt;h4 id="分区容忍性">分区容忍性&lt;/h4>
&lt;p>（Partition Tolerance）&lt;/p>
&lt;p>第一版解释：System continues to work despite message loss or partial failure.&lt;/p>
&lt;p>简单翻译为：出现消息丢失或者分区错误时系统能够继续运行。&lt;/p>
&lt;p>第二版解释：The system will continue to function when network partitions occur.&lt;/p>
&lt;p>简单翻译为：当出现网络分区后，系统能够继续“履行职责”。&lt;/p>
&lt;p>第一版解释和第二版解释主要差异点表现在：&lt;/p>
&lt;p>1、第一版用的是 work，第二版用的是 function。&lt;/p>
&lt;p>work 强调“运行”，只要系统不宕机，我们都可以说系统在 work，返回错误也是 work，拒绝服务也是 work；而 function 强调“发挥作用”“履行职责”，这点和可用性是一脉相承的。也就是说，只有返回 reasonable response 才是 function。相比之下，第二版解释更加明确。&lt;/p>
&lt;p>2、第一版描述分区用的是 message loss or partial failure，第二版直接用 network partitions。&lt;/p>
&lt;p>对比两版解释，第一版是直接说原因，即 message loss 造成了分区，但 message loss 的定义有点狭隘，因为通常我们说的 message loss（丢包），只是网络故障中的一种；第二版直接说现象，即发生了分区现象，不管是什么原因，可能是丢包，也可能是连接中断，还可能是拥塞，只要导致了网络分区，就通通算在里面。&lt;/p>
&lt;h3 id="cap应用">CAP应用&lt;/h3>
&lt;p>虽然 CAP 理论定义是三个要素中只能取两个，但放到分布式环境下来思考，我们会发现必须选择 P（分区容忍）要素，因为网络本身无法做到 100% 可靠，有可能出故障，所以分区是一个必然的现象。如果我们选择了 CA 而放弃了 P，那么当发生分区现象时，为了保证 C，系统需要禁止写入，当有写入请求时，系统返回 error（例如，当前系统不允许写入），这又和 A 冲突了，因为 A 要求返回 no error 和 no timeout。因此，分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。&lt;/p>
&lt;h4 id="cp">CP&lt;/h4>
&lt;p>Consistency/Partition Tolerance&lt;/p>
&lt;p>如下图所示，为了保证一致性，当发生分区现象后，N1 节点上的数据已经更新到 y，但由于 N1 和 N2 之间的复制通道中断，数据 y 无法同步到 N2，N2 节点上的数据还是 x。这时客户端 C 访问 N2 时，N2 需要返回 Error，提示客户端 C“系统现在发生了错误”，这种处理方式违背了可用性（Availability）的要求，因此 CAP 三者只能满足 CP。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_1.png" alt="architecture-high-availability_1.png">&lt;/p>
&lt;h4 id="ap">AP&lt;/h4>
&lt;p>Availability/Partition Tolerance&lt;/p>
&lt;p>如下图所示，为了保证可用性，当发生分区现象后，N1 节点上的数据已经更新到 y，但由于 N1 和 N2 之间的复制通道中断，数据 y 无法同步到 N2，N2 节点上的数据还是 x。这时客户端 C 访问 N2 时，N2 将当前自己拥有的数据 x 返回给客户端 C 了，而实际上当前最新的数据已经是 y 了，这就不满足一致性（Consistency）的要求了，因此 CAP 三者只能满足 AP。注意：这里 N2 节点返回 x，虽然不是一个“正确”的结果，但是一个“合理”的结果，因为 x 是旧的数据，并不是一个错乱的值，只是不是最新的数据而已。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_2.png" alt="architecture-high-availability_2.png">&lt;/p>
&lt;h2 id="高可用架构-cap细节">高可用架构-CAP细节&lt;/h2>
&lt;p>当谈到数据一致性时，CAP、ACID、BASE 难免会被我们拿出来讨论，原因在于这三者都是和数据一致性相关的理论，如果不仔细理解三者之间的差别，则可能会陷入一头雾水的状态，不知道应该用哪个才好。&lt;/p>
&lt;h3 id="cap关键细节点">CAP关键细节点&lt;/h3>
&lt;p>埃里克·布鲁尔（Eric Brewer）在《CAP 理论十二年回顾：“规则”变了》（&lt;a href="http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed">http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed&lt;/a>）一文中详细地阐述了理解和应用 CAP 的一些细节点，可能是由于作者写作风格的原因，对于一些非常关键的细节点一句话就带过了，这里我特别提炼出来重点阐述。&lt;/p>
&lt;p>1、CAP 关注的粒度是数据，而不是整个系统。&lt;/p>
&lt;p>原文：C 与 A 之间的取舍可以在同一系统内以非常细小的粒度反复发生，而每一次的决策可能因为具体的操作，乃至因为牵涉到特定的数据或用户而有所不同。&lt;/p>
&lt;p>CAP 理论的定义和解释中，用的都是 system、node 这类系统级的概念，这就给很多人造成了很大的误导，认为我们在进行架构设计时，整个系统要么选择 CP，要么选择 AP。但在实际设计过程中，每个系统不可能只处理一种数据，而是包含多种类型的数据，有的数据必须选择 CP，有的数据必须选择 AP。而如果我们做设计时，从整个系统的角度去选择 CP 还是 AP，就会发现顾此失彼，无论怎么做都是有问题的。&lt;/p>
&lt;p>以一个最简单的用户管理系统为例，用户管理系统包含用户账号数据（用户 ID、密码）、用户信息数据（昵称、兴趣、爱好、性别、自我介绍等）。通常情况下，用户账号数据会选择 CP，而用户信息数据会选择 AP，如果限定整个系统为 CP，则不符合用户信息数据的应用场景；如果限定整个系统为 AP，则又不符合用户账号数据的应用场景。&lt;/p>
&lt;p>所以在 CAP 理论落地实践时，需要将系统内的数据按照不同的应用场景和要求进行分类，每类数据选择不同的策略（CP 还是 AP），而不是直接限定整个系统所有数据都是同一策略。&lt;/p>
&lt;p>2、CAP 是忽略网络延迟的。&lt;/p>
&lt;p>这是一个非常隐含的假设，布鲁尔在定义一致性时，并没有将延迟考虑进去。也就是说，当事务提交时，数据能够瞬间复制到所有节点。但实际情况下，从节点 A 复制数据到节点 B，总是需要花费一定时间的。如果是相同机房，耗费时间可能是几毫秒；如果是跨地域的机房，例如北京机房同步到广州机房，耗费的时间就可能是几十毫秒。这就意味着，CAP 理论中的 C 在实践中是不可能完美实现的，在数据复制的过程中，节点 A 和节点 B 的数据并不一致。&lt;/p>
&lt;p>不要小看了这几毫秒或者几十毫秒的不一致，对于某些严苛的业务场景，例如和金钱相关的用户余额，或者和抢购相关的商品库存，技术上是无法做到分布式场景下完美的一致性的。而业务上必须要求一致性，因此单个用户的余额、单个商品的库存，理论上要求选择 CP 而实际上 CP 都做不到，只能选择 CA。也就是说，只能单点写入，其他节点做备份，无法做到分布式情况下多点写入。&lt;/p>
&lt;p>需要注意的是，这并不意味着这类系统无法应用分布式架构，只是说“单个用户余额、单个商品库存”无法做分布式，但系统整体还是可以应用分布式架构的。例如，下面的架构图是常见的将用户分区的分布式架构。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_3.png" alt="architecture-high-availability_3.png">&lt;/p>
&lt;p>可以将用户 id 为 0 ~ 100 的数据存储在 Node 1，将用户 id 为 101 ~ 200 的数据存储在 Node 2，Client 根据用户 id 来决定访问哪个 Node。对于单个用户来说，读写操作都只能在某个节点上进行；对所有用户来说，有一部分用户的读写操作在 Node 1 上，有一部分用户的读写操作在 Node 2 上。&lt;/p>
&lt;p>这样的设计有一个很明显的问题就是某个节点故障时，这个节点上的用户就无法进行读写操作了，但站在整体上来看，这种设计可以降低节点故障时受影响的用户的数量和范围，毕竟只影响 20% 的用户肯定要比影响所有用户要好。这也是为什么挖掘机挖断光缆后，支付宝只有一部分用户会出现业务异常，而不是所有用户业务异常的原因。&lt;/p>
&lt;p>2、正常运行情况下，不存在 CP 和 AP 的选择，可以同时满足 CA。&lt;/p>
&lt;p>CAP 理论告诉我们分布式系统只能选择 CP 或者 AP，但其实这里的前提是系统发生了“分区”现象。如果系统没有发生分区现象，也就是说 P 不存在的时候（节点间的网络连接一切正常），我们没有必要放弃 C 或者 A，应该 C 和 A 都可以保证，这就要求架构设计的时候既要考虑分区发生时选择 CP 还是 AP，也要考虑分区没有发生时如何保证 CA。&lt;/p>
&lt;p>同样以用户管理系统为例，即使是实现 CA，不同的数据实现方式也可能不一样：用户账号数据可以采用“消息队列”的方式来实现 CA，因为消息队列可以比较好地控制实时性，但实现起来就复杂一些；而用户信息数据可以采用“数据库同步”的方式来实现 CA，因为数据库的方式虽然在某些场景下可能延迟较高，但使用起来简单。&lt;/p>
&lt;p>3、放弃并不等于什么都不做，需要为分区恢复后做准备。&lt;/p>
&lt;p>CAP 理论告诉我们三者只能取两个，需要“牺牲”（sacrificed）另外一个，这里的“牺牲”是有一定误导作用的，因为“牺牲”让很多人理解成什么都不做。实际上，CAP 理论的“牺牲”只是说在分区过程中我们无法保证 C 或者 A，但并不意味着什么都不做。因为在系统整个运行周期中，大部分时间都是正常的，发生分区现象的时间并不长。例如，99.99% 可用性（俗称 4 个 9）的系统，一年运行下来，不可用的时间只有 50 分钟；99.999%（俗称 5 个 9）可用性的系统，一年运行下来，不可用的时间只有 5 分钟。分区期间放弃 C 或者 A，并不意味着永远放弃 C 和 A，可以在分区期间进行一些操作，从而让分区故障解决后，系统能够重新达到 CA 的状态。&lt;/p>
&lt;p>最典型的就是在分区期间记录一些日志，当分区故障解决后，系统根据日志进行数据恢复，使得重新达到 CA 状态。同样以用户管理系统为例，对于用户账号数据，假设选择了 CP，则分区发生后，节点 1 可以继续注册新用户，节点 2 无法注册新用户（这里就是不符合 A 的原因，因为节点 2 收到注册请求后会返回 error），此时节点 1 可以将新注册但未同步到节点 2 的用户记录到日志中。当分区恢复后，节点 1 读取日志中的记录，同步给节点 2，当同步完成后，节点 1 和节点 2 就达到了同时满足 CA 的状态。&lt;/p>
&lt;p>而对于用户信息数据，假设选择了 AP，则分区发生后，节点 1 和节点 2 都可以修改用户信息，但两边可能修改不一样。例如，用户在节点 1 中将爱好改为“旅游、美食、跑步”，然后用户在节点 2 中将爱好改为“美食、游戏”，节点 1 和节点 2 都记录了未同步的爱好数据，当分区恢复后，系统按照某个规则来合并数据。例如，按照“最后修改优先规则”将用户爱好修改为“美食、游戏”，按照“字数最多优先规则”则将用户爱好修改为“旅游，美食、跑步”，也可以完全将数据冲突报告出来，由人工来选择具体应该采用哪一条。&lt;/p>
&lt;h3 id="acid">ACID&lt;/h3>
&lt;p>ACID 是数据库管理系统为了保证事务的正确性而提出来的一个理论，ACID 包含四个约束。&lt;/p>
&lt;p>1、Atomicity（原子性）&lt;/p>
&lt;p>一个事务中的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。&lt;/p>
&lt;p>2、Consistency（一致性）在事务开始之前和事务结束以后，数据库的完整性没有被破坏。&lt;/p>
&lt;p>3、Isolation（隔离性）数据库允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。&lt;/p>
&lt;p>4、Durability（持久性）事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。&lt;/p>
&lt;p>可以看到，ACID 中的 A（Atomicity）和 CAP 中的 A（Availability）意义完全不同，而 ACID 中的 C 和 CAP 中的 C 名称虽然都是一致性，但含义也完全不一样。ACID 中的 C 是指数据库的数据完整性，而 CAP 中的 C 是指分布式节点中的数据一致性。再结合 ACID 的应用场景是数据库事务，CAP 关注的是分布式系统数据读写这个差异点来看，其实 CAP 和 ACID 的对比就类似关公战秦琼，虽然关公和秦琼都是武将，但其实没有太多可比性。&lt;/p>
&lt;h3 id="base">BASE&lt;/h3>
&lt;p>BASE 是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency），核心思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。&lt;/p>
&lt;p>1、基本可用（Basically Available）&lt;/p>
&lt;p>分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。&lt;/p>
&lt;p>这里的关键词是“部分”和“核心”，具体选择哪些作为可以损失的业务，哪些是必须保证的业务，是一项有挑战的工作。例如，对于一个用户管理系统来说，“登录”是核心功能，而“注册”可以算作非核心功能。因为未注册的用户本来就还没有使用系统的业务，注册不了最多就是流失一部分用户，而且这部分用户数量较少。如果用户已经注册但无法登录，那就意味用户无法使用系统。例如，充了钱的游戏不能玩了、云存储不能用了……这些会对用户造成较大损失，而且登录用户数量远远大于新注册用户，影响范围更大。&lt;/p>
&lt;p>2、软状态（Soft State）&lt;/p>
&lt;p>允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。&lt;/p>
&lt;p>3、最终一致性（Eventual Consistency）&lt;/p>
&lt;p>系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。&lt;/p>
&lt;p>这里的关键词是“一定时间” 和 “最终”，“一定时间”和数据的特性是强关联的，不同的数据能够容忍的不一致时间是不同的。举一个微博系统的例子，用户账号数据最好能在 1 分钟内就达到一致状态，因为用户在 A 节点注册或者登录后，1 分钟内不太可能立刻切换到另外一个节点，但 10 分钟后可能就重新登录到另外一个节点了；而用户发布的最新微博，可以容忍 30 分钟内达到一致状态，因为对于用户来说，看不到某个明星发布的最新微博，用户是无感知的，会认为明星没有发布微博。“最终”的含义就是不管多长时间，最终还是要达到一致性的状态。&lt;/p>
&lt;p>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。前面在剖析 CAP 理论时，提到了其实和 BASE 相关的两点：&lt;/p>
&lt;p>1、CAP 理论是忽略延时的，而实际应用中延时是无法避免的。&lt;/p>
&lt;p>这一点就意味着完美的 CP 场景是不存在的，即使是几毫秒的数据复制延迟，在这几毫秒时间间隔内，系统是不符合 CP 要求的。因此 CAP 中的 CP 方案，实际上也是实现了最终一致性，只是“一定时间”是指几毫秒而已。&lt;/p>
&lt;p>2、AP 方案中牺牲一致性只是指分区期间，而不是永远放弃一致性。&lt;/p>
&lt;p>这一点其实就是 BASE 理论延伸的地方，分区期间牺牲一致性，但分区故障恢复后，系统应该达到最终一致性。&lt;/p>
&lt;p>综合上面的分析，ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。&lt;/p>
&lt;h2 id="fmea排查可用性隐患">FMEA排查可用性隐患&lt;/h2>
&lt;h3 id="fmea介绍">FMEA介绍&lt;/h3>
&lt;p>FMEA（Failure mode and effects analysis，故障模式与影响分析）又称为失效模式与后果分析、失效模式与效应分析、故障模式与后果分析等，专栏采用“&lt;strong>故障模式与影响分析&lt;/strong>”，因为这个中文翻译更加符合可用性的语境。FMEA 是一种在各行各业都有广泛应用的可用性分析方法，通过对系统范围内潜在的故障模式加以分析，并按照严重程度进行分类，以确定失效对于系统的最终影响。&lt;/p>
&lt;p>FMEA 最早是在美国军方开始应用的，20 世纪 40 年代后期，美国空军正式采用了 FMEA。尽管最初是在军事领域建立的方法，但 FMEA 方法现在已广泛应用于各种各样的行业，包括半导体加工、餐饮服务、塑料制造、软件及医疗保健行业。FMEA 之所以能够在这些差异很大的领域都得到应用，根本原因在于 FMEA 是一套分析和思考的方法，而不是某个领域的技能或者工具。&lt;/p>
&lt;p>回到软件架构设计领域，FMEA 并不能指导我们如何做架构设计，而是当我们设计出一个架构后，再使用 FMEA 对这个架构进行分析，看看架构是否还存在某些可用性的隐患。&lt;/p>
&lt;h3 id="fmea-方法">FMEA 方法&lt;/h3>
&lt;p>在架构设计领域，FMEA 的具体分析方法是：&lt;/p>
&lt;ul>
&lt;li>给出初始的架构设计图。&lt;/li>
&lt;li>假设架构中某个部件发生故障。&lt;/li>
&lt;li>分析此故障对系统功能造成的影响。&lt;/li>
&lt;li>根据分析结果，判断架构是否需要进行优化。&lt;/li>
&lt;/ul>
&lt;p>FMEA 分析的方法其实很简单，就是一个 FMEA 分析表，常见的 FMEA 分析表格包含下面部分。&lt;/p>
&lt;h4 id="1-功能点">1.功能点&lt;/h4>
&lt;p>当前的 FMEA 分析涉及的功能点，注意这里的“功能点”指的是从用户角度来看的，而不是从系统各个模块功能点划分来看的。例如，对于一个用户管理系统，使用 FMEA 分析时 “登录”“注册”才是功能点，而用户管理系统中的数据库存储功能、Redis 缓存功能不能作为 FMEA 分析的功能点。&lt;/p>
&lt;h4 id="2-故障模式">2.故障模式&lt;/h4>
&lt;p>故障模式指的是系统会出现什么样的故障，包括故障点和故障形式。需要特别注意的是，这里的故障模式并不需要给出真正的故障原因，我们只需要假设出现某种故障现象即可，例如 MySQL 响应时间达到 3 秒。造成 MySQL 响应时间达到 3 秒可能的原因很多：磁盘坏道、慢查询、服务器到 MySQL 的连接网络故障、MySQL bug 等，我们并不需要在故障模式中一一列出来，而是在后面的“故障原因”一节中列出来。因为在实际应用过程中，不管哪种原因，只要现象是一样的，对业务的影响就是一样的。&lt;/p>
&lt;p>此外，故障模式的描述要尽量精确，多使用量化描述，避免使用泛化的描述。例如，推荐使用“MySQL 响应时间达到 3 秒”，而不是“MySQL 响应慢”。&lt;/p>
&lt;h4 id="3-故障影响">3.故障影响&lt;/h4>
&lt;p>当发生故障模式中描述的故障时，功能点具体会受到什么影响。常见的影响有：功能点偶尔不可用、功能点完全不可用、部分用户功能点不可用、功能点响应缓慢、功能点出错等。&lt;/p>
&lt;p>故障影响也需要尽量准确描述。例如，推荐使用“20% 的用户无法登录”，而不是“大部分用户无法登录”。要注意这里的数字不需要完全精确，比如 21.25% 这样的数据其实是没有必要的，我们只需要预估影响是 20% 还是 40%。&lt;/p>
&lt;h4 id="4-严重程度">4.严重程度&lt;/h4>
&lt;p>严重程度指站在业务的角度故障的影响程度，一般分为“致命 / 高 / 中 / 低 / 无”五个档次。严重程度按照这个公式进行评估：严重程度 = 功能点重要程度 × 故障影响范围 × 功能点受损程度。同样以用户管理系统为例：登录功能比修改用户资料要重要得多，80% 的用户比 20% 的用户范围更大，完全无法登录比登录缓慢要更严重。因此我们可以得出如下故障模式的严重程度。&lt;/p>
&lt;ul>
&lt;li>致命：超过 70% 用户无法登录。&lt;/li>
&lt;li>高：超过 30% 的用户无法登录。&lt;/li>
&lt;li>中：所有用户登录时间超过 5 秒。&lt;/li>
&lt;li>低：10% 的用户登录时间超过 5 秒。&lt;/li>
&lt;li>中：所有用户都无法修改资料。&lt;/li>
&lt;li>低：20% 的用户无法修改头像。&lt;/li>
&lt;/ul>
&lt;p>对于某个故障的影响到底属于哪个档次，有时会出现一些争议。例如，“所有用户都无法修改资料”，有的人认为是高，有的人可能认为是中，这个没有绝对标准，一般建议相关人员讨论确定即可。也不建议花费太多时间争论，争执不下时架构师裁定即可。&lt;/p>
&lt;h4 id="5-故障原因">5.故障原因&lt;/h4>
&lt;p>“故障模式”中只描述了故障的现象，并没有单独列出故障原因。主要原因在于不管什么故障原因，故障现象相同，对功能点的影响就相同。那为何这里还要单独将故障原因列出来呢？主要原因有这几个：&lt;/p>
&lt;p>1、不同的故障原因发生概率不相同&lt;/p>
&lt;p>例如，导致 MySQL 查询响应慢的原因可能是 MySQL bug，也可能是没有索引。很明显“MySQL bug”的概率要远远低于“没有索引”；而不同的概率又会影响我们具体如何应对这个故障。&lt;/p>
&lt;p>2、不同的故障原因检测手段不一样&lt;/p>
&lt;p>例如，磁盘坏道导致 MySQL 响应慢，那我们需要增加机器的磁盘坏道检查，这个检查很可能不是当前系统本身去做，而是另外运维专门的系统；如果是慢查询导致 MySQL 慢，那我们只需要配置 MySQL 的慢查询日志即可。&lt;/p>
&lt;p>3、不同的故障原因的处理措施不一样&lt;/p>
&lt;p>例如，如果是 MySQL bug，我们的应对措施只能是升级 MySQL 版本；如果是没有索引，我们的应对措施就是增加索引。&lt;/p>
&lt;h4 id="6-故障概率">6.故障概率&lt;/h4>
&lt;p>这里的概率就是指某个具体故障原因发生的概率。例如，磁盘坏道的概率、MySQL bug 的概率、没有索引的概率。一般分为“高 / 中 / 低”三档即可，具体评估的时候需要有以下几点需要重点关注。&lt;/p>
&lt;p>1、硬件&lt;/p>
&lt;p>硬件随着使用时间推移，故障概率会越来越高。例如，新的硬盘坏道几率很低，但使用了 3 年的硬盘，坏道几率就会高很多。&lt;/p>
&lt;p>2、开源系统&lt;/p>
&lt;p>成熟的开源系统 bug 率低，刚发布的开源系统 bug 率相比会高一些；自己已经有使用经验的开源系统 bug 率会低，刚开始尝试使用的开源系统 bug 率会高。自研系统和开源系统类似，成熟的&lt;/p>
&lt;p>3、自研系统&lt;/p>
&lt;p>故障概率会低，而新开发的系统故障概率会高。&lt;/p>
&lt;p>高中低是相对的，只是为了确定优先级以决定后续的资源投入，没有必要绝对量化，因为绝对量化是需要成本的，而且很多时候都没法量化。例如，XX 开源系统是 3 个月故障一次，还是 6 个月才故障一次，是无法评估的。&lt;/p>
&lt;h4 id="7-风险程度">7.风险程度&lt;/h4>
&lt;p>风险程度就是综合严重程度和故障概率来一起判断某个故障的最终等级，风险程度 = 严重程度 × 故障概率。因此可能出现某个故障影响非常严重，但其概率很低，最终来看风险程度就低。“某个机房业务瘫痪”对业务影响是致命的，但如果故障原因是“地震”，那概率就很低。例如，广州的地震概率就很低，5 级以上地震的 20 世纪才 1 次（1940 年）；如果故障的原因是“机房空调烧坏”，则概率就比地震高很多了，可能是 2 年 1 次；如果故障的原因是“系统所在机架掉电”，这个概率比机房空调又要高了，可能是 1 年 1 次。同样的故障影响，不同的故障原因有不同的概率，最终得到的风险级别就是不同的。&lt;/p>
&lt;h4 id="8-已有措施">8.已有措施&lt;/h4>
&lt;p>针对具体的故障原因，系统现在是否提供了某些措施来应对，包括：检测告警、容错、自恢复等。&lt;/p>
&lt;p>1、检测告警&lt;/p>
&lt;p>最简单的措施就是检测故障，然后告警，系统自己不针对故障进行处理，需要人工干预。&lt;/p>
&lt;p>2、容错&lt;/p>
&lt;p>检测到故障后，系统能够通过备份手段应对。例如，MySQL 主备机，当业务服务器检测到主机无法连接后，自动连接备机读取数据。&lt;/p>
&lt;p>3、自恢复&lt;/p>
&lt;p>检测到故障后，系统能够自己恢复。例如，Hadoop 检测到某台机器故障后，能够将存储在这台机器的副本重新分配到其他机器。当然，这里的恢复主要还是指“业务”上的恢复，一般不太可能将真正的故障恢复。例如，Hadoop 不可能将产生了磁盘坏道的磁盘修复成没有坏道的磁盘。&lt;/p>
&lt;h4 id="9-规避措施">9.规避措施&lt;/h4>
&lt;p>规避措施指为了降低故障发生概率而做的一些事情，可以是技术手段，也可以是管理手段。例如：&lt;/p>
&lt;p>技术手段：为了避免新引入的 MongoDB 丢失数据，在 MySQL 中冗余一份。&lt;/p>
&lt;p>管理手段：为了降低磁盘坏道的概率，强制统一更换服务时间超过 2 年的磁盘。&lt;/p>
&lt;h4 id="10-解决措施">10.解决措施&lt;/h4>
&lt;p>解决措施指为了能够解决问题而做的一些事情，一般都是技术手段。例如：&lt;/p>
&lt;p>1、为了解决密码暴力破解，增加密码重试次数限制。&lt;/p>
&lt;p>2、为了解决拖库导致数据泄露，将数据库中的敏感数据加密保存。&lt;/p>
&lt;p>3、为了解决非法访问，增加白名单控制。&lt;/p>
&lt;p>一般来说，如果某个故障既可以采取规避措施，又可以采取解决措施，那么我们会优先选择解决措施，毕竟能解决问题当然是最好的。但很多时候有些问题是系统自己无法解决的，例如磁盘坏道、开源系统 bug，这类故障只能采取规避措施；系统能够自己解决的故障，大部分是和系统本身功能相关的。&lt;/p>
&lt;h4 id="11-后续规划">11.后续规划&lt;/h4>
&lt;p>综合前面的分析，就可以看出哪些故障我们目前还缺乏对应的措施，哪些已有措施还不够，针对这些不足的地方，再结合风险程度进行排序，给出后续的改进规划。这些规划既可以是技术手段，也可以是管理手段；可以是规避措施，也可以是解决措施。同时需要考虑资源的投入情况，优先将风险程度高的系统隐患解决。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>1、地震导致机房业务中断：这个故障模式就无法解决，只能通过备份中心规避，尽量减少影响；而机柜断电导致机房业务中断：可以通过将业务机器分散在不同机柜来规避。&lt;/p>
&lt;p>2、敏感数据泄露：这个故障模式可以通过数据库加密的技术手段来解决。&lt;/p>
&lt;p>3、MongoDB 断电丢数据：这个故障模式可以通过将数据冗余一份在 MySQL 中，在故障情况下重建数据来规避影响。&lt;/p>
&lt;h3 id="fmea实战">FMEA实战&lt;/h3>
&lt;p>下面以一个简单的样例来模拟一次 FMEA 分析。假设设计一个最简单的用户管理系统，包含登录和注册两个功能，其初始架构是：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_4.png" alt="architecture-high-availability_4.png">&lt;/p>
&lt;p>初始架构很简单：MySQL 负责存储，Memcache（以下简称 MC）负责缓存，Server 负责业务处理。这个架构通过 FMEA 分析后，能够有什么样的发现，下表是分析的样例（注意，这个样例并不完整，可以自行尝试将这个案例补充完整）。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_5.png" alt="architecture-high-availability_5.png">&lt;/p>
&lt;p>经过上表的 FMEA 分析，将“后续规划”列的内容汇总一下，最终得到了下面几条需要改进的措施：&lt;/p>
&lt;p>1、MySQL 增加备机。&lt;/p>
&lt;p>2、MC 从单机扩展为集群。&lt;/p>
&lt;p>3、MySQL 双网卡连接。&lt;/p>
&lt;p>改进后的架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_6.png" alt="architecture-high-availability_6.png">&lt;/p>
&lt;h2 id="高可用存储架构-双机架构">高可用存储架构：双机架构&lt;/h2>
&lt;p>存储高可用方案的本质都是通过将数据复制到多个存储设备，通过数据冗余的方式来实现高可用，其复杂性主要体现在如何应对复制延迟和中断导致的数据不一致问题。因此，对任何一个高可用存储方案，需要从以下几个方面去进行思考和分析：&lt;/p>
&lt;p>1、数据如何复制？&lt;/p>
&lt;p>2、各个节点的职责是什么？&lt;/p>
&lt;p>3、如何应对复制延迟？&lt;/p>
&lt;p>4、如何应对复制中断？&lt;/p>
&lt;p>常见的高可用存储架构有主备、主从、主主、集群、分区，每一种又可以根据业务的需求进行一些特殊的定制化功能，由此衍生出更多的变种。由于不同业务的定制功能难以通用化，今天将针对业界通用的方案，来分析常见的双机高可用架构：主备、主从、主备 / 主从切换和主主。&lt;/p>
&lt;h3 id="主备复制">主备复制&lt;/h3>
&lt;p>主备复制是最常见也是最简单的一种存储高可用方案，几乎所有的存储系统都提供了主备复制的功能，例如 MySQL、Redis、MongoDB 等。&lt;/p>
&lt;p>1、基本实现&lt;/p>
&lt;p>下面是标准的主备方案结构图：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_7.png" alt="architecture-high-availability_7.png">&lt;/p>
&lt;p>其整体架构比较简单，主备架构中的“备机”主要还是起到一个备份作用，并不承担实际的业务读写操作，如果要把备机改为主机，需要人工操作。&lt;/p>
&lt;p>2、优缺点分析&lt;/p>
&lt;p>主备复制架构的优点就是简单，表现有：&lt;/p>
&lt;p>1）对于客户端来说，不需要感知备机的存在，即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。&lt;/p>
&lt;p>2）对于主机和备机来说，双方只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。&lt;/p>
&lt;p>主备复制架构的缺点主要有：&lt;/p>
&lt;p>1）备机仅仅只为备份，并没有提供读写操作，硬件成本上有浪费。&lt;/p>
&lt;p>2）故障后需要人工干预，无法自动恢复。人工处理的效率是很低的，可能打电话找到能够操作的人就耗费了 10 分钟，甚至如果是深更半夜，出了故障都没人知道。人工在执行恢复操作的过程中也容易出错，因为这类操作并不常见，可能 1 年就 2、3 次，实际操作的时候很可能遇到各种意想不到的问题。&lt;/p>
&lt;p>综合主备复制架构的优缺点，内部的后台管理系统使用主备复制架构的情况会比较多，例如学生管理系统、员工管理系统、假期管理系统等，因为这类系统的数据变更频率低，即使在某些场景下丢失数据，也可以通过人工的方式补全。&lt;/p>
&lt;h3 id="主从复制">主从复制&lt;/h3>
&lt;p>主从复制和主备复制只有一字之差，“从”意思是“随从、仆从”，“备”的意思是备份。可以理解为仆从是要帮主人干活的，这里的干活就是承担“读”的操作。也就是说，主机负责读写操作，从机只负责读操作，不负责写操作。&lt;/p>
&lt;p>1、基本实现&lt;/p>
&lt;p>下面是标准的主从复制架构：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_8.png" alt="architecture-high-availability_8.png">&lt;/p>
&lt;p>与主备复制架构比较类似，主要的差别点在于从机正常情况下也是要提供读的操作。&lt;/p>
&lt;p>2、优缺点分析&lt;/p>
&lt;p>主从复制与主备复制相比，优点有：&lt;/p>
&lt;p>1）主从复制在主机故障时，读操作相关的业务可以继续运行。&lt;/p>
&lt;p>2）主从复制架构的从机提供读操作，发挥了硬件的性能。&lt;/p>
&lt;p>缺点有：&lt;/p>
&lt;p>1）主从复制架构中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。&lt;/p>
&lt;p>2）主从复制架构中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。&lt;/p>
&lt;p>3）故障时需要人工干预。&lt;/p>
&lt;p>综合主从复制的优缺点，一般情况下，写少读多的业务使用主从复制的存储架构比较多。例如，论坛、BBS、新闻网站这类业务，此类业务的读操作数量是写操作数量的 10 倍甚至 100 倍以上。&lt;/p>
&lt;h3 id="双机切换">双机切换&lt;/h3>
&lt;h4 id="设计关键">设计关键&lt;/h4>
&lt;p>主备复制和主从复制方案存在两个共性的问题：&lt;/p>
&lt;p>1、主机故障后，无法进行写操作。&lt;/p>
&lt;p>2、如果主机无法恢复，需要人工指定新的主机角色。&lt;/p>
&lt;p>双机切换就是为了解决这两个问题而产生的，包括主备切换和主从切换两种方案。简单来说，这两个方案就是在原有方案的基础上增加“切换”功能，即系统自动决定主机角色，并完成角色切换。由于主备切换和主从切换在切换的设计上没有差别，我接下来以主备切换为例，一起来看看双机切换架构是如何实现的。&lt;/p>
&lt;p>要实现一个完善的切换方案，必须考虑这几个关键的设计点：&lt;/p>
&lt;p>1、主备间状态判断&lt;/p>
&lt;p>主要包括两方面： 状态传递的渠道，以及状态检测的内容。&lt;/p>
&lt;p>状态传递的渠道：是相互间互相连接，还是第三方仲裁？&lt;/p>
&lt;p>状态检测的内容：例如机器是否掉电、进程是否存在、响应是否缓慢等。&lt;/p>
&lt;p>2、切换决策&lt;/p>
&lt;p>主要包括几方面：切换时机、切换策略、自动程度。&lt;/p>
&lt;p>切换时机：什么情况下备机应该升级为主机？是机器掉电后备机才升级，还是主机上的进程不存在就升级，还是主机响应时间超过 2 秒就升级，还是 3 分钟内主机连续重启 3 次就升级等。&lt;/p>
&lt;p>切换策略：原来的主机故障恢复后，要再次切换，确保原来的主机继续做主机，还是原来的主机故障恢复后自动成为新的备机？&lt;/p>
&lt;p>自动程度：切换是完全自动的，还是半自动的？例如，系统判断当前需要切换，但需要人工做最终的确认操作（例如，单击一下“切换”按钮）。&lt;/p>
&lt;p>3、数据冲突&lt;/p>
&lt;p>解决当原有故障的主机恢复后，新旧主机之间可能存在数据冲突。例如，用户在旧主机上新增了一条 ID 为 100 的数据，这个数据还没有复制到旧的备机，此时发生了切换，旧的备机升级为新的主机，用户又在新的主机上新增了一条 ID 为 100 的数据，当旧的故障主机恢复后，这两条 ID 都为 100 的数据，应该怎么处理？&lt;/p>
&lt;p>以上设计点并没有放之四海而皆准的答案，不同的业务要求不一样，所以切换方案比复制方案不只是多了一个切换功能那么简单，而是复杂度上升了一个量级。形象点来说，如果复制方案的代码是 1000 行，那么切换方案的代码可能就是 10000 行，多出来的那 9000 行就是用于实现上面所讲的 3 个设计点的。&lt;/p>
&lt;h4 id="常见架构">常见架构&lt;/h4>
&lt;p>根据状态传递渠道的不同，常见的主备切换架构有三种形式：互连式、中介式和模拟式。&lt;/p>
&lt;p>&lt;strong>互连式&lt;/strong>&lt;/p>
&lt;p>故名思议，互连式就是指主备机直接建立状态传递的渠道，架构图请注意与主备复制架构对比。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_9.png" alt="architecture-high-availability_9.png">&lt;/p>
&lt;p>可以看到，在主备复制的架构基础上，主机和备机多了一个“状态传递”的通道，这个通道就是用来传递状态信息的。这个通道的具体实现可以有很多方式：&lt;/p>
&lt;p>1、可以是网络连接（例如，各开一个端口），也可以是非网络连接（用串口线连接）。&lt;/p>
&lt;p>2、可以是主机发送状态给备机，也可以是备机到主机来获取状态信息。&lt;/p>
&lt;p>3、可以和数据复制通道共用，也可以独立一条通道。&lt;/p>
&lt;p>4、状态传递通道可以是一条，也可以是多条，还可以是不同类型的通道混合（例如，网络 + 串口）。&lt;/p>
&lt;p>为了充分利用切换方案能够自动决定主机这个优势，客户端这里也会有一些相应的改变，常见的方式有：&lt;/p>
&lt;p>1、为了切换后不影响客户端的访问，主机和备机之间共享一个对客户端来说唯一的地址。例如虚拟 IP，主机需要绑定这个虚拟的 IP。&lt;/p>
&lt;p>2、客户端同时记录主备机的地址，哪个能访问就访问哪个；备机虽然能收到客户端的操作请求，但是会直接拒绝，拒绝的原因就是“备机不对外提供服务”。&lt;/p>
&lt;p>互连式主备切换主要的缺点在于：&lt;/p>
&lt;p>1、如果状态传递的通道本身有故障（例如，网线被人不小心踢掉了），那么备机也会认为主机故障了从而将自己升级为主机，而此时主机并没有故障，最终就可能出现两个主机。&lt;/p>
&lt;p>2、虽然可以通过增加多个通道来增强状态传递的可靠性，但这样做只是降低了通道故障概率而已，不能从根本上解决这个缺点，而且通道越多，后续的状态决策会更加复杂，因为对备机来说，可能从不同的通道收到了不同甚至矛盾的状态信息。&lt;/p>
&lt;p>&lt;strong>中介式&lt;/strong>&lt;/p>
&lt;p>中介式指的是在主备两者之外引入第三方中介，主备机之间不直接连接，而都去连接中介，并且通过中介来传递状态信息，其架构图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_10.png" alt="architecture-high-availability_10.png">&lt;/p>
&lt;p>对比一下互连式切换架构，可以看到主机和备机不再通过互联通道传递状态信息，而是都将状态上报给中介这一角色。单纯从架构上看，中介式似乎比互连式更加复杂了，首先要引入中介，然后要各自上报状态。然而事实上，中介式架构在状态传递和决策上却更加简单。&lt;/p>
&lt;p>&lt;strong>连接管理更简单&lt;/strong>：主备机无须再建立和管理多种类型的状态传递连接通道，只要连接到中介即可，实际上是降低了主备机的连接管理复杂度。&lt;/p>
&lt;p>例如，互连式要求主机开一个监听端口，备机来获取状态信息；或者要求备机开一个监听端口，主机推送状态信息到备机；如果还采用了串口连接，则需要增加串口连接管理和数据读取。采用中介式后，主备机都只需要把状态信息发送给中介，或者从中介获取对方的状态信息。无论是发送还是获取，主备机都是作为中介的客户端去操作，复杂度会降低。&lt;/p>
&lt;p>&lt;strong>状态决策更简单&lt;/strong>：主备机的状态决策简单了，无须考虑多种类型的连接通道获取的状态信息如何决策的问题，只需要按照下面简单的算法即可完成状态决策。&lt;/p>
&lt;p>1）无论是主机还是备机，初始状态都是备机，并且只要与中介断开连接，就将自己降级为备机，因此可能出现双备机的情况。&lt;/p>
&lt;p>2）主机与中介断连后，中介能够立刻告知备机，备机将自己升级为主机。&lt;/p>
&lt;p>3）如果是网络中断导致主机与中介断连，主机自己会降级为备机，网络恢复后，旧的主机以新的备机身份向中介上报自己的状态。&lt;/p>
&lt;p>4）如果是掉电重启或者进程重启，旧的主机初始状态为备机，与中介恢复连接后，发现已经有主机了，保持自己备机状态不变。&lt;/p>
&lt;p>5）主备机与中介连接都正常的情况下，按照实际的状态决定是否进行切换。例如，主机响应时间超过 3 秒就进行切换，主机降级为备机，备机升级为主机即可。&lt;/p>
&lt;p>虽然中介式架构在状态传递和状态决策上更加简单，但并不意味着这种优点是没有代价的，其关键代价就在于如何实现中介本身的高可用。如果中介自己宕机了，整个系统就进入了双备的状态，写操作相关的业务就不可用了。这就陷入了一个递归的陷阱：为了实现高可用引入中介，但中介本身又要求高可用，于是又要设计中介的高可用方案……如此递归下去就无穷无尽了。&lt;/p>
&lt;p>MongoDB 的 Replica Set 采取的就是这种方式，其基本架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_11.png" alt="architecture-high-availability_11.png">&lt;/p>
&lt;p>MongoDB(M) 表示主节点，MongoDB(S) 表示备节点，MongoDB(A) 表示仲裁节点。主备节点存储数据，仲裁节点不存储数据。客户端同时连接主节点与备节点，不连接仲裁节点。&lt;/p>
&lt;p>幸运的是，开源方案已经有比较成熟的中介式解决方案，例如 ZooKeeper 和 Keepalived。ZooKeeper 本身已经实现了高可用集群架构，因此已经帮我们解决了中介本身的可靠性问题，在工程实践中推荐基于 ZooKeeper 搭建中介式切换架构。&lt;/p>
&lt;p>&lt;strong>模拟式&lt;/strong>&lt;/p>
&lt;p>模拟式指主备机之间并不传递任何状态数据，而是备机模拟成一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态。其基本架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_12.png" alt="architecture-high-availability_12.png">&lt;/p>
&lt;p>对比一下互连式切换架构，我们可以看到，主备机之间只有数据复制通道，而没有状态传递通道，备机通过模拟的读写操作来探测主机的状态，然后根据读写操作的响应情况来进行状态决策。&lt;/p>
&lt;p>模拟式切换与互连式切换相比，优点是实现更加简单，因为省去了状态传递通道的建立和管理工作。&lt;/p>
&lt;p>简单既是优点，同时也是缺点。因为模拟式读写操作获取的状态信息只有响应信息（例如，HTTP 404，超时、响应时间超过 3 秒等），没有互连式那样多样（除了响应信息，还可以包含 CPU 负载、I/O 负载、吞吐量、响应时间等），基于有限的状态来做状态决策，可能出现偏差。&lt;/p>
&lt;h3 id="主主复制">主主复制&lt;/h3>
&lt;p>主主复制指的是两台机器都是主机，互相将数据复制给对方，客户端可以任意挑选其中一台机器进行读写操作，下面是基本架构图。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_13.png" alt="architecture-high-availability_13.png">&lt;/p>
&lt;p>相比主备切换架构，主主复制架构具有如下特点：&lt;/p>
&lt;p>1）两台都是主机，不存在切换的概念。&lt;/p>
&lt;p>2）客户端无须区分不同角色的主机，随便将读写操作发送给哪台主机都可以。&lt;/p>
&lt;p>从上面的描述来看，主主复制架构从总体上来看要简单很多，无须状态信息传递，也无须状态决策和状态切换。然而事实上主主复制架构也并不简单，而是有其独特的复杂性，具体表现在：如果采取主主复制架构，必须保证数据能够双向复制，而很多数据是不能双向复制的。例如：&lt;/p>
&lt;p>1）用户注册后生成的用户 ID，如果按照数字增长，那就不能双向复制，否则就会出现 X 用户在主机 A 注册，分配的用户 ID 是 100，同时 Y 用户在主机 B 注册，分配的用户 ID 也是 100，这就出现了冲突。&lt;/p>
&lt;p>2）库存不能双向复制。例如，一件商品库存 100 件，主机 A 上减了 1 件变成 99，主机 B 上减了 2 件变成 98，然后主机 A 将库存 99 复制到主机 B，主机 B 原有的库存 98 被覆盖，变成了 99，而实际上此时真正的库存是 97。类似的还有余额数据。&lt;/p>
&lt;p>因此，主主复制架构对数据的设计有严格的要求，一般适合于那些临时性、可丢失、可覆盖的数据场景。例如，用户登录产生的 session 数据（可以重新登录生成）、用户行为的日志数据（可以丢失）、论坛的草稿数据（可以丢失）等。&lt;/p>
&lt;h2 id="高可用存储架构-集群和分区">高可用存储架构：集群和分区&lt;/h2>
&lt;h3 id="数据集群">数据集群&lt;/h3>
&lt;p>主备、主从、主主架构本质上都有一个隐含的假设：主机能够存储所有数据，但主机本身的存储和处理能力肯定是有极限的。以 PC 为例，Intel 386 时代服务器存储能力只有几百 MB，Intel 奔腾时代服务器存储能力可以有几十 GB，Intel 酷睿多核时代的服务器可以有几个 TB。单纯从硬件发展的角度来看，似乎发展速度还是挺快的，但如果和业务发展速度对比，那就差得远了。早在 2013 年，Facebook 就有 2500 亿张上传照片，当时这些照片的容量就已经达到了 250 PB 字节（250 × 1024TB），平均一天上传的图片有 3 亿 5000 万张。如此大量的数据，单台服务器肯定是无法存储和处理的，我们必须使用多台服务器来存储数据，这就是数据集群架构。&lt;/p>
&lt;p>简单来说，集群就是多台机器组合在一起形成一个统一的系统，这里的“多台”，数量上至少是 3 台；相比而言，主备、主从都是 2 台机器。根据集群中机器承担的不同角色来划分，集群可以分为两类：数据集中集群、数据分散集群。&lt;/p>
&lt;p>1、数据集中集群&lt;/p>
&lt;p>数据集中集群与主备、主从这类架构相似，也可以称数据集中集群为 1 主多备或者 1 主多从。无论是 1 主 1 从、1 主 1 备，还是 1 主多备、1 主多从，数据都只能往主机中写，而读操作可以参考主备、主从架构进行灵活多变。下图是读写全部到主机的一种架构：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_14.png" alt="architecture-high-availability_14.png">&lt;/p>
&lt;p>虽然架构上是类似的，但由于集群里面的服务器数量更多，导致复杂度整体更高一些，具体体现在：&lt;/p>
&lt;p>1）主机如何将数据复制给备机&lt;/p>
&lt;p>主备和主从架构中，只有一条复制通道，而数据集中集群架构中，存在多条复制通道。多条复制通道首先会增大主机复制的压力，某些场景下我们需要考虑如何降低主机复制压力，或者降低主机复制给正常读写带来的压力。&lt;/p>
&lt;p>其次，多条复制通道可能会导致多个备机之间数据不一致，某些场景下我们需要对备机之间的数据一致性进行检查和修正。&lt;/p>
&lt;p>2）备机如何检测主机状态&lt;/p>
&lt;p>主备和主从架构中，只有一台备机需要进行主机状态判断。在数据集中集群架构中，多台备机都需要对主机状态进行判断，而不同的备机判断的结果可能是不同的，如何处理不同备机对主机状态的不同判断，是一个复杂的问题。&lt;/p>
&lt;p>3）主机故障后，如何决定新的主机&lt;/p>
&lt;p>主从架构中，如果主机故障，将备机升级为主机即可；而在数据集中集群架构中，有多台备机都可以升级为主机，但实际上只能允许一台备机升级为主机，那么究竟选择哪一台备机作为新的主机，备机之间如何协调，这也是一个复杂的问题。&lt;/p>
&lt;p>目前开源的数据集中集群以 ZooKeeper 为典型，ZooKeeper 通过 ZAB 算法来解决上述提到的几个问题，但 ZAB 算法的复杂度是很高的。&lt;/p>
&lt;p>2、数据分散集群&lt;/p>
&lt;p>数据分散集群指多个服务器组成一个集群，每台服务器都会负责存储一部分数据；同时，为了提升硬件利用率，每台服务器又会备份一部分数据。&lt;/p>
&lt;p>数据分散集群的复杂点在于如何将数据分配到不同的服务器上，算法需要考虑这些设计点：&lt;/p>
&lt;p>1）均衡性&lt;/p>
&lt;p>算法需要保证服务器上的数据分区基本是均衡的，不能存在某台服务器上的分区数量是另外一台服务器的几倍的情况。&lt;/p>
&lt;p>2）容错性&lt;/p>
&lt;p>当出现部分服务器故障时，算法需要将原来分配给故障服务器的数据分区分配给其他服务器。&lt;/p>
&lt;p>3）可伸缩性&lt;/p>
&lt;p>当集群容量不够，扩充新的服务器后，算法能够自动将部分数据分区迁移到新服务器，并保证扩容后所有服务器的均衡性。&lt;/p>
&lt;p>数据分散集群和数据集中集群的不同点在于，数据分散集群中的每台服务器都可以处理读写请求，因此不存在数据集中集群中负责写的主机那样的角色。但在数据分散集群中，必须有一个角色来负责执行数据分配算法，这个角色可以是独立的一台服务器，也可以是集群自己选举出的一台服务器。如果是集群服务器选举出来一台机器承担数据分区分配的职责，则这台服务器一般也会叫作主机，但我们需要知道这里的“主机”和数据集中集群中的“主机”，其职责是有差异的。&lt;/p>
&lt;p>Hadoop 的实现就是独立的服务器负责数据分区的分配，这台服务器叫作 Namenode。Hadoop 的数据分区管理架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_15.png" alt="architecture-high-availability_15.png">&lt;/p>
&lt;p>下面是 Hadoop 官方的解释，能够说明集中式数据分区管理的基本方式。&lt;/p>
&lt;blockquote>
&lt;p>HDFS 采用 master/slave 架构。一个 HDFS 集群由一个 Namenode 和一定数目的 Datanodes 组成。Namenode 是一个中心服务器，负责管理文件系统的名字空间（namespace），以及客户端对文件的访问。集群中的 Datanode 一般是一个节点一个，负责管理它所在节点上的存储。HDFS 暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组 Datanode 上。Namenode 执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体 Datanode 节点的映射。Datanode 负责处理文件系统客户端的读写请求。在 Namenode 的统一调度下进行数据块的创建、删除和复制操作。&lt;/p>
&lt;/blockquote>
&lt;p>与 Hadoop 不同的是，Elasticsearch 集群通过选举一台服务器来做数据分区的分配，叫作 master node，其数据分区管理架构是：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_16.png" alt="architecture-high-availability_16.png">&lt;/p>
&lt;p>其中 master 节点的职责如下：&lt;/p>
&lt;p>The master node is responsible for lightweight cluster-wide actions such as creating or deleting an index, tracking which nodes are part of the cluster, and deciding which shards to allocate to which nodes. It is important for cluster health to have a stable master node.&lt;/p>
&lt;p>来源：&lt;a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html&lt;/a>&lt;/p>
&lt;p>数据集中集群架构中，客户端只能将数据写到主机；数据分散集群架构中，客户端可以向任意服务器中读写数据。正是因为这个关键的差异，决定了两种集群的应用场景不同。一般来说，数据集中集群适合数据量不大，集群机器数量不多的场景。例如，ZooKeeper 集群，一般推荐 5 台机器左右，数据量是单台服务器就能够支撑；而数据分散集群，由于其良好的可伸缩性，适合业务数据量巨大、集群机器数量庞大的业务场景。例如，Hadoop 集群、HBase 集群，大规模的集群可以达到上百台甚至上千台服务器。&lt;/p>
&lt;h3 id="数据分区">数据分区&lt;/h3>
&lt;p>前面我们讨论的存储高可用架构都是基于硬件故障的场景去考虑和设计的，主要考虑当部分硬件可能损坏的情况下系统应该如何处理，但对于一些影响非常大的灾难或者事故来说，有可能所有的硬件全部故障。例如，新奥尔良水灾、美加大停电、洛杉矶大地震等这些极端灾害或者事故，可能会导致一个城市甚至一个地区的所有基础设施瘫痪，这种情况下基于硬件故障而设计的高可用架构不再适用，我们需要基于地理级别的故障来设计高可用架构，这就是数据分区架构产生的背景。&lt;/p>
&lt;p>数据分区指将数据按照一定的规则进行分区，不同分区分布在不同的地理位置上，每个分区存储一部分数据，通过这种方式来规避地理级别的故障所造成的巨大影响。采用了数据分区的架构后，即使某个地区发生严重的自然灾害或者事故，受影响的也只是一部分数据，而不是全部数据都不可用；当故障恢复后，其他地区备份的数据也可以帮助故障地区快速恢复业务。&lt;/p>
&lt;p>设计一个良好的数据分区架构，需要从多方面去考虑。&lt;/p>
&lt;p>1、数据量&lt;/p>
&lt;p>数据量的大小直接决定了分区的规则复杂度。例如，使用 MySQL 来存储数据，假设一台 MySQL 存储能力是 500GB，那么 2TB 的数据就至少需要 4 台 MySQL 服务器；而如果数据是 200TB，并不是增加到 800 台的 MySQL 服务器那么简单。如果按照 4 台服务器那样去平行管理 800 台服务器，复杂度会发生本质的变化，具体表现为：&lt;/p>
&lt;p>1）800 台服务器里面可能每周都有一两台服务器故障，从 800 台里面定位出 2 台服务器故障，很多情况下并不是一件容易的事情，运维复杂度高。&lt;/p>
&lt;p>2）增加新的服务器，分区相关的配置甚至规则需要修改，而每次修改理论上都有可能影响已有的 800 台服务器的运行，不小心改错配置的情况在实践中太常见了。&lt;/p>
&lt;p>3）如此大量的数据，如果在地理位置上全部集中于某个城市，风险很大，遇到了水灾、大停电这种灾难性的故障时，数据可能全部丢失，因此分区规则需要考虑地理容灾。&lt;/p>
&lt;p>因此，数据量越大，分区规则会越复杂，考虑的情况也越多。&lt;/p>
&lt;p>2、分区规则&lt;/p>
&lt;p>地理位置有近有远，因此可以得到不同的分区规则，包括洲际分区、国家分区、城市分区。具体采取哪种或者哪几种规则，需要综合考虑业务范围、成本等因素。&lt;/p>
&lt;p>通常情况下，洲际分区主要用于面向不同大洲提供服务，由于跨洲通讯的网络延迟已经大到不适合提供在线服务了，因此洲际间的数据中心可以不互通或者仅仅作为备份；国家分区主要用于面向不同国家的用户提供服务，不同国家有不同语言、法律、业务等，国家间的分区一般也仅作为备份；城市分区由于都在同一个国家或者地区内，网络延迟较低，业务相似，分区同时对外提供服务，可以满足业务异地多活之类的需求。&lt;/p>
&lt;p>3）复制规则&lt;/p>
&lt;p>数据分区指将数据分散在多个地区，在某些异常或者灾难情况下，虽然部分数据受影响，但整体数据并没有全部被影响，本身就相当于一个高可用方案了。但仅仅做到这点还不够，因为每个分区本身的数据量虽然只是整体数据的一部分，但还是很大，这部分数据如果损坏或者丢失，损失同样难以接受。因此即使是分区架构，同样需要考虑复制方案。&lt;/p>
&lt;p>常见的分区复制规则有三种：集中式、互备式和独立式。&lt;/p>
&lt;p>&lt;strong>集中式&lt;/strong>&lt;/p>
&lt;p>集中式备份指存在一个总的备份中心，所有的分区都将数据备份到备份中心，其基本架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_17.png" alt="architecture-high-availability_17.png">&lt;/p>
&lt;p>集中式备份架构的优缺点是：&lt;/p>
&lt;p>1）设计简单，各分区之间并无直接联系，可以做到互不影响。&lt;/p>
&lt;p>2）扩展容易，如果要增加第四个分区（例如，武汉分区），只需要将武汉分区的数据复制到西安备份中心即可，其他分区不受影响。&lt;/p>
&lt;p>3）成本较高，需要建设一个独立的备份中心。&lt;/p>
&lt;p>&lt;strong>互备式&lt;/strong>&lt;/p>
&lt;p>互备式备份指每个分区备份另外一个分区的数据，其基本架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_18.png" alt="architecture-high-availability_18.png">&lt;/p>
&lt;p>互备式备份架构的优缺点是：&lt;/p>
&lt;p>1）设计比较复杂，各个分区除了要承担业务数据存储，还需要承担备份功能，相互之间互相关联和影响。&lt;/p>
&lt;p>2）扩展麻烦，如果增加一个武汉分区，则需要修改广州分区的复制指向武汉分区，然后将武汉分区的复制指向北京分区。而原有北京分区已经备份了的广州分区的数据怎么处理也是个难题，不管是做数据迁移，还是广州分区历史数据保留在北京分区，新数据备份到武汉分区，无论哪种方式都很麻烦。&lt;/p>
&lt;p>3）成本低，直接利用已有的设备。&lt;/p>
&lt;p>&lt;strong>独立式&lt;/strong>&lt;/p>
&lt;p>独立式备份指每个分区自己有独立的备份中心，其基本架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_19.png" alt="architecture-high-availability_19.png">&lt;/p>
&lt;p>有一个细节需要特别注意，各个分区的备份并不和原来的分区在一个地方。例如，北京分区的备份放到了天津，上海的放到了杭州，广州的放到了汕头，这样做的主要目的是规避同城或者相同地理位置同时发生灾难性故障的极端情况。如果北京分区机房在朝阳区，而备份机房放在通州区，整个北京停电的话，两个机房都无法工作。&lt;/p>
&lt;p>独立式备份架构的优缺点是：&lt;/p>
&lt;p>1）设计简单，各分区互不影响。&lt;/p>
&lt;p>2）扩展容易，新增加的分区只需要搭建自己的备份中心即可。&lt;/p>
&lt;p>3）成本高，每个分区需要独立的备份中心，备份中心的场地成本是主要成本，因此独立式比集中式成本要高很多。&lt;/p>
&lt;h2 id="如何设计计算高可用架构">如何设计计算高可用架构&lt;/h2>
&lt;p>计算高可用的主要设计目标是当出现部分硬件损坏时，计算任务能够继续正常运行。因此计算高可用的本质是通过冗余来规避部分故障的风险，单台服务器是无论如何都达不到这个目标的。所以计算高可用的设计思想很简单：通过增加更多服务器来达到计算高可用。&lt;/p>
&lt;p>计算高可用架构的设计复杂度主要体现在&lt;strong>任务管理&lt;/strong>方面，即当任务在某台服务器上执行失败后，如何将任务重新分配到新的服务器进行执行。因此，计算高可用架构设计的关键点有下面两点。&lt;/p>
&lt;p>1）哪些服务器可以执行任务&lt;/p>
&lt;p>第一种方式和计算高性能中的集群类似，每个服务器都可以执行任务。例如，常见的访问网站的某个页面。&lt;/p>
&lt;p>第二种方式和存储高可用中的集群类似，只有特定服务器（通常叫“主机”）可以执行任务。当执行任务的服务器故障后，系统需要挑选新的服务器来执行任务。例如，ZooKeeper 的 Leader 才能处理写操作请求。&lt;/p>
&lt;p>2）任务如何重新执行&lt;/p>
&lt;p>第一种策略是对于已经分配的任务即使执行失败也不做任何处理，系统只需要保证新的任务能够分配到其他非故障服务器上执行即可。&lt;/p>
&lt;p>第二种策略是设计一个任务管理器来管理需要执行的计算任务，服务器执行完任务后，需要向任务管理器反馈任务执行结果，任务管理器根据任务执行结果来决定是否需要将任务重新分配到另外的服务器上执行。&lt;/p>
&lt;p>需要注意的是：“任务分配器”是一个逻辑的概念，并不一定要求系统存在一个独立的任务分配器模块。例如：&lt;/p>
&lt;p>1）Nginx 将页面请求发送给 Web 服务器，而 CSS/JS 等静态文件直接读取本地缓存。这里的 Nginx 角色是反向代理系统，但是承担了任务分配器的职责，而不需要 Nginx 做反向代理，后面再来一个任务分配器。&lt;/p>
&lt;p>2）对于一些后台批量运算的任务，可以设计一个独立的任务分配系统来管理这些批处理任务的执行和分配。&lt;/p>
&lt;p>3）ZooKeeper 中的 Follower 节点，当接收到写请求时会将请求转发给 Leader 节点处理，当接收到读请求时就自己处理，这里的 Follower 就相当于一个逻辑上的任务分配器。&lt;/p>
&lt;p>接下来将详细阐述常见的计算高可用架构：主备、主从和集群。&lt;/p>
&lt;h3 id="主备">主备&lt;/h3>
&lt;p>主备架构是计算高可用最简单的架构，和存储高可用的主备复制架构类似，但是要更简单一些，因为计算高可用的主备架构无须数据复制，其基本的架构示意图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_20.png" alt="architecture-high-availability_20.png">&lt;/p>
&lt;p>主备方案的详细设计：&lt;/p>
&lt;p>1）主机执行所有计算任务。例如，读写数据、执行操作等。&lt;/p>
&lt;p>2）当主机故障（例如，主机宕机）时，任务分配器不会自动将计算任务发送给备机，此时系统处于不可用状态。&lt;/p>
&lt;p>3）如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续将任务发送给主机。&lt;/p>
&lt;p>4）如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将备机升为主机，然后让任务分配器将任务发送给新的主机（即原来的备机）；同时，为了继续保持主备架构，需要人工增加新的机器作为备机。&lt;/p>
&lt;p>根据备机状态的不同，主备架构又可以细分为冷备架构和温备架构。&lt;/p>
&lt;p>&lt;strong>冷备&lt;/strong>：备机上的程序包和配置文件都准备好，但备机上的业务系统没有启动（注意：备机的服务器是启动的），主机故障后，需要人工手工将备机的业务系统启动，并将任务分配器的任务请求切换发送给备机。&lt;/p>
&lt;p>&lt;strong>温备&lt;/strong>：备机上的业务系统已经启动，只是不对外提供服务，主机故障后，人工只需要将任务分配器的任务请求切换发送到备机即可。冷备可以节省一定的能源，但温备能够大大减少手工操作时间，因此一般情况下推荐用温备的方式。&lt;/p>
&lt;p>主备架构的优点就是简单，主备机之间不需要进行交互，状态判断和切换操作由人工执行，系统实现很简单。而缺点正好也体现在“人工操作”这点上，因为人工操作的时间不可控，可能系统已经发生问题了，但维护人员还没发现，等了 1 个小时才发现。发现后人工切换的操作效率也比较低，可能需要半个小时才完成切换操作，而且手工操作过程中容易出错。例如，修改配置文件改错了、启动了错误的程序等。&lt;/p>
&lt;p>和存储高可用中的主备复制架构类似，计算高可用的主备架构也比较适合与内部管理系统、后台管理系统这类使用人数不多、使用频率不高的业务，不太适合在线的业务。&lt;/p>
&lt;h3 id="主从">主从&lt;/h3>
&lt;p>和存储高可用中的主从复制架构类似，计算高可用的主从架构中的从机也是要执行任务的。任务分配器需要将任务进行分类，确定哪些任务可以发送给主机执行，哪些任务可以发送给备机执行，其基本的架构示意图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_21.png" alt="architecture-high-availability_21.png">&lt;/p>
&lt;p>主从方案详细设计：&lt;/p>
&lt;p>1）正常情况下，主机执行部分计算任务（如图中的“计算任务 A”），备机执行部分计算任务（如图中的“计算任务 B”）。&lt;/p>
&lt;p>2）当主机故障（例如，主机宕机）时，任务分配器不会自动将原本发送给主机的任务发送给从机，而是继续发送给主机，不管这些任务执行是否成功。&lt;/p>
&lt;p>3）如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续按照原有的设计策略分配任务，即计算任务 A 发送给主机，计算任务 B 发送给从机。&lt;/p>
&lt;p>4）如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将原来的从机升级为主机（一般只是修改配置即可），增加新的机器作为从机，新的从机准备就绪后，任务分配器继续按照原有的设计策略分配任务。&lt;/p>
&lt;p>主从架构与主备架构相比，优缺点有：&lt;/p>
&lt;p>优点：主从架构的从机也执行任务，发挥了从机的硬件性能。&lt;/p>
&lt;p>缺点：主从架构需要将任务分类，任务分配器会复杂一些。&lt;/p>
&lt;h3 id="集群">集群&lt;/h3>
&lt;p>主备架构和主从架构通过冗余一台服务器来提升可用性，且需要人工来切换主备或者主从。这样的架构虽然简单，但存在一个主要的问题：人工操作效率低、容易出错、不能及时处理故障。因此在可用性要求更加严格的场景中，我们需要系统能够自动完成切换操作，这就是高可用集群方案。&lt;/p>
&lt;p>高可用计算的集群方案根据集群中服务器节点角色的不同，可以分为两类：一类是对称集群，即集群中每个服务器的角色都是一样的，都可以执行所有任务；另一类是非对称集群，集群中的服务器分为多个不同的角色，不同的角色执行不同的任务，例如最常见的 Master-Slave 角色。&lt;/p>
&lt;p>需要注意的是，计算高可用集群包含 2 台服务器的集群，这点和存储高可用集群不太一样。存储高可用集群把双机架构和集群架构进行了区分；而在计算高可用集群架构中，2 台服务器的集群和多台服务器的集群，在设计上没有本质区别，因此不需要进行区分。&lt;/p>
&lt;h4 id="对称集群">对称集群&lt;/h4>
&lt;p>对称集群更通俗的叫法是&lt;strong>负载均衡集群&lt;/strong>，因此接下来使用“负载均衡集群”这个通俗的说法，架构示意图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_22.png" alt="architecture-high-availability_22.png">&lt;/p>
&lt;p>负载均衡集群详细设计：&lt;/p>
&lt;p>1）正常情况下，任务分配器采取某种策略（随机、轮询等）将计算任务分配给集群中的不同服务器。&lt;/p>
&lt;p>2）当集群中的某台服务器故障后，任务分配器不再将任务分配给它，而是将任务分配给其他服务器执行。&lt;/p>
&lt;p>3）当故障的服务器恢复后，任务分配器重新将任务分配给它执行。&lt;/p>
&lt;p>负载均衡集群的设计关键点在于两点：&lt;/p>
&lt;p>1）任务分配器需要选取分配策略。&lt;/p>
&lt;p>2）任务分配器需要检测服务器状态。&lt;/p>
&lt;p>任务分配策略比较简单，轮询和随机基本就够了。状态检测稍微复杂一些，既要检测服务器的状态，例如服务器是否宕机、网络是否正常等；同时还要检测任务的执行状态，例如任务是否卡死、是否执行时间过长等。常用的做法是任务分配器和服务器之间通过心跳来传递信息，包括服务器信息和任务信息，然后根据实际情况来确定状态判断条件。&lt;/p>
&lt;p>例如，一个在线页面访问系统，正常情况下页面平均会在 500 毫秒内返回，那么状态判断条件可以设计为：1 分钟内响应时间超过 1 秒（包括超时）的页面数量占了 80% 时，就认为服务器有故障。&lt;/p>
&lt;p>例如，一个后台统计任务系统，正常情况下任务会在 5 分钟内执行完成，那么状态判断条件可以设计为：单个任务执行时间超过 10 分钟还没有结束，就认为服务器有故障。&lt;/p>
&lt;p>通过上面两个案例可以看出，不同业务场景的状态判断条件差异很大，实际设计时要根据业务需求来进行设计和调优。&lt;/p>
&lt;h4 id="非对称集群">非对称集群&lt;/h4>
&lt;p>非对称集群中不同服务器的角色是不同的，不同角色的服务器承担不同的职责。以 Master-Slave 为例，部分任务是 Master 服务器才能执行，部分任务是 Slave 服务器才能执行。非对称集群的基本架构示意图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_23.png" alt="architecture-high-availability_23.png">&lt;/p>
&lt;p>非对称集群架构详细设计：&lt;/p>
&lt;p>1）集群会通过某种方式来区分不同服务器的角色。例如，通过 ZAB 算法选举，或者简单地取当前存活服务器中节点 ID 最小的服务器作为 Master 服务器。&lt;/p>
&lt;p>2）任务分配器将不同任务发送给不同服务器。例如，图中的计算任务 A 发送给 Master 服务器，计算任务 B 发送给 Slave 服务器。&lt;/p>
&lt;p>3）当指定类型的服务器故障时，需要重新分配角色。例如，Master 服务器故障后，需要将剩余的 Slave 服务器中的一个重新指定为 Master 服务器；如果是 Slave 服务器故障，则并不需要重新分配角色，只需要将故障服务器从集群剔除即可。&lt;/p>
&lt;p>非对称集群相比负载均衡集群，设计复杂度主要体现在两个方面：&lt;/p>
&lt;p>1）任务分配策略更加复杂：需要将任务划分为不同类型并分配给不同角色的集群节点。&lt;/p>
&lt;p>2）角色分配策略实现比较复杂：例如，可能需要使用 ZAB、Raft 这类复杂的算法来实现 Leader 的选举。&lt;/p>
&lt;p>以 ZooKeeper 为例：&lt;/p>
&lt;p>1）任务分配器：ZooKeeper 中不存在独立的任务分配器节点，每个 Server 都是任务分配器，Follower 收到请求后会进行判断，如果是写请求就转发给 Leader，如果是读请求就自己处理。&lt;/p>
&lt;p>2）角色指定：ZooKeeper 通过 ZAB 算法来选举 Leader，当 Leader 故障后，所有的 Follower 节点会暂停读写操作，开始进行选举，直到新的 Leader 选举出来后才继续对 Client 提供服务。&lt;/p>
&lt;h2 id="业务高可用保障-异地多活架构">业务高可用保障：异地多活架构&lt;/h2>
&lt;p>无论是高可用计算架构，还是高可用存储架构，其本质的设计目的都是为了解决部分服务器故障的场景下，如何保证系统能够继续提供服务。但在一些极端场景下，有可能所有服务器都出现故障。例如，典型的有机房断电、机房火灾、地震、水灾……这些极端情况会导致某个系统所有服务器都故障，或者业务整体瘫痪，而且即使有其他地区的备份，把备份业务系统全部恢复到能够正常提供业务，花费的时间也比较长，可能是半小时，也可能是 12 小时。因为备份系统平时不对外提供服务，可能会存在很多隐藏的问题没有发现。如果业务期望达到即使在此类灾难性故障的情况下，业务也不受影响，或者在几分钟内就能够很快恢复，那么就需要设计异地多活架构。&lt;/p>
&lt;h3 id="异地多活应用场景">异地多活应用场景&lt;/h3>
&lt;p>顾名思义，异地多活架构的关键点就是异地、多活，其中异地就是指地理位置上不同的地方，类似于“不要把鸡蛋都放在同一篮子里”；多活就是指不同地理位置上的系统都能够提供业务服务，这里的“活”是活动、活跃的意思。判断一个系统是否符合异地多活，需要满足两个标准：&lt;/p>
&lt;p>1）正常情况下，用户无论访问哪一个地点的业务系统，都能够得到正确的业务服务。&lt;/p>
&lt;p>2）某个地方业务异常的时候，用户访问其他地方正常的业务系统，能够得到正确的业务服务。&lt;/p>
&lt;p>与“活”对应的是字是“备”，备是备份，正常情况下对外是不提供服务的，如果需要提供服务，则需要大量的人工干预和操作，花费大量的时间才能让“备”变成“活”。&lt;/p>
&lt;p>单纯从异地多活的描述来看，异地多活很强大，能够保证在灾难的情况下业务都不受影响。那是不是意味着不管什么业务，我们都要去实现异地多活架构呢？其实不然，因为实现异地多活架构不是没有代价的，相反其代价很高，具体表现为：&lt;/p>
&lt;p>1）系统复杂度会发生质的变化，需要设计复杂的异地多活架构。&lt;/p>
&lt;p>2）成本会上升，毕竟要多在一个或者多个机房搭建独立的一套业务系统。&lt;/p>
&lt;p>因此，异地多活虽然功能很强大，但也不是每个业务不管三七二十一都要上异地多活。例如，常见的新闻网站、企业内部的 IT 系统、游戏、博客站点等，如果无法承受异地多活带来的复杂度和成本，是可以不做异地多活的，只需要做异地备份即可。因为这类业务系统即使中断，对用户的影响并不会很大，例如，A 新闻网站看不了，用户换个新闻网站即可。而共享单车、滴滴出行、支付宝、微信这类业务，就需要做异地多活了，这类业务系统中断后，对用户的影响很大。例如，支付宝用不了，就没法买东西了；滴滴用不了，用户就打不到车了。&lt;/p>
&lt;p>当然，如果业务规模很大，能够做异地多活的情况下还是尽量。首先，这样能够在异常的场景下给用户提供更好的体验；其次，业务规模很大肯定会伴随衍生的收入，例如广告收入，异地多活能够减少异常场景带来的收入损失。同样以新闻网站为例，虽然从业务的角度来看，新闻类网站对用户影响不大，反正用户也可以从其他地方看到基本相同的新闻，甚至用户几个小时不看新闻也没什么问题。但是从网站本身来看，几个小时不可访问肯定会影响用户对网站的口碑；其次几个小时不可访问，网站上的广告收入损失也会很大。&lt;/p>
&lt;h3 id="架构模式">架构模式&lt;/h3>
&lt;p>根据地理位置上的距离来划分，异地多活架构可以分为同城异区、跨城异地、跨国异地。接下来详细解释一下每一种架构的细节与优缺点。&lt;/p>
&lt;h4 id="同城异区">同城异区&lt;/h4>
&lt;p>同城异区指的是将业务部署在同一个城市不同区的多个机房。例如，在北京部署两个机房，一个机房在海淀区，一个在通州区，然后将两个机房用专用的高速网络连接在一起。&lt;/p>
&lt;p>如果考虑一些极端场景（例如，美加大停电、新奥尔良水灾），同城异区似乎没什么作用，那为何还要设计同城异区这种架构呢？答案就在于“同城”。&lt;/p>
&lt;p>同城的两个机房，距离上一般大约就是几十千米，通过搭建高速的网络，同城异区的两个机房能够实现和同一个机房内几乎一样的网络传输速度。这就意味着虽然是两个不同地理位置上的机房，但逻辑上我们可以将它们看作同一个机房，这样的设计大大降低了复杂度，减少了异地多活的设计和实现复杂度及成本。&lt;/p>
&lt;p>那如果采用了同城异区架构，一旦发生新奥尔良水灾这种灾难怎么办呢？很遗憾，答案是无能为力。但需要考虑的是，这种极端灾难发生概率是比较低的，可能几年或者十几年才发生一次。其次，除了这类灾难，机房火灾、机房停电、机房空调故障这类问题发生的概率更高，而且破坏力一样很大。而这些故障场景，同城异区架构都可以很好地解决。因此，结合复杂度、成本、故障发生概率来综合考虑，同城异区是应对机房级别故障的最优架构。&lt;/p>
&lt;h4 id="跨城异地">跨城异地&lt;/h4>
&lt;p>跨城异地指的是业务部署在不同城市的多个机房，而且距离最好要远一些。例如，将业务部署在北京和广州两个机房，而不是将业务部署在广州和深圳的两个机房。&lt;/p>
&lt;p>为何跨城异地要强调距离要远呢？前面在介绍同城异区的架构时提到同城异区不能解决新奥尔良水灾这种问题，而两个城市离得太近又无法应对如美加大停电这种问题，跨城异地其实就是为了解决这两类问题的，因此需要在距离上比较远，才能有效应对这类极端灾难事件。&lt;/p>
&lt;p>跨城异地虽然能够有效应对极端灾难事件，但“距离较远”这点并不只是一个距离数字上的变化，而是量变引起了质变，导致了跨城异地的架构复杂度大大上升。距离增加带来的最主要问题是两个机房的网络传输速度会降低，这不是以人的意志为转移的，而是物理定律决定的，即光速真空传播大约是每秒 30 万千米，在光纤中传输的速度大约是每秒 20 万千米，再加上传输中的各种网络设备的处理，实际还远远达不到理论上的速度。&lt;/p>
&lt;p>除了距离上的限制，中间传输各种不可控的因素也非常多。例如，挖掘机把光纤挖断、中美海底电缆被拖船扯断、骨干网故障等，这些线路很多是第三方维护，针对故障我们根本无能为力也无法预知。例如，广州机房到北京机房，正常情况下 RTT 大约是 50 毫秒左右，遇到网络波动之类的情况，RTT 可能飙升到 500 毫秒甚至 1 秒，更不用说经常发生的线路丢包问题，那延迟可能就是几秒几十秒了。&lt;/p>
&lt;p>以上描述的问题，虽然同城异区理论上也会遇到，但由于同城异区距离较短，中间经过的线路和设备较少，问题发生的概率会低很多。而且同城异区距离短，即使是搭建多条互联通道，成本也不会太高，而跨城异区距离太远，搭建或者使用多通道的成本会高不少。&lt;/p>
&lt;p>跨城异地距离较远带来的网络传输延迟问题，给异地多活架构设计带来了复杂性，如果要做到真正意义上的多活，业务系统需要考虑部署在不同地点的两个机房，在数据短时间不一致的情况下，还能够正常提供业务。这就引入了一个看似矛盾的地方：数据不一致业务肯定不会正常，但跨城异地肯定会导致数据不一致。&lt;/p>
&lt;p>如何解决这个问题呢？重点还是在“数据”上，即根据数据的特性来做不同的架构。如果是强一致性要求的数据，例如银行存款余额、支付宝余额等，这类数据实际上是无法做到跨城异地多活的。我们来看一个假设的例子，假如做一个互联网金融的业务，用户余额支持跨城异地多活，系统分别部署在广州和北京，那么如果挖掘机挖断光缆后，会出现如下场景：&lt;/p>
&lt;p>1）用户 A 余额有 10000 元钱，北京和广州机房都是这个数据。&lt;/p>
&lt;p>2）用户 A 向用户 B 转了 5000 元钱，这个操作是在广州机房完成的，完成后用户 A 在广州机房的余额是 5000 元。&lt;/p>
&lt;p>3）由于广州和北京机房网络被挖掘机挖断，广州机房无法将余额变动通知北京机房，此时北京机房用户 A 的余额还是 10000 元。&lt;/p>
&lt;p>4）用户 A 到北京机房又发起转账，此时他看到自己的余额还有 10000 元，于是向用户 C 转账 10000 元，转账完成后用户 A 的余额变为 0。&lt;/p>
&lt;p>5）用户 A 到广州机房一看，余额怎么还有 5000 元？于是赶紧又发起转账，转账 5000 元给用户 D；此时广州机房用户 A 的余额也变为 0 了。&lt;/p>
&lt;p>最终，本来余额 10000 元的用户 A，却转了 20000 元出去给其他用户。&lt;/p>
&lt;p>对于以上这种假设场景，虽然普通用户很难这样自如地操作，但如果真的这么做，被黑客发现后，后果不堪设想。正因为如此，支付宝等金融相关的系统，对余额这类数据，一般不会做跨城异地的多活架构，而只能采用同城异区这种架构。&lt;/p>
&lt;p>而对数据一致性要求不那么高，或者数据不怎么改变，或者即使数据丢失影响也不大的业务，跨城异地多活就能够派上用场了。例如，用户登录（数据不一致时用户重新登录即可）、新闻类网站（一天内的新闻数据变化较少）、微博类网站（丢失用户发布的微博或者评论影响不大），这些业务采用跨城异地多活，能够很好地应对极端灾难的场景。&lt;/p>
&lt;h4 id="跨国异地">跨国异地&lt;/h4>
&lt;p>跨国异地指的是业务部署在不同国家的多个机房。相比跨城异地，跨国异地的距离就更远了，因此数据同步的延时会更长，正常情况下可能就有几秒钟了。这种程度的延迟已经无法满足异地多活标准的第一条：“正常情况下，用户无论访问哪一个地点的业务系统，都能够得到正确的业务服务”。例如，假设有一个微博类网站，分别在中国的上海和美国的纽约都建了机房，用户 A 在上海机房发表了一篇微博，此时如果他的一个关注者 B 用户访问到美国的机房，很可能无法看到用户 A 刚刚发表的微博。虽然跨城异地也会有此类同步延时问题，但正常情况下几十毫秒的延时对用户来说基本无感知的；而延时达到几秒钟就感觉比较明显了。&lt;/p>
&lt;p>因此，跨国异地的“多活”，和跨城异地的“多活”，实际的含义并不完全一致。跨国异地多活的主要应用场景一般有这几种情况：&lt;/p>
&lt;p>1、为不同地区用户提供服务&lt;/p>
&lt;p>例如，亚马逊中国是为中国用户服务的，而亚马逊美国是为美国用户服务的，亚马逊中国的用户如果访问美国亚马逊，是无法用亚马逊中国的账号登录美国亚马逊的。&lt;/p>
&lt;p>2、只读类业务做多活&lt;/p>
&lt;p>例如，谷歌的搜索业务，由于用户搜索资料时，这些资料都已经存在于谷歌的搜索引擎上面，无论是访问英国谷歌，还是访问美国谷歌，搜索结果基本相同，并且对用户来说，也不需要搜索到最新的实时资料，跨国异地的几秒钟网络延迟，对搜索结果是没有什么影响的。&lt;/p>
&lt;h2 id="异地多活设计4大技巧">异地多活设计4大技巧&lt;/h2>
&lt;h3 id="1-保证核心业务的异地多活">1、保证核心业务的异地多活&lt;/h3>
&lt;p>“异地多活”是为了保证业务的高可用，但很多架构师在考虑这个“业务”时，会不自觉地陷入一个思维误区：要保证所有业务都能“异地多活”！&lt;/p>
&lt;p>假设需要做一个“用户子系统”，这个子系统负责“注册”“登录”“用户信息”三个业务。为了支持海量用户，设计了一个“用户分区”的架构，即正常情况下用户属于某个主分区，每个分区都有其他数据的备份，用户用邮箱或者手机号注册，路由层拿到邮箱或者手机号后，通过 Hash 计算属于哪个中心，然后请求对应的业务中心。基本的架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_24.png" alt="architecture-high-availability_24.png">&lt;/p>
&lt;p>这样一个系统，如果 3 个业务要同时实现异地多活，会发现这些难以解决的问题：&lt;/p>
&lt;p>1）注册问题&lt;/p>
&lt;p>A 中心注册了用户，数据还未同步到 B 中心，此时 A 中心宕机，为了支持注册业务多活，可以挑选 B 中心让用户去重新注册。看起来很容易就支持多活了，但仔细思考一下会发现这样做会有问题：一个手机号只能注册一个账号，A 中心的数据没有同步过来，B 中心无法判断这个手机号是否重复，如果 B 中心让用户注册，后来 A 中心恢复了，发现数据有冲突，怎么解决？实际上是无法解决的，因为同一个手机号注册的账号不能以后一次注册为准；而如果 B 中心不支持本来属于 A 中心的业务进行注册，注册业务的多活又成了空谈。&lt;/p>
&lt;p>如果修改业务规则，允许一个手机号注册多个账号不就可以了吗？这样做是不可行的，类似一个手机号只能注册一个账号这种规则，是核心业务规则，修改核心业务规则的代价非常大，几乎所有的业务都要重新设计，为了架构设计去改变业务规则（而且是这么核心的业务规则）是得不偿失的。&lt;/p>
&lt;p>2）用户信息问题&lt;/p>
&lt;p>用户信息的修改和注册有类似的问题，即 A、B 两个中心在异常的情况下都修改了用户信息，如何处理冲突？&lt;/p>
&lt;p>由于用户信息并没有账号那么关键，一种简单的处理方式是按照时间合并，即最后修改的生效。业务逻辑上没问题，但实际操作也有一个很关键的“坑”：怎么保证多个中心所有机器时间绝对一致？在异地多中心的网络下，这个是无法保证的，即使有时间同步也无法完全保证，只要两个中心的时间误差超过 1 秒，数据就可能出现混乱，即先修改的反而生效。&lt;/p>
&lt;p>还有一种方式是生成全局唯一递增 ID，这个方案的成本很高，因为这个全局唯一递增 ID 的系统本身又要考虑异地多活，同样涉及数据一致性和冲突的问题。&lt;/p>
&lt;p>综合上面的简单分析可以发现，如果“注册”“登录”“用户信息”全部都要支持异地多活，实际上是挺难的，有的问题甚至是无解的。那这种情况下应该如何考虑“异地多活”的架构设计呢？答案其实很简单：&lt;strong>优先实现核心业务的异地多活架构！&lt;/strong>&lt;/p>
&lt;p>对于这个模拟案例来说，“登录”才是最核心的业务，“注册”和“用户信息”虽然也是主要业务，但并不一定要实现异地多活，主要原因在于业务影响不同。对于一个日活 1000 万的业务来说，每天注册用户可能是几万，修改用户信息的可能还不到 1 万，但登录用户是 1000 万，很明显应该保证登录的异地多活。&lt;/p>
&lt;p>对于新用户来说，注册不了的影响并不明显，因为他还没有真正开始使用业务。用户信息修改也类似，暂时修改不了用户信息，对于其业务不会有很大影响。而如果有几百万用户登录不了，就相当于几百万用户无法使用业务，对业务的影响就非常大了：公司的客服热线很快就被打爆，微博、微信上到处都在传业务宕机，论坛里面到处是抱怨的用户，那就是互联网大事件了！&lt;/p>
&lt;p>而登录实现“异地多活”恰恰是最简单的，因为每个中心都有所有用户的账号和密码信息，用户在哪个中心都可以登录。用户在 A 中心登录，A 中心宕机后，用户到 B 中心重新登录即可。如果某个用户在 A 中心修改了密码，此时数据还没有同步到 B 中心，用户到 B 中心登录是无法登录的，这个怎么处理？这个问题其实就涉及另外一个设计技巧了，卖个关子稍后再谈。&lt;/p>
&lt;h3 id="2-保证核心数据最终一致性">2、保证核心数据最终一致性&lt;/h3>
&lt;p>异地多活本质上是通过异地的数据冗余，来保证在极端异常的情况下业务也能够正常提供给用户，因此数据同步是异地多活架构设计的核心。但大部分架构师在考虑数据同步方案时，会不知不觉地陷入完美主义误区：要所有数据都实时同步！&lt;/p>
&lt;p>数据冗余是要将数据从 A 地同步到 B 地，从业务的角度来看是越快越好，最好和本地机房一样的速度最好。但让人头疼的问题正在这里：异地多活理论上就不可能很快，因为这是物理定律决定的（上一期已有说明）。&lt;/p>
&lt;p>因此异地多活架构面临一个无法彻底解决的矛盾：业务上要求数据快速同步，物理上正好做不到数据快速同步，因此所有数据都实时同步，实际上是一个无法达到的目标。既然是无法彻底解决的矛盾，那就只能想办法尽量减少影响。有几种方法可以参考：&lt;/p>
&lt;p>1）尽量减少异地多活机房的距离，搭建高速网络&lt;/p>
&lt;p>这和上一期讲到的同城异区架构类似，但搭建跨城异地的高速网络成本远远超过同城异区的高速网络，成本巨大，一般只有巨头公司才能承担。&lt;/p>
&lt;p>2）尽量减少数据同步，只同步核心业务相关的数据&lt;/p>
&lt;p>简单来说就是不重要的数据不同步，同步后没用的数据不同步，只同步核心业务相关的数据。&lt;/p>
&lt;p>以前面的“用户子系统”为例，用户登录所产生的 token 或者 session 信息，数据量很大，但其实并不需要同步到其他业务中心，因为这些数据丢失后重新登录就可以再次获取了。&lt;/p>
&lt;p>这时可能会想到：这些数据丢失后要求用户重新登录，影响用户体验！确实如此，毕竟需要用户重新输入账户和密码信息，或者至少要弹出登录界面让用户点击一次，但相比为了同步所有数据带来的代价，这个影响完全可以接受。为什么这么说呢，还是卖个关子会在后面分析。&lt;/p>
&lt;p>3）保证最终一致性，不保证实时一致性&lt;/p>
&lt;p>最终一致性就是前面介绍 CAP 理论时提到的 BASE 理论，即业务不依赖数据同步的实时性，只要数据最终能一致即可。例如，A 机房注册了一个用户，业务上不要求能够在 50 毫秒内就同步到所有机房，正常情况下要求 5 分钟同步到所有机房即可，异常情况下甚至可以允许 1 小时或者 1 天后能够一致。&lt;/p>
&lt;p>最终一致性在具体实现时，还需要根据不同的数据特征，进行差异化的处理，以满足业务需要。例如，对“账号”信息来说，如果在 A 机房新注册的用户 5 分钟内正好跑到 B 机房了，此时 B 机房还没有这个用户的信息，为了保证业务的正确，B 机房就需要根据路由规则到 A 机房请求数据。&lt;/p>
&lt;p>而对“用户信息”来说，5 分钟后同步也没有问题，也不需要采取其他措施来弥补，但还是会影响用户体验，即用户看到了旧的用户信息，这个问题怎么解决呢？好像又是一个解决不了的问题，和前面留下的两个问题一起，在最后再给出答案。&lt;/p>
&lt;h3 id="3-采用多种手段同步数据">3、采用多种手段同步数据&lt;/h3>
&lt;p>数据同步是异地多活架构设计的核心，幸运的是基本上存储系统本身都会有同步的功能。例如，MySQL 的主备复制、Redis 的 Cluster 功能、Elasticsearch 的集群功能。这些系统本身的同步功能已经比较强大，能够直接拿来就用，但这也无形中将引入了一个思维误区：只使用存储系统的同步功能！&lt;/p>
&lt;p>既然说存储系统本身就有同步功能，而且同步功能还很强大，为何说只使用存储系统是一个思维误区呢？因为虽然绝大部分场景下，存储系统本身的同步功能基本上也够用了，但在某些比较极端的情况下，存储系统本身的同步功能可能难以满足业务需求。&lt;/p>
&lt;p>以 MySQL 为例，MySQL 5.1 版本的复制是单线程的复制，在网络抖动或者大量数据同步时，经常发生延迟较长的问题，短则延迟十几秒，长则可能达到十几分钟。而且即使通过监控的手段知道了 MySQL 同步时延较长，也难以采取什么措施，只能干等。&lt;/p>
&lt;p>Redis 又是另外一个问题，Redis 3.0 之前没有 Cluster 功能，只有主从复制功能，而为了设计上的简单，Redis 2.8 之前的版本，主从复制有一个比较大的隐患：从机宕机或者和主机断开连接都需要重新连接主机，重新连接主机都会触发全量的主从复制。这时主机会生成内存快照，主机依然可以对外提供服务，但是作为读的从机，就无法提供对外服务了，如果数据量大，恢复的时间会相当长。&lt;/p>
&lt;p>综合上面的案例可以看出，存储系统本身自带的同步功能，在某些场景下是无法满足业务需要的。尤其是异地多机房这种部署，各种各样的异常情况都可能出现，当只考虑存储系统本身的同步功能时，就会发现无法做到真正的异地多活。&lt;/p>
&lt;p>解决的方案就是拓开思路，避免只使用存储系统的同步功能，可以将多种手段配合存储系统的同步来使用，甚至可以不采用存储系统的同步方案，改用自己的同步方案。&lt;/p>
&lt;p>还是以前面的“用户子系统”为例，可以采用如下几种方式同步数据：&lt;/p>
&lt;p>1）消息队列方式&lt;/p>
&lt;p>对于账号数据，由于账号只会创建，不会修改和删除（假设我们不提供删除功能），我们可以将账号数据通过消息队列同步到其他业务中心。&lt;/p>
&lt;p>2）二次读取方式&lt;/p>
&lt;p>某些情况下可能出现消息队列同步也延迟了，用户在 A 中心注册，然后访问 B 中心的业务，此时 B 中心本地拿不到用户的账号数据。为了解决这个问题，B 中心在读取本地数据失败时，可以根据路由规则，再去 A 中心访问一次（这就是所谓的二次读取，第一次读取本地，本地失败后第二次读取对端），这样就能够解决异常情况下同步延迟的问题。&lt;/p>
&lt;p>3）存储系统同步方式&lt;/p>
&lt;p>对于密码数据，由于用户改密码频率较低，而且用户不可能在 1 秒内连续改多次密码，所以通过数据库的同步机制将数据复制到其他业务中心即可，用户信息数据和密码类似。&lt;/p>
&lt;p>4）回源读取方式&lt;/p>
&lt;p>对于登录的 session 数据，由于数据量很大，可以不同步数据；但当用户在 A 中心登录后，然后又在 B 中心登录，B 中心拿到用户上传的 session id 后，根据路由判断 session 属于 A 中心，直接去 A 中心请求 session 数据即可；反之亦然，A 中心也可以到 B 中心去获取 session 数据。&lt;/p>
&lt;p>5）重新生成数据方式&lt;/p>
&lt;p>对于“回源读取”场景，如果异常情况下，A 中心宕机了，B 中心请求 session 数据失败，此时就只能登录失败，让用户重新在 B 中心登录，生成新的 session 数据。&lt;/p>
&lt;p>注意：以上方案仅仅是示意，实际的设计方案要比这个复杂一些，还有很多细节要考虑。综合上述的各种措施，最后“用户子系统”同步方式整体如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_25.png" alt="architecture-high-availability_25.png">&lt;/p>
&lt;h3 id="4-只保证绝大部分用户的异地多活">4、只保证绝大部分用户的异地多活&lt;/h3>
&lt;p>前面在给出每个思维误区对应的解决方案时，留下了几个小尾巴：某些场景下我们无法保证 100% 的业务可用性，总是会有一定的损失。例如，密码不同步导致无法登录、用户信息不同步导致用户看到旧的信息等，这个问题怎么解决呢？&lt;/p>
&lt;p>其实这个问题涉及异地多活架构设计中一个典型的思维误区：要保证业务 100% 可用！但极端情况下就是会丢一部分数据，就是会有一部分数据不能同步，有没有什么巧妙能做到 100% 可用呢？&lt;/p>
&lt;p>很遗憾，答案是没有！异地多活也无法保证 100% 的业务可用，这是由物理规律决定的，光速和网络的传播速度、硬盘的读写速度、极端异常情况的不可控等，都是无法 100% 解决的。所以针对这个思维误区，答案是“忍”！也就是说要忍受这一小部分用户或者业务上的损失，否则本来想为了保证最后的 0.01% 的用户的可用性，做一个完美方案，结果却发现 99.99% 的用户都保证不了了。&lt;/p>
&lt;p>对于某些实时强一致性的业务，实际上受影响的用户会更多，甚至可能达到 1/3 的用户。以银行转账这个业务为例，假设小明在北京 XX 银行开了账号，如果小明要转账，一定要北京的银行业务中心才可用，否则就不允许小明自己转账。如果不这样的话，假设在北京和上海两个业务中心实现了实时转账的异地多活，某些异常情况下就可能出现小明只有 1 万元存款，他在北京转给了张三 1 万元，然后又到上海转给了李四 1 万元，两次转账都成功了。这种漏洞如果被人利用，后果不堪设想。&lt;/p>
&lt;p>当然，针对银行转账这个业务，虽然无法做到“实时转账”的异地多活，但可以通过特殊的业务手段让转账业务也能实现异地多活。例如，转账业务除了“实时转账”外，还提供“转账申请”业务，即小明在上海业务中心提交转账请求，但上海的业务中心并不立即转账，而是记录这个转账请求，然后后台异步发起真正的转账操作，如果此时北京业务中心不可用，转账请求就可以继续等待重试；假设等待 2 个小时后北京业务中心恢复了，此时上海业务中心去请求转账，发现余额不够，这个转账请求就失败了。小明再登录上来就会看到转账申请失败，原因是“余额不足”。&lt;/p>
&lt;p>不过需要注意的是“转账申请”的这种方式虽然有助于实现异地多活，但其实还是牺牲了用户体验的，对于小明来说，本来一次操作的事情，需要分为两次：一次提交转账申请，另外一次是要确认是否转账成功。虽然无法做到 100% 可用性，但并不意味着什么都不能做，为了让用户心里更好受一些，可以采取一些措施进行安抚或者补偿，例如：&lt;/p>
&lt;p>1）挂公告&lt;/p>
&lt;p>说明现在有问题和基本的问题原因，如果不明确原因或者不方便说出原因，可以发布“技术正在紧急处理”这类比较轻松和有趣的公告。&lt;/p>
&lt;p>2）事后对用户进行补偿&lt;/p>
&lt;p>例如，送一些业务上可用的代金券、小礼包等，减少用户的抱怨。&lt;/p>
&lt;p>3）补充体验&lt;/p>
&lt;p>对于为了做异地多活而带来的体验损失，可以想一些方法减少或者规避。以“转账申请”为例，为了让用户不用确认转账申请是否成功，我们可以在转账成功或者失败后直接给用户发个短信，告诉他转账结果，这样用户就不用时不时地登录系统来确认转账是否成功了。&lt;/p>
&lt;h3 id="核心思想">核心思想&lt;/h3>
&lt;p>异地多活设计的理念可以总结为一句话：采用多种手段，保证绝大部分用户的核心业务异地多活！&lt;/p>
&lt;h2 id="异地多活设计4步走">异地多活设计4步走&lt;/h2>
&lt;h3 id="1-业务分级">1、业务分级&lt;/h3>
&lt;p>按照一定的标准将业务进行分级，挑选出核心的业务，只为核心业务设计异地多活，降低方案整体复杂度和实现成本。&lt;/p>
&lt;p>常见的分级标准有下面几种：&lt;/p>
&lt;p>1）访问量大的业务&lt;/p>
&lt;p>以用户管理系统为例，业务包括登录、注册、用户信息管理，其中登录的访问量肯定是最大的。&lt;/p>
&lt;p>2）核心业务&lt;/p>
&lt;p>以 QQ 为例，QQ 的主场景是聊天，QQ 空间虽然也是重要业务，但和聊天相比，重要性就会低一些，如果要从聊天和 QQ 空间两个业务里面挑选一个做异地多活，那明显聊天要更重要（当然，此类公司如腾讯，应该是两个都实现了异地多活的）。&lt;/p>
&lt;p>3）产生大量收入的业务&lt;/p>
&lt;p>同样以 QQ 为例，聊天可能很难为腾讯带来收益，因为聊天没法插入广告；而 QQ 空间反而可能带来更多收益，因为 QQ 空间可以插入很多广告，因此如果从收入的角度来看，QQ 空间做异地多活的优先级反而高于 QQ 聊天了。&lt;/p>
&lt;p>以一直在举例的用户管理系统为例，“登录”业务符合“访问量大的业务”和“核心业务”这两条标准，因此将登录业务作为核心业务。&lt;/p>
&lt;h3 id="2-数据分类">2、数据分类&lt;/h3>
&lt;p>挑选出核心业务后，需要对核心业务相关的数据进一步分析，目的在于识别所有的数据及数据特征，这些数据特征会影响后面的方案设计。&lt;/p>
&lt;p>常见的数据特征分析维度有：&lt;/p>
&lt;p>1）数据量&lt;/p>
&lt;p>这里的数据量包括总的数据量和新增、修改、删除的量。对异地多活架构来说，新增、修改、删除的数据就是可能要同步的数据，数据量越大，同步延迟的几率越高，同步方案需要考虑相应的解决方案。&lt;/p>
&lt;p>2）唯一性&lt;/p>
&lt;p>唯一性指数据是否要求多个异地机房产生的同类数据必须保证唯一。例如用户 ID，如果两个机房的两个不同用户注册后生成了一样的用户 ID，这样业务上就出错了。&lt;/p>
&lt;p>数据的唯一性影响业务的多活设计，如果数据不需要唯一，那就说明两个地方都产生同类数据是可能的；如果数据要求必须唯一，要么只能一个中心点产生数据，要么需要设计一个数据唯一生成的算法。&lt;/p>
&lt;p>3）实时性&lt;/p>
&lt;p>实时性指如果在 A 机房修改了数据，要求多长时间必须同步到 B 机房，实时性要求越高，对同步的要求越高，方案越复杂。&lt;/p>
&lt;p>4）可丢失性&lt;/p>
&lt;p>可丢失性指数据是否可以丢失。例如，写入 A 机房的数据还没有同步到 B 机房，此时 A 机房机器宕机会导致数据丢失，那这部分丢失的数据是否对业务会产生重大影响。&lt;/p>
&lt;p>例如，登录过程中产生的 session 数据就是可丢失的，因为用户只要重新登录就可以生成新的 session；而用户 ID 数据是不可丢失的，丢失后用户就会失去所有和用户 ID 相关的数据，例如用户的好友、用户的钱等。&lt;/p>
&lt;p>5）可恢复性&lt;/p>
&lt;p>可恢复性指数据丢失后，是否可以通过某种手段进行恢复，如果数据可以恢复，至少说明对业务的影响不会那么大，这样可以相应地降低异地多活架构设计的复杂度。&lt;/p>
&lt;p>例如，用户的微博丢失后，用户重新发一篇一模一样的微博，这个就是可恢复的；或者用户密码丢失，用户可以通过找回密码来重新设置一个新密码，这也算是可以恢复的；而用户账号如果丢失，用户无法登录系统，系统也无法通过其他途径来恢复这个账号，这就是不可恢复的数据。&lt;/p>
&lt;p>同样以用户管理系统的登录业务为例，简单分析如下表所示。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_26.png" alt="architecture-high-availability_26.png">&lt;/p>
&lt;h3 id="3-数据同步">3、数据同步&lt;/h3>
&lt;p>确定数据的特点后，可以根据不同的数据设计不同的同步方案。常见的数据同步方案有：&lt;/p>
&lt;p>1）存储系统同步&lt;/p>
&lt;p>这是最常用也是最简单的同步方式。例如，使用 MySQL 的数据主从数据同步、主主数据同步。&lt;/p>
&lt;p>这类数据同步的优点是使用简单，因为几乎主流的存储系统都会有自己的同步方案；缺点是这类同步方案都是通用的，无法针对业务数据特点做定制化的控制。例如，无论需要同步的数据量有多大，MySQL 都只有一个同步通道。因为要保证事务性，一旦数据量比较大，或者网络有延迟，则同步延迟就会比较严重。&lt;/p>
&lt;p>2）消息队列同步&lt;/p>
&lt;p>采用独立消息队列进行数据同步，常见的消息队列有 Kafka、ActiveMQ、RocketMQ 等。&lt;/p>
&lt;p>消息队列同步适合无事务性或者无时序性要求的数据。例如，用户账号，两个用户先后注册了账号 A 和 B，如果同步时先把 B 同步到异地机房，再同步 A 到异地机房，业务上是没有问题的。而如果是用户密码，用户先改了密码为 m，然后改了密码为 n，同步时必须先保证同步 m 到异地机房，再同步 n 到异地机房；如果反过来，同步后用户的密码就不对了。因此，对于新注册的用户账号，可以采用消息队列同步了；而对于用户密码，就不能采用消息队列同步了。&lt;/p>
&lt;p>3）重复生成&lt;/p>
&lt;p>数据不同步到异地机房，每个机房都可以生成数据，这个方案适合于可以重复生成的数据。例如，登录产生的 cookie、session 数据、缓存数据等。&lt;/p>
&lt;p>同样以用户管理系统的登录业务为例，针对不同的数据特点设计不同的同步方案，如下表所示。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_27.png" alt="architecture-high-availability_27.png">&lt;/p>
&lt;h3 id="4-异常处理">4、异常处理&lt;/h3>
&lt;p>无论数据同步方案如何设计，一旦出现极端异常的情况，总是会有部分数据出现异常的。例如，同步延迟、数据丢失、数据不一致等。异常处理就是假设在出现这些问题时，系统将采取什么措施来应对。异常处理主要有以下几个目的：&lt;/p>
&lt;p>1）问题发生时，避免少量数据异常导致整体业务不可用。&lt;/p>
&lt;p>2）问题恢复后，将异常的数据进行修正。&lt;/p>
&lt;p>3）对用户进行安抚，弥补用户损失。&lt;/p>
&lt;p>常见的异常处理措施有这几类：&lt;/p>
&lt;h4 id="多通道同步">多通道同步&lt;/h4>
&lt;p>多通道同步的含义是采取多种方式来进行数据同步，其中某条通道故障的情况下，系统可以通过其他方式来进行同步，这种方式可以应对同步通道处故障的情况。&lt;/p>
&lt;p>以用户管理系统中的用户账号数据为例，我们的设计方案一开始挑选了消息队列的方式进行同步，考虑异常情况下，消息队列同步通道可能中断，也可能延迟很严重；为了保证新注册账号能够快速同步到异地机房，再增加一种 MySQL 同步这种方式作为备份。这样针对用户账号数据同步，系统就有两种同步方式：MySQL 主从同步和消息队列同步。除非两个通道同时故障，否则用户账号数据在其中一个通道异常的情况下，能够通过另外一个通道继续同步到异地机房，如下图所示。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_28.png" alt="architecture-high-availability_28.png">&lt;/p>
&lt;p>多通道同步设计的方案关键点有：&lt;/p>
&lt;p>1）一般情况下，采取两通道即可，采取更多通道理论上能够降低风险，但付出的成本也会增加很多。&lt;/p>
&lt;p>2）数据库同步通道和消息队列同步通道不能采用相同的网络连接，否则一旦网络故障，两个通道都同时故障；可以一个走公网连接，一个走内网连接。&lt;/p>
&lt;p>3）需要数据是可以重复覆盖的，即无论哪个通道先到哪个通道后到，最终结果是一样的。例如，新建账号数据就符合这个标准，而密码数据则不符合这个标准。&lt;/p>
&lt;h4 id="同步和访问结合">同步和访问结合&lt;/h4>
&lt;p>这里的访问指异地机房通过系统的接口来进行数据访问。例如业务部署在异地两个机房 A 和 B，B 机房的业务系统通过接口来访问 A 机房的系统获取账号信息，如下图所示。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_29.png" alt="architecture-high-availability_29.png">&lt;/p>
&lt;p>同步和访问结合方案的设计关键点有：&lt;/p>
&lt;p>1）接口访问通道和数据库同步通道不能采用相同的网络连接，不能让数据库同步和接口访问都走同一条网络通道，可以采用接口访问走公网连接，数据库同步走内网连接这种方式。&lt;/p>
&lt;p>2）数据有路由规则，可以根据数据来推断应该访问哪个机房的接口来读取数据。例如，有 3 个机房 A、B、C，B 机房拿到一个不属于 B 机房的数据后，需要根据路由规则判断是访问 A 机房接口，还是访问 C 机房接口。&lt;/p>
&lt;p>3）由于有同步通道，优先读取本地数据，本地数据无法读取到再通过接口去访问，这样可以大大降低跨机房的异地接口访问数量，适合于实时性要求非常高的数据。&lt;/p>
&lt;h4 id="日志记录">日志记录&lt;/h4>
&lt;p>日志记录主要用于用户故障恢复后对数据进行恢复，其主要方式是每个关键操作前后都记录相关一条日志，然后将日志保存在一个独立的地方，当故障恢复后，拿出日志跟数据进行对比，对数据进行修复。&lt;/p>
&lt;p>为了应对不同级别的故障，日志保存的要求也不一样，常见的日志保存方式有：&lt;/p>
&lt;p>1）服务器上保存日志，数据库中保存数据，这种方式可以应对单台数据库服务器故障或者宕机的情况。&lt;/p>
&lt;p>2）本地独立系统保存日志，这种方式可以应对某业务服务器和数据库同时宕机的情况。例如，服务器和数据库部署在同一个机架，或者同一个电源线路上，就会出现服务器和数据库同时宕机的情况。&lt;/p>
&lt;p>3）日志异地保存，这种方式可以应对机房宕机的情况。&lt;/p>
&lt;p>上面不同的日志保存方式，应对的故障越严重，方案本身的复杂度和成本就会越高，实际选择时需要综合考虑成本和收益情况。&lt;/p>
&lt;h4 id="用户补偿">用户补偿&lt;/h4>
&lt;p>无论采用什么样的异常处理措施，都只能最大限度地降低受到影响的范围和程度，无法完全做到没有任何影响。例如，双同步通道有可能同时出现故障、日志记录方案本身日志也可能丢失。因此，无论多么完美的方案，故障的场景下总是可能有一小部分用户业务上出问题，系统无法弥补这部分用户的损失。但可以采用人工的方式对用户进行补偿，弥补用户损失，培养用户的忠诚度。简单来说，系统的方案是为了保证 99.99% 的用户在故障的场景下业务不受影响，人工的补偿是为了弥补 0.01% 的用户的损失。&lt;/p>
&lt;p>常见的补偿措施有送用户代金券、礼包、礼品、红包等，有时为了赢得用户口碑，付出的成本可能还会比较大，但综合最终的收益来看还是很值得的。例如暴雪《炉石传说》2017 年回档故障，暴雪给每个用户大约价值人民币 200 元的补偿，结果玩家都求暴雪再来一次回档，形象地说明了玩家对暴雪补偿的充分认可。&lt;/p>
&lt;h2 id="应对接口级故障">应对接口级故障&lt;/h2>
&lt;p>介绍了异地多活方案。它主要用来应对系统级的故障，例如机器宕机、机房故障和网络故障等问题。这些系统级的故障虽然影响很大，但发生概率较小。在实际业务运行过程中，还有另外一种故障影响可能没有那么大，但发生的概率较高，这就是今天我要跟你聊的接口级的故障。&lt;/p>
&lt;p>接口级故障的典型表现就是，系统并没有宕机、网络也没有中断，但业务却出现问题了，例如业务响应缓慢、大量访问超时和大量访问出现异常（给用户弹出提示“无法连接数据库”）。&lt;/p>
&lt;p>这类问题的主要原因在于系统压力太大、负载太高，导致无法快速处理业务请求，由此引发更多的后续问题。最常见的情况就是，数据库慢查询将数据库的服务器资源耗尽，导致读写超时，业务读写数据库时要么无法连接数据库、要么超时，最终用户看到的现象就是访问很慢，一会儿访问抛出异常，一会儿访问又是正常结果。&lt;/p>
&lt;p>如果进一步探究，导致接口级故障的原因可以分为两大类：&lt;/p>
&lt;p>1）内部原因：包括程序 bug 导致死循环，某个接口导致数据库慢查询，程序逻辑不完善导致耗尽内存等。&lt;/p>
&lt;p>2）外部原因：包括黑客攻击，促销或者抢购引入了超出平时几倍甚至几十倍的用户，第三方系统大量请求，第三方系统响应缓慢等。&lt;/p>
&lt;p>解决接口级故障的核心思想和异地多活基本类似，都是&lt;strong>优先保证核心业务&lt;/strong>和&lt;strong>优先保证绝大部分用户&lt;/strong>。常见的应对方法有四种，&lt;strong>降级、熔断、限流和排队&lt;/strong>，下面会一一讲解。&lt;/p>
&lt;h3 id="降级">降级&lt;/h3>
&lt;p>降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。&lt;/p>
&lt;p>例如，论坛可以降级为只能看帖子，不能发帖子；也可以降级为只能看帖子和评论，不能发评论；而 App 的日志上传接口，可以完全停掉一段时间，这段时间内 App 都不能上传日志。&lt;/p>
&lt;p>降级的核心思想就是丢车保帅，优先保证核心业务。&lt;/p>
&lt;p>常见的实现降级的方式有两种：&lt;/p>
&lt;h4 id="系统后门降级">系统后门降级&lt;/h4>
&lt;p>简单来说，就是系统预留了后门用于降级操作。例如，系统提供一个降级 URL，当访问这个 URL 时，就相当于执行降级指令，具体的降级指令通过 URL 的参数传入即可。这种方案有一定的安全隐患，所以也会在 URL 中加入密码这类安全措施。&lt;/p>
&lt;p>系统后门降级的方式实现成本低，但主要缺点是如果服务器数量多，需要一台一台去操作，效率比较低，这在故障处理争分夺秒的场景下是比较浪费时间的。&lt;/p>
&lt;h4 id="独立降级系统">独立降级系统&lt;/h4>
&lt;p>为了解决系统后门降级方式的缺点，我们可以将降级操作独立到一个单独的系统中，实现复杂的权限管理、批量操作等功能。&lt;/p>
&lt;p>其基本架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_30.png" alt="architecture-high-availability_30.png">&lt;/p>
&lt;h3 id="熔断">熔断&lt;/h3>
&lt;p>熔断是指按照规则停掉外部接口的访问，防止某些外部接口故障导致自己的系统处理能力急剧下降或者出故障。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_31.png" alt="architecture-high-availability_31.png">&lt;/p>
&lt;p>熔断和降级是两个比较容易混淆的概念，因为单纯从名字上看，好像都有禁止某个功能的意思。但它们的内涵是不同的，因为&lt;strong>降级的目的是应对系统自身的故障，而熔断的目的是应对依赖的外部系统故障的情况&lt;/strong>。&lt;/p>
&lt;p>假设一个这样的场景：A 服务的 X 功能依赖 B 服务的某个接口，当 B 服务的接口响应很慢的时候，A 服务的 X 功能响应肯定也会被拖慢，进一步导致 A 服务的线程都被卡在 X 功能处理上，于是 A 服务的其他功能都会被卡住或者响应非常慢。&lt;/p>
&lt;p>这时就需要熔断机制了：A 服务不再请求 B 服务的这个接口，A 服务内部只要发现是请求 B 服务的这个接口就立即返回错误，从而避免 A 服务整个被拖慢甚至拖死。&lt;/p>
&lt;p>实现熔断机制有两个关键点：&lt;/p>
&lt;p>一是需要有一个&lt;strong>统一的 API 调用层&lt;/strong>，由 API 调用层来进行采样或者统计。如果接口调用散落在代码各处，就没法进行统一处理了。&lt;/p>
&lt;p>二是&lt;strong>阈值的设计&lt;/strong>，例如 1 分钟内 30% 的请求响应时间超过 1 秒就熔断，这个策略中的“1 分钟”“30%”“1 秒”都对最终的熔断效果有影响。实践中，一般都是先根据分析确定阈值，然后上线观察效果，再进行调优。&lt;/p>
&lt;h3 id="限流">限流&lt;/h3>
&lt;p>降级是从系统功能优先级的角度考虑如何应对故障，而限流则是从用户访问压力的角度来考虑如何应对故障。限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。&lt;/p>
&lt;p>虽然“丢弃”这个词听起来让人不太舒服，但保证一部分请求能够正常响应，总比全部请求都不能响应要好得多。&lt;/p>
&lt;p>限流一般都是系统内实现的，常见的限流方式可以分为两类：基于请求限流和基于资源限流。&lt;/p>
&lt;h4 id="基于请求限流">基于请求限流&lt;/h4>
&lt;p>基于请求限流指从外部访问的请求角度考虑限流，常见的方式有两种。&lt;/p>
&lt;p>第一种是限制总量，也就是限制某个指标的累积上限，常见的是限制当前系统服务的用户总量，例如：某个直播间限制总用户数上限为 100 万，超过 100 万后新的用户无法进入；某个抢购活动商品数量只有 100 个，限制参与抢购的用户上限为 1 万个，1 万以后的用户直接拒绝。&lt;/p>
&lt;p>第二种是限制时间量，也就是限制一段时间内某个指标的上限，例如 1 分钟内只允许 10000 个用户访问；每秒请求峰值最高为 10 万。&lt;/p>
&lt;p>无论是限制总量还是限制时间量，共同的特点都是实现简单，但在实践中面临的主要问题是比较难以找到合适的阈值。例如系统设定了 1 分钟 10000 个用户，但实际上 6000 个用户的时候系统就扛不住了；或者达到 1 分钟 10000 用户后，其实系统压力还不大，但此时已经开始丢弃用户访问了。&lt;/p>
&lt;p>即使找到了合适的阈值，基于请求限流还面临硬件相关的问题。例如一台 32 核的机器和 64 核的机器处理能力差别很大，阈值是不同的，可能有的技术人员以为简单根据硬件指标进行数学运算就可以得出来，实际上这样是不可行的，64 核的机器比 32 核的机器，业务处理性能并不是 2 倍的关系，可能是 1.5 倍，甚至可能是 1.1 倍。&lt;/p>
&lt;p>为了找到合理的阈值，通常情况下可以采用性能压测来确定阈值，但性能压测也存在覆盖场景有限的问题，可能出现某个性能压测没有覆盖的功能导致系统压力很大；另外一种方式是逐步优化：先设定一个阈值然后上线观察运行情况，发现不合理就调整阈值。&lt;/p>
&lt;p>基于上述的分析，根据阈值来限制访问量的方式更多的适应于业务功能比较简单的系统，例如负载均衡系统、网关系统、抢购系统等。&lt;/p>
&lt;h4 id="基于资源限流">基于资源限流&lt;/h4>
&lt;p>基于请求限流是从系统外部考虑的，而基于资源限流是从系统内部考虑的，也就是找到系统内部影响性能的关键资源，对其使用上限进行限制。常见的内部资源包括连接数、文件句柄、线程数和请求队列等。&lt;/p>
&lt;p>例如，采用 Netty 来实现服务器，每个进来的请求都先放入一个队列，业务线程再从队列读取请求进行处理，队列长度最大值为 10000，队列满了就拒绝后面的请求；也可以根据 CPU 的负载或者占用率进行限流，当 CPU 的占用率超过 80% 的时候就开始拒绝新的请求。&lt;/p>
&lt;p>基于资源限流相比基于请求限流能够更加有效地反映当前系统的压力，但实际设计时也面临两个主要的难点：如何确定关键资源，以及如何确定关键资源的阈值。&lt;/p>
&lt;p>通常情况下，这也是一个逐步调优的过程：设计的时候先根据推断选择某个关键资源和阈值，然后测试验证，再上线观察，如果发现不合理，再进行优化。&lt;/p>
&lt;h4 id="限流算法">限流算法&lt;/h4>
&lt;p>为了更好地实现前面描述的各种限流方式，通常情况下我们会基于限流算法来设计方案。常见的限流算法有两大类四小类，它们的实现原理和优缺点各不相同，在实际设计的时候需要根据业务场景来选择。&lt;/p>
&lt;p>1、时间窗&lt;/p>
&lt;p>第一大类是时间窗算法，它会限制一定时间窗口内的请求量或者资源消耗量，根据实现方式又可以细分为“固定时间窗”和“滑动时间窗”。&lt;/p>
&lt;p>1）固定时间窗&lt;/p>
&lt;p>固定时间窗算法的实现原理是，统计固定时间周期内的请求量或者资源消耗量，超过限额就会启动限流，如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_32.png" alt="architecture-high-availability_32.png">&lt;/p>
&lt;p>它的优点是实现简单，缺点是存在&lt;strong>临界点&lt;/strong>问题。例如上图中的红蓝两点只间隔了短短 10 秒，期间的请求数却已经达到 200，超过了算法规定的限额（1 分钟内处理 100）。但是因为这些请求分别来自两个统计窗口，从单个窗口来看还没有超出限额，所以并不会启动限流，结果可能导致系统因为压力过大而挂掉。&lt;/p>
&lt;p>2）滑动时间窗&lt;/p>
&lt;p>为了解决临界点问题，滑动时间窗算法应运而生，它的实现原理是，两个统计周期部分重叠，从而避免短时间内的两个统计点分属不同的时间窗的情况，如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_33.png" alt="architecture-high-availability_33.png">&lt;/p>
&lt;p>总体上来看，滑动时间窗的限流效果要比固定时间窗更好，但是实现也会稍微复杂一些。&lt;/p>
&lt;p>2、桶算法&lt;/p>
&lt;p>第二大类是桶算法，用一个虚拟的“桶”来临时存储一些东西。根据桶里面放的东西，又可以细分为“漏桶”和“令牌桶”。&lt;/p>
&lt;p>2.1 漏桶&lt;/p>
&lt;p>漏桶算法的实现原理是，将请求放入“桶”（消息队列等），业务处理单元（线程、进程和应用等）从桶里拿请求处理，桶满则丢弃新的请求。&lt;/p>
&lt;p>漏桶算法的三个关键实现点：&lt;/p>
&lt;p>1）流入速率不固定：可能瞬间流入非常多的请求，例如 0 点签到、整点秒杀。&lt;/p>
&lt;p>匀速 (极速) 流出：这是理解漏桶算法的关键，也就是说即使大量请求进入了漏桶，但是从漏桶2）流出的速度是匀速的，速度的最大值就是系统的极限处理速度（对应图中的“极速”）。这样就保证了系统在收到海量请求的时候不被压垮，这是第一层的保护措施。需要注意的是：如果漏桶没有堆积，那么流出速度就等于流入速度，这个时候流出速度就不是匀速的。&lt;/p>
&lt;p>3）桶满则丢弃请求：这是第二层保护措施，也就是说漏桶不是无限容量，而是有限容量，例如漏桶最多存储 100 万个请求，桶满了则直接丢弃后面的请求。&lt;/p>
&lt;p>漏桶算法的技术本质是总量控制，桶大小是设计关键，具体的优缺点如下：&lt;/p>
&lt;p>1）突发大量流量时丢弃的请求较少，因为漏桶本身有缓存请求的作用。&lt;/p>
&lt;p>2）桶大小动态调整比较困难（例如 Java BlockingQueue），需要不断的尝试才能找到符合业务需求的最佳桶大小。&lt;/p>
&lt;p>3）无法精确控制流出速度，也就是业务的处理速度。&lt;/p>
&lt;p>漏桶算法主要适用于瞬时高并发流量的场景（例如刚才提到的 0 点签到、整点秒杀等）。在短短几分钟内涌入大量请求时，为了更好的业务效果和用户体验，即使处理慢一些，也要做到尽量不丢弃用户请求。&lt;/p>
&lt;p>2.2 令牌桶算法&lt;/p>
&lt;p>令牌桶算法和漏桶算法的不同之处在于，桶中放入的不是请求，而是“令牌”，这个令牌就是业务处理前需要拿到的“许可证”。也就是说，当系统收到一个请求时，先要到令牌桶里面拿“令牌”，拿到令牌才能进一步处理，拿不到就要丢弃请求。&lt;/p>
&lt;p>令牌桶算法的三个关键设计点：&lt;/p>
&lt;p>1）有一个处理单元往桶里面放令牌，放的速率是可以控制的。&lt;/p>
&lt;p>2）桶里面可以累积一定数量的令牌，当突发流量过来的时候，因为桶里面有累积的令牌，此时的业务处理速度会超过令牌放入的速度。&lt;/p>
&lt;p>3）如果令牌不足，即使系统有能力处理，也会丢弃请求。&lt;/p>
&lt;p>令牌桶算法的技术本质是&lt;strong>速率控制&lt;/strong>，令牌产生的速率是设计关键，具体的优缺点如下：&lt;/p>
&lt;p>1）可以动态调整处理速率，实现更加灵活。&lt;/p>
&lt;p>2）突发大量流量的时候可能丢弃很多请求，因为令牌桶不能累积太多令牌。&lt;/p>
&lt;p>3）实现相对复杂。&lt;/p>
&lt;p>令牌桶算法主要适用于两种典型的场景，一种是需要控制访问第三方服务的速度，防止把下游压垮，例如支付宝需要控制访问银行接口的速率；另一种是需要控制自己的处理速度，防止过载，例如压测结果显示系统最大处理 TPS 是 100，那么就可以用令牌桶来限制最大的处理速度。&lt;/p>
&lt;p>上面介绍漏桶算法的时候提到漏桶算法可以应对瞬时高并发流量，现在介绍令牌桶算法时，又说令牌桶允许突发流量。&lt;/p>
&lt;p>其实，令牌桶的“允许突发”实际上只是“允许一定程度的突发”，比如系统处理能力是每秒 100 TPS，突发到 120 TPS 是可以的，但如果突发到 1000 TPS 的话，系统大概率就被压垮了。所以处理秒杀时高并发流量，还是得用漏桶算法。&lt;/p>
&lt;p>令牌桶的算法原本是用于网络设备控制传输速度的，而且它控制的目的是保证一段时间内的平均传输速度。之所以说令牌桶适合突发流量，是指在网络传输的时候，可以允许某段时间内（一般就几秒）超过平均传输速率，这在网络环境下常见的情况就是“网络抖动”。&lt;/p>
&lt;p>但这个短时间的突发流量并不会导致雪崩效应，网络设备也能够处理得过来。对应到令牌桶应用到业务处理的场景，就要求即使有突发流量来了，系统自己或者下游系统要真的能够处理的过来，否则令牌桶允许突发流量进来，结果系统或者下游处理不了，那还是会被压垮。&lt;/p>
&lt;p>因此，令牌桶在实际设计的时候，桶大小不能像漏桶那样设计很大，需要根据系统的处理能力来进行仔细的估算。例如，漏桶算法的桶容量可以设计为 100 万，但是一个每秒 30 TPS 的令牌桶，桶的容量可能只能设计成 40 左右。海外有的银行给移动钱包提供的接口 TPS 上限是 30，压测到了 40 就真的挂了。&lt;/p>
&lt;h3 id="排队">排队&lt;/h3>
&lt;p>排队实际上是限流的一个变种，限流是直接拒绝用户，排队是让用户等待一段时间，全世界最有名的排队当属 12306 网站排队了。&lt;/p>
&lt;p>排队虽然没有直接拒绝用户，但用户等了很长时间后进入系统，体验并不一定比限流好。&lt;/p>
&lt;p>由于排队需要临时缓存大量的业务请求，单个系统内部无法缓存这么多数据，一般情况下，排队需要用独立的系统去实现，例如使用 Kafka 这类消息队列来缓存用户请求。&lt;/p>
&lt;p>1 号店的“双 11”秒杀排队系统架构：（参考：&lt;a href="https://www.infoq.cn/article/yhd-11-11-queuing-system-design">https://www.infoq.cn/article/yhd-11-11-queuing-system-design&lt;/a>）&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-high-availability_34.png" alt="architecture-high-availability_34.png">&lt;/p>
&lt;p>基本实现摘录如下：&lt;/p>
&lt;p>【排队模块】负责接收用户的抢购请求，将请求以先入先出的方式保存下来。每一个参加秒杀活动的商品保存一个队列，队列的大小可以根据参与秒杀的商品数量（或加点余量）自行定义。&lt;/p>
&lt;p>【调度模块】负责排队模块到服务模块的动态调度，不断检查服务模块，一旦处理能力有空闲，就从排队队列头上把用户访问请求调入服务模块，并负责向服务模块分发请求。这里调度模块扮演一个中介的角色，但不只是传递请求而已，它还担负着调节系统处理能力的重任。我们可以根据服务模块的实际处理能力，动态调节向排队系统拉取请求的速度。&lt;/p>
&lt;p>【服务模块】负责调用真正业务来处理服务，并返回处理结果，调用排队模块的接口回写业务处理结果。&lt;/p></description></item><item><title>Docs: 架构设计04-可扩展架构模式</title><link>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A104-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A104-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid><description>
&lt;h2 id="可扩展架构的基本思想和模式">可扩展架构的基本思想和模式&lt;/h2>
&lt;p>架构可扩展模式内容包括分层架构、SOA 架构、微服务和微内核等。&lt;/p>
&lt;p>软件系统的这种天生和内在的可扩展的特性，既是魅力所在，又是难点所在。魅力体现在我们可以通过修改和扩展，不断地让软件系统具备更多的功能和特性，满足新的需求或者顺应技术发展的趋势。而难点体现在如何以最小的代价去扩展系统，因为很多情况下牵一发动全身，扩展时可能出现到处都要改，到处都要推倒重来的情况。这样做的风险不言而喻：改动的地方越多，投入也越大，出错的可能性也越大。因此，如何避免扩展时改动范围太大，是软件架构可扩展性设计的主要思考点。&lt;/p>
&lt;h3 id="可扩展的基本思想">可扩展的基本思想&lt;/h3>
&lt;p>可扩展性架构的设计方法很多，但万变不离其宗，所有的可扩展性架构设计，背后的基本思想都可以总结为一个字：&lt;strong>拆&lt;/strong>！&lt;/p>
&lt;p>拆，就是将原本大一统的系统拆分成多个规模小的部分，扩展时只修改其中一部分即可，无须整个系统到处都改，通过这种方式来减少改动范围，降低改动风险。&lt;/p>
&lt;p>按照不同的思路来拆分软件系统，就会得到不同的架构。常见的拆分思路有如下三种。&lt;/p>
&lt;p>1）面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分。&lt;/p>
&lt;p>2）面向服务拆分：将系统提供的服务拆分，每个服务作为一部分。&lt;/p>
&lt;p>3）面向功能拆分：将系统提供的功能拆分，每个功能作为一部分。&lt;/p>
&lt;p>理解这三种思路的关键就在于如何理解“流程”“服务”“功能”三者的联系和区别。从范围上来看，从大到小依次为：流程 &amp;gt; 服务 &amp;gt; 功能，单纯从概念解释可能难以理解，但实际上看几个案例就很清楚了。&lt;/p>
&lt;p>以 TCP/IP 协议栈为例，来说明“流程”“服务”“功能”的区别和联系。TCP/IP 协议栈和模型图如下图所示。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_1.png" alt="architecture-scalability_1.png">&lt;/p>
&lt;p>1）流程&lt;/p>
&lt;p>对应 TCP/IP 四层模型，因为 TCP/IP 网络通信流程是：应用层 → 传输层 → 网络层 → 物理 + 数据链路层，不管最上层的应用层是什么，这个流程都不会变。&lt;/p>
&lt;p>2）服务&lt;/p>
&lt;p>对应应用层的 HTTP、FTP、SMTP 等服务，HTTP 提供 Web 服务，FTP 提供文件服务，SMTP 提供邮件服务，以此类推。&lt;/p>
&lt;p>3）功能&lt;/p>
&lt;p>每个服务都会提供相应的功能。例如，HTTP 服务提供 GET、POST 功能，FTP 提供上传下载功能，SMTP 提供邮件发送和收取功能。&lt;/p>
&lt;p>再以一个简单的学生信息管理系统为例（几乎每个技术人员读书时都做过这样一个系统），拆分方式是：&lt;/p>
&lt;p>1、面向流程拆分&lt;/p>
&lt;p>展示层 → 业务层 → 数据层 → 存储层，各层含义是：&lt;/p>
&lt;p>1）展示层：负责用户页面设计，不同业务有不同的页面。例如，登录页面、注册页面、信息管理页面、安全设置页面等。&lt;/p>
&lt;p>2）业务层：负责具体业务逻辑的处理。例如，登录、注册、信息管理、修改密码等业务。&lt;/p>
&lt;p>3）数据层：负责完成数据访问。例如，增删改查数据库中的数据、记录事件到日志文件等。&lt;/p>
&lt;p>4）存储层：负责数据的存储。例如，关系型数据库 MySQL、缓存系统 Memcache 等。&lt;/p>
&lt;p>最终的架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_2.png" alt="architecture-scalability_2.png">&lt;/p>
&lt;p>2、面向服务拆分&lt;/p>
&lt;p>将系统拆分为注册、登录、信息管理、安全设置等服务，最终架构示意图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_3.png" alt="architecture-scalability_3.png">&lt;/p>
&lt;p>3、面向功能拆分&lt;/p>
&lt;p>每个服务都可以拆分为更多细粒度的功能，例如：&lt;/p>
&lt;p>1）注册服务：提供多种方式进行注册，包括手机号注册、身份证注册、学生邮箱注册三个功能。&lt;/p>
&lt;p>2）登录服务：包括手机号登录、身份证登录、邮箱登录三个功能。&lt;/p>
&lt;p>3）信息管理服务：包括基本信息管理、课程信息管理、成绩信息管理等功能。&lt;/p>
&lt;p>4）安全设置服务：包括修改密码、安全手机、找回密码等功能。&lt;/p>
&lt;p>最终架构图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_4.png" alt="architecture-scalability_4.png">&lt;/p>
&lt;p>通过学生信息管理系统的案例可以发现，不同的拆分方式，架构图差异很大。但好像无论哪种方式，最终都是可以实现的。既然如此，何必费尽心机去选择呢，随便挑选一个不就可以了？当然不能随便挑，否则架构设计就没有意义。原因在于：&lt;strong>不同的拆分方式，本质上决定了系统的扩展方式&lt;/strong>。&lt;/p>
&lt;h3 id="可扩展方式">可扩展方式&lt;/h3>
&lt;p>在一个理想的环境，团队都是高手，每个程序员都很厉害，对业务都很熟悉，新来的同事很快就知晓所有的细节……那确实不拆分也没有问题。但现实却是：团队有菜鸟程序员，到底是改 A 处实现功能还是改 B 处实现功能，完全取决于他觉得哪里容易改；有的程序员比较粗心；有的程序员某天精神状态不太好；新来的同事不知道历史上某行代码为何那么“恶心”，而轻易地将其改漂亮了一些……所有的这些问题都可能出现，这时候就会发现，合理的拆分，能够强制保证即使程序员出错，出错的范围也不会太广，影响也不会太大。&lt;/p>
&lt;p>下面是不同拆分方式应对扩展时的优势。&lt;/p>
&lt;h4 id="面向流程拆分">面向流程拆分&lt;/h4>
&lt;p>扩展时大部分情况只需要修改某一层，少部分情况可能修改关联的两层，不会出现所有层都同时要修改。例如学生信息管理系统，如果将存储层从 MySQL 扩展为同时支持 MySQL 和 Oracle，那么只需要扩展存储层和数据层即可，展示层和业务层无须变动。&lt;/p>
&lt;h4 id="面向服务拆分">面向服务拆分&lt;/h4>
&lt;p>对某个服务扩展，或者要增加新的服务时，只需要扩展相关服务即可，无须修改所有的服务。同样以学生管理系统为例，如果需要在注册服务中增加一种“学号注册”功能，则只需要修改“注册服务”和“登录服务”即可，“信息管理服务”和“安全设置”服务无须修改。&lt;/p>
&lt;h4 id="面向功能拆分">面向功能拆分&lt;/h4>
&lt;p>对某个功能扩展，或者要增加新的功能时，只需要扩展相关功能即可，无须修改所有的服务。同样以学生管理系统为例，如果增加“学号注册”功能，则只需要在系统中增加一个新的功能模块，同时修改“登录功能”模块即可，其他功能都不受影响。&lt;/p>
&lt;p>不同的拆分方式，将得到不同的系统架构，典型的&lt;strong>可扩展系统架构&lt;/strong>有：&lt;/p>
&lt;p>1）面向流程拆分：&lt;strong>分层架构&lt;/strong>。&lt;/p>
&lt;p>2）面向服务拆分：&lt;strong>SOA&lt;/strong>、&lt;strong>微服务&lt;/strong>。&lt;/p>
&lt;p>3）面向功能拆分：&lt;strong>微内核架构&lt;/strong>。&lt;/p>
&lt;p>当然，这几个系统架构并&lt;strong>不是非此即彼&lt;/strong>的，而是可以在系统架构设计中进行组合使用的。以学生管理系统为例，最终可以这样设计架构：&lt;/p>
&lt;p>1）整体系统采用面向服务拆分中的“微服务”架构，拆分为“注册服务”“登录服务”“信息管理服务”“安全服务”，每个服务是一个独立运行的子系统。&lt;/p>
&lt;p>2）其中的“注册服务”子系统本身又是采用面向流程拆分的分层架构。&lt;/p>
&lt;p>3）“登录服务”子系统采用的是面向功能拆分的“微内核”架构。&lt;/p>
&lt;h2 id="传统的可扩展架构模式-分层架构和soa">传统的可扩展架构模式：分层架构和SOA&lt;/h2>
&lt;p>相比于高性能、高可用架构模式在最近几十年的迅猛发展来说，可扩展架构模式的发展可以说是步履蹒跚，最近几年火热的微服务模式算是可扩展模式发展历史中为数不多的亮点，但这也导致了现在谈可扩展的时候必谈微服务，甚至微服务架构都成了架构设计的银弹，高性能也用微服务、高可用也用微服务，很多时候这样的架构设计看起来高大上，实际上是大炮打蚊子，违背了架构设计的“合适原则”和“简单原则”。&lt;/p>
&lt;h3 id="分层架构">分层架构&lt;/h3>
&lt;p>分层架构是很常见的架构模式，它也叫 N 层架构，通常情况下，N 至少是 2 层。例如，C/S 架构、B/S 架构。常见的是 3 层架构（例如，MVC、MVP 架构）、4 层架构，5 层架构的比较少见，一般是比较复杂的系统才会达到或者超过 5 层，比如操作系统内核架构。&lt;/p>
&lt;p>按照分层架构进行设计时，根据不同的划分维度和对象，可以得到多种不同的分层架构。&lt;/p>
&lt;h4 id="c-s-架构-b-s-架构">C/S 架构、B/S 架构&lt;/h4>
&lt;p>划分的对象是整个业务系统，划分的维度是用户交互，即将和用户交互的部分独立为一层，支撑用户交互的后台作为另外一层。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_5.png" alt="architecture-scalability_5.png">&lt;/p>
&lt;h4 id="mvc-架构-mvp-架构">MVC 架构、MVP 架构&lt;/h4>
&lt;p>划分的对象是单个业务子系统，划分的维度是职责，将不同的职责划分到独立层，但各层的依赖关系比较灵活。例如，MVC 架构中各层之间是两两交互的：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_6.png" alt="architecture-scalability_6.png">&lt;/p>
&lt;h4 id="逻辑分层架构">逻辑分层架构&lt;/h4>
&lt;p>划分的对象可以是单个业务子系统，也可以是整个业务系统，划分的维度也是职责。虽然都是基于职责划分，但逻辑分层架构和 MVC 架构、MVP 架构的不同点在于，逻辑分层架构中的层是自顶向下依赖的。典型的有操作系统内核架构、TCP/IP 架构。例如，下面是 Android 操作系统架构图。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_7.png" alt="architecture-scalability_7.png">&lt;/p>
&lt;p>典型的 J2EE 系统架构也是逻辑分层架构，架构图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_8.png" alt="architecture-scalability_8.png">&lt;/p>
&lt;p>针对整个业务系统进行逻辑分层的架构图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_9.png" alt="architecture-scalability_9.png">&lt;/p>
&lt;p>无论采取何种分层维度，分层架构设计最核心的一点就是&lt;strong>需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构&lt;/strong>，这也是分层不能分太多层的原因。否则如果两个层的差异不明显，就会出现程序员小明认为某个功能应该放在 A 层，而程序员老王却认为同样的功能应该放在 B 层，这样会导致分层混乱。如果这样的架构进入实际开发落地，则 A 层和 B 层就会乱成一锅粥，也就失去了分层的意义。&lt;/p>
&lt;p>分层架构之所以能够较好地支撑系统扩展，本质在于&lt;strong>隔离关注点&lt;/strong>（separation of concerns），即每个层中的组件只会处理本层的逻辑。比如说，展示层只需要处理展示逻辑，业务层中只需要处理业务逻辑，这样我们在扩展某层时，其他层是不受影响的，通过这种方式可以支撑系统在某层上快速扩展。例如，Linux 内核如果要增加一个新的文件系统，则只需要修改文件存储层即可，其他内核层无须变动。&lt;/p>
&lt;p>当然，并不是简单地分层就一定能够实现隔离关注点从而支撑快速扩展，分层时要保证层与层之间的依赖是稳定的，才能真正支撑快速扩展。例如，Linux 内核为了支撑不同的文件系统格式，抽象了 VFS 文件系统接口，架构图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_10.png" alt="architecture-scalability_10.png">&lt;/p>
&lt;p>如果没有 VFS，只是简单地将 ext2、ext3、reiser 等文件系统划为“文件系统层”，那么这个分层是达不到支撑可扩展的目的的。因为增加一个新的文件系统后，所有基于文件系统的功能都要适配新的文件系统接口；而有了 VFS 后，只需要 VFS 适配新的文件系统接口，其他基于文件系统的功能是依赖 VFS 的，不会受到影响。&lt;/p>
&lt;p>&lt;strong>对于操作系统这类复杂的系统，接口本身也可以成为独立的一层&lt;/strong>。例如，把 VFS 独立为一层是完全可以的。而对于一个简单的业务系统，接口可能就是 Java 语言上的几个 interface 定义，这种情况下如果独立为一层，看起来可能就比较重了。例如，经典的 J2EE 分层架构中，Presentation Layer 和 Business Layer 之间如果硬要拆分一个独立的接口层，则显得有点多余了。&lt;/p>
&lt;p>分层结构的另外一个特点就是层层传递，也就是说一旦分层确定，整个业务流程是按照层进行依次传递的，不能在层之间进行跳跃。最简单的 C/S 结构，用户必须先使用 C 层，然后 C 层再传递到 S 层，用户是不能直接访问 S 层的。传统的 J2EE 4 层架构，收到请求后，必须按照下面的方式传递请求：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_11.png" alt="architecture-scalability_11.png">&lt;/p>
&lt;p>分层结构的这种约束，好处在于强制将分层依赖限定为两两依赖，降低了整体系统复杂度。例如，Business Layer 被 Presentation Layer 依赖，自己只依赖 Persistence Layer。但分层结构的代价就是冗余，也就是说，不管这个业务有多么简单，每层都必须要参与处理，甚至可能每层都写了一个简单的包装函数。以用户管理系统最简单的一个功能“查看头像”为例。查看头像功能的实现很简单，只是显示一张图片而已，但按照分层分册架构来实现，每层都要写一个简单的函数。&lt;/p>
&lt;p>不建议自由选择是否绕过分层的约束，分层架构的优势就体现在通过分层强制约束两两依赖，一旦自由选择绕过分层，时间一长，架构就会变得混乱。除此以外，虽然分层架构的实现在某些场景下看起来有些啰嗦和冗余，但复杂度却很低。&lt;/p>
&lt;p>分层架构另外一个典型的缺点就是性能，因为每一次业务请求都需要穿越所有的架构分层，有一些事情是多余的，多少都会有一些性能的浪费。当然，这里所谓的性能缺点只是理论上的分析，实际上分层带来的性能损失，如果放到 20 世纪 80 年代，可能很明显；但到了现在，硬件和网络的性能有了质的飞越，其实分层模式理论上的这点性能损失，在实际应用中，绝大部分场景下都可以忽略不计。&lt;/p>
&lt;h3 id="soa">SOA&lt;/h3>
&lt;p>SOA 的全称是 Service Oriented Architecture，中文翻译为“面向服务的架构”，诞生于上世纪 90 年代，1996 年 Gartner 的两位分析师 Roy W. Schulte 和 Yefim V. Natis 发表了第一个 SOA 的报告。&lt;/p>
&lt;p>2005 年，Gartner 预言：到了 2008 年，SOA 将成为 80% 的开发项目的基础（&lt;a href="https://www.safaribooksonline.com/library/view/soa-in-practice/9780596529550/ch01s04.html">https://www.safaribooksonline.com/library/view/soa-in-practice/9780596529550/ch01s04.html&lt;/a>）。历史证明这个预言并不十分靠谱，SOA 虽然在很多企业成功推广，但没有达到占有绝对优势的地步。SOA 更多是在传统企业（例如，制造业、金融业等）落地和推广，在互联网行业并没有大规模地实践和推广。互联网行业推行 SOA 最早的应该是亚马逊，得益于杰弗·贝索斯的远见卓识，亚马逊内部的系统都以服务的方式构造，间接地促使了后来的亚马逊云计算技术的出现。&lt;/p>
&lt;p>SOA 出现 的背景是企业内部的 IT 系统重复建设且效率低下，主要体现在：&lt;/p>
&lt;p>1）企业各部门有独立的 IT 系统，比如人力资源系统、财务系统、销售系统，这些系统可能都涉及人员管理，各 IT 系统都需要重复开发人员管理的功能。例如，某个员工离职后，需要分别到上述三个系统中删除员工的权限。&lt;/p>
&lt;p>2）各个独立的 IT 系统可能采购于不同的供应商，实现技术不同，企业自己也不太可能基于这些系统进行重构。&lt;/p>
&lt;p>3）随着业务的发展，复杂度越来越高，更多的流程和业务需要多个 IT 系统合作完成。由于各个独立的 IT 系统没有标准的实现方式（例如，人力资源系统用 Java 开发，对外提供 RPC；而财务系统用 C# 开发，对外提供 SOAP 协议），每次开发新的流程和业务，都需要协调大量的 IT 系统，同时定制开发，效率很低。&lt;/p>
&lt;p>为了应对传统 IT 系统存在的问题，SOA 提出了 3 个关键概念。&lt;/p>
&lt;p>1）服务&lt;/p>
&lt;p>所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。&lt;/p>
&lt;p>服务可大可小，可简单也可复杂。例如，人力资源管理可以是一项服务，包括人员基本信息管理、请假管理、组织结构管理等功能；而人员基本信息管理也可以作为一项独立的服务，组织结构管理也可以作为一项独立的服务。到底是划分为粗粒度的服务，还是划分为细粒度的服务，需要根据企业的实际情况进行判断。&lt;/p>
&lt;p>2）ESB&lt;/p>
&lt;p>ESB 的全称是 Enterprise Service Bus，中文翻译为“企业服务总线”。从名字就可以看出，ESB 参考了计算机总线的概念。计算机中的总线将各个不同的设备连接在一起，ESB 将企业中各个不同的服务连接在一起。因为各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。SOA 使用 ESB 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。&lt;/p>
&lt;p>3）松耦合&lt;/p>
&lt;p>松耦合的目的是减少各个服务间的依赖和互相影响。因为采用 SOA 架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖。如果做不到松耦合，某个服务一升级，依赖它的其他服务全部故障，这样肯定是无法满足业务需求的。&lt;/p>
&lt;p>但实际上真正做到松耦合并没有那么容易，要做到完全后向兼容，是一项复杂的任务。&lt;/p>
&lt;p>典型的 SOA 架构样例如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_12.png" alt="architecture-scalability_12.png">&lt;/p>
&lt;p>SOA 架构是比较高层级的架构设计理念，一般情况下可以说某个企业采用了 SOA 的架构来构建 IT 系统，但不会说某个独立的系统采用了 SOA 架构。例如，某企业采用 SOA 架构，将系统分为“人力资源管理服务”“考勤服务”“财务服务”，但人力资源管理服务本身通常不会再按照 SOA 的架构拆分更多服务，也不会再使用独立的一套 ESB，因为这些系统本身可能就是采购的，ESB 本身也是采购的，如果人力资源系统本身重构为多个子服务，再部署独立的 ESB 系统，成本很高，也没有什么收益。&lt;/p>
&lt;p>SOA 解决了传统 IT 系统重复建设和扩展效率低的问题，但其本身也引入了更多的复杂性。SOA 最广为人诟病的就是 ESB，ESB 需要实现与各种系统间的协议转换、数据转换、透明的动态路由等功能。例如，下图中 ESB 将 JSON 转换为 Java（摘自《Microservices vs. Service-Oriented Architecture》）。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_13.png" alt="architecture-scalability_13.png">&lt;/p>
&lt;p>下图中 ESB 将 REST 协议转换为 RMI 和 AMQP 两个不同的协议：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_14.png" alt="architecture-scalability_14.png">&lt;/p>
&lt;p>ESB 虽然功能强大，但现实中的协议有很多种，如 JMS、WS、HTTP、RPC 等，数据格式也有很多种，如 XML、JSON、二进制、HTML 等。ESB 要完成这么多协议和数据格式的互相转换，工作量和复杂度都很大，而且这种转换是需要耗费大量计算性能的，当 ESB 承载的消息太多时，ESB 本身会成为整个系统的性能瓶颈。&lt;/p>
&lt;p>当然，SOA 的 ESB 设计也是无奈之举。回想一下 SOA 的提出背景就可以发现，企业在应用 SOA 时，各种异构的 IT 系统都已经存在很多年了，完全重写或者按照统一标准进行改造的成本是非常大的，只能通过 ESB 方式去适配已经存在的各种异构系统。&lt;/p>
&lt;h2 id="深入理解微服务架构">深入理解微服务架构&lt;/h2>
&lt;h3 id="微服务背景">微服务背景&lt;/h3>
&lt;p>微服务是近几年非常火热的架构设计理念，大部分人认为是 Martin Fowler 提出了微服务概念，但事实上微服务概念的历史要早得多，也不是 Martin Fowler 创造出来的，Martin 只是将微服务进行了系统的阐述（原文链接：&lt;a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html&lt;/a>）。不过不能否认 Martin 在推动微服务起到的作用，微服务能火，Martin 功不可没。&lt;/p>
&lt;p>微服务的定义相信早已耳熟能详，参考维基百科，简单梳理一下微服务的历史（&lt;a href="https://en.wikipedia.org/wiki/Microservices#History">https://en.wikipedia.org/wiki/Microservices#History&lt;/a>）：&lt;/p>
&lt;p>1）2005 年：Dr. Peter Rodgers 在 Web Services Edge 大会上提出了“Micro-Web-Services”的概念。&lt;/p>
&lt;p>2）2011 年：一个软件架构工作组使用了“microservice”一词来描述一种架构模式。&lt;/p>
&lt;p>3）2012 年：同样是这个架构工作组，正式确定用“microservice”来代表这种架构。&lt;/p>
&lt;p>4）2012 年：ThoughtWorks 的 James Lewis 针对微服务概念在 QCon San Francisco 2012 发表了演讲。&lt;/p>
&lt;p>5）2014 年：James Lewis 和 Martin Fowler 合写了关于微服务的一篇学术性的文章，详细阐述了微服务。&lt;/p>
&lt;p>由于微服务的理念中也包含了“服务”的概念，而 SOA 中也有“服务”的概念，自然而然地会提出疑问：微服务与 SOA 有什么关系？有什么区别？为何有了 SOA 还要提微服务？&lt;/p>
&lt;h3 id="微服务与-soa-的关系">微服务与 SOA 的关系&lt;/h3>
&lt;p>关于 SOA 和微服务的关系和区别，大概分为下面几个典型的观点。&lt;/p>
&lt;p>1、微服务是 SOA 的实现方式&lt;/p>
&lt;p>如下图所示，这种观点认为 SOA 是一种架构理念，而微服务是 SOA 理念的一种具体实现方法。例如，“微服务就是使用 HTTP RESTful 协议来实现 ESB 的 SOA”“使用 SOA 来构建单个系统就是微服务”和“微服务就是更细粒度的 SOA”。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_15.png" alt="architecture-scalability_15.png">&lt;/p>
&lt;p>2、微服务是去掉 ESB 后的 SOA&lt;/p>
&lt;p>如下图所示，这种观点认为传统 SOA 架构最广为人诟病的就是庞大、复杂、低效的 ESB，因此将 ESB 去掉，改为轻量级的 HTTP 实现，就是微服务。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_16.png" alt="architecture-scalability_16.png">&lt;/p>
&lt;p>3、微服务是一种和 SOA 相似但本质上不同的架构理念&lt;/p>
&lt;p>如下图所示，这种观点认为微服务和 SOA 只是有点类似，但本质上是不同的架构设计理念。相似点在于下图中交叉的地方，就是两者都关注“服务”，都是通过服务的拆分来解决可扩展性问题。本质上不同的地方在于几个核心理念的差异：是否有 ESB、服务的粒度、架构设计的目标等。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_17.png" alt="architecture-scalability_17.png">&lt;/p>
&lt;p>以上观点看似都有一定的道理，但都有点差别，到底哪个才是准确的呢？单纯从概念上是难以分辨的，对比一下 SOA 和微服务的一些具体做法，再来看看到底哪一种观点更加符合实际情况。&lt;/p>
&lt;p>1、服务粒度&lt;/p>
&lt;p>整体上来说，SOA 的服务粒度要粗一些，而微服务的服务粒度要细一些。例如，对一个大型企业来说，“员工管理系统”就是一个 SOA 架构中的服务；而如果采用微服务架构，则“员工管理系统”会被拆分为更多的服务，比如“员工信息管理”“员工考勤管理”“员工假期管理”和“员工福利管理”等更多服务。&lt;/p>
&lt;p>2、服务通信&lt;/p>
&lt;p>SOA 采用了 ESB 作为服务间通信的关键组件，负责服务定义、服务路由、消息转换、消息传递，总体上是重量级的实现。微服务推荐使用统一的协议和格式，例如，RESTful 协议、RPC 协议，无须 ESB 这样的重量级实现。Martin Fowler 将微服务架构的服务通讯理念称为“Smart endpoints and dumb pipes”，简单翻译为“聪明的终端，愚蠢的管道”。之所以用“愚蠢”二字，其实就是与 ESB 对比的，因为 ESB 太强大了，既知道每个服务的协议类型（例如，是 RMI 还是 HTTP），又知道每个服务的数据类型（例如，是 XML 还是 JSON），还知道每个数据的格式（例如，是 2017-01-01 还是 01/01/2017），而微服务的“dumb pipes”仅仅做消息传递，对消息格式和内容一无所知。&lt;/p>
&lt;p>3、服务交付&lt;/p>
&lt;p>SOA 对服务的交付并没有特殊要求，因为 SOA 更多考虑的是兼容已有的系统；微服务的架构理念要求“快速交付”，相应地要求采取自动化测试、持续集成、自动化部署等敏捷开发相关的最佳实践。如果没有这些基础能力支撑，微服务规模一旦变大（例如，超过 20 个微服务），整体就难以达到快速交付的要求，这也是很多企业在实行微服务时踩过的一个明显的坑，就是系统拆分为微服务后，部署的成本呈指数上升。&lt;/p>
&lt;p>4、应用场景&lt;/p>
&lt;p>SOA 更加适合于庞大、复杂、异构的企业级系统，这也是 SOA 诞生的背景。这类系统的典型特征就是很多系统已经发展多年，采用不同的企业级技术，有的是内部开发的，有的是外部购买的，无法完全推倒重来或者进行大规模的优化和重构。因为成本和影响太大，只能采用兼容的方式进行处理，而承担兼容任务的就是 ESB。&lt;/p>
&lt;p>微服务更加适合于快速、轻量级、基于 Web 的互联网系统，这类系统业务变化快，需要快速尝试、快速交付；同时基本都是基于 Web，虽然开发技术可能差异很大（例如，Java、C++、.NET 等），但对外接口基本都是提供 HTTP RESTful 风格的接口，无须考虑在接口层进行类似 SOA 的 ESB 那样的处理。&lt;/p>
&lt;p>综合上述分析，将 SOA 和微服务对比如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_18.png" alt="architecture-scalability_18.png">&lt;/p>
&lt;p>因此可以看到，SOA 和微服务本质上是两种不同的架构设计理念，只是在“服务”这个点上有交集而已，因此两者的关系应该是上面第三种观点。其实，Martin Fowler 在他的微服务文章中，已经做了很好的提炼：（&lt;a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html&lt;/a>）&lt;/p>
&lt;blockquote>
&lt;p>In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery.&lt;/p>
&lt;/blockquote>
&lt;p>上述英文的三个关键词分别是：small、lightweight、automated，基本上浓缩了微服务的精华，也是微服务与 SOA 的本质区别所在。&lt;/p>
&lt;p>通过前面的详细分析和比较，似乎微服务本质上就是一种比 SOA 要优秀很多的架构模式，那是否意味着我们都应该把架构重构为微服务呢？&lt;/p>
&lt;p>其实不然，SOA 和微服务是两种不同理念的架构模式，并不存在孰优孰劣，只是应用场景不同而已。介绍 SOA 时候提到其产生历史背景是因为企业的 IT 服务系统庞大而又复杂，改造成本很高，但业务上又要求其互通，因此才会提出 SOA 这种解决方案。如果将微服务的架构模式生搬硬套到企业级 IT 服务系统中，这些 IT 服务系统的改造成本可能远远超出实施 SOA 的成本。&lt;/p>
&lt;h3 id="微服务的陷阱">微服务的陷阱&lt;/h3>
&lt;p>单纯从上面的对比来看，似乎微服务大大优于 SOA，这也导致了很多团队在实践时不加思考地采用微服务——既不考虑团队的规模，也不考虑业务的发展，也没有考虑基础技术的支撑，只是觉得微服务很牛就赶紧来实施，以为实施了微服务后就什么问题都解决了，而一旦真正实施后才发现掉到微服务的坑里面去了。&lt;/p>
&lt;p>看一下微服务具体有哪些坑：&lt;/p>
&lt;p>1、服务划分过细，服务间关系复杂&lt;/p>
&lt;p>服务划分过细，单个服务的复杂度确实下降了，但整个系统的复杂度却上升了，因为微服务将系统内的复杂度转移为系统间的复杂度了。&lt;/p>
&lt;p>从理论的角度来计算，n 个服务的复杂度是 n×(n-1)/2，整体系统的复杂度是随着微服务数量的增加呈指数级增加的。下图形象了说明了整体复杂度：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_19.png" alt="architecture-scalability_19.png">&lt;/p>
&lt;p>粗粒度划分服务时，系统被划分为 3 个服务，虽然单个服务较大，但服务间的关系很简单；细粒度划分服务时，虽然单个服务小了一些，但服务间的关系却复杂了很多。&lt;/p>
&lt;p>2、服务数量太多，团队效率急剧下降&lt;/p>
&lt;p>微服务的“微”字，本身就是一个陷阱，很多团队看到“微”字后，就想到必须将服务拆分得很细，有的团队人员规模是 5 ~ 6 个人，然而却拆分出 30 多个微服务，平均每个人要维护 5 个以上的微服务。&lt;/p>
&lt;p>这样做给工作效率带来了明显的影响，一个简单的需求开发就需要涉及多个微服务，光是微服务之间的接口就有 6 ~ 7 个，无论是设计、开发、测试、部署，都需要工程师不停地在不同的服务间切换。&lt;/p>
&lt;p>1）开发工程师要设计多个接口，打开多个工程，调试时要部署多个程序，提测时打多个包。&lt;/p>
&lt;p>2）测试工程师要部署多个环境，准备多个微服务的数据，测试多个接口。&lt;/p>
&lt;p>3）运维工程师每次上线都要操作多个微服务，并且微服务之间可能还有依赖关系。&lt;/p>
&lt;p>3、调用链太长，性能下降&lt;/p>
&lt;p>由于微服务之间都是通过 HTTP 或者 RPC 调用的，每次调用必须经过网络。一般线上的业务接口之间的调用，平均响应时间大约为 50 毫秒，如果用户的一起请求需要经过 6 次微服务调用，则性能消耗就是 300 毫秒，这在很多高性能业务场景下是难以满足需求的。为了支撑业务请求，可能需要大幅增加硬件，这就导致了硬件成本的大幅上升。&lt;/p>
&lt;p>4、调用链太长，问题定位困难&lt;/p>
&lt;p>系统拆分为微服务后，一次用户请求需要多个微服务协同处理，任意微服务的故障都将导致整个业务失败。然而由于微服务数量较多，且故障存在扩散现象，快速定位到底是哪个微服务故障是一件复杂的事情。下面是一个典型样例。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_20.png" alt="architecture-scalability_20.png">&lt;/p>
&lt;p>5、没有自动化支撑，无法快速交付&lt;/p>
&lt;p>如果没有相应的自动化系统进行支撑，都是靠人工去操作，那么微服务不但达不到快速交付的目的，甚至还不如一个大而全的系统效率高。例如：&lt;/p>
&lt;p>1）没有自动化测试支撑，每次测试时需要测试大量接口。&lt;/p>
&lt;p>2）没有自动化部署支撑，每次部署 6 ~ 7 个服务，几十台机器，运维人员敲 shell 命令逐台部署，手都要敲麻。&lt;/p>
&lt;p>3）没有自动化监控，每次故障定位都需要人工查几十台机器几百个微服务的各种状态和各种日志文件。&lt;/p>
&lt;p>6、没有服务治理，微服务数量多了后管理混乱&lt;/p>
&lt;p>信奉微服务理念的设计人员总是强调微服务的 lightweight 特性，并举出 ESB 的反例来证明微服务的优越之处。但具体实践后就会发现，随着微服务种类和数量越来越多，如果没有服务治理系统进行支撑，微服务提倡的 lightweight 就会变成问题。主要问题有：&lt;/p>
&lt;p>1）服务路由：假设某个微服务有 60 个节点，部署在 20 台机器上，那么其他依赖的微服务如何知道这个部署情况呢？&lt;/p>
&lt;p>2）服务故障隔离：假设上述例子中的 60 个节点有 5 个节点发生故障了，依赖的微服务如何处理这种情况呢？&lt;/p>
&lt;p>3）服务注册和发现：同样是上述的例子，现在我们决定从 60 个节点扩容到 80 个节点，或者将 60 个节点缩减为 40 个节点，新增或者减少的节点如何让依赖的服务知道呢？&lt;/p>
&lt;p>如果以上场景都依赖人工去管理，整个系统将陷入一片混乱，最终的解决方案必须依赖自动化的服务管理系统，这时就会发现，微服务所推崇的“lightweight”，最终也发展成和 ESB 几乎一样的复杂程度。&lt;/p>
&lt;h2 id="微服务架构最佳实践-方法篇">微服务架构最佳实践：方法篇&lt;/h2>
&lt;p>上面谈了实施微服务需要避免踩的陷阱，简单提炼为：&lt;/p>
&lt;p>1）微服务拆分过细，过分强调“small”。&lt;/p>
&lt;p>2）微服务基础设施不健全，忽略了“automated”。&lt;/p>
&lt;p>3）微服务并不轻量级，规模大了后，“lightweight”不再适应。&lt;/p>
&lt;p>针对这些问题，下面看看微服务最佳实践应该如何去做。主要分为方法篇和基础设施篇&lt;/p>
&lt;h3 id="服务粒度">服务粒度&lt;/h3>
&lt;p>针对微服务拆分过细导致的问题，建议基于团队规模进行拆分，类似贝索斯在定义团队规模时提出的“两个披萨”理论（每个团队的人数不能多到两张披萨都不够吃的地步），分享一个认为微服务拆分粒度的“三个火枪手”原则，即一个微服务三个人负责开发。在实施微服务架构时，根据团队规模来划分微服务数量，如果业务规继续发展，团队规模扩大，再将已有的微服务进行拆分。例如，团队最初有 6 个人，那么可以划分为 2 个微服务，随着业务的发展，业务功能越来越多，逻辑越来越复杂，团队扩展到 12 个人，那么可以将已有的 2 个微服务进行拆分，变成 4 个微服务。&lt;/p>
&lt;p>为什么是 3 个人，不是 4 个，也不是 2 个呢？&lt;/p>
&lt;p>首先，从系统规模来讲，3 个人负责开发一个系统，系统的复杂度刚好达到每个人都能全面理解整个系统，又能够进行分工的粒度；如果是 2 个人开发一个系统，系统的复杂度不够，开发人员可能觉得无法体现自己的技术实力；如果是 4 个甚至更多人开发一个系统，系统复杂度又会无法让开发人员对系统的细节都了解很深。&lt;/p>
&lt;p>其次，从团队管理来说，3 个人可以形成一个稳定的备份，即使 1 个人休假或者调配到其他系统，剩余 2 个人还可以支撑；如果是 2 个人，抽调 1 个后剩余的 1 个人压力很大；如果是 1 个人，这就是单点了，团队没有备份，某些情况下是很危险的，假如这个人休假了，系统出问题了怎么办？&lt;/p>
&lt;p>最后，从技术提升的角度来讲，3 个人的技术小组既能够形成有效的讨论，又能够快速达成一致意见；如果是 2 个人，可能会出现互相坚持自己的意见，或者 2 个人经验都不足导致设计缺陷；如果是 1 个人，由于没有人跟他进行技术讨论，很可能陷入思维盲区导致重大问题；如果是 4 个人或者更多，可能有的参与的人员并没有认真参与，只是完成任务而已。&lt;/p>
&lt;p>“三个火枪手”的原则主要应用于微服务设计和开发阶段，如果微服务经过一段时间发展后已经比较稳定，处于维护期了，无须太多的开发，那么平均 1 个人维护 1 个微服务甚至几个微服务都可以。当然考虑到人员备份问题，每个微服务最好都安排 2 个人维护，每个人都可以维护多个微服务。&lt;/p>
&lt;h3 id="拆分方法">拆分方法&lt;/h3>
&lt;p>基于“三个火枪手”的理论，可以计算出拆分后合适的服务数量，但具体怎么拆也是有技巧的，并不是快刀斩乱麻随便拆分成指定数量的微服务就可以了，也不是只能按照业务来进行拆分，而是可以根据目的的不同灵活地选取不同的拆分方式。接下来一一介绍常见的拆分方式。&lt;/p>
&lt;h4 id="基于业务逻辑拆分">基于业务逻辑拆分&lt;/h4>
&lt;p>这是最常见的一种拆分方式，将系统中的业务模块按照职责范围识别出来，每个单独的业务模块拆分为一个独立的服务。&lt;/p>
&lt;p>基于业务逻辑拆分虽然看起来很直观，但在实践过程中最常见的一个问题就是团队成员对于“职责范围”的理解差异很大，经常会出现争论，难以达成一致意见。例如：假设做一个电商系统，第一种方式是将服务划分为“商品”“交易”“用户”3 个服务，第二种方式是划分为“商品”“订单”“支付”“发货”“买家”“卖家”6 个服务，哪种方式更合理，是不是划分越细越正确？&lt;/p>
&lt;p>导致这种困惑的主要根因在于从业务的角度来拆分的话，规模粗和规模细都没有问题，因为拆分基础都是业务逻辑，要判断拆分粒度，不能从业务逻辑角度，而要根据前面介绍的“三个火枪手”的原则，计算一下大概的服务数量范围，然后再确定合适的“职责范围”，否则就可能出现划分过粗或者过细的情况，而且大部分情况下会出现过细的情况。&lt;/p>
&lt;p>例如：如果团队规模是 10 个人支撑业务，按照“三个火枪手”规则计算，大约需要划分为 4 个服务，那么“登录、注册、用户信息管理”都可以划到“用户服务”职责范围内；如果团队规模是 100 人支撑业务，服务数量可以达到 40 个，那么“用户登录“就是一个服务了；如果团队规模达到 1000 人支撑业务，那“用户连接管理”可能就是一个独立的服务了。&lt;/p>
&lt;h4 id="基于可扩展拆分">基于可扩展拆分&lt;/h4>
&lt;p>将系统中的业务模块按照稳定性排序，将已经成熟和改动不大的服务拆分为&lt;strong>稳定服务&lt;/strong>，将经常变化和迭代的服务拆分为&lt;strong>变动服务&lt;/strong>。稳定的服务粒度可以粗一些，即使逻辑上没有强关联的服务，也可以放在同一个子系统中，例如将“日志服务”和“升级服务”放在同一个子系统中；不稳定的服务粒度可以细一些，但也不要太细，始终记住要控制服务的总数量。&lt;/p>
&lt;p>这样拆分主要是为了提升项目快速迭代的效率，避免在开发的时候，不小心影响了已有的成熟功能导致线上问题。&lt;/p>
&lt;h4 id="基于可靠性拆分">基于可靠性拆分&lt;/h4>
&lt;p>将系统中的业务模块按照优先级排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用。具体拆分的时候，核心服务可以是一个也可以是多个，只要最终的服务数量满足“三个火枪手”的原则就可以。&lt;/p>
&lt;p>这样拆分带来下面几个好处：&lt;/p>
&lt;p>1）避免非核心服务故障影响核心服务&lt;/p>
&lt;p>例如，日志上报一般都属于非核心服务，但是在某些场景下可能有大量的日志上报，如果系统没有拆分，那么日志上报可能导致核心服务故障；拆分后即使日志上报有问题，也不会影响核心服务。&lt;/p>
&lt;p>2）核心服务高可用方案可以更简单&lt;/p>
&lt;p>核心服务的功能逻辑更加简单，存储的数据可能更少，用到的组件也会更少，设计高可用方案大部分情况下要比不拆分简单很多。&lt;/p>
&lt;p>3）能够降低高可用成本&lt;/p>
&lt;p>将核心服务拆分出来后，核心服务占用的机器、带宽等资源比不拆分要少很多。因此，只针对核心服务做高可用方案，机器、带宽等成本比不拆分要节省较多。&lt;/p>
&lt;h4 id="基于性能拆分">基于性能拆分&lt;/h4>
&lt;p>基于性能拆分和基于可靠性拆分类似，将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务。常见的拆分方式和具体的性能瓶颈有关，可以拆分 Web 服务、数据库、缓存等。例如电商的抢购，性能压力最大的是入口的排队功能，可以将排队功能独立为一个服务。&lt;/p>
&lt;p>以上几种拆分方式不是多选一，而是可以根据实际情况自由排列组合，例如可以基于可靠性拆分出服务 A，基于性能拆分出服务 B，基于可扩展拆分出 C/D/F 三个服务，加上原有的服务 X，最后总共拆分出 6 个服务（A/B/C/D/F/X）。&lt;/p>
&lt;h3 id="基础设施">基础设施&lt;/h3>
&lt;p>大部分人主要关注的是微服务的“small”和“lightweight”特性，但实际上真正决定微服务成败的，恰恰是那个被大部分人都忽略的“automated”。为何这样说呢？因为服务粒度即使划分不合理，实际落地后如果团队遇到麻烦，自然会想到拆服务或者合服务；如果“automated”相关的基础设施不健全，那微服务就是焦油坑，让研发、测试、运维陷入各种微服务陷阱中。&lt;/p>
&lt;p>微服务基础设施如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_21.png" alt="architecture-scalability_21.png">&lt;/p>
&lt;p>看到上面这张图，相信很多人都会倒吸一口凉气，说好的微服务的“轻量级”呢？都这么多基础设施还好意思说自己是“轻量级”，感觉比 ESB 还要复杂啊？&lt;/p>
&lt;p>确实如此，微服务并不是很多人认为的那样又简单又轻量级。要做好微服务，这些基础设施都是必不可少的，否则微服务就会变成一个焦油坑，让业务和团队在里面不断挣扎且无法自拔。因此也可以说，微服务并没有减少复杂度，而只是将复杂度从 ESB 转移到了基础设施。可以看到，“服务发现”“服务路由”等其实都是 ESB 的功能，只是在微服务中剥离出来成了独立的基础系统。&lt;/p>
&lt;p>虽然建设完善的微服务基础设施是一项庞大的工程，但也不用太过灰心，认为自己团队小或者公司规模不大就不能实施微服务了。第一个原因是已经有开源的微服务基础设施全家桶了，例如大名鼎鼎的 Spring Cloud 项目，涵盖了服务发现、服务路由、网关、配置中心等功能；第二个原因是如果微服务的数量并不是很多的话，并不是每个基础设施都是必须的。通常情况下，建议按照下面优先级来搭建基础设施：&lt;/p>
&lt;p>1）服务发现、服务路由、服务容错：这是最基本的微服务基础设施。&lt;/p>
&lt;p>2）接口框架、API 网关：主要是为了提升开发效率，接口框架是提升内部服务的开发效率，API 网关是为了提升与外部服务对接的效率。&lt;/p>
&lt;p>3）自动化部署、自动化测试、配置中心：主要是为了提升测试和运维效率。&lt;/p>
&lt;p>4）服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率。&lt;/p>
&lt;p>以上 3 和 4 两类基础设施，其重要性会随着微服务节点数量增加而越来越重要，但在微服务节点数量较少的时候，可以通过人工的方式支撑，虽然效率不高，但也基本能够顶住。&lt;/p>
&lt;h2 id="微服务架构最佳实践-基础设施篇">微服务架构最佳实践：基础设施篇&lt;/h2>
&lt;p>每项微服务基础设施都是一个平台、一个系统、一个解决方案，如果要自己实现，其过程和做业务系统类似，都需要经过需求分析、架构设计、开发、测试、部署上线等步骤，这里介绍一下每个基础设施的主要作用，更多详细设计可以参考 Spring Cloud 的相关资料（&lt;a href="https://projects.spring.io/spring-cloud/">https://projects.spring.io/spring-cloud/&lt;/a>）。&lt;/p>
&lt;h3 id="自动化测试">自动化测试&lt;/h3>
&lt;p>微服务将原本大一统的系统拆分为多个独立运行的“微”服务，微服务之间的接口数量大大增加，并且微服务提倡快速交付，版本周期短，版本更新频繁。如果每次更新都靠人工回归整个系统，则工作量大，效率低下，达不到“快速交付”的目的，因此必须通过自动化测试系统来完成绝大部分测试回归的工作。&lt;/p>
&lt;p>自动化测试涵盖的范围包括代码级的单元测试、单个系统级的集成测试、系统间的接口测试，理想情况是每类测试都自动化。如果因为团队规模和人力的原因无法全面覆盖，至少要做到接口测试自动化。&lt;/p>
&lt;h3 id="自动化部署">自动化部署&lt;/h3>
&lt;p>相比大一统的系统，微服务需要部署的节点增加了几倍甚至十几倍，微服务部署的频率也会大幅提升（例如，业务系统 70% 的工作日都有部署操作），综合计算下来，微服务部署的次数是大一统系统部署次数的几十倍。这么大量的部署操作，如果继续采用人工手工处理，需要投入大量的人力，且容易出错，因此需要自动化部署的系统来完成部署操作。&lt;/p>
&lt;p>自动化部署系统包括版本管理、资源管理（例如，机器管理、虚拟机管理）、部署操作、回退操作等功能。&lt;/p>
&lt;h3 id="配置中心">配置中心&lt;/h3>
&lt;p>微服务的节点数量非常多，通过人工登录每台机器手工修改，效率低，容易出错。特别是在部署或者排障时，需要快速增删改查配置，人工操作的方式显然是不行的。除此以外，有的运行期配置需要动态修改并且所有节点即时生效，人工操作是无法做到的。综合上面的分析，微服务需要一个统一的配置中心来管理所有微服务节点的配置。&lt;/p>
&lt;p>配置中心包括配置版本管理（例如，同样的微服务，有 10 个节点是给移动用户服务的，有 20 个节点给联通用户服务的，配置项都一样，配置值不一样）、增删改查配置、节点管理、配置同步、配置推送等功能。&lt;/p>
&lt;h3 id="接口框架">接口框架&lt;/h3>
&lt;p>微服务提倡轻量级的通信方式，一般采用 HTTP/REST 或者 RPC 方式统一接口协议。但在实践过程中，光统一接口协议还不够，还需要统一接口传递的数据格式。例如，需要指定接口协议为 HTTP/REST，但这还不够，还需要指定 HTTP/REST 的数据格式采用 JSON，并且 JSON 的数据都遵循相应规范。&lt;/p>
&lt;p>如果只是简单指定了 HTTP/REST 协议，而不指定 JSON 和 JSON 的数据规范，那么就会出现这样混乱的情况：有的微服务采用 XML，有的采用 JSON，有的采用键值对；即使同样都是 JSON，JSON 数据格式也不一样。这样每个微服务都要适配几套甚至几十套接口协议，相当于把曾经由 ESB 做的事情转交给微服务自己做了，这样做的效率显然是无法接受的，因此需要统一接口框架。&lt;/p>
&lt;p>接口框架不是一个可运行的系统，一般以库或者包的形式提供给所有微服务调用。例如，针对上面的 JSON 样例，可以由某个基础技术团队提供多种不同语言的解析包（Java 包、Python 包、C 库等）。&lt;/p>
&lt;h3 id="api-网关">API 网关&lt;/h3>
&lt;p>系统拆分为微服务后，内部的微服务之间是互联互通的，相互之间的访问都是点对点的。如果外部系统想调用系统的某个功能，也采取点对点的方式，则外部系统会非常“头大”。因为在外部系统看来，它不需要也没办法理解这么多微服务的职责分工和边界，它只会关注它需要的能力，而不会关注这个能力应该由哪个微服务提供。&lt;/p>
&lt;p>除此以外，外部系统访问系统还涉及安全和权限相关的限制，如果外部系统直接访问某个微服务，则意味着每个微服务都要自己实现安全和权限的功能，这样做不但工作量大，而且都是重复工作。&lt;/p>
&lt;p>综合上面的分析，微服务需要一个统一的 API 网关，负责外部系统的访问操作。API 网关是外部系统访问的接口，所有的外部系统接⼊系统都需要通过 API 网关，主要包括接入鉴权（是否允许接入）、权限控制（可以访问哪些功能）、传输加密、请求路由、流量控制等功能。&lt;/p>
&lt;h3 id="服务发现">服务发现&lt;/h3>
&lt;p>微服务种类和数量很多，如果这些信息全部通过手工配置的方式写入各个微服务节点，首先配置工作量很大，配置文件可能要配几百上千行，几十个节点加起来后配置项就是几万几十万行了，人工维护这么大数量的配置项是一项灾难；其次是微服务节点经常变化，可能是由于扩容导致节点增加，也可能是故障处理时隔离掉一部分节点，还可能是采用灰度升级，先将一部分节点升级到新版本，然后让新老版本同时运行。不管哪种情况，都希望节点的变化能够及时同步到所有其他依赖的微服务。如果采用手工配置，是不可能做到实时更改生效的。因此，需要一套服务发现的系统来支撑微服务的自动注册和发现。&lt;/p>
&lt;p>服务发现主要有两种实现方式：自理式和代理式。&lt;/p>
&lt;h4 id="自理式">自理式&lt;/h4>
&lt;p>自理式结构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_22.png" alt="architecture-scalability_22.png">&lt;/p>
&lt;p>自理式结构就是指每个微服务自己完成服务发现。例如，图中 SERVICE INSTANCE A 访问 SERVICE REGISTRY 获取服务注册信息，然后直接访问 SERVICE INSTANCE B。&lt;/p>
&lt;p>自理式服务发现实现比较简单，因为这部分的功能一般通过统一的程序库或者程序包提供给各个微服务调用，而不会每个微服务都自己来重复实现一遍；并且由于每个微服务都承担了服务发现的功能，访问压力分散到了各个微服务节点，性能和可用性上不存在明显的压力和风险。&lt;/p>
&lt;h4 id="代理式">代理式&lt;/h4>
&lt;p>代理式结构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_23.png" alt="architecture-scalability_23.png">&lt;/p>
&lt;p>代理式结构就是指微服务之间有一个负载均衡系统（图中的 LOAD BALANCER 节点），由负载均衡系统来完成微服务之间的服务发现。&lt;/p>
&lt;p>代理式的方式看起来更加清晰，微服务本身的实现也简单了很多，但实际上这个方案风险较大。第一个风险是可用性风险，一旦 LOAD BALANCER 系统故障，就会影响所有微服务之间的调用；第二个风险是性能风险，所有的微服务之间的调用流量都要经过 LOAD BALANCER 系统，性能压力会随着微服务数量和流量增加而不断增加，最后成为性能瓶颈。因此 LOAD BALANCER 系统需要设计成集群的模式，但 LOAD BALANCER 集群的实现本身又增加了复杂性。&lt;/p>
&lt;p>不管是自理式还是代理式，服务发现的核心功能就是服务注册表，注册表记录了所有的服务节点的配置和状态，每个微服务启动后都需要将自己的信息注册到服务注册表，然后由微服务或者 LOAD BALANCER 系统到服务注册表查询可用服务。&lt;/p>
&lt;h3 id="服务路由">服务路由&lt;/h3>
&lt;p>有了服务发现后，微服务之间能够方便地获取相关配置信息，但具体进行某次调用请求时，还需要从所有符合条件的可用微服务节点中挑选出一个具体的节点发起请求，这就是服务路由需要完成的功能。&lt;/p>
&lt;p>服务路由和服务发现紧密相关，服务路由一般不会设计成一个独立运行的系统，通常情况下是和服务发现放在一起实现的。对于自理式服务发现，服务路由是微服务内部实现的；对于代理式服务发现，服务路由是由 LOAD BALANCER 系统实现的。无论放在哪里实现，服务路由核心的功能就是路由算法。常见的路由算法有：随机路由、轮询路由、最小压力路由、最小连接数路由等。&lt;/p>
&lt;h3 id="服务容错">服务容错&lt;/h3>
&lt;p>系统拆分为微服务后，单个微服务故障的概率变小，故障影响范围也减少，但是微服务的节点数量大大增加。从整体上来看，系统中某个微服务出故障的概率会大大增加。前面在分析微服务陷阱时提到微服务具有故障扩散的特点，如果不及时处理故障，故障扩散开来就会导致看起来系统中很多服务节点都故障了，因此需要微服务能够自动应对这种出错场景，及时进行处理。否则，如果节点一故障就需要人工处理，投入人力大，处理速度慢；而一旦处理速度慢，则故障就很快扩散，所以我们需要服务容错的能力。&lt;/p>
&lt;p>常见的服务容错包括请求重试、流控和服务隔离。通常情况下，服务容错会集成在服务发现和服务路由系统中。&lt;/p>
&lt;h3 id="服务监控">服务监控&lt;/h3>
&lt;p>系统拆分为微服务后，节点数量大大增加，导致需要监控的机器、网络、进程、接口调用数等监控对象的数量大大增加；同时，一旦发生故障，需要快速根据各类信息来定位故障。这两个目标如果靠人力去完成是不现实的。举个简单例子：收到用户投诉说业务有问题，如果此时采取人工的方式去搜集、分析信息，可能把几十个节点的日志打开一遍就需要十几分钟了，因此需要服务监控系统来完成微服务节点的监控。&lt;/p>
&lt;p>服务监控的主要作用有：&lt;/p>
&lt;p>1）实时搜集信息并进行分析，避免故障后再来分析，减少了处理时间。&lt;/p>
&lt;p>2）服务监控可以在实时分析的基础上进行预警，在问题萌芽的阶段发觉并预警，降低了问题影响的范围和时间。&lt;/p>
&lt;p>通常情况下，服务监控需要搜集并分析大量的数据，因此建议做成独立的系统，而不要集成到服务发现、API 网关等系统中。&lt;/p>
&lt;h3 id="服务跟踪">服务跟踪&lt;/h3>
&lt;p>服务监控可以做到微服务节点级的监控和信息收集，但如果需要跟踪某一个请求在微服务中的完整路径，服务监控是难以实现的。因为如果每个服务的完整请求链信息都实时发送给服务监控系统，数据量会大到无法处理。&lt;/p>
&lt;p>服务监控和服务跟踪的区别可以简单概括为宏观和微观的区别。例如，A 服务通过 HTTP 协议请求 B 服务 10 次，B 通过 HTTP 返回 JSON 对象，服务监控会记录请求次数、响应时间平均值、响应时间最高值、错误码分布这些信息；而服务跟踪会记录其中某次请求的发起时间、响应时间、响应错误码、请求参数、返回的 JSON 对象等信息。&lt;/p>
&lt;p>目前无论是分布式跟踪还是微服务的服务跟踪，绝大部分请求跟踪的实现技术都基于 Google 的 Dapper 论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》。&lt;/p>
&lt;h3 id="服务安全">服务安全&lt;/h3>
&lt;p>系统拆分为微服务后，数据分散在各个微服务节点上。从系统连接的角度来说，任意微服务都可以访问所有其他微服务节点；但从业务的角度来说，部分敏感数据或者操作，只能部分微服务可以访问，而不是所有的微服务都可以访问，因此需要设计服务安全机制来保证业务和数据的安全性。&lt;/p>
&lt;p>服务安全主要分为三部分：接入安全、数据安全、传输安全。通常情况下，服务安全可以集成到配置中心系统中进行实现，即配置中心配置微服务的接入安全策略和数据安全策略，微服务节点从配置中心获取这些配置信息，然后在处理具体的微服务调用请求时根据安全策略进行处理。由于这些策略是通用的，一般会把策略封装成通用的库提供给各个微服务调用。基本架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_24.png" alt="architecture-scalability_24.png">&lt;/p>
&lt;h2 id="微内核架构详解">微内核架构详解&lt;/h2>
&lt;p>微内核架构（Microkernel Architecture），也被称为插件化架构（Plug-in Architecture），是一种面向功能进行拆分的可扩展性架构，通常用于实现基于产品（原文为 product-based，指存在多个版本、需要下载安装才能使用，与 web-based 相对应）的应用。例如 Eclipse 这类 IDE 软件、UNIX 这类操作系统、淘宝 App 这类客户端软件等，也有一些企业将自己的业务系统设计成微内核的架构，例如保险公司的保险核算逻辑系统，不同的保险品种可以将逻辑封装成插件。&lt;/p>
&lt;h3 id="基本架构">基本架构&lt;/h3>
&lt;p>微内核架构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑，例如专栏前面经常提到的“学生信息管理”系统中的“手机号注册”功能。&lt;/p>
&lt;p>微内核的基本架构示意图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_25.png" alt="architecture-scalability_25.png">&lt;/p>
&lt;p>上面这张图中核心系统 Core System 功能比较稳定，不会因为业务功能扩展而不断修改，插件模块可以根据业务功能的需要不断地扩展。微内核的架构本质就是将变化部分封装在插件里面，从而达到快速灵活扩展的目的，而又不影响整体系统的稳定。&lt;/p>
&lt;h3 id="设计关键点">设计关键点&lt;/h3>
&lt;p>微内核的核心系统设计的关键技术有：插件管理、插件连接和插件通信。&lt;/p>
&lt;h4 id="插件管理">插件管理&lt;/h4>
&lt;p>核心系统需要知道当前有哪些插件可用，如何加载这些插件，什么时候加载插件。常见的实现方法是插件注册表机制。&lt;/p>
&lt;p>核心系统提供插件注册表（可以是配置文件，也可以是代码，还可以是数据库），插件注册表含有每个插件模块的信息，包括它的名字、位置、加载时机（启动就加载，还是按需加载）等。&lt;/p>
&lt;h4 id="插件连接">插件连接&lt;/h4>
&lt;p>插件连接指插件如何连接到核心系统。通常来说，核心系统必须制定插件和核心系统的连接规范，然后插件按照规范实现，核心系统按照规范加载即可。&lt;/p>
&lt;p>常见的连接机制有 OSGi（Eclipse 使用）、消息模式、依赖注入（Spring 使用），甚至使用分布式的协议都是可以的，比如 RPC 或者 HTTP Web 的方式。&lt;/p>
&lt;h4 id="插件通信">插件通信&lt;/h4>
&lt;p>插件通信指插件间的通信。虽然设计的时候插件间是完全解耦的，但实际业务运行过程中，必然会出现某个业务流程需要多个插件协作，这就要求两个插件间进行通信。由于插件之间没有直接联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制。这种情况和计算机类似，计算机的 CPU、硬盘、内存、网卡是独立设计的配件，但计算机运行过程中，CPU 和内存、内存和硬盘肯定是有通信的，计算机通过主板上的总线提供了这些组件之间的通信功能。微内核的核心系统也必须提供类似的通信机制，各个插件之间才能进行正常的通信。&lt;/p>
&lt;h3 id="osgi-架构简析">OSGi 架构简析&lt;/h3>
&lt;p>OSGi 的全称是 Open Services Gateway initiative，本身其实是指 OSGi Alliance。这个联盟是 Sun Microsystems、IBM、爱立信等公司于 1999 年 3 月成立的开放的标准化组织，最初名为 Connected Alliance。它是一个非盈利的国际组织，旨在建立一个开放的服务规范，为通过网络向设备提供服务建立开放的标准，这个标准就是 OSGi specification。现在我们谈到 OSGi，如果没有特别说明，一般都是指 OSGi 的规范。&lt;/p>
&lt;p>OSGi 联盟的初始目标是构建一个在广域网和局域网或设备上展开业务的基础平台，所以 OSGi 的最早设计也是针对嵌入式应用的，诸如机顶盒、服务网关、手机、汽车等都是其应用的主要环境。然而，无心插柳柳成荫，由于 OSGi 具备动态化、热插拔、高可复用性、高效性、扩展方便等优点，它被应用到了 PC 上的应用开发。尤其是 Eclipse 这个流行软件采用 OSGi 标准后，OSGi 更是成为了首选的插件化标准。现在谈论 OSGi，已经和嵌入式应用关联不大了，更多是将 OSGi 当作一个微内核的架构模式。&lt;/p>
&lt;p>Eclipse 从 3.0 版本开始，抛弃了原来自己实现的插件化框架，改用了 OSGi 框架。需要注意的是，OSGi 是一个插件化的标准，而不是一个可运行的框架，Eclipse 采用的 OSGi 框架称为 Equinox，类似的实现还有 Apache 的 Felix、Spring 的 Spring DM。OSGi 框架的逻辑架构图如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_26.png" alt="architecture-scalability_26.png">&lt;/p>
&lt;h4 id="模板层-module-层">模板层（Module 层）&lt;/h4>
&lt;p>模块层实现插件管理功能。OSGi 中，插件被称为 Bundle，每个 Bundle 是一个 Java 的 JAR 文件，每个 Bundle 里面都包含一个元数据文件 MANIFEST.MF，这个文件包含了 Bundle 的基本信息。例如，Bundle 的名称、描述、开发商、classpath，以及需要导入的包和输出的包等，OSGi 核心系统会将这些信息加载到系统中用于后续使用。&lt;/p>
&lt;h4 id="生命周期层-lifecycle-层">生命周期层（Lifecycle 层）&lt;/h4>
&lt;p>生命周期层实现插件连接功能，提供了执行时模块管理、模块对底层 OSGi 框架的访问。生命周期层精确地定义了 Bundle 生命周期的操作（安装、更新、启动、停止、卸载），Bundle 必须按照规范实现各个操作。&lt;/p>
&lt;h4 id="服务层-service-层">服务层（Service 层）&lt;/h4>
&lt;p>服务层实现插件通信的功能。OSGi 提供了一个服务注册的功能，用于各个插件将自己能提供的服务注册到 OSGi 核心的服务注册中心，如果某个服务想用其他服务，则直接在服务注册中心搜索可用服务中心就可以了。&lt;/p>
&lt;h3 id="规则引擎架构简析">规则引擎架构简析&lt;/h3>
&lt;p>规则引擎从结构上来看也属于微内核架构的一种具体实现，其中执行引擎可以看作是微内核，执行引擎解析配置好的业务流，执行其中的条件和规则，通过这种方式来支持业务的灵活多变。&lt;/p>
&lt;p>规则引擎在计费、保险、促销等业务领域应用较多。例如电商促销 满 100 送 50，3 件立减 50。促销规则完整列下来可能有几十上百种，再加上排列组合，促销方案可能有几百上千种，这样的业务如果完全靠代码来实现，开发效率远远跟不上业务的变化速度，而规则引擎却能够很灵活的应对这种需求，主要原因在于：&lt;/p>
&lt;p>1）可扩展&lt;/p>
&lt;p>通过引入规则引擎，业务逻辑实现与业务系统分离，可以在不改动业务系统的情况下扩展新的业务功能。&lt;/p>
&lt;p>2）易理解&lt;/p>
&lt;p>规则通过自然语言描述，业务人员易于理解和操作，而不像代码那样只有程序员才能理解和开发。&lt;/p>
&lt;p>3）高效率&lt;/p>
&lt;p>规则引擎系统一般提供可视化的规则定制、审批、查询及管理，方便业务人员快速配置新的业务。&lt;/p>
&lt;p>规则引擎的基本架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-scalability_27.png" alt="architecture-scalability_27.png">&lt;/p>
&lt;p>简单介绍一下：&lt;/p>
&lt;p>1）开发人员将业务功能分解提炼为多个规则，将规则保存在规则库中。&lt;/p>
&lt;p>2）业务人员根据业务需要，通过将规则排列组合，配置成业务流程，保存在业务库中。&lt;/p>
&lt;p>3）规则引擎执行业务流程实现业务功能。&lt;/p>
&lt;p>对照微内核架构的设计关键点，规则引擎是具体是如何实现的。&lt;/p>
&lt;p>1）插件管理&lt;/p>
&lt;p>规则引擎中的规则就是微内核架构的插件，引擎就是微内核架构的内核。规则可以被引擎加载和执行。规则引擎架构中，规则一般保存在规则库中，通常使用数据库来存储。&lt;/p>
&lt;p>2）插件连接&lt;/p>
&lt;p>类似于程序员开发的时候需要采用 Java、C++ 等语言，规则引擎也规定了规则开发的语言，业务人员需要基于规则语言来编写规则文件，然后由规则引擎加载执行规则文件来完成业务功能，因此，规则引擎的插件连接实现机制其实就是规则语言。&lt;/p>
&lt;p>3）插件通信&lt;/p>
&lt;p>规则引擎的规则之间进行通信的方式就是数据流和事件流，由于单个规则并不需要依赖其他规则，因此规则之间没有主动的通信，规则只需要输出数据或者事件，由引擎将数据或者事件传递到下一个规则。&lt;/p>
&lt;p>目前最常用的规则引擎是开源的 JBoss Drools，采用 Java 语言编写，基于 Rete 算法（参考&lt;a href="https://en.wikipedia.org/wiki/Rete_algorithm">https://en.wikipedia.org/wiki/Rete_algorithm&lt;/a>）。Drools 具有下面这些优点：&lt;/p>
&lt;p>1）非常活跃的社区支持，以及广泛的应用。&lt;/p>
&lt;p>2）快速的执行速度。&lt;/p>
&lt;p>3）与 Java Rule Engine API（JSR-94）兼容。&lt;/p>
&lt;p>4）提供了基于 Web 的 BRMS——Guvnor，Guvnor 提供了规则管理的知识库，通过它可以实现规则的版本控制，以及规则的在线修改与编译，使得开发人员和系统管理人员可以在线管理业务规则。&lt;/p>
&lt;p>虽然 Drools 号称简单易用，但实际上其规则语言还是和编程语言比较类似，在实际应用的时候普通业务人员面对这样的规则语言，学习成本和理解成本还是比较高的，例如下面这个样例（&lt;a href="https://blog.csdn.net/ouyangshixiong/article/details/46315273">https://blog.csdn.net/ouyangshixiong/article/details/46315273&lt;/a>）：&lt;/p>
&lt;p>因此，通常情况下需要基于 Drools 进行封装，将规则配置做成可视化的操作，例如下面电商反欺诈的一个示例（&lt;a href="https://cloud.tencent.com/developer/article/1031839">https://cloud.tencent.com/developer/article/1031839&lt;/a>）&lt;/p></description></item><item><title>Docs: 架构设计05-架构实战</title><link>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A105-%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A105-%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/</guid><description>
&lt;h2 id="架构演进方向">架构演进方向&lt;/h2>
&lt;h3 id="架构演进背景">架构演进背景&lt;/h3>
&lt;p>互联网的出现不但改变了普通人的生活方式，同时也促进了技术圈的快速发展和开放。在开源和分享两股力量的推动下，最近 10 多年的技术发展可以说是目不暇接，你方唱罢我登场，大的方面有大数据、云计算、人工智能等，细分的领域有 NoSQL、Node.js、Docker 容器化等。各个大公司也乐于将自己的技术分享出来，以此来提升自己的技术影响力，打造圈内技术口碑，从而形成强大的人才吸引力，典型的有，Google 的大数据论文、淘宝的全链路压测、微信的红包高并发技术等。&lt;/p>
&lt;p>对于技术人员来说，技术的快速发展当然是一件大好事，毕竟这意味着技术百宝箱中又多了更多的可选工具，同时也可以通过学习业界先进的技术来提升自己的技术实力。但对于架构师来说，除了这些好处，却也多了“甜蜜的烦恼”：面对层出不穷的新技术，应该采取什么样的策略？&lt;/p>
&lt;p>架构师可能经常会面临下面这些诱惑或者挑战：&lt;/p>
&lt;p>1）现在 Docker 虚拟化技术很流行，要不要引进，引入 Docker 后可以每年节省几十万元的硬件成本呢？&lt;/p>
&lt;p>2）竞争对手用了阿里的云计算技术，听说因为上了云，业务增长了好几倍呢，我们是否也应该尽快上云啊？&lt;/p>
&lt;p>3）自己的技术和业界顶尖公司（例如，淘宝、微信）差距很大，应该投入人力和时间追上去，不然招聘的时候没有技术影响力！&lt;/p>
&lt;p>4）公司的技术发展现在已经比较成熟了，程序员都觉得在公司学不到东西，可以尝试引入 Golang 来给大家一个学习新技术的机会。&lt;/p>
&lt;p>类似的问题还有很多，本质上都可以归纳总结为一个问题：架构师应该如何判断技术演进的方向？关于这个问题的答案，基本上可以分为几个典型的派别：&lt;/p>
&lt;h4 id="潮流派">潮流派&lt;/h4>
&lt;p>潮流派的典型特征就是对于新技术特别热衷，紧跟技术潮流，当有新的技术出现时，迫切想将新的技术应用到自己的产品中。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>1）NoSQL 很火，咱们要大规模地切换为 NoSQL。&lt;/p>
&lt;p>2）大数据好牛呀，将我们的 MySQL 切换为 Hadoop 吧。&lt;/p>
&lt;p>3）Node.js 使得 JavaScript 统一前后端，这样非常有助于开展工作。&lt;/p>
&lt;p>问题：&lt;/p>
&lt;p>首先，新技术需要时间成熟，如果刚出来就用，此时新技术还不怎么成熟，实际应用中很可能遇到各种“坑”，自己成了实验小白鼠。&lt;/p>
&lt;p>其次，新技术需要学习，需要花费一定的时间去掌握，这个也是较大的成本；如果等到掌握了技术后又发现不适用，则是一种较大的人力浪费。&lt;/p>
&lt;h4 id="保守派">保守派&lt;/h4>
&lt;p>保守派的典型特征和潮流派正好相反，对于新技术抱有很强的戒备心，稳定压倒一切，已经掌握了某种技术，就一直用这种技术打天下。就像有句俗语说的，“如果你手里有一把锤子，那么所有的问题都变成了钉子”，保守派就是拿着一把锤子解决所有的问题。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>1）MySQL 咱们用了这么久了，很熟悉了，业务用 MySQL，数据分析也用 MySQL，报表还用 MySQL 吧。&lt;/p>
&lt;p>2）Java 语言我们都很熟，业务用 Java，工具用 Java，平台也用 Java。&lt;/p>
&lt;p>问题：&lt;/p>
&lt;p>保守派的主要问题是不能享受新技术带来的收益，因为新技术很多都是为了解决以前技术存在的固有缺陷。就像汽车取代马车一样，不是量变而是质变，带来的收益不是线性变化的，而是爆发式变化的。如果无视技术的发展，形象一点说就是有了拖拉机，你还偏偏要用牛车。&lt;/p>
&lt;h4 id="跟风派">跟风派&lt;/h4>
&lt;p>跟风派与潮流派不同，这里的跟风派不是指跟着技术潮流，而是指跟着竞争对手的步子走。简单来说，判断技术的发展就看竞争对手，竞争对手用了咱们就用，竞争对手没用咱们就等等看。例如：&lt;/p>
&lt;p>1）这项技术腾讯用了吗？腾讯用了我们就用。&lt;/p>
&lt;p>2）阿里用了 Hadoop，他们都在用，肯定是好东西，咱们也要尽快用起来，以提高咱们的竞争力。&lt;/p>
&lt;p>3）Google 都用了 Docker，咱们也用吧。&lt;/p>
&lt;p>不同派别的不同做法本质上是价值观的不同：潮流派的价值观是新技术肯定能带来很大收益；稳定派的价值观是稳定压倒一切；跟风派的价值观是别人用了我就用。这些价值观本身都有一定的道理，但如果不考虑实际情况生搬硬套，就会出现“橘生淮南则为橘，生于淮北则为枳”的情况。&lt;/p>
&lt;p>问题：&lt;/p>
&lt;p>可能很多人都会认为，跟风派与“潮流派”和“保守派”相比，是最有效的策略，既不会承担“潮流派”的风险，也不会遭受“保守派”的损失，花费的资源也少，简直就是一举多得。&lt;/p>
&lt;p>看起来很美妙，但跟风派最大的问题在于如果没有风可跟的时候怎么办。如果你是领头羊怎么办，其他人都准备跟你的风呢？另外一种情况就是竞争对手的这些信息并不那么容易获取，即使获取到了一些信息，大部分也是不全面的，一不小心可能就变成邯郸学步了。&lt;/p>
&lt;p>即使有风可跟，其实也存在问题。有时候适用于竞争对手的技术，并不一定适用于自己，盲目模仿可能带来相反的效果。&lt;/p>
&lt;p>既然潮流派、保守派、跟风派都存在这样或者那样的问题，那架构师究竟如何判断技术演进的方向呢？&lt;/p>
&lt;h3 id="技术演进的动力">技术演进的动力&lt;/h3>
&lt;p>不管是潮流派、保守派，还是跟风派，都是站在技术本身的角度来考虑问题的，正所谓“不识庐山真面，只缘身在此山中”，只有跳出技术的范畴，从一个更广更高的角度来考虑这个问题，这个角度就是企业的业务发展。&lt;/p>
&lt;p>无论是代表新兴技术的互联网企业，还是代表传统技术的制造业；无论是通信行业，还是金融行业的发展，归根到底就是业务的发展。而影响一个企业业务的发展主要有 3 个因素：&lt;strong>市场、技术、管理&lt;/strong>，这三者构成支撑业务发展的铁三角，任何一个因素的不足，都可能导致企业的业务停滞不前。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_1.png" alt="architecture-action_1.png">&lt;/p>
&lt;p>在这个铁三角中，业务处于三角形的中心，毫不夸张地说，市场、技术、管理都是为了支撑企业业务的发展。这里主要探讨“技术”和“业务”之间的关系和互相如何影响。&lt;/p>
&lt;p>可以简单地将企业的业务分为两类：一类是产品类，一类是服务类。&lt;/p>
&lt;p>产品类：360 的杀毒软件、苹果的 iPhone、UC 的浏览器等都属于这个范畴，这些产品本质上和传统的制造业产品类似，都是具备了某种“功能”，单个用户通过购买或者免费使用这些产品来完成自己相关的某些任务，用户对这些产品是独占的。&lt;/p>
&lt;p>服务类：百度的搜索、淘宝的购物、新浪的微博、腾讯的 IM 等都属于这个范畴，大量用户使用这些服务来完成需要与其他人交互的任务，单个用户“使用”但不“独占”某个服务。事实上，服务的用户越多，服务的价值就越大。服务类的业务符合互联网的特征和本质：“互联”+“网”。&lt;/p>
&lt;p>对于产品类业务，&lt;strong>技术创新推动业务发展&lt;/strong>！&lt;/p>
&lt;p>为何对于产品类的业务，技术创新能够推动业务发展呢？答案在于用户选择一个产品的根本驱动力在于产品的功能是否能够更好地帮助自己完成任务。用户会自然而然地选择那些功能更加强大、性能更加先进、体验更加顺畅、外观更加漂亮的产品，而功能、性能、体验、外观等都需要强大的技术支撑。例如，iPhone 手机的多点触摸操作、UC 浏览器的 U3 内核等。&lt;/p>
&lt;p>对于“服务”类的业务，答案和产品类业务正好相反：&lt;strong>业务发展推动技术的发展&lt;/strong>！&lt;/p>
&lt;p>截然相反的主要原因是用户选择服务的根本驱动力与选择产品不同。用户选择一个产品的根本驱动力是其“功能”，而用户选择一个服务的根本驱动力不是功能，而是“规模”。&lt;/p>
&lt;p>例如，选择 UC 浏览器还是选择 QQ 浏览器，更多的人是根据个人喜好和体验来决定的；而选择微信还是 Whatsapp，就不是根据它们之间的功能差异来选择的，而是根据其规模来选择的，就像我更喜欢 Whatsapp 的简洁，但我的朋友和周边的人都用微信，那我也不得不用微信。&lt;/p>
&lt;p>当“规模”成为业务的决定因素后，服务模式的创新就成为了业务发展的核心驱动力，而产品只是为了完成服务而提供给用户使用的一个载体。以淘宝为例，淘宝提供的“网络购物”是一种新的服务，这种业务与传统的到实体店购物是完全不同的，而为了完成这种业务，需要“淘宝网”“支付宝”“一淘”和“菜鸟物流”等多个产品。随便一个软件公司，如果只是模仿开发出类似的产品，只要愿意投入，半年时间就可以将这些产品全部开发出来。但是这样做并没有意义，因为用户选择的是淘宝的整套网络购物服务，并且这个服务已经具备了一定的规模，其他公司不具备这种同等规模服务的能力。即使开发出完全一样的产品，用户也不会因为产品功能更加强大而选择新的类似产品。&lt;/p>
&lt;p>以微信为例，同样可以得出类似结论。假如进行技术创新，开发一个耗电量只有微信的 1/10，用户体验比微信好 10 倍的产品，你觉得现在的微信用户都会抛弃微信，而转投我们的这个产品吗？我相信绝大部分人都不会，因为微信不是一个互联网产品，而是一个互联网服务，你一个人换到其他类微信类产品是没有意义的。&lt;/p>
&lt;p>因此，服务类的业务发展路径是这样的：提出一种创新的服务模式→吸引了一批用户→业务开始发展→吸引了更多用户→服务模式不断完善和创新→吸引越来越多的用户，如此循环往复。在这个发展路径中，技术并没有成为业务发展的驱动力，反过来由于用户规模的不断扩展，业务的不断创新和改进，对技术会提出越来越高的要求，因此是业务驱动了技术发展。&lt;/p>
&lt;p>其实回到产品类业务，如果将观察的时间拉长来看，即使是产品类业务，在技术创新开创了一个新的业务后，后续的业务发展也会反向推动技术的发展。例如，第一代 iPhone 缺少对 3G 的支持，且只能通过 Web 发布应用程序，第二代 iPhone 才开始支持 3G，并且内置 GPS；UC 浏览器随着功能越来越强大，原有的技术无法满足业务发展的需求，浏览器的架构需要进行更新，先后经过 UC 浏览器 7.0 版本、8.0 版本、9.0 版本等几个技术差异很大的版本。&lt;/p>
&lt;p>综合这些分析，除非是开创新的技术能够推动或者创造一种新的业务，其他情况下，都是业务的发展推动了技术的发展。&lt;/p>
&lt;h3 id="技术演进的模式">技术演进的模式&lt;/h3>
&lt;p>明确了技术发展主要的驱动力是业务发展后，看看业务发展究竟是如何驱动技术发展的。&lt;/p>
&lt;p>业务模式千差万别，有互联网的业务（淘宝、微信等），有金融的业务（中国平安、招商银行等），有传统企业的业务（各色 ERP 对应的业务）等，但无论什么模式的业务，如果业务的发展需要技术同步发展进行支撑，无一例外是因为业务“复杂度”的上升，导致原有的技术无法支撑。&lt;/p>
&lt;p>按照前面所介绍的复杂度分类，复杂度要么来源于功能不断叠加，要么来源于规模扩大，从而对性能和可用性有了更高的要求。既然如此，判断到底是什么复杂度发生了变化就显得至关重要了。是任何时候都要同时考虑功能复杂度和规模复杂度吗？还是有时候考虑功能复杂度，有时候考虑规模复杂度？还是随机挑一个复杂度的问题解决就可以了？&lt;/p>
&lt;p>对于架构师来说，判断业务当前和接下来一段时间的主要复杂度是什么就非常关键。判断不准确就会导致投入大量的人力和时间做了对业务没有作用的事情，判断准确就能够做到技术推动业务更加快速发展。那架构师具体应该按照什么标准来判断呢？&lt;/p>
&lt;p>答案就是基于业务发展阶段进行判断，这也是为什么架构师必须具备业务理解能力的原因。不同的行业业务发展路径、轨迹、模式不一样，架构师必须能够基于行业发展和企业自身情况做出准确判断。&lt;/p>
&lt;p>假设是一个银行 IT 系统的架构师：&lt;/p>
&lt;p>1）90 年代主要的业务复杂度可能就是银行业务范围逐渐扩大，功能越来越复杂，导致内部系统数量越来越多，单个系统功能越来越复杂。&lt;/p>
&lt;p>2）2004 年以后主要的复杂度就是银行业务从柜台转向网上银行，网上银行的稳定性、安全性、易用性是主要的复杂度，这些复杂度主要由银行 IT 系统自己解决。&lt;/p>
&lt;p>3）2009 年以后主要的复杂度又变化为移动支付复杂度，尤其是“双 11”这种海量支付请求的情况下，高性能、稳定性、安全性是主要的复杂度，而这些复杂度需要银行和移动支付服务商（支付宝、微信）等一起解决。&lt;/p>
&lt;p>而如果是淘宝这种互联网业务的架构师，业务发展又会是另外一种模式：&lt;/p>
&lt;p>1）2003 年，业务刚刚创立，主要的复杂度体现为如何才能快速开发各种需求，淘宝团队采取的是买了一个 PHP 写的系统来改。&lt;/p>
&lt;p>2）2004 年，上线后业务发展迅速，用户请求数量大大增加，主要的复杂度体现为如何才能保证系统的性能，淘宝的团队采取的是用 Oracle 取代 MySQL。&lt;/p>
&lt;p>3）用户数量再次增加，主要的复杂度还是性能和稳定性，淘宝的团队采取的是 Java 替换 PHP。&lt;/p>
&lt;p>4）2005 年，用户数量继续增加，主要的复杂度体现为单一的 Oracle 库已经无法满足性能要求，于是进行了分库分表、读写分离、缓存等优化。&lt;/p>
&lt;p>5）2008 年，淘宝的商品数量在 1 亿以上，PV2.5 亿以上，主要的复杂度又变成了系统内部耦合，交易和商品耦合在一起，支付的时候又和支付宝强耦合，整个系统逻辑复杂，功能之间跳来跳去，用户体验也不好。淘宝的团队采取的是系统解耦，将交易中心、类目管理、用户中心从原来大一统的系统里面拆分出来。&lt;/p>
&lt;h2 id="互联网技术演进模式">互联网技术演进模式&lt;/h2>
&lt;p>各行业的业务发展轨迹并不完全相同，无法给出一个统一的模板让所有的架构师拿来就套用，因此以互联网的业务发展为案例，谈谈互联网技术演进的模式，其他行业可以参考分析方法对自己的行业进行分析。&lt;/p>
&lt;p>互联网业务千差万别，但由于它们具有“规模决定一切”的相同点，其发展路径也基本上是一致的。互联网业务发展一般分为几个时期：初创期、发展期、竞争期、成熟期。&lt;/p>
&lt;p>不同时期的差别主要体现在两个方面：&lt;strong>复杂性、用户规模&lt;/strong>。&lt;/p>
&lt;h3 id="业务复杂性">业务复杂性&lt;/h3>
&lt;p>互联网业务发展第一个主要方向就是“业务越来越复杂”，不同时期业务的复杂性的表现如下。&lt;/p>
&lt;h4 id="初创期">初创期&lt;/h4>
&lt;p>互联网业务刚开始一般都是一个创新的业务点，这个业务点的重点不在于“完善”，而在于“创新”，只有创新才能吸引用户；而且因为其“新”的特点，其实一开始是不可能很完善的。只有随着越来越多的用户的使用，通过快速迭代试错、用户的反馈等手段，不断地在实践中去完善，才能继续创新。初创期的业务对技术就一个要求：“快”，但这个时候却又是创业团队最弱小的时期，可能就几个技术人员，所以这个时候十八般武艺都需要用上：能买就买，有开源的就用开源的。&lt;/p>
&lt;p>还以淘宝和 QQ 为例。&lt;/p>
&lt;p>第一版的淘宝（&lt;a href="https://blog.csdn.net/linlin_juejue/article/details/5959171">https://blog.csdn.net/linlin_juejue/article/details/5959171&lt;/a>）&lt;/p>
&lt;p>第一版的 QQ（&lt;a href="http://www.yixieshi.com/20770.html">http://www.yixieshi.com/20770.html&lt;/a>）&lt;/p>
&lt;p>可以看到最开始的淘宝和 QQ 与现在相比，几乎看不出是同一个业务了。&lt;/p>
&lt;h4 id="发展期">发展期&lt;/h4>
&lt;p>当业务推出后经过市场验证如果是可行的，则吸引的用户就会越来越多，此时原来不完善的业务就进入了一个快速发展的时期。业务快速发展时期的主要目的是将原来不完善的业务逐渐完善，因此会有越来越多的新功能不断地加入到系统中。对于绝大部分技术团队来说，这个阶段技术的核心工作是快速地实现各种需求，只有这样才能满足业务发展的需要。&lt;/p>
&lt;p>如何做到“快”，一般会经历下面几个阶段。&lt;/p>
&lt;p>1、堆功能期&lt;/p>
&lt;p>业务进入快速发展期的初期，此时团队规模也不大，业务需求又很紧，最快实现业务需求的方式是继续在原有的系统里面不断地增加新的功能，重构、优化、架构等方面的工作即使想做，也会受制于人力和业务发展的压力而放在一边。&lt;/p>
&lt;p>2、优化期&lt;/p>
&lt;p>“堆功能”的方式在刚开始的时候好用，因为系统还比较简单，但随着功能越来越多，系统开始变得越来越复杂，后面继续堆功能会感到越来越吃力，速度越来越慢。一种典型的场景是做一个需求要改好多地方，一不小心就改出了问题。直到有一天，技术团队或者产品人员再也受不了这种慢速的方式，终于下定决定要解决这个问题了。&lt;/p>
&lt;p>如何解决这个问题，一般会分为两派：一派是优化派，一派是架构派。&lt;/p>
&lt;p>优化派的核心思想是将现有的系统优化。例如，采用重构、分层、优化某个 MySQL 查询语句，将机械硬盘换成 SSD，将数据库从 MySQL 换成 Oracle，增加 Memcache 缓存等。优化派的优势是对系统改动较小，优化可以比较快速地实施；缺点就是可能过不了多久，系统又撑不住了。&lt;/p>
&lt;p>架构派的核心思想是调整系统架构，主要是将原来的大系统拆分为多个互相配合的小系统。例如，将购物系统拆分为登录认证子系统、订单系统、查询系统、分析系统等。架构派的优势是一次调整可以支撑比较长期的业务发展，缺点是动作较大、耗时较长，对业务的发展影响也比较大。&lt;/p>
&lt;p>相信在很多公司都遇到这种情况，大部分情况下都是“优化派”会赢，主要的原因还是因为此时“优化”是最快的方式。至于说“优化派”支撑不了多久这个问题，其实也不用考虑太多，因为业务能否发展到那个阶段还是个未知数，保证当下的竞争力是最主要的问题。&lt;/p>
&lt;p>3、架构期&lt;/p>
&lt;p>经过优化期后，如果业务能够继续发展，慢慢就会发现优化也顶不住了，毕竟再怎么优化，系统的能力总是有极限的。Oracle 再强大，也不可能一台 Oracle 顶住 1 亿的交易量；小型机再好，也不可能一台机器支持 100 万在线人数。此时已经没有别的选择，只能进行架构调整。&lt;/p>
&lt;p>架构期可以用的手段很多，但归根结底可以总结为一个字“拆”，什么地方都可以拆。&lt;/p>
&lt;p>拆功能：例如，将购物系统拆分为登录认证子系统、订单系统、查询系统、分析系统等。&lt;/p>
&lt;p>拆数据库：MySQL 一台变两台，2 台变 4 台，增加 DBProxy、分库分表等。&lt;/p>
&lt;p>拆服务器：服务器一台变两台，2 台变 4 台，增加负载均衡的系统，如 Nginx、HAProxy 等。&lt;/p>
&lt;h4 id="竞争期">竞争期&lt;/h4>
&lt;p>当业务继续发展，已经形成一定规模后，一定会有竞争对手开始加入行业来竞争，毕竟谁都想分一块蛋糕，甚至有可能一不小心还会成为下一个 BAT。当竞争对手加入后，大家互相学习和模仿，业务更加完善，也不断有新的业务创新出来，而且由于竞争的压力，对技术的要求是更上一层楼了。&lt;/p>
&lt;p>新业务的创新给技术带来的典型压力就是新的系统会更多，同时，原有的系统也会拆得越来越多。两者合力的一个典型后果就是系统数量在原来的基础上又增加了很多。架构拆分后带来的美好时光又开始慢慢消逝，技术工作又开始进入了“慢”的状态，这又是怎么回事呢？&lt;/p>
&lt;p>原来系统数量越来越多，到了一个临界点后就产生了质变，即系统数量的量变带来了技术工作的质变。主要体现在下面几个方面：&lt;/p>
&lt;p>1、重复造轮子&lt;/p>
&lt;p>系统越来越多，各系统相似的工作越来越多。例如，每个系统都有存储，都要用缓存，都要用数据库。新建一个系统，这些工作又要都做一遍，即使其他系统已经做过了一遍，这样怎么能快得起来？&lt;/p>
&lt;p>2、系统交互一团乱麻&lt;/p>
&lt;p>系统越来越多，各系统的交互关系变成了网状。系统间的交互数量和系统的数量成平方比的关系。例如，4 个系统的交互路径是 6 个，10 个系统的交互路径是 45 个。每实现一个业务需求，都需要几个甚至十几个系统一起改，然后互相调用来调用去，联调成了研发人员的灾难、联测成了测试人员的灾难、部署成了运维的灾难。&lt;/p>
&lt;p>针对这个时期业务变化带来的问题，技术工作主要的解决手段有：&lt;/p>
&lt;p>1、平台化&lt;/p>
&lt;p>目的在于解决“重复造轮子”的问题。&lt;/p>
&lt;p>存储平台化：淘宝的 TFS、京东 JFS。&lt;/p>
&lt;p>数据库平台化：百度的 DBProxy、淘宝 TDDL。&lt;/p>
&lt;p>缓存平台化：Twitter 的 Twemproxy，豆瓣的 BeansDB、腾讯 TTC。&lt;/p>
&lt;p>2、服务化&lt;/p>
&lt;p>目的在于解决“系统交互”的问题，常见的做法是通过消息队列来完成系统间的异步通知，通过服务框架来完成系统间的同步调用。&lt;/p>
&lt;p>消息队列：淘宝的 Notify、MetaQ，开源的 Kafka、ActiveMQ 等。&lt;/p>
&lt;p>服务框架：Facebook 的 thrift、当当网的 Dubbox、淘宝的 HSF 等。&lt;/p>
&lt;h4 id="成熟期">成熟期&lt;/h4>
&lt;p>当企业熬过竞争期，成为了行业的领头羊，或者整个行业整体上已经处于比较成熟的阶段，市场地位已经比较牢固后，业务创新的机会已经不大，竞争压力也没有那么激烈，此时求快求新已经没有很大空间，业务上开始转向为“求精”：响应时间是否比竞争对手快？用户体验是否比竞争对手好？成本是否比竞争对手低……&lt;/p>
&lt;p>此时技术上其实也基本进入了成熟期，该拆的也拆了，该平台化的也平台化了，技术上能做的大动作其实也不多了，更多的是进行优化。但有时候也会为了满足某个优化，系统做很大的改变。例如，为了将用户响应时间从 200ms 降低到 50ms，可能就需要从很多方面进行优化：CDN、数据库、网络等。这个时候的技术优化没有固定的套路，只能按照竞争的要求，找出自己的弱项，然后逐项优化。在逐项优化时，可以采取之前各个时期采用的手段。&lt;/p>
&lt;h3 id="用户规模">用户规模&lt;/h3>
&lt;p>互联网业务的发展第二个主要方向就是“用户量越来越大”。互联网业务的发展会经历“初创期、发展期、竞争期、成熟期”几个阶段，不同阶段典型的差别就是用户量的差别，用户量随着业务的发展而越来越大。用户量增大对技术的影响主要体现在两个方面：性能要求越来越高、可用性要求越来越高。&lt;/p>
&lt;h4 id="性能">性能&lt;/h4>
&lt;p>用户量增大给技术带来的第一个挑战就是性能要求越来越高。以互联网企业最常用的 MySQL 为例，再简单的查询，再高的硬件配置，单台 MySQL 机器支撑的 TPS 和 QPS 最高也就是万级，低的可能是几千，高的也不过几万。当用户量增长后，必然要考虑使用多台 MySQL，从一台 MySQL 到多台 MySQL 不是简单的数量的增加，而是本质上的改变，即原来集中式的存储变为了分布式的存储。&lt;/p>
&lt;p>稍微有经验的工程师都会知道，分布式将会带来复杂度的大幅度上升。以 MySQL 为例，分布式 MySQL 要考虑分库分表、读写分离、复制、同步等很多问题。&lt;/p>
&lt;h4 id="可用性">可用性&lt;/h4>
&lt;p>用户量增大对技术带来的第二个挑战就是可用性要求越来越高。当有 1 万个用户的时候，宕机 1 小时可能也没有很大的影响；但当有了 100 万用户的时候，宕机 10 分钟，投诉电话估计就被打爆了，这些用户再到朋友圈抱怨一下系统有多烂，很可能就不会再有机会发展下一个 100 万用户了。&lt;/p>
&lt;p>除了口碑的影响，可用性对收入的影响也会随着用户量增大而增大。1 万用户宕机 1 小时，可能才损失了几千元；100 万用户宕机 10 分钟，损失可能就是几十万元了。&lt;/p>
&lt;h3 id="量变到质变">量变到质变&lt;/h3>
&lt;p>通过前面的分析可以看到互联网业务驱动技术发展的两大主要因素是复杂性和用户规模，而这两个因素的本质其实都是“量变带来质变”。&lt;/p>
&lt;p>究竟用户规模发展到什么阶段才会由量变带来质变，虽然不同的业务有所差别，但基本上可以按照下面这个模型去衡量。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_2.png" alt="architecture-action_2.png">&lt;/p>
&lt;p>应对业务质变带来的技术压力，不同时期有不同的处理方式，但不管什么样的方式，其核心目标都是为了满足业务“快”的要求，当发现业务快不起来的时候，其实就是技术的水平已经跟不上业务发展的需要了，技术变革和发展的时候就到了。更好的做法是在问题还没有真正暴露出来就能够根据趋势预测下一个转折点，提前做好技术上的准备，这对技术人员的要求是非常高的。&lt;/p>
&lt;h2 id="互联网架构模板-存储层技术">互联网架构模板：存储层技术&lt;/h2>
&lt;p>很多人对于 BAT 的技术有一种莫名的崇拜感，觉得只有天才才能做出这样的系统，但经过前面对架构的本质、架构的设计原则、架构的设计模式、架构演进等多方位的探讨和阐述，可以看到，其实并没有什么神秘的力量和魔力融合在技术里面，而是业务的不断发展推动了技术的发展，这样一步一个脚印，持续几年甚至十几年的发展，才能达到当前技术复杂度和先进性。&lt;/p>
&lt;p>抛开 BAT 各自差异很大的业务，站在技术的角度来看，其实 BAT 的技术架构基本是一样的。再将视角放大，会发现整个互联网行业的技术发展，最后都是殊途同归。&lt;/p>
&lt;p>如果自己正处于一个创业公司，或者正在为成为另一个 BAT 拼搏，那么深入理解这种技术模式（或者叫技术结构、技术架构），对于自己和公司的发展都大有裨益。互联网的标准技术架构如下图所示，这张图基本上涵盖了互联网技术公司的大部分技术点，不同的公司只是在具体的技术实现上稍有差异，但不会跳出这个框架的范畴。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_3.png" alt="architecture-action_3.png">&lt;/p>
&lt;p>这里将逐层介绍每个技术点的产生背景、应用场景、关键技术，有的技术点可能已经在前面的架构模式部分有所涉及，因此就不再详细展开技术细节了，而是将关键技术点分门别类，进而形成一张架构大图，让架构师对一个公司的整体技术架构有一个完整的全貌认知。&lt;/p>
&lt;h3 id="sql">SQL&lt;/h3>
&lt;p>SQL 即我们通常所说的关系数据。前几年 NoSQL 火了一阵子，很多人都理解为 NoSQL 是完全抛弃关系数据，全部采用非关系型数据。但经过几年的试验后，大家发现关系数据不可能完全被抛弃，NoSQL 不是 No SQL，而是 Not Only SQL，即 NoSQL 是 SQL 的补充。&lt;/p>
&lt;p>所以互联网行业也必须依赖关系数据，考虑到 Oracle 太贵，还需要专人维护，一般情况下互联网行业都是用 MySQL、PostgreSQL 这类开源数据库。这类数据库的特点是开源免费，拿来就用；但缺点是性能相比商业数据库要差一些。随着互联网业务的发展，性能要求越来越高，必然要面对一个问题：将数据拆分到多个数据库实例才能满足业务的性能需求（其实 Oracle 也一样，只是时间早晚的问题）。&lt;/p>
&lt;p>数据库拆分满足了性能的要求，但带来了复杂度的问题：数据如何拆分、数据如何组合？这个复杂度的问题解决起来并不容易，如果每个业务都去实现一遍，重复造轮子将导致投入浪费、效率降低，业务开发想快都快不起来。&lt;/p>
&lt;p>所以互联网公司流行的做法是业务发展到一定阶段后，就会将这部分功能独立成中间件，例如百度的 DBProxy、淘宝的 TDDL。不过这部分的技术要求很高，将分库分表做到自动化和平台化，不是一件容易的事情，所以一般是规模很大的公司才会自己做。中小公司建议使用开源方案，例如 MySQL 官方推荐的 MySQL Router、360 开源的数据库中间件 Atlas。&lt;/p>
&lt;p>假如公司业务继续发展，规模继续扩大，SQL 服务器越来越多，如果每个业务都基于统一的数据库中间件独立部署自己的 SQL 集群，就会导致新的复杂度问题，具体表现在：&lt;/p>
&lt;p>1）数据库资源使用率不高，比较浪费。&lt;/p>
&lt;p>2）各 SQL 集群分开维护，投入的维护成本越来越高。&lt;/p>
&lt;p>因此，实力雄厚的大公司此时一般都会在 SQL 集群上构建 SQL 存储平台，以对业务透明的形式提供资源分配、数据备份、迁移、容灾、读写分离、分库分表等一系列服务，例如淘宝的 UMP（Unified MySQL Platform）系统。&lt;/p>
&lt;h3 id="nosql">NoSQL&lt;/h3>
&lt;p>首先 NoSQL 在数据结构上与传统的 SQL 的不同，例如典型的 Memcache 的 key-value 结构、Redis 的复杂数据结构、MongoDB 的文档数据结构；其次，NoSQL 无一例外地都会将性能作为自己的一大卖点。NoSQL 的这两个特点很好地弥补了关系数据库的不足，因此在互联网行业 NoSQL 的应用基本上是基础要求。&lt;/p>
&lt;p>由于 NoSQL 方案一般自己本身就提供集群的功能，例如 Memcache 的一致性 Hash 集群、Redis 3.0 的集群，因此 NoSQL 在刚开始应用时很方便，不像 SQL 分库分表那么复杂。一般公司也不会在开始时就考虑将 NoSQL 包装成存储平台，但如果公司发展很快，例如 Memcache 的节点有上千甚至几千时，NoSQL 存储平台就很有意义了。首先是存储平台通过集中管理能够大大提升运维效率；其次是存储平台可以大大提升资源利用效率，2000 台机器，如果利用率能提升 10%，就可以减少 200 台机器，一年几十万元就节省出来了。&lt;/p>
&lt;p>所以，NoSQL 发展到一定规模后，通常都会在 NoSQL 集群的基础之上再实现统一&lt;strong>存储平台&lt;/strong>，统一存储平台主要实现这几个功能：&lt;/p>
&lt;p>1）资源动态按需动态分配：例如同一台 Memcache 服务器，可以根据内存利用率，分配给多个业务使用。&lt;/p>
&lt;p>2）资源自动化管理：例如新业务只需要申请多少 Memcache 缓存空间就可以了，无需关注具体是哪些 Memcache 服务器在为自己提供服务。&lt;/p>
&lt;p>3）故障自动化处理：例如某台 Memcache 服务器挂掉后，有另外一台备份 Memcache 服务器能立刻接管缓存请求，不会导致丢失很多缓存数据。&lt;/p>
&lt;p>当然要发展到这个阶段，一般也是大公司才会这么做，简单来说就是如果只有几十台 NoSQL 服务器，做存储平台收益不大；但如果有几千台 NoSQL 服务器，NoSQL 存储平台就能够产生很大的收益。&lt;/p>
&lt;h3 id="小文件存储">小文件存储&lt;/h3>
&lt;p>除了关系型的业务数据，互联网行业还有很多用于展示的数据。例如，淘宝的商品图片、商品描述；Facebook 的用户图片；新浪微博的一条微博内容等。这些数据具有三个典型特征：一是数据小，一般在 1MB 以下；二是数量巨大，Facebook 在 2013 年每天上传的照片就达到了 3.5 亿张；三是访问量巨大，Facebook 每天的访问量超过 10 亿。&lt;/p>
&lt;p>由于互联网行业基本上每个业务都会有大量的小数据，如果每个业务都自己去考虑如何设计海量存储和海量访问，效率自然会低，重复造轮子也会投入浪费，所以自然而然就要将小文件存储做成统一的和业务无关的平台。&lt;/p>
&lt;p>和 SQL 和 NoSQL 不同的是，小文件存储不一定需要公司或者业务规模很大，基本上认为业务在起步阶段就可以考虑做小文件统一存储。得益于开源运动的发展和最近几年大数据的火爆，在开源方案的基础上封装一个小文件存储平台并不是太难的事情。例如，HBase、Hadoop、Hypertable、FastDFS 等都可以作为小文件存储的底层平台，只需要将这些开源方案再包装一下基本上就可以用了。&lt;/p>
&lt;p>典型的小文件存储有：淘宝的 TFS、京东 JFS、Facebook 的 Haystack。&lt;/p>
&lt;p>下图是淘宝 TFS 的架构：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_4.png" alt="architecture-action_4.png">&lt;/p>
&lt;h3 id="大文件存储">大文件存储&lt;/h3>
&lt;p>互联网行业的大文件主要分为两类：一类是业务上的大数据，例如 Youtube 的视频、电影网站的电影；另一类是海量的日志数据，例如各种访问日志、操作日志、用户轨迹日志等。和小文件的特点正好相反，大文件的数量没有小文件那么多，但每个文件都很大，几百 MB、几个 GB 都是常见的，几十 GB、几 TB 也是有可能的，因此在存储上和小文件有较大差别，不能直接将小文件存储系统拿来存储大文件。&lt;/p>
&lt;p>说到大文件，特别要提到 Google 和 Yahoo，Google 的 3 篇大数据论文（Bigtable/Map- Reduce/GFS）开启了一个大数据的时代，而 Yahoo 开源的 Hadoop 系列（HDFS、HBase 等），基本上垄断了开源界的大数据处理。当然，江山代有才人出，长江后浪推前浪，Hadoop 后又有更多优秀的开源方案被贡献出来，现在随便走到大街上拉住一个程序员，如果他不知道大数据，那基本上可以确定是“火星程序员”。&lt;/p>
&lt;p>对照 Google 的论文构建一套完整的大数据处理方案的难度和成本实在太高，而且开源方案现在也很成熟了，所以大数据存储和处理这块反而是最简单的，因为你没有太多选择，只能用这几个流行的开源方案，例如，Hadoop、HBase、Storm、Hive 等。实力雄厚一些的大公司会基于这些开源方案，结合自己的业务特点，封装成大数据平台，例如淘宝的云梯系统、腾讯的 TDW 系统。&lt;/p>
&lt;p>下面是 Hadoop 的生态圈：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_5.png" alt="architecture-action_5.png">&lt;/p>
&lt;h2 id="互联网架构模板-开发层和服务层技术">互联网架构模板：开发层和服务层技术&lt;/h2>
&lt;h3 id="开发层技术">开发层技术&lt;/h3>
&lt;h4 id="开发框架">开发框架&lt;/h4>
&lt;p>前面深入分析了互联网业务发展的一个特点：复杂度越来越高。复杂度增加的典型现象就是系统越来越多，不同的系统由不同的小组开发。如果每个小组用不同的开发框架和技术，则会带来很多问题，典型的问题有：&lt;/p>
&lt;p>1）技术人员之间没有共同的技术语言，交流合作少。&lt;/p>
&lt;p>2）每类技术都需要投入大量的人力和资源并熟练精通。&lt;/p>
&lt;p>3）不同团队之间人员无法快速流动，人力资源不能高效的利用。&lt;/p>
&lt;p>所以，互联网公司都会指定一个大的技术方向，然后使用统一的开发框架。例如，Java 相关的开发框架 SSH、SpringMVC、Play，Ruby 的 Ruby on Rails，PHP 的 ThinkPHP，Python 的 Django 等。使用统一的开发框架能够解决上面提到的各种问题，大大提升组织和团队的开发效率。&lt;/p>
&lt;p>对于框架的选择，有一个总的原则：&lt;strong>优选成熟的框架，避免盲目追逐新技术&lt;/strong>！&lt;/p>
&lt;p>原因如下：首先，成熟的框架资料文档齐备，各种坑基本上都有人踩过了，遇到问题很容易通过搜索来解决。其次，成熟的框架受众更广，招聘时更加容易招到合适的人才。第三，成熟的框架更加稳定，不会出现大的变动，适合长期发展。&lt;/p>
&lt;h4 id="web-服务器">Web 服务器&lt;/h4>
&lt;p>开发框架只是负责完成业务功能的开发，真正能够运行起来给用户提供服务，还需要服务器配合。&lt;/p>
&lt;p>独立开发一个成熟的 Web 服务器，成本非常高，况且业界又有那么多成熟的开源 Web 服务器，所以互联网行业基本上都是“拿来主义”，挑选一个流行的开源服务器即可。大一点的公司，可能会在开源服务器的基础上，结合自己的业务特点做二次开发，例如淘宝的 Tengine，但一般公司基本上只需要将开源服务器摸透，优化一下参数，调整一下配置就差不多了。&lt;/p>
&lt;p>选择一个服务器主要和开发语言相关，例如，Java 的有 Tomcat、JBoss、Resin 等，PHP/Python 的用 Nginx，当然最保险的就是用 Apache 了，什么语言都支持。&lt;/p>
&lt;p>你可能会担心 Apache 的性能之类的问题，其实不用过早担心这个，等到业务真的发展到 Apache 撑不住的时候再考虑切换也不迟，那时候有的是钱，有的是人，有的是时间。&lt;/p>
&lt;h4 id="容器">容器&lt;/h4>
&lt;p>容器是最近几年才开始火起来的，其中以 Docker 为代表，在 BAT 级别的公司已经有较多的应用。例如，腾讯万台规模的 Docker 应用实践（&lt;a href="http://www.infoq.com/cn/articles/tencent-millions-scale-docker-application-practice">http://www.infoq.com/cn/articles/tencent-millions-scale-docker-application-practice&lt;/a>）、新浪微博红包的大规模 Docker 集群（&lt;a href="http://www.infoq.com/cn/articles/large-scale-docker-cluster-practise-experience-share">http://www.infoq.com/cn/articles/large-scale-docker-cluster-practise-experience-share&lt;/a>）等。&lt;/p>
&lt;p>传统的虚拟化技术是虚拟机，解决了跨平台的问题，但由于虚拟机太庞大，启动又慢，运行时太占资源，在互联网行业并没有大规模应用；而 Docker 的容器技术，虽然没有跨平台，但启动快，几乎不占资源，推出后立刻就火起来了，预计 Docker 类的容器技术将是技术发展的主流方向。&lt;/p>
&lt;p>千万不要以为 Docker 只是一个虚拟化或者容器技术，它将在很大程度上改变目前的技术形势：&lt;/p>
&lt;p>1）运维方式会发生革命性的变化：Docker 启动快，几乎不占资源，随时启动和停止，基于 Docker 打造自动化运维、智能化运维将成为主流方式。&lt;/p>
&lt;p>2）设计模式会发生本质上的变化：启动一个新的容器实例代价如此低，将鼓励设计思路朝“微服务”的方向发展。&lt;/p>
&lt;p>例如，一个传统的网站包括登录注册、页面访问、搜索等功能，没有用容器的情况下，除非有特别大的访问量，否则这些功能开始时都是集成在一个系统里面的；有了容器技术后，一开始就可以将这些功能按照服务的方式设计，避免后续访问量增大时又要重构系统。&lt;/p>
&lt;h3 id="服务层技术">服务层技术&lt;/h3>
&lt;p>互联网业务的不断发展带来了复杂度的不断提升，业务系统也越来越多，系统间相互依赖程度加深。比如说为了完成 A 业务系统，可能需要 B、C、D、E 等十几个其他系统进行合作。从数学的角度进行评估，可以发现系统间的依赖是呈指数级增长的：3 个系统相互关联的路径为 3 条，6 个系统相互关联的路径为 15 条。&lt;/p>
&lt;p>服务层的主要目标其实就是为了降低系统间相互关联的复杂度。&lt;/p>
&lt;h4 id="配置中心">配置中心&lt;/h4>
&lt;p>故名思议，配置中心就是集中管理各个系统的配置。当系统数量不多的时候，一般是各系统自己管理自己的配置，但系统数量多了以后，这样的处理方式会有问题：&lt;/p>
&lt;p>1）某个功能上线时，需要多个系统配合一起上线，分散配置时，配置检查、沟通协调需要耗费较多时间。&lt;/p>
&lt;p>2）处理线上问题时，需要多个系统配合查询相关信息，分散配置时，操作效率很低，沟通协调也需要耗费较多时间。&lt;/p>
&lt;p>3）各系统自己管理配置时，一般是通过文本编辑的方式修改的，没有自动的校验机制，容易配置错误，而且很难发现。&lt;/p>
&lt;p>例如，将 IP 地址的数字 0 误敲成了键盘的字母 O，肉眼非常难发现，但程序检查其实就很容易。&lt;/p>
&lt;p>实现配置中心主要就是为了解决上面这些问题，将配置中心做成通用的系统的好处有：&lt;/p>
&lt;p>1）集中配置多个系统，操作效率高。&lt;/p>
&lt;p>2）所有配置都在一个集中的地方，检查方便，协作效率高。&lt;/p>
&lt;p>3）配置中心可以实现程序化的规则检查，避免常见的错误。比如说检查最小值、最大值、是否 IP 地址、是否 URL 地址，都可以用正则表达式完成。&lt;/p>
&lt;p>4）配置中心相当于备份了系统的配置，当某些情况下需要搭建新的环境时，能够快速搭建环境和恢复业务。&lt;/p>
&lt;p>整机磁盘坏掉、机器主板坏掉……遇到这些不可恢复的故障时，基本上只能重新搭建新的环境。程序包肯定是已经有的，加上配置中心的配置，能够很快搭建新的运行环境，恢复业务。否则几十个配置文件重新一个个去 Vim 中修改，耗时很长，还很容易出错。&lt;/p>
&lt;p>下面是配置中心简单的设计，其中通过“系统标识 + host + port”来标识唯一一个系统运行实例是常见的设计方法。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_6.png" alt="architecture-action_6.png">&lt;/p>
&lt;h4 id="服务中心">服务中心&lt;/h4>
&lt;p>当系统数量不多的时候，系统间的调用一般都是直接通过配置文件记录在各系统内部的，但当系统数量多了以后，这种方式就存在问题了。&lt;/p>
&lt;p>比如说总共有 10 个系统依赖 A 系统的 X 接口，A 系统实现了一个新接口 Y，能够更好地提供原有 X 接口的功能，如果要让已有的 10 个系统都切换到 Y 接口，则这 10 个系统的几十上百台机器的配置都要修改，然后重启，可想而知这个效率是很低的。&lt;/p>
&lt;p>除此以外，如果 A 系统总共有 20 台机器，现在其中 5 台出故障了，其他系统如果是通过域名访问 A 系统，则域名缓存失效前，还是可能访问到这 5 台故障机器的；如果其他系统通过 IP 访问 A 系统，那么 A 系统每次增加或者删除机器，其他所有 10 个系统的几十上百台机器都要同步修改，这样的协调工作量也是非常大的。&lt;/p>
&lt;p>服务中心就是为了解决上面提到的跨系统依赖的“配置”和“调度”问题。服务中心的实现一般来说有两种方式：服务名字系统和服务总线系统。&lt;/p>
&lt;p>1、服务名字系统（Service Name System）&lt;/p>
&lt;p>看到这个翻译，会立刻联想到 DNS，即 Domain Name System。两者的性质是基本类似的。DNS 的作用将域名解析为 IP 地址，人工记不住太多的数字 IP，域名就容易记住。服务名字系统是为了将 Service 名称解析为“host + port + 接口名称”，但是和 DNS 一样，真正发起请求的还是请求方。基本的设计如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_7.png" alt="architecture-action_7.png">&lt;/p>
&lt;p>2、服务总线系统（Service Bus System）&lt;/p>
&lt;p>可以联想到计算机的总线，两者的本质也是基本类似的。相比服务名字系统，服务总线系统更进一步了：由总线系统完成调用，服务请求方都不需要直接和服务提供方交互了。基本的设计如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_8.png" alt="architecture-action_8.png">&lt;/p>
&lt;p>“服务名字系统”和“服务总线系统”简单对比如下表所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_9.png" alt="architecture-action_9.png">&lt;/p>
&lt;h4 id="消息队列">消息队列&lt;/h4>
&lt;p>互联网业务的一个特点是“快”，这就要求很多业务处理采用异步的方式。例如，大 V 发布一条微博后，系统需要发消息给关注的用户，我们不可能等到所有消息都发送给关注用户后再告诉大 V 说微博发布成功了，只能先让大 V 发布微博，然后再发消息给关注用户。&lt;/p>
&lt;p>传统的异步通知方式是由消息生产者直接调用消息消费者提供的接口进行通知的，但当业务变得庞大，子系统数量增多时，这样做会导致系统间交互非常复杂和难以管理，因为系统间互相依赖和调用，整个系统的结构就像一张蜘蛛网，如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_10.png" alt="architecture-action_10.png">&lt;/p>
&lt;p>消息队列就是为了实现这种跨系统异步通知的中间件系统。消息队列既可以“一对一”通知，也可以“一对多”广播。以微博为例，可以清晰地看到异步通知的实现和作用，如下图所示。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_11.png" alt="architecture-action_11.png">&lt;/p>
&lt;p>对比前面的蜘蛛网架构，可以清晰地看出引入消息队列系统后的效果：&lt;/p>
&lt;p>1）整体结构从网状结构变为线性结构，结构清晰；&lt;/p>
&lt;p>2）消息生产和消息消费解耦，实现简单；&lt;/p>
&lt;p>3）增加新的消息消费者，消息生产者完全不需要任何改动，扩展方便；&lt;/p>
&lt;p>4）消息队列系统可以做高可用、高性能，避免各业务子系统各自独立做一套，减轻工作量；&lt;/p>
&lt;p>5）业务子系统只需要聚焦业务即可，实现简单。&lt;/p>
&lt;p>消息队列系统基本功能的实现比较简单，但要做到高性能、高可用、消息时序性、消息事务性则比较难。业界已经有很多成熟的开源实现方案，如果要求不高，基本上拿来用即可，例如，RocketMQ、Kafka、ActiveMQ 等。但如果业务对消息的可靠性、时序、事务性要求较高时，则要深入研究这些开源方案，否则很容易踩坑。&lt;/p>
&lt;p>开源的用起来方便，但要改就很麻烦了。由于其相对比较简单，很多公司也会花费人力和时间重复造一个轮子，这样也有好处，因为可以根据自己的业务特点做快速的适配开发。&lt;/p>
&lt;h2 id="互联网架构模板-网络层技术">互联网架构模板：网络层技术&lt;/h2>
&lt;p>除了复杂度，互联网业务发展的另外两个关键特点是“高性能”和“高可用”。通常情况下，在设计高可用和高性能系统的时候，主要关注点在系统本身的复杂度，然后通过各种手段来实现高可用和高性能的要求，例如前面介绍的计算高性能架构模式、存储高可用架构模式等。但是当站在一个公司的的角度来思考架构的时候，单个系统的高可用和高性能并不等于整体业务的高可用和高性能，互联网业务的高性能和高可用需要从更高的角度去设计，这个高点就是“网络”，所以将相关措施统一划归为“网络层”。注意这里的网络层和通常理解的如何搭建一个局域网这种概念不一样，这里强调的是站在网络层的角度整体设计架构，而不是某个具体网络的搭建。&lt;/p>
&lt;h3 id="负载均衡">负载均衡&lt;/h3>
&lt;p>顾名思议，负载均衡就是将请求均衡地分配到多个系统上。使用负载均衡的原因也很简单：每个系统的处理能力是有限的，为了应对大容量的访问，必须使用多个系统。例如，一台 32 核 64GB 内存的机器，性能测试数据显示每秒处理 Hello World 的 HTTP 请求不超过 2 万，实际业务机器处理 HTTP 请求每秒可能才几百 QPS，而互联网业务并发超过 1 万是比较常见的，遇到双十一、过年发红包这些极端场景，每秒可以达到几十万的请求。&lt;/p>
&lt;h4 id="dns">DNS&lt;/h4>
&lt;p>DNS 是最简单也是最常见的负载均衡方式，一般用来实现地理级别的均衡。例如，北方的用户访问北京的机房，南方的用户访问广州的机房。一般不会使用 DNS 来做机器级别的负载均衡，因为太耗费 IP 资源了。例如，百度搜索可能要 10000 台以上机器，不可能将这么多机器全部配置公网 IP，然后用 DNS 来做负载均衡。有兴趣的读者可以在 Linux 用“dig baidu.com”命令看看实际上用了几个 IP 地址。&lt;/p>
&lt;p>DNS 负载均衡的优点是通用（全球通用）、成本低（申请域名，注册 DNS 即可），但缺点也比较明显，主要体现在：&lt;/p>
&lt;p>1）DNS 缓存的时间比较长，即使将某台业务机器从 DNS 服务器上删除，由于缓存的原因，还是有很多用户会继续访问已经被删除的机器。&lt;/p>
&lt;p>2）DNS 不够灵活。DNS 不能感知后端服务器的状态，只能根据配置策略进行负载均衡，无法做到更加灵活的负载均衡策略。比如说某台机器的配置比其他机器要好很多，理论上来说应该多分配一些请求给它，但 DNS 无法做到这一点。&lt;/p>
&lt;p>所以对于时延和故障敏感的业务，有实力的公司可能会尝试实现 HTTP-DNS 的功能，即使用 HTTP 协议实现一个私有的 DNS 系统。HTTP-DNS 主要应用在通过 App 提供服务的业务上，因为在 App 端可以实现灵活的服务器访问策略，如果是 Web 业务，实现起来就比较麻烦一些，因为 URL 的解析是由浏览器来完成的，只有 Javascript 的访问可以像 App 那样实现比较灵活的控制。&lt;/p>
&lt;p>HTTP-DNS 的优缺点有：&lt;/p>
&lt;p>1）灵活：HTTP-DNS 可以根据业务需求灵活的设置各种策略。&lt;/p>
&lt;p>2）可控：HTTP-DNS 是自己开发的系统，IP 更新、策略更新等无需依赖外部服务商。&lt;/p>
&lt;p>3）及时：HTTP-DNS 不受传统 DNS 缓存的影响，可以非常快地更新数据、隔离故障。&lt;/p>
&lt;p>4）开发成本高：没有通用的解决方案，需要自己开发。&lt;/p>
&lt;p>5）侵入性：需要 App 基于 HTTP-DNS 进行改造。&lt;/p>
&lt;h4 id="nginx-lvs-f5">Nginx 、LVS 、F5&lt;/h4>
&lt;p>DNS 用于实现地理级别的负载均衡，而 Nginx、LVS、F5 用于同一地点内机器级别的负载均衡。其中 Nginx 是软件的 7 层负载均衡，LVS 是内核的 4 层负载均衡，F5 是硬件的 4 层负载均衡。&lt;/p>
&lt;p>软件和硬件的区别就在于性能，硬件远远高于软件，Ngxin 的性能是万级，一般的 Linux 服务器上装个 Nginx 大概能到 5 万 / 秒；LVS 的性能是十万级，没有具体测试过，据说可达到 80 万 / 秒；F5 性能是百万级，从 200 万 / 秒到 800 万 / 秒都有。硬件虽然性能高，但是单台硬件的成本也很高，一台最便宜的 F5 都是几十万，但是如果按照同等请求量级来计算成本的话，实际上硬件负载均衡设备可能会更便宜，例如假设每秒处理 100 万请求，用一台 F5 就够了，但用 Nginx，可能要 20 台，这样折算下来用 F5 的成本反而低。因此通常情况下，如果性能要求不高，可以用软件负载均衡；如果性能要求很高，推荐用硬件负载均衡。&lt;/p>
&lt;p>4 层和 7 层的区别就在于协议和灵活性。Nginx 支持 HTTP、E-mail 协议，而 LVS 和 F5 是 4 层负载均衡，和协议无关，几乎所有应用都可以做，例如聊天、数据库等。&lt;/p>
&lt;p>目前很多云服务商都已经提供了负载均衡的产品，例如阿里云的 SLB、UCloud 的 ULB 等，中小公司直接购买即可。&lt;/p>
&lt;h3 id="cdn">CDN&lt;/h3>
&lt;p>CDN 是为了解决用户网络访问时的“最后一公里”效应，本质上是一种“以空间换时间”的加速策略，即将内容缓存在离用户最近的地方，用户访问的是缓存的内容，而不是站点实时的内容。&lt;/p>
&lt;p>下面是简单的 CDN 请求流程示意图：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_12.png" alt="architecture-action_12.png">&lt;/p>
&lt;p>CDN 经过多年的发展，已经变成了一个很庞大的体系：分布式存储、全局负载均衡、网络重定向、流量控制等都属于 CDN 的范畴，尤其是在视频、直播等领域，如果没有 CDN，用户是不可能实现流畅观看内容的。&lt;/p>
&lt;p>幸运的是大部分程序员和架构师都不太需要深入理解 CDN 的细节，因为 CDN 作为网络的基础服务，独立搭建的成本巨大，很少有公司自己设计和搭建 CDN 系统，从 CDN 服务商购买 CDN 服务即可，目前有专门的 CDN 服务商，例如网宿和蓝汛；也有云计算厂家提供 CDN 服务，例如阿里云和腾讯云都提供 CDN 的服务。&lt;/p>
&lt;h3 id="多机房">多机房&lt;/h3>
&lt;p>从架构上来说，单机房就是一个全局的网络单点，在发生比较大的故障或者灾害时，单机房难以保证业务的高可用。例如，停电、机房网络中断、地震、水灾等都有可能导致一个机房完全瘫痪。&lt;/p>
&lt;p>多机房设计最核心的因素就是如何处理时延带来的影响，常见的策略有：&lt;/p>
&lt;h4 id="同城多机房">同城多机房&lt;/h4>
&lt;p>同一个城市多个机房，距离不会太远，可以投入重金，搭建私有的高速网络，基本上能够做到和同机房一样的效果。&lt;/p>
&lt;p>这种方式对业务影响很小，但投入较大，如果不是大公司，一般是承受不起的；而且遇到极端的地震、水灾等自然灾害，同城多机房也是有很大风险的。&lt;/p>
&lt;h4 id="跨城多机房">跨城多机房&lt;/h4>
&lt;p>在不同的城市搭建多个机房，机房间通过网络进行数据复制（例如，MySQL 主备复制），但由于跨城网络时延的问题，业务上需要做一定的妥协和兼容，比如不需要数据的实时强一致性，只是保证最终一致性。&lt;/p>
&lt;p>例如，微博类产品，B 用户关注了 A 用户，A 用户在北京机房发布了一条微博，B 在广州机房不需要立刻看到 A 用户发的微博，等 10 分钟看到也可以。&lt;/p>
&lt;p>这种方式实现简单，但和业务有很强的相关性，微博可以这样做，支付宝的转账业务就不能这样做，因为用户余额是强一致性的。&lt;/p>
&lt;h4 id="跨国多机房">跨国多机房&lt;/h4>
&lt;p>和跨城多机房类似，只是地理上分布更远，时延更大。由于时延太大和用户跨国访问实在太慢，跨国多机房一般仅用于备份和服务本国用户。&lt;/p>
&lt;h3 id="多中心">多中心&lt;/h3>
&lt;p>多中心必须以多机房为前提，但从设计的角度来看，多中心相比多机房是本质上的飞越，难度也高出一个等级。&lt;/p>
&lt;p>简单来说，多机房的主要目标是灾备，当机房故障时，可以比较快速地将业务切换到另外一个机房，这种切换操作允许一定时间的中断（例如，10 分钟、1 个小时），而且业务也可能有损失（例如，某些未同步的数据不能马上恢复，或者要等几天才恢复，甚至永远都不能恢复了）。因此相比多机房来说，多中心的要求就高多了，要求每个中心都同时对外提供服务，且业务能够自动在多中心之间切换，故障后不需人工干预或者很少的人工干预就能自动恢复。&lt;/p>
&lt;p>多中心设计的关键就在于“数据一致性”和“数据事务性”如何保证，这两个难点都和业务紧密相关，目前没有很成熟的且通用的解决方案，需要基于业务的特性进行详细的分析和设计。以淘宝为例，淘宝对外宣称自己是多中心的，但是在实际设计过程中，商品浏览的多中心方案、订单的多中心方案、支付的多中心方案都需要独立设计和实现。&lt;/p>
&lt;p>正因为多中心设计的复杂性，不一定所有业务都能实现多中心，目前国内的银行、支付宝这类系统就没有完全实现多中心，不然也不会出现挖掘机一铲子下去，支付宝中断 4 小时的故障。&lt;/p>
&lt;h2 id="互联网架构模板-用户层和业务层">互联网架构模板：用户层和业务层&lt;/h2>
&lt;h3 id="用户层技术">用户层技术&lt;/h3>
&lt;h4 id="用户管理">用户管理&lt;/h4>
&lt;p>互联网业务的一个典型特征就是通过互联网将众多分散的用户连接起来，因此用户管理是互联网业务必不可少的一部分。&lt;/p>
&lt;p>稍微大一点的互联网业务，肯定会涉及多个子系统，这些子系统不可能每个都管理这么庞大的用户，由此引申出用户管理的第一个目标：单点登录（SSO），又叫统一登录。单点登录的技术实现手段较多，例如 cookie、JSONP、token 等，目前最成熟的开源单点登录方案当属 CAS，其架构如下（&lt;a href="https://apereo.github.io/cas/4.2.x/planning/Architecture.html">https://apereo.github.io/cas/4.2.x/planning/Architecture.html&lt;/a> ）：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_13.png" alt="architecture-action_13.png">&lt;/p>
&lt;p>除此之外，当业务做大成为了平台后，开放成为了促进业务进一步发展的手段，需要允许第三方应用接入，由此引申出用户管理的第二个目标：授权登录。现在最流行的授权登录就是 OAuth 2.0 协议，基本上已经成为了事实上的标准，如果要做开放平台，则最好用这个协议，私有协议漏洞多，第三方接入也麻烦。&lt;/p>
&lt;p>用户管理系统面临的主要问题是用户数巨大，一般至少千万级，QQ、微信、支付宝这种巨无霸应用都是亿级用户。不过也不要被这个数据给吓倒了，用户管理虽然数据量巨大，但实现起来并不难，原因是什么呢？ 因为用户数据量虽然大，但是不同用户之间没有太强的业务关联，A 用户登录和 B 用户登录基本没有关系。因此虽然数据量巨大，但用一个简单的负载均衡架构就能轻松应对。&lt;/p>
&lt;p>用户管理的基本架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_14.png" alt="architecture-action_14.png">&lt;/p>
&lt;h4 id="消息推送">消息推送&lt;/h4>
&lt;p>消息推送根据不同的途径，分为短信、邮件、站内信、App 推送。除了 App，不同的途径基本上调用不同的 API 即可完成，技术上没有什么难度。例如，短信需要依赖运营商的短信接口，邮件需要依赖邮件服务商的邮件接口，站内信是系统提供的消息通知功能。&lt;/p>
&lt;p>App 目前主要分为 iOS 和 Android 推送，iOS 系统比较规范和封闭，基本上只能使用苹果的 APNS；但 Android 就不一样了，在国外，用 GCM 和 APNS 差别不大；但是在国内，情况就复杂多了：首先是 GCM 不能用；其次是各个手机厂商都有自己的定制的 Android，消息推送实现也不完全一样。因此 Android 的消息推送就五花八门了，大部分有实力的大厂，都会自己实现一套消息推送机制，例如阿里云移动推送、腾讯信鸽推送、百度云推送；也有第三方公司提供商业推送服务，例如友盟推送、极光推送等。&lt;/p>
&lt;p>通常情况下，对于中小公司，如果不涉及敏感数据，Android 系统上推荐使用第三方推送服务，因为毕竟是专业做推送服务的，消息到达率是有一定保证的。&lt;/p>
&lt;p>如果涉及敏感数据，需要自己实现消息推送，这时就有一定的技术挑战了。消息推送主要包含 3 个功能：设备管理（唯一标识、注册、注销）、连接管理和消息管理，技术上面临的主要挑战有：&lt;/p>
&lt;p>1）海量设备和用户管理&lt;/p>
&lt;p>消息推送的设备数量众多，存储和管理这些设备是比较复杂的；同时，为了针对不同用户进行不同的业务推广，还需要收集用户的一些信息，简单来说就是将用户和设备关联起来，需要提取用户特征对用户进行分类或者打标签等。&lt;/p>
&lt;p>2）连接保活&lt;/p>
&lt;p>要想推送消息必须有连接通道，但是应用又不可能一直在前台运行，大部分设备为了省电省流量等原因都会限制应用后台运行，限制应用后台运行后连接通道可能就被中断了，导致消息无法及时的送达。连接保活是整个消息推送设计中细节和黑科技最多的地方，例如应用互相拉起、找手机厂商开白名单等。&lt;/p>
&lt;p>3）消息管理&lt;/p>
&lt;p>实际业务运营过程中，并不是每个消息都需要发送给每个用户，而是可能根据用户的特征，选择一些用户进行消息推送。由于用户特征变化很大，各种排列组合都有可能，将消息推送给哪些用户这部分的逻辑要设计得非常灵活，才能支撑花样繁多的业务需求，具体的设计方案可以采取规则引擎之类的微内核架构技术。&lt;/p>
&lt;h4 id="存储云-图片云">存储云、图片云&lt;/h4>
&lt;p>互联网业务场景中，用户会上传多种类型的文件数据，例如微信用户发朋友圈时上传图片，微博用户发微博时上传图片、视频，优酷用户上传视频，淘宝卖家上传商品图片等，这些文件具备几个典型特点：&lt;/p>
&lt;p>1）数据量大：用户基数大，用户上传行为频繁，例如 2016 年的时候微信朋友圈每天上传图片就达到了 10 亿张（&lt;a href="http://mi.techweb.com.cn/tmt/2016-05-25/2338330.shtml">http://mi.techweb.com.cn/tmt/2016-05-25/2338330.shtml&lt;/a>）。&lt;/p>
&lt;p>2）文件体积小：大部分图片是几百 KB 到几 MB，短视频播放时间也是在几分钟内。&lt;/p>
&lt;p>3）访问有时效性：大部分文件是刚上传的时候访问最多，随着时间的推移访问量越来越小。&lt;/p>
&lt;p>为了满足用户的文件上传和存储需求，需要对用户提供文件存储和访问功能，这里就需要用到前面我在专栏第 40 期介绍“存储层”技术时提到的“小文件存储”技术。简单来说，存储云和图片云通常的实现都是“CDN + 小文件存储”，现在有了“云”之后，除非 BAT 级别，一般不建议自己再重复造轮子了，直接买云服务可能是最快也是最经济的方式。&lt;/p>
&lt;p>既然存储云和图片云都是基于“CDN + 小文件存储”的技术，为何不统一一套系统，而将其拆分为两个系统呢？这是因为“图片”业务的复杂性导致的，普通的文件基本上提供存储和访问就够了，而图片涉及的业务会更多，包括裁剪、压缩、美化、审核、水印等处理，因此通常情况下图片云会拆分为独立的系统对用户提供服务。&lt;/p>
&lt;h3 id="业务层技术">业务层技术&lt;/h3>
&lt;p>互联网的业务千差万别，不同的业务分解下来有不同的系统，所以业务层没有办法提炼一些公共的系统或者组件。抛开业务上的差异，各个互联网业务发展最终面临的问题都是类似的：业务复杂度越来越高。也就是说，业务层面对的主要技术挑战是“复杂度”。&lt;/p>
&lt;p>复杂度越来越高的一个主要原因就是系统越来越庞大，业务越来越多。幸运的是，面对业务层的技术挑战，我们有一把“屠龙宝刀”，不管什么业务难题，用上“屠龙宝刀”问题都能迎刃而解。这把“屠龙宝刀”就是“拆”，化整为零、分而治之，将整体复杂性分散到多个子业务或者子系统里面去。具体拆的方式你可以查看专栏前面可扩展架构模式部分的分层架构、微服务、微内核等。&lt;/p>
&lt;p>以一个简单的电商系统为例，如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_15.png" alt="architecture-action_15.png">&lt;/p>
&lt;p>这个模拟的电商系统经历了 3 个发展阶段：&lt;/p>
&lt;p>1）第一阶段：所有功能都在 1 个系统里面。&lt;/p>
&lt;p>2）第二阶段：将商品和订单拆分到 2 个子系统里面。&lt;/p>
&lt;p>3）第三阶段：商品子系统和订单子系统分别拆分成了更小的 6 个子系统。&lt;/p>
&lt;p>上面只是个样例，实际上随着业务的发展，子系统会越来越多，据说淘宝内部大大小小的已经有成百上千的子系统了。&lt;/p>
&lt;p>随着子系统数量越来越多，如果达到几百上千，另外一个复杂度问题又会凸显出来：子系统数量太多，已经没有人能够说清楚业务的调用流程了，出了问题排查也会特别复杂。此时应该怎么处理呢，总不可能又将子系统合成大系统吧？最终答案还是“合”，正所谓“合久必分、分久必合”，但合的方式不一样，此时采取的“合”的方式是按照“高内聚、低耦合”的原则，将职责关联比较强的子系统合成一个虚拟业务域，然后通过网关对外统一呈现，类似于设计模式中的 Facade 模式。同样以电商为样例，采用虚拟业务域后，其架构如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_16.png" alt="architecture-action_16.png">&lt;/p>
&lt;h2 id="互联网架构模板-平台技术">互联网架构模板：平台技术&lt;/h2>
&lt;p>当业务规模比较小、系统复杂度不高时，运维、测试、数据分析、管理等支撑功能主要由各系统或者团队独立完成。随着业务规模越来越大，系统复杂度越来越高，子系统数量越来越多，如果继续采取各自为政的方式来实现这些支撑功能，会发现重复工作非常多。因此自然而然就会想到将这些支撑功能做成平台，避免重复造轮子，减少不规范带来的沟通和协作成本。&lt;/p>
&lt;h3 id="运维平台">运维平台&lt;/h3>
&lt;p>运维平台核心的职责分为四大块：配置、部署、监控、应急，每个职责对应系统生命周期的一个阶段，如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_17.png" alt="architecture-action_17.png">&lt;/p>
&lt;ul>
&lt;li>配置：主要负责资源的管理。例如，机器管理、IP 地址管理、虚拟机管理等。&lt;/li>
&lt;li>部署：主要负责将系统发布到线上。例如，包管理、灰度发布管理、回滚等。&lt;/li>
&lt;li>监控：主要负责收集系统上线运行后的相关数据并进行监控，以便及时发现问题。&lt;/li>
&lt;li>应急：主要负责系统出故障后的处理。例如，停止程序、下线故障机器、切换 IP 等。&lt;/li>
&lt;/ul>
&lt;p>运维平台的核心设计要素是“四化”：标准化、平台化、自动化、可视化。&lt;/p>
&lt;h4 id="标准化">标准化&lt;/h4>
&lt;p>需要制定运维标准，规范配置管理、部署流程、监控指标、应急能力等，各系统按照运维标准来实现，避免不同的系统不同的处理方式。标准化是运维平台的基础，没有标准化就没有运维平台。&lt;/p>
&lt;p>如果某个系统就是无法改造自己来满足运维标准，那该怎么办呢？常见的做法是不改造系统，由中间方来完成规范适配。例如，某个系统对外提供了 RESTful 接口的方式来查询当前的性能指标，而运维标准是性能数据通过日志定时上报，那么就可以写一个定时程序访问 RESTful 接口获取性能数据，然后转换为日志上报到运维平台。&lt;/p>
&lt;h4 id="平台化">平台化&lt;/h4>
&lt;p>传统的手工运维方式需要投入大量人力，效率低，容易出错，因此需要在运维标准化的基础上，将运维的相关操作都集成到运维平台中，通过运维平台来完成运维工作。&lt;/p>
&lt;p>运维平台的好处有：&lt;/p>
&lt;p>1）可以将运维标准固化到平台中，无须运维人员死记硬背运维标准。&lt;/p>
&lt;p>2）运维平台提供简单方便的操作，相比之下人工操作低效且容易出错。&lt;/p>
&lt;p>3）运维平台是可复用的，一套运维平台可以支撑几百上千个业务系统。&lt;/p>
&lt;h4 id="自动化">自动化&lt;/h4>
&lt;p>传统手工运维方式效率低下的一个主要原因就是要执行大量重复的操作，运维平台可以将这些重复操作固化下来，由系统自动完成。&lt;/p>
&lt;p>例如，一次手工部署需要登录机器、上传包、解压包、备份旧系统、覆盖旧系统、启动新系统，这个过程中需要执行大量的重复或者类似的操作。有了运维平台后，平台需要提供自动化的能力，完成上述操作，部署人员只需要在最开始单击“开始部署”按钮，系统部署完成后通知部署人员即可。&lt;/p>
&lt;p>类似的还有监控，有了运维平台后，运维平台可以实时收集数据并进行初步分析，当发现数据异常时自动发出告警，无须运维人员盯着数据看，或者写一大堆“grep + awk + sed”来分析日志才能发现问题。&lt;/p>
&lt;h4 id="可视化">可视化&lt;/h4>
&lt;p>运维平台有非常多的数据，如果全部通过人工去查询数据再来判断，则效率很低。尤其是在故障应急时，时间就是生命，处理问题都是争分夺秒，能减少 1 分钟的时间就可能挽回几十万元的损失，可视化的主要目的就是为了提升数据查看效率。&lt;/p>
&lt;p>可视化的原理和汽车仪表盘类似，如果只是一连串的数字显示在屏幕上，相信大部分人一看到一连串的数字，第一感觉是眼花，而且也很难将数据与具体的情况联系起来。而有了仪表盘后，通过仪表盘的指针偏离幅度及指针指向的区域颜色，能够一目了然地看出当前的状态是低速、中速还是高速。&lt;/p>
&lt;p>可视化相比简单的数据罗列，具备下面这些优点：&lt;/p>
&lt;p>1）能够直观地看到数据的相关属性，例如，汽车仪表盘中的数据最小值是 0，最大是 100，单位是 MPH。&lt;/p>
&lt;p>2）能够将数据的含义展示出来，例如汽车仪表盘中不同速度的颜色指示。&lt;/p>
&lt;p>3）能够将关联数据整合一起展示，例如汽车仪表盘的速度和里程。&lt;/p>
&lt;h3 id="测试平台">测试平台&lt;/h3>
&lt;p>测试平台核心的职责当然就是测试了，包括单元测试、集成测试、接口测试、性能测试等，都可以在测试平台来完成。&lt;/p>
&lt;p>测试平台的核心目的是提升测试效率，从而提升产品质量，其设计关键就是自动化。传统的测试方式是测试人员手工执行测试用例，测试效率低，重复的工作多。通过测试平台提供的自动化能力，测试用例能够重复执行，无须人工参与，大大提升了测试效率。&lt;/p>
&lt;p>为了达到“自动化”的目标，测试平台的基本架构如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_18.png" alt="architecture-action_18.png">&lt;/p>
&lt;h4 id="用例管理">用例管理&lt;/h4>
&lt;p>测试自动化的主要手段就是通过脚本或者代码来进行测试，例如单元测试用例是代码、接口测试用例可以用 Python 来写、可靠性测试用例可以用 Shell 来写。为了能够重复执行这些测试用例，测试平台需要将用例管理起来，管理的维度包括业务、系统、测试类型、用例代码。例如，网购业务的订单系统的接口测试用例。&lt;/p>
&lt;h4 id="资源管理">资源管理&lt;/h4>
&lt;p>测试用例要放到具体的运行环境中才能真正执行，运行环境包括硬件（服务器、手机、平板电脑等）、软件（操作系统、数据库、Java 虚拟机等）、业务系统（被测试的系统）。&lt;/p>
&lt;p>除了性能测试，一般的自动化测试对性能要求不高，所以为了提升资源利用率，大部分的测试平台都会使用虚拟技术来充分利用硬件资源，如虚拟机、Docker 等技术。&lt;/p>
&lt;h4 id="任务管理">任务管理&lt;/h4>
&lt;p>任务管理的主要职责是将测试用例分配到具体的资源上执行，跟踪任务的执行情况。任务管理是测试平台设计的核心，它将测试平台的各个部分串联起来从而完成自动化测试。&lt;/p>
&lt;h4 id="数据管理">数据管理&lt;/h4>
&lt;p>测试任务执行完成后，需要记录各种相关的数据（例如，执行时间、执行结果、用例执行期间的 CPU、内存占用情况等），这些数据具备下面这些作用：&lt;/p>
&lt;p>1）展现当前用例的执行情况。&lt;/p>
&lt;p>2）作为历史数据，方便后续的测试与历史数据进行对比，从而发现明显的变化趋势。例如，某个版本后单元测试覆盖率从 90% 下降到 70%。&lt;/p>
&lt;p>3）作为大数据的一部分，可以基于测试的任务数据进行一些数据挖掘。例如，某个业务一年执行了 10000 个用例测试，另外一个业务只执行了 1000 个用例测试，两个业务规模和复杂度差不多，为何差异这么大？&lt;/p>
&lt;h3 id="数据平台">数据平台&lt;/h3>
&lt;p>数据平台的核心职责主要包括三部分：数据管理、数据分析和数据应用。每一部分又包含更多的细分领域，详细的数据平台架构如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_19.png" alt="architecture-action_19.png">&lt;/p>
&lt;h4 id="数据管理-1">数据管理&lt;/h4>
&lt;p>数据管理包含数据采集、数据存储、数据访问和数据安全四个核心职责，是数据平台的基础功能。&lt;/p>
&lt;p>1）数据采集：从业务系统搜集各类数据。例如，日志、用户行为、业务数据等，将这些数据传送到数据平台。&lt;/p>
&lt;p>2）数据存储：将从业务系统采集的数据存储到数据平台，用于后续数据分析。&lt;/p>
&lt;p>3）数据访问：负责对外提供各种协议用于读写数据。例如，SQL、Hive、Key-Value 等读写协议。&lt;/p>
&lt;p>4）数据安全：通常情况下数据平台都是多个业务共享的，部分业务敏感数据需要加以保护，防止被其他业务读取甚至修改，因此需要设计数据安全策略来保护数据。&lt;/p>
&lt;h4 id="数据分析">数据分析&lt;/h4>
&lt;p>数据分析包括数据统计、数据挖掘、机器学习、深度学习等几个细分领域。&lt;/p>
&lt;p>1）数据统计：根据原始数据统计出相关的总览数据。例如，PV、UV、交易额等。&lt;/p>
&lt;p>2）数据挖掘：数据挖掘这个概念本身含义可以很广，为了与机器学习和深度学习区分开，这里的数据挖掘主要是指传统的数据挖掘方式。例如，有经验的数据分析人员基于数据仓库构建一系列规则来对数据进行分析从而发现一些隐含的规律、现象、问题等，经典的数据挖掘案例就是沃尔玛的啤酒与尿布的关联关系的发现。&lt;/p>
&lt;p>3）机器学习、深度学习：机器学习和深度学习属于数据挖掘的一种具体实现方式，由于其实现方式与传统的数据挖掘方式差异较大，因此数据平台在实现机器学习和深度学习时，需要针对机器学习和深度学习独立进行设计。&lt;/p>
&lt;h4 id="数据应用">数据应用&lt;/h4>
&lt;p>数据应用很广泛，既包括在线业务，也包括离线业务。例如，推荐、广告等属于在线应用，报表、欺诈检测、异常检测等属于离线应用。&lt;/p>
&lt;p>数据应用能够发挥价值的前提是需要有“大数据”，只有当数据的规模达到一定程度，基于数据的分析、挖掘才能发现有价值的规律、现象、问题等。如果数据没有达到一定规模，通常情况下做好数据统计就足够了，尤其是很多初创企业，无须一开始就参考 BAT 来构建自己的数据平台。&lt;/p>
&lt;h3 id="管理平台">管理平台&lt;/h3>
&lt;p>管理平台的核心职责就是权限管理，无论是业务系统（例如，淘宝网）、中间件系统（例如，消息队列 Kafka），还是平台系统（例如，运维平台），都需要进行管理。如果每个系统都自己来实现权限管理，效率太低，重复工作很多，因此需要统一的管理平台来管理所有的系统的权限。&lt;/p>
&lt;p>权限管理主要分为两部分：身份认证、权限控制，其基本架构如下图所示。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_20.png" alt="architecture-action_20.png">&lt;/p>
&lt;h4 id="身份认证">身份认证&lt;/h4>
&lt;p>确定当前的操作人员身份，防止非法人员进入系统。例如，不允许匿名用户进入系统。为了避免每个系统都自己来管理用户，通常情况下都会使用企业账号来做统一认证和登录。&lt;/p>
&lt;h4 id="权限控制">权限控制&lt;/h4>
&lt;p>根据操作人员的身份确定操作权限，防止未经授权的人员进行操作。例如，不允许研发人员进入财务系统查看别人的工资。&lt;/p>
&lt;h2 id="架构重构01-有的放矢">架构重构01：有的放矢&lt;/h2>
&lt;p>相比全新的架构设计来说，架构重构对架构师的要求更高，主要体现在：&lt;/p>
&lt;p>1）业务已经上线，不能停下来架构重构时，业务已经上线运行了，重构既需要尽量保证业务继续往前发展，又要完成架构调整，这就好比“给飞行中的波音 747 换引擎”；而如果是新设计架构，业务还没有上线，则即使做砸了对业务也不会有太大影响。&lt;/p>
&lt;p>2）关联方众多，牵一发动全身架构重构涉及的业务关联方很多，不同关联方的资源投入程度、业务发展速度、对架构痛点的敏感度等有很大差异，如何尽量减少对关联方的影响，或者协调关联方统一行动，是一项很大的挑战；而如果是新设计架构，则在新架构上线前，对关联方没有影响。&lt;/p>
&lt;p>3）旧架构的约束&lt;/p>
&lt;p>架构重构需要在旧的架构基础上进行，这是一个很强的约束，会限制架构师的技术选择范围；而如果是新设计架构，则架构师的技术选择余地大得多。&lt;/p>
&lt;p>即使是决定推倒到重来，完全抛弃旧的架构而去设计新的架构，新架构也会受到旧架构的约束和影响，因为业务在旧架构上产生的数据是不能推倒重来的，新架构必须考虑如何将旧架构产生的数据转换过来。&lt;/p>
&lt;p>因此，架构重构对架构师的综合能力要求非常高，业务上要求架构师能够说服产品经理暂缓甚至暂停业务来进行架构重构；团队上需要架构师能够与其他团队达成一致的架构重构计划和步骤；技术上需要架构师给出让技术团队认可的架构重构方案。&lt;/p>
&lt;p>总之，架构重构需要架构师既要说得动老板，也要镇得住同事；既要技术攻关，又要协调资源；既要保证业务正常发展，又要在指定时间内完成目标……总之就是十八般武艺要样样精通。&lt;/p>
&lt;p>说了那么多架构重构的难度，千万不要被困难所吓倒，架构师正是需要在原来一团乱麻中找到线索，然后重新穿针引线，帮助业务进一步腾飞发展。接下来架构重构第一招：有的放矢。&lt;/p>
&lt;p>通常情况下，当系统架构不满足业务的发展时，其表现形式是系统不断出现各种问题，轻微一点的如系统响应慢、数据错误、某些用户访问失败等，严重的可能是宕机、数据库瘫痪、数据丢失等，或者系统的开发效率很低。开始的时候，技术团队可能只针对具体的问题去解决，解决一个算一个，但如果持续时间较长，例如持续了半年甚至一年情况都不见好转，此时可能有人想到了系统的架构是否存在问题，讨论是否是因为架构原因导致了各种问题。一旦确定需要进行架构重构，就会由架构师牵头来进行架构重构的分析。&lt;/p>
&lt;p>当架构师真正开始进行架构重构分析时，就会发现自己好像进了一个迷雾森林，到处都是问题，每个问题都需要解决，不知道出路在哪里，感觉如果要解决所有这些问题，架构重构其实也无能为力。有的架构师一上来搜集了系统当前存在的问题，然后汇总成一个 100 行的 Excel 表格，看到这样一个表格就懵了：这么多问题，要到猴年马月才能全部解决完啊？&lt;/p>
&lt;p>期望通过架构重构来解决所有问题当然是不现实的，所以架构师的首要任务是&lt;strong>从一大堆纷繁复杂的问题中识别出真正要通过架构重构来解决的问题，集中力量快速解决，而不是想着通过架构重构来解决所有的问题&lt;/strong>。否则就会陷入人少事多头绪乱的处境，团队累死累活弄个大半年，最后发现好像什么都做了，但每个问题都依然存在。尤其是对于刚接手一个新系统的架构师或者技术主管来说，一定要控制住“新官上任三把火”的冲动，避免摊大饼式或者运动式的重构和优化。&lt;/p>
&lt;p>下面看几个重构案例&lt;/p>
&lt;h3 id="后台系统-不合理的耦合">后台系统：不合理的耦合&lt;/h3>
&lt;p>M 系统是一个后台管理系统，负责管理所有游戏相关的数据，重构的主要原因是因为系统耦合了 P 业务独有的数据和所有业务公用的数据，导致可扩展性比较差。其大概架构如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_21.png" alt="architecture-action_21.png">&lt;/p>
&lt;p>举一个简单的例子：数据库中的某张表，一部分字段是所有业务公用的“游戏数据”，一部分字段是 P 业务系统“独有的数据”，开发时如果要改这张表，代码和逻辑都很复杂，改起来效率很低。&lt;/p>
&lt;p>针对 M 系统存在的问题，重构目标就是将游戏数据和业务数据拆分，解开两者的耦合，使得两个系统都能够独立快速发展。重构的方案如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_22.png" alt="architecture-action_22.png">&lt;/p>
&lt;p>重构后的效果非常明显，重构后的 M 系统和 P 业务后台系统每月上线版本数是重构前的 4 倍！&lt;/p>
&lt;h3 id="游戏接入系统-全局单点的可用性">游戏接入系统：全局单点的可用性&lt;/h3>
&lt;p>S 系统是游戏接入的核心系统，一旦 S 系统故障，大量游戏玩家就不能登录游戏。而 S 系统并不具备多中心的能力，一旦主机房宕机，整个 S 系统业务就不可用了。其大概架构如下图所示，可以看出数据库主库是全局单点，一旦数据库主库不可用，两个集群的写业务都不可用了。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_23.png" alt="architecture-action_23.png">&lt;/p>
&lt;p>针对 S 系统存在的问题，重构目标就是实现双中心，使得任意一个机房都能够提供完整的服务，在某个机房故障时，另外一个机房能够全部接管所有业务。重构方案如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_24.png" alt="architecture-action_24.png">&lt;/p>
&lt;p>重构后系统的可用性从 3 个 9 提升到 4 个 9，重构前最夸张的一个月有 4 次较大的线上故障，重构后虽然也经历了机房交换机宕机、运营商线路故障、机柜断电等问题，但对业务都没有什么大的影响。&lt;/p>
&lt;h3 id="大系统带来的开发效率">大系统带来的开发效率&lt;/h3>
&lt;p>X 系统是创新业务的主系统，之前在业务快速尝试和快速发展期间，怎么方便怎么操作，怎么快速怎么做，系统设计并未投入太多精力和时间，很多东西都“塞”到同一个系统中，导致到了现在已经改不动了。做一个新功能或者新业务，需要花费大量的时间来讨论和梳理各种业务逻辑，一不小心就踩个大坑。X 系统的架构如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_25.png" alt="architecture-action_25.png">&lt;/p>
&lt;p>X 系统的问题看起来和 M 系统比较类似，都是可扩展性存在问题，但其实根本原因不一样：M 系统是因为耦合了不同业务的数据导致系统可扩展性不足，而 X 系统是因为将业务相关的所有功能都放在同一个系统中，导致系统可扩展性不足；同时，所有功能都在一个系统中，也可能导致一个功能出问题，整站不可用。比如说某个功能把数据库拖慢了，整站所有业务跟着都慢了。针对 X 系统存在的问题，重构目标是将各个功能拆分到不同的子系统中，降低单个系统的复杂度。重构后的架构如下图所示（仅仅是示例，实际架构远比下图复杂）：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_26.png" alt="architecture-action_26.png">&lt;/p>
&lt;p>重构后各个系统之间通过接口交互，虽然看似增加了接口的工作量，但整体来说，各系统的发展和开发速度比原来快了很多，系统也相对更加简单，也不会出现某个子系统有问题，所有业务都有问题。&lt;/p>
&lt;p>这三个系统重构的方案，现在回过头来看，感觉是理所当然的，但实际上当时做分析和决策时，远远没有这么简单。以 M 系统为例，当时我们接手后遇到的问题有很多，例如：&lt;/p>
&lt;p>1）数据经常出错。M 系统是单机，单机宕机后所有后台操作就不能进行了。&lt;/p>
&lt;p>2）性能比较差，有的操作耗时好久。&lt;/p>
&lt;p>3）界面比较丑，操作不人性化。&lt;/p>
&lt;p>4）历史上经过几手转接，代码比较混乱。&lt;/p>
&lt;p>5）业务数据和游戏数据耦合，开发效率很低。&lt;/p>
&lt;p>从这么多问题中识别出重构的目标，并不是一目了然的；而如果想一下全部解决所有这些问题，人力和时间又不够！所以架构师需要透过问题表象看到问题本质，找出真正需要通过架构重构解决的核心问题，从而做到有的放矢，既不会耗费大量的人力和时间投入，又能够解决核心问题。这对架构师的分析和判断能力要求非常高，既不能看到问题就想到要架构重构，也不能只是针对问题进行系统优化，判断到底是采取架构重构还是采取系统优化，可能不同的架构师和团队都有不同的看法。这里分享一个简单的做法：假设我们现在需要从 0 开始设计当前系统，新架构和老架构是否类似？如果差异不大，说明采取系统优化即可；如果差异很大，那可能就要进行系统重构了。&lt;/p>
&lt;p>那原来发现的那些非架构重构问题怎么办呢？当然不能放任不管。以 M 系统为例，我们在重构完成后，又启动了多个优化的项目去优化这些问题，但此时的优化主要由团队内部完成即可，和其他团队没有太多关联，优化的速度是很快的。如果没有重构就进行优化，则每次优化都要拉一大堆关联业务的团队来讨论方案，效率非常低下！&lt;/p>
&lt;h2 id="架构重构02-合纵连横">架构重构02：合纵连横&lt;/h2>
&lt;h3 id="合纵">合纵&lt;/h3>
&lt;p>架构重构是大动作，持续时间比较长，而且会占用一定的研发资源，包括开发和测试，因此不可避免地会影响业务功能的开发。因此，要想真正推动一个架构重构项目启动，需要花费大量的精力进行游说和沟通。注意这里不是指办公室政治，而是指要和利益相关方沟通好，让大家对于重构能够达成一致共识，避免重构过程中不必要的反复和争执。&lt;/p>
&lt;p>一般的技术人员谈到架构重构时，就会搬出一大堆技术术语：可扩展性、可用性、性能、耦合、代码很乱……但从过往的实际经验来看，如果和非技术人员这样沟通，效果如同鸡同鸭讲，没有技术背景的人员很难理解，甚至有可能担心是在忽悠人。&lt;/p>
&lt;p>在沟通协调时，将技术语言转换为通俗语言，以事实说话，以数据说话，是沟通的关键！&lt;/p>
&lt;h3 id="连横">连横&lt;/h3>
&lt;p>除了上面讨论的和上下游沟通协调，有的重构还需要和其他相关或者配合的系统的沟通协调。由于大家都是做技术的，有比较多的共同语言，所以这部分的沟通协调其实相对来说要容易一些，但也不是说想推动就能推动的，主要的阻力来自“这对我有什么好处”和“这部分我这边现在不急”。&lt;/p>
&lt;p>对于“这对我有什么好处”问题，有的人会简单理解为这是自私的表现，认为对方不顾大局，于是沟通的时候将问题人为拔高。例如“你应该站在部门的角度来考虑这个问题”“这对公司整体利益有帮助”等。这种沟通效果其实很差，首先是这种拔高一般都比较虚，无法明确，不同的人理解也不一样，无法达成共识；其次是如果对公司和部门有利，但对某个小组没用甚至不利，那么可能是因为目前的方案不够好，还可以考虑另外的方案。&lt;/p>
&lt;p>那如何才能有效地推动呢？有效的策略是“&lt;strong>换位思考、合作双赢、关注长期&lt;/strong>”。简单来说就是站在对方的角度思考，重构对他有什么好处，能够帮他解决什么问题，带来什么收益。&lt;/p>
&lt;p>以上一章的 M 系统为例，当时有另外一个 C 系统和 M 系统通过数据库直连共用数据库，我们的重构方案是要去掉两个系统同时在底层操作数据库，改为 C 系统通过调用 M 系统接口来写入数据库。这个方案对 C 系统来说，很明显的一点就是 C 系统短期的改动比较大，要将十几个功能都从直接读写数据库改为跨系统接口调用。刚开始 C 系统也是觉得重构对他们没有什么作用，后来我们经过分析和沟通，了解到 C 系统其实也深受目前这种架构之苦，主要体现在“数据经常出错要排查”（因为 C 系统和 M 系统都在写同一个数据库，逻辑很难保证完全一致）、“要跟着 M 系统同步开发”（因为 M 系统增加表或者字段，C 系统要从数据库自己读取出来，还要理解逻辑）、“C 系统要连两个数据库，出问题不好查”（因为 C 系统自己还有数据库）……这些问题其实在 M 系统重构后都可以解决，虽然短期内 C 系统有一定的开发工作量，但从中长期来看，C 系统肯定可以省很多事情。例如，数据问题排查主要是 M 系统的事情了，通过 M 系统的接口获取数据，无须关注数据相关的业务逻辑等。通过这种方式沟通协调，C 系统很乐意跟我们一起做重构，而且事实也证明重构后对 C 系统和 M 系统都有很大好处。&lt;/p>
&lt;p>当然如果真的出现了对公司或者部门有利，对某个小组不利的情况，那可能需要协调更高层级的管理者才能够推动，平级推动是比较难的。&lt;/p>
&lt;p>对于“这部分我们现在不急”问题，有的人可能会认为这是在找借口，也不排除这种可能性。但就算真的是找借口，那也是因为大家没有达成一致意见，可能对方不好意思直接拒绝。所以这种情况就可以参考上面“这对我有什么好处”问题的处理方法来处理。&lt;/p>
&lt;p>如果对方真的是因为有其他更重要的业务，此时勉为其难也不好，还是那句话：换位思考！因为大部分重构的系统并不是到了火烧眉毛非常紧急的时候才开始启动的，而是有一定前瞻性的规划，如果对方真的有其他更加重要的事情，采取等待的策略也未尝不可，但要明确正式启动的时间。例如，3 个月后开始、6 月份开始，千万不能说“以后”“等不忙的时候”这种无法明确的时间点。&lt;/p>
&lt;p>除了计划上灵活一点，方案上也可以灵活一点：我们可以先不做这个系统相关的重构，先把其他需要重构的做完。因为大部分需要重构的系统，需要做的事情很多，分阶段处理，在风险规避、计划安排等方面更加灵活可控。&lt;/p>
&lt;h2 id="架构重构03-运筹帷幄">架构重构03：运筹帷幄&lt;/h2>
&lt;p>通常情况下，需要架构重构的系统，基本上都是因为各种历史原因和历史问题没有及时处理，遗留下来逐渐积累，然后到了一个临界点，各种问题开始互相作用，集中爆发！到了真正要开始重构的时候，架构师识别出系统关键的复杂度问题后，如果只针对这个复杂度问题进行架构重构，可能会发现还是无法落地，因为很多条件不具备或者有的问题没解决的情况下就是不能做架构重构。因此，架构师在识别系统关键的复杂度问题后，还需要识别为了解决这个问题，需要做哪些准备事项，或者还要先解决哪些问题。这就需要架构重构第三招：运筹帷幄。&lt;/p>
&lt;p>经过分析和思考，可能从最初的 100 个问题列表，挑选出其中 50 个是需要在架构重构中解决的，其中一些是基础能力建设或者准备工作，而另外一些就是架构重构的核心工作。有了这样一个表格后，那我们应该怎么去把这 50 个问题最终解决呢？&lt;/p>
&lt;p>最简单的做法是每次从中挑一个解决，最终总会把所有的问题都解决。这种做法操作起来比较简单，但效果会很差，为什么呢？&lt;/p>
&lt;p>第一个原因是&lt;strong>没有区分问题的优先级&lt;/strong>，所有问题都一视同仁，没有集中有限资源去解决最重要或者最关键的问题，导致最后做了大半年，回头一看好像做了很多事情，但没取得什么阶段性的成果。&lt;/p>
&lt;p>第二个原因是&lt;strong>没有将问题分类&lt;/strong>，导致相似问题没有统筹考虑，方案可能出现反复，效率不高。&lt;/p>
&lt;p>第三个原因是会&lt;strong>迫于业务版本的压力，专门挑容易做的实施&lt;/strong>，到了稍微难一点的问题的时候，就因为复杂度和投入等原因被搁置，达不到重构的真正目的。&lt;/p>
&lt;p>以 X 系统为例，之前其实也整理了系统目前存在的问题，大的项包括可用性、性能、安全、用户体验等，每个大项又包括十几二十个子项。但是实施时基本上就是挑软柿子捏，觉得哪个好落地、占用资源不太多，就挑来做，结果做了半年，好像做了很多功能，但整体却没什么进展。&lt;/p>
&lt;p>成立了一个“X 项目”后，在原来整理的问题基础上，识别出架构的核心复杂度体现在庞大的系统集成了太多功能，可扩展性不足；但目前系统的可用性也不高，经常出线上问题，耗费大量的人力去处理。因此又识别出如果要做架构重构，就需要系统处于一个比较稳定的状态，不要经常出线上问题。而目前系统的可用性性不高，有的是因为硬件资源不够用了，或者某些系统组件使用不合理，有的是因为架构上存在问题。&lt;/p>
&lt;p>基于这些分析，制定了总体的策略，如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_27.png" alt="architecture-action_27.png">&lt;/p>
&lt;p>可以看到，真正的架构重构在第三阶段，第一阶段和第二阶段都是为了第三阶段做准备而已，但如果没有第一阶段和第二阶段的铺垫，直接开始第三阶段的架构重构工作，架构重构方案需要糅合第一阶段和第二阶段的一些事项（例如，业务降级、接入服务中心等），会导致架构重构方案不聚焦，而且异常复杂。&lt;/p>
&lt;p>为什么最终采用这样一个策略呢？主要还是为了集中有限的资源，某个阶段集中解决某一类问题。这样做首先是效率高，因为阶段目标比较明确，做决策和方案的时候无须进行太多选择；其次是每个阶段都能看到明显的成果，给团队很大的信心。比如说第一阶段的“救火”，做完之后，系统很少有因为机器过载、缓存响应慢、虚拟机挂死等问题导致的故障了；完成第二阶段的事项后，因为组件、外部系统故障导致系统故障的问题也很少了。完成前两个阶段后，我们就可以安心地做第三阶段的“服务化”工作了。&lt;/p>
&lt;p>S 系统的重构做法也是类似，但 S 系统当时面临的主要问题就是可用性不高，并没有系统耦合的问题，所以我们当时的策略是“先救火、后优化、再重构”。“救火”阶段做了扩容（防止资源不足导致系统被压死）和 Nginx 一键切换功能（故障时快速切换）；优化阶段将一些明显的可用性问题解决（包括性能问题等）；重构阶段将原来的单点数据库改为多中心。&lt;/p>
&lt;p>总结一下重构的做法，其实就是“分段实施”，&lt;strong>将要解决的问题根据优先级、重要性、实施难度等划分为不同的阶段，每个阶段聚焦于一个整体的目标，集中精力和资源解决一类问题&lt;/strong>。这样做有几个好处：&lt;/p>
&lt;p>1）每个阶段都有明确目标，做完之后效果明显，团队信心足，后续推进更加容易。&lt;/p>
&lt;p>2）每个阶段的工作量不会太大，可以和业务并行。&lt;/p>
&lt;p>3）每个阶段的改动不会太大，降低了总体风险。&lt;/p>
&lt;p>具体如何制定“分段实施”的策略呢？&lt;/p>
&lt;p>1）优先级排序&lt;/p>
&lt;p>将明显且又比较紧急的事项优先落地，解决目前遇到的主要问题。例如，扩容在 S 系统和 X 系统中都是最优先实施的，因为如果不扩容，系统隔三差五一会出现响应超时报警，一会来个过载报警，一会来个大面积不可用……这些问题耗费大量的人力和精力，也就没法做其他事情了。&lt;/p>
&lt;p>2）问题分类将问题按照性质分类，每个阶段集中解决一类问题。例如，X 系统的第二阶段，我们将多个底层系统切换到公司统一的公共组件，提升整体可用性。&lt;/p>
&lt;p>3）先易后难&lt;/p>
&lt;p>这点与很多人的直觉不太一样，有的人认为应该先攻克最难的问题，所谓“擒贼先擒王”，解决最难的问题后其他问题就不在话下。这样看起来很美好，但实际上不可行。&lt;/p>
&lt;p>首先，一开始就做最难的部分，会发现想要解决这个最难的问题，要先解决其他容易的问题。&lt;/p>
&lt;p>其次，最难的问题解决起来耗时都比较长，占用资源比较多，如果一开始做最难的，可能做了一两个月还没有什么进展和成果，会影响相关人员对项目的评价和看法，也可能影响团队士气。&lt;/p>
&lt;p>第三，刚开始的分析并不一定全面，所以一开始对最难的或者最关键的事项的判断可能会出错。&lt;/p>
&lt;p>采取“先易后难”的策略，能够很大程度上避免“先难后易”策略的问题。&lt;/p>
&lt;p>首先，随着项目的推进，一些相对简单的问题逐渐解决，会发现原来看起来很难的问题已经不那么难了，甚至有的问题可能都消失了。&lt;/p>
&lt;p>其次，先易后难能够比较快地看到成果，虽然成果可能不大，但至少能看到一些成效了，对后续的项目推进和提升团队士气有很大好处。&lt;/p>
&lt;p>第三，随着项目的进行，原来遗漏的一些点，或者分析和判断错误的点，会逐渐显示出来，及时根据实际情况进行调整，能够有效地保证整个重构的效果。&lt;/p>
&lt;p>4）循序渐进&lt;/p>
&lt;p>按照前 3 个步骤划分了架构重构的实施阶段后，就需要评估每个阶段所需要耗费的时间，很可能会出现有的阶段耗时可能只要 1 个月，而有的却需要 6 个月，虽然这可能确实是客观事实，但通常情况下，按照固定的步骤和节奏，更有利于项目推进。我的经验是每个阶段最少 1 个月，最长不要超过 3 个月，如果评估超过 3 个月的，那就再拆分为更多阶段。就像 X 项目，我们先划分了阶段，每个阶段又分了任务子集，当任务子集比较小的时候，多个任务子集可以并行；当任务子集比较大的时候，就当成一个独立的里程碑推进。&lt;/p>
&lt;h2 id="开源项目-选择-使用及二次开发">开源项目：选择、使用及二次开发&lt;/h2>
&lt;p>软件开发领域有一个流行的原则：DRY，Don’t repeat yourself。翻译过来更通俗易懂：不要重复造轮子。开源项目的主要目的是共享，其实就是为了让大家不要重复造轮子，尤其是在互联网这样一个快速发展的领域，速度就是生命，引入开源项目可以节省大量的人力和时间，大大加快业务的发展速度，何乐而不为呢？&lt;/p>
&lt;p>然而现实往往没有那么美好，开源项目虽然节省了大量的人力和时间，但带来的问题也不少，相信绝大部分技术人员都踩过开源软件的坑，小的影响可能是宕机半小时，大的问题可能是丢失几十万条数据，甚至灾难性的事故是全部数据都丢失。&lt;/p>
&lt;p>除此以外，虽然 DRY 原则摆在那里，但实际上开源项目反而是最不遵守 DRY 原则的，重复的轮子好多，你有 MySQL，我有 PostgreSQL；你有 MongoDB，我有 Cassandra；你有 Memcached，我有 Redis；你有 Gson，我有 Jackson；你有 Angular，我有 React……总之放眼望去，其实相似的轮子很多！相似轮子太多，如何选择就成了让人头疼的问题了。&lt;/p>
&lt;p>完全不用开源项目几乎是不可能的，架构师需要更加聪明地选择和使用开源项目。形象点说：不要重复发明轮子，但要找到合适的轮子！&lt;/p>
&lt;h3 id="选-如何选择一个开源项目">选：如何选择一个开源项目&lt;/h3>
&lt;h4 id="聚焦是否满足业务">聚焦是否满足业务&lt;/h4>
&lt;p>架构师在选择开源项目时，一个头疼的问题就是相似的开源项目较多，而且后面的总是要宣称比前面的更加优秀。有的架构师在选择时有点无所适从，总是会担心选择了 A 项目而错过了 B 项目。这个问题的解决方式是&lt;strong>聚焦于是否满足业务，而不需要过于关注开源项目是否优秀&lt;/strong>。&lt;/p>
&lt;p>Tokyo Tyrant 的教训&lt;/p>
&lt;p>在开发一个社交类业务时，使用了 TT（Tokyo Tyrant）开源项目，觉得既能够做缓存取代 Memcached，又有持久化存储功能，还可以取代 MySQL，觉得很强大，于是就在业务里面大量使用了。但后来的使用过程让人很郁闷，主要表现为：不能完全取代 MySQL，因此有两份存储，设计时每次都要讨论和决策究竟什么数据放 MySQL，什么数据放 TT。功能上看起来很高大上，但相应的 bug 也不少，而且有的 bug 是致命的。例如所有数据不可读，后来是自己研究源码写了一个工具才恢复了部分数据。功能确实强大，但需要花费较长时间熟悉各种细节，不熟悉随便用很容易踩坑。后来反思和总结，其实当时的业务 Memcached + MySQL 完全能够满足，而且大家都熟悉，其实完全不需要引入 TT。&lt;/p>
&lt;p>简单来说：如果业务要求 1000 TPS，那么一个 20000 TPS 和 50000 TPS 的项目是没有区别的。有的架构师可能会担心 TPS 不断上涨怎么办？其实不用过于担心，架构是可以不断演进的，等到真的需要这么高的时候再来架构重构，这里的设计决策遵循架构设计原则中的“合适原则”和”演化原则”。&lt;/p>
&lt;h4 id="聚焦是否成熟">聚焦是否成熟&lt;/h4>
&lt;p>很多新的开源项目往往都会声称自己比以前的项目更加优秀：性能更高、功能更强、引入更多新概念……看起来都很诱人，但实际上都有意无意地隐藏了一个负面的问题：更加不成熟！不管多优秀的程序员写出来的项目都会有 bug，千万不要以为作者历害就没有 bug，Windows、Linux、MySQL 的开发者都是顶级的开发者，系统一样有很多 bug。&lt;/p>
&lt;p>不成熟的开源项目应用到生产环境，风险极大：轻则宕机，重则宕机后重启都恢复不了，更严重的是数据丢失都找不回来。还是以上面提到的 TT 为例：真的遇到异常断电后，文件被损坏，重启也恢复不了的故障。还好当时每天做了备份，于是只能用 1 天前的数据进行恢复，但当天的数据全部丢失了。花费了大量的时间和人力去看源码，自己写工具恢复了部分数据，好在这些数据不是金融相关的数据，丢失一部分问题也不大，否则就有大麻烦了。所以在选择开源项目时，尽量选择成熟的开源项目，降低风险。&lt;/p>
&lt;p>可以从这几个方面考察开源项目是否成熟：&lt;/p>
&lt;p>1）版本号：除非特殊情况，否则不要选 0.X 版本的，至少选 1.X 版本的，版本号越高越好。&lt;/p>
&lt;p>2）使用的公司数量：一般开源项目都会把采用了自己项目的公司列在主页上，公司越大越好，数量越多越好。&lt;/p>
&lt;p>3）社区活跃度：看看社区是否活跃，发帖数、回复数、问题处理速度等。&lt;/p>
&lt;h4 id="聚焦运维能力">聚焦运维能力&lt;/h4>
&lt;p>大部分架构师在选择开源项目时，基本上都是聚焦于技术指标，例如性能、可用性、功能这些评估点，而几乎不会去关注运维方面的能力。但如果要将项目应用到线上生产环境，则&lt;strong>运维能力是必不可少的一环&lt;/strong>，否则一旦出问题，运维、研发、测试都只能干瞪眼。&lt;/p>
&lt;p>可以从这几个方面去考察运维能力：&lt;/p>
&lt;p>1）开源项目日志是否齐全：有的开源项目日志只有寥寥启动停止几行，出了问题根本无法排查。&lt;/p>
&lt;p>2）开源项目是否有命令行、管理控制台等维护工具，能够看到系统运行时的情况。&lt;/p>
&lt;p>3）开源项目是否有故障检测和恢复的能力，例如告警、切换等。&lt;/p>
&lt;p>如果是开源库，例如 Netty 这种网络库，本身是不具备运维能力的，那么就需要在使用库的时候将一些关键信息通过日志记录下来，例如在 Netty 的 Handler 里面打印一些关键日志。&lt;/p>
&lt;h3 id="用-如何使用开源项目">用：如何使用开源项目&lt;/h3>
&lt;h4 id="深入研究-仔细测试">深入研究，仔细测试&lt;/h4>
&lt;p>很多人用开源项目，其实是完完全全的“拿来主义”，看了几个 Demo，把程序跑起来就开始部署到线上应用了。这就好像看了一下开车指南，知道了方向盘是转向、油门是加速、刹车是减速，然后就开车上路了，其实是非常危险的。&lt;/p>
&lt;p>Elasticsearch 的案例：有团队使用了 Elasticsearch，基本上是拿来就用，倒排索引是什么都不太清楚，配置都是用默认值，跑起来就上线了，结果就遇到节点 ping 时间太长，剔除异常节点太慢，导致整站访问挂掉。&lt;/p>
&lt;p>MySQL 的案例：很多团队最初使用 MySQL 时，也没有怎么研究过，经常有业务部门抱怨 MySQL 太慢了。但经过定位，发现最关键的几个参数（例如，innodb_buffer_pool_size、sync_binlog、innodb_log_file_size 等）都没有配置或者配置错误，性能当然会慢。&lt;/p>
&lt;p>可以从这几方面进行研究和测试：&lt;/p>
&lt;p>1）通读开源项目的设计文档或者白皮书，了解其设计原理。&lt;/p>
&lt;p>2）核对每个配置项的作用和影响，识别出关键配置项。&lt;/p>
&lt;p>3）进行多种场景的性能测试。&lt;/p>
&lt;p>4）进行压力测试，连续跑几天，观察 CPU、内存、磁盘 I/O 等指标波动。&lt;/p>
&lt;p>5）进行故障测试：kill、断电、拔网线、重启 100 次以上、切换等。&lt;/p>
&lt;h4 id="小心应用-灰度发布">小心应用，灰度发布&lt;/h4>
&lt;p>假如做了上面的“深入研究、仔细测试”，发现没什么问题，是否就可以放心大胆地应用到线上了呢？别高兴太早，即使研究再深入，测试再仔细，还是要小心为妙，因为再怎么深入地研究，再怎么仔细地测试，都只能降低风险，但不可能完全覆盖所有线上场景。&lt;/p>
&lt;h4 id="做好应急-以防万一">做好应急，以防万一&lt;/h4>
&lt;p>即使前面的工作做得非常完善和充分，也不能认为万事大吉，尤其是刚开始使用一个开源项目，运气不好可能遇到一个之前全世界的使用者从来没遇到的 bug，导致业务都无法恢复，尤其是存储方面，一旦出现问题无法恢复，可能就是致命的打击。&lt;/p>
&lt;p>MongoDB 丢失数据&lt;/p>
&lt;p>某个业务使用了 MongoDB，结果宕机后部分数据丢失，无法恢复，也没有其他备份，人工恢复都没办法，只能接一个用户投诉处理一个，导致 DBA 和运维从此以后都反对用 MongoDB，即使是尝试性的。虽然因为一次故障就完全反对尝试是有点反应过度了，但确实故障也提了一个醒：对于重要的业务或者数据，使用开源项目时，最好有另外一个比较成熟的方案做备份，尤其是数据存储。例如，如果要用 MongoDB 或者 Redis，可以用 MySQL 做备份存储。这样做虽然复杂度和成本高一些，但关键时刻能够救命！&lt;/p>
&lt;h3 id="改-基于开源项目二次开发">改：基于开源项目二次开发&lt;/h3>
&lt;h4 id="保持纯洁-加以包装">保持纯洁，加以包装&lt;/h4>
&lt;p>当发现开源项目有的地方不满足需求时，自然会有一种去改改的冲动，但是怎么改是个大学问。一种方式是投入几个人从内到外全部改一遍，将其改造成完全符合业务需求。但这样做有几个比较严重的问题：&lt;/p>
&lt;p>1）投入太大，一般来说，Redis 这种级别的开源项目，真要自己改，至少要投入 2 个人，搞 1 个月以上。&lt;/p>
&lt;p>2）失去了跟随原项目演进的能力：改的太多，即使原有开源项目继续演进，也无法合并了，因为差异太大。&lt;/p>
&lt;p>所以建议是不要改动原系统，而是要开发辅助系统：监控、报警、负载均衡、管理等。以 Redis 为例，如果想增加集群功能，则不要去改动 Redis 本身的实现，而是增加一个 proxy 层来实现。Twitter 的 Twemproxy 就是这样做的，而 Redis 到了 3.0 后本身提供了集群功能，原有的方案简单切换到 Redis 3.0 即可（详细可参考&lt;a href="https://www.cnblogs.com/gomysql/p/4413922.html">这里&lt;/a>）。&lt;/p>
&lt;p>如果实在想改到原有系统，建议是直接给开源项目提需求或者 bug，但弊端就是响应比较缓慢，这个就要看业务紧急程度了，如果实在太急那就只能自己改了；如果不是太急，建议做好备份或者应急手段即可。&lt;/p>
&lt;h4 id="发明你要的轮子">发明你要的轮子&lt;/h4>
&lt;p>这一点估计让你大跌眼镜，怎么讲了半天，最后又回到了“重复发明你要的轮子”呢？其实选与不选开源项目，核心还是一个成本和收益的问题，并不是说选择开源项目就一定是最优的项目，最主要的问题是：&lt;strong>没有完全适合你的轮子！&lt;/strong>&lt;/p>
&lt;p>软件领域和硬件领域最大的不同就是软件领域没有绝对的工业标准，大家想怎么玩就怎么玩。不像硬件领域，造一个尺寸与众不同的轮子，其他车都用不上，轮子工艺再高，质量再好也是白费；软件领域可以造很多相似的轮子，基本上能到处用。例如，把缓存从 Memcached 换成 Redis，不会有太大的问题。&lt;/p>
&lt;p>除此以外，开源项目为了能够大规模应用，考虑的是通用的处理方案，而不同的业务其实差异较大，通用方案并不一定完美适合具体的某个业务。比如说 Memcached，通过一致性 Hash 提供集群功能，但是我们的一些业务，缓存如果有一台宕机，整个业务可能就被拖慢了，这就要求我们提供缓存备份的功能。但 Memcached 又没有，而 Redis 当时又没有集群功能，于是投入 2~4 个人花了大约 2 个月时间基于 LevelDB 的原理，自己做了一套缓存框架支持存储、备份、集群的功能，后来又在这个框架的基础上增加了跨机房同步的功能，很大程度上提升了业务的可用性水平。如果完全采用开源项目，等开源项目来实现，是不可能这么快速的，甚至开源项目完全就不支持需求。&lt;/p>
&lt;p>如果有钱有人有时间，投入人力去重复发明完美符合自己业务特点的轮子也是很好的选择！毕竟，很多财大气粗的公司（BAT 等）都是这样做的，否则也就没有那么多好用的开源项目了。&lt;/p>
&lt;h2 id="app-架构的演进">App 架构的演进&lt;/h2>
&lt;p>首先，复习一下之前所讲述的架构设计理念，可以提炼为下面几个关键点：&lt;/p>
&lt;p>1）架构是系统的顶层结构。&lt;/p>
&lt;p>2）架构设计的主要目的是为了解决软件系统复杂度带来的问题。&lt;/p>
&lt;p>3）架构设计需要遵循三个主要原则：合适原则、简单原则、演化原则。&lt;/p>
&lt;p>4）架构设计首先要掌握业界已经成熟的各种架构模式，然后再进行优化、调整、创新。&lt;/p>
&lt;h3 id="web-app">Web App&lt;/h3>
&lt;p>最早的 App 有很多采用这种架构，大多数尝试性的业务，一开始也是这样的架构。Web App 架构又叫包壳架构，简单来说就是在 Web 的业务上包装一个 App 的壳，业务逻辑完全还是 Web 实现，App 壳完成安装的功能，让用户看起来像是在使用 App，实际上和用浏览器访问 PC 网站没有太大差别。&lt;/p>
&lt;p>为何早期的 App 或者尝试新的业务采用这种架构比较多呢？简单来说，就是当时业务面临的复杂度决定的。以早期的 App 为例，大约在 2010 年前后，移动互联网虽然发展很迅速，但受限于用户的设备、移动网络的速度等约束，PC 互联网还是主流，移动互联网还是一个新鲜事物，未来的发展前景和发展趋势，其实当年大家也不一定能完全看得清楚。例如淘宝也是在 2013 年才开始决定“All in 无线”的，在这样的业务背景下，当时的业务重心还是在 PC 互联网上，移动互联网更多是尝试性的。既然是尝试，那就要求快速和低成本，虽然当时的 Android 和 iOS 已经都有了开发 App 的功能，但原生的开发成本太高，因此自然而然，Web App 这种包壳架构就被大家作为首选尝试架构了，其主要解决“快速开发”和“低成本”两个复杂度问题，架构设计遵循“合适原则”和“简单原则”。&lt;/p>
&lt;h3 id="原生-app">原生 App&lt;/h3>
&lt;p>Web App 虽然解决了“快速开发”和“低成本”两个复杂度问题，但随着业务的发展，Web App 的劣势逐渐成为了主要的复杂度问题，主要体现在：&lt;/p>
&lt;p>1）移动设备的发展速度远远超过 Web 技术的发展速度，因此 Web App 的体验相比原生 App 的体验，差距越来越明显。&lt;/p>
&lt;p>2）移动互联网飞速发展，趋势越来越明显，App 承载的业务逻辑也越来越复杂，进一步加剧了 Web App 的体验问题。&lt;/p>
&lt;p>3）移动设备在用户体验方面有很多优化和改进，而 Web App 无法利用这些技术优势，只有原生 App 才能够利用这些技术优势。&lt;/p>
&lt;p>因此，随着业务发展和技术演进，移动开发的复杂度从“快速开发”和“低成本”转向了“用户体验”，而要保证用户体验，采用原生 App 的架构是最合适的，这里的架构设计遵循“演化原则”。&lt;/p>
&lt;p>原生 App 解决了用户体验问题，大约在 2013 年前后开始快速发展，那个时候的 Android 工程师和 iOS 工程师就像现在的人工智能工程师一样非常抢手，很多同学也是那时候从后端转行到 App 开发的。&lt;/p>
&lt;h3 id="hybrid-app">Hybrid App&lt;/h3>
&lt;p>原生 App 很好的解决了用户体验问题，但业务和技术也在发展，移动互联网此时已经成为明确的大趋势，团队需要考虑的不是要不要转移动互联网的问题，而是要考虑如何在移动互联网更具竞争力的问题，因此各种基于移动互联网特点的功能和体验方式不断被创造出来，大家拼的竞争方式就是看谁更快抓住用户需求和痛点。因此，移动开发的复杂度又回到了“快速开发”，这时就发现了原生 App 开发的痛点：由于 Android、iOS、Windows Phone（当年确实是这三个主流平台）的原生开发完全不能兼容，同样的功能需要三个平台重复开发，每个平台还有一些差异，因此自然快不起来。&lt;/p>
&lt;p>为了解决“快速开发”的复杂度问题，大家自然又想到了 Web 的方式，但 Web 的体验还是远远不如原生，怎么解决这个问题呢？其实没有办法完美解决，但可以根据不同的业务要求选取不同的方案，例如对体验要求高的业务采用原生 App 实现，对体验要求不高的可以采用 Web 的方式实现，这就是 Hybrid App 架构的核心设计思想，主要遵循架构设计的“合适原则”。&lt;/p>
&lt;h3 id="组件化-容器化">组件化 &amp;amp; 容器化&lt;/h3>
&lt;p>Hybrid App 能够较好的平衡“用户体验”和“快速开发”两个复杂度问题（注意是“平衡”，不是“同时解决”），但对于一些超级 App 来说，随着业务规模越来越大、业务越来越复杂，虽然在用户看来可能是一个 App，但事实上承载了几十上百个业务。以手机淘宝为例，阿里确认“All in 无线”战略后，手机淘宝定位为阿里集团移动端的“航空母舰”，上面承载了非常多的子业务，淘宝的首页第一屏，相关的子业务初步估计就有 10 个以上。&lt;/p>
&lt;p>再以微信为例，作为腾讯在移动互联网的“航空母舰”，其业务也是非常的多，“发现”tab 页就有 7 个子业务。&lt;/p>
&lt;p>这么多业务集中在一个 App 上，每个业务又在不断地扩展，后续又可能会扩展新的业务，并且每个业务就是一个独立的团队负责开发，因此整个 App 的可扩展性引入了新的复杂度问题。&lt;/p>
&lt;p>前面提到可扩展的基本思想就是“拆”，但是这个思想应用到 App 和后端系统时，具体的做法就明显不同了。简单来说，App 和后端系统存在一个本质的区别，App 是面向用户的，后端系统是不面向用户的，因此 App 再怎么拆，对用户还是只能呈现同一个 App，不可能将一个 App 拆分为几十个独立 App；而后端系统就不一样了，采用微服务架构后，后端系统可以拆分为几百上千个子服务都没有问题。同时，App 的业务再怎么拆分，技术栈是一样的，不然没法集成在一个 App 里面；而后端就不同了，不同的微服务可以用不同的技术栈开发。&lt;/p>
&lt;p>在这种业务背景下，组件化和容器化架构应运而生，其基本思想都是将超级 App 拆分为众多组件，这些组件遵循预先制定好的规范，独立开发、独立测试、独立上线。如果某个组件依赖其他组件，组件之间通过消息系统进行通信，通过这种方式来实现组件隔离，从而避免各个团队之间的互相依赖和影响，以提升团队开发效率和整个系统的可扩展性。组件化和容器化的架构出现遵循架构设计的“演化原则”，只有当业务复杂度发展到一定规模后才适应，因此我们会看到大厂应用这个架构的比较多，而中小公司的 App，业务没那么复杂，其实并不一定需要采用组件化和容器化架构。&lt;/p>
&lt;p>对于组件化和容器化并没有非常严格的定义，我理解两者在规范、拆分、团队协作方面都是一样的，区别在于发布方式，组件化采用的是静态发布，即所有的组件各自独自开发测试，然后跟随 App 的某个版本统一上线；容器化采用的是动态发布，即容器可以动态加载组件，组件准备好了直接发布，容器会动态更新组件，无需等待某个版本才能上线。&lt;/p>
&lt;p>关于手机淘宝 App 更详细的架构演进可以参考&lt;a href="http://www.infoq.com/cn/articles/shoutao-atlas">《Atlas：手淘 Native 容器化框架和思考》&lt;/a>，微信 App 的架构演进可以参考 &lt;a href="https://www.infoq.cn/article/wechat-android-app-architecture">《微信 Android 客户端架构演进之路》&lt;/a>。&lt;/p>
&lt;h3 id="跨平台-app">跨平台 App&lt;/h3>
&lt;p>前面介绍的各种 App 架构，除了 Web App 外，其他都面临着同一个问题：跨平台需要重复开发。同一个功能和业务，Android 开发一遍，iOS 也要开发一遍，这里其实存在人力投入的问题，违背了架构设计中的“简单原则”。站在企业的角度来讲，当然希望能够减少人力投入成本（虽然我站在程序员的角度来讲是不希望程序员被减少的），因此最近几年各种跨平台方案不断涌现，比较知名的有 Facebook 的 React Native、阿里的 Weex、Google 的 Flutter。虽然也有很多公司在尝试使用，但目前这几个方案都不算很成熟，且在用户体验方面与原生 App 还是有一定差距，例如 Airbnb 就宣布放弃使用 React Native，回归使用原生技术（&lt;a href="https://www.oschina.net/news/97276/airbnb-sunsetting-react-native">https://www.oschina.net/news/97276/airbnb-sunsetting-react-native&lt;/a>）。&lt;/p>
&lt;p>前端的情况也是类似的。&lt;/p>
&lt;h2 id="架构实战-架构设计文档模板">架构实战：架构设计文档模板&lt;/h2>
&lt;h3 id="备选方案模板">备选方案模板&lt;/h3>
&lt;h4 id="需求介绍">需求介绍&lt;/h4>
&lt;p>&lt;strong>[需求介绍主要描述需求的背景、目标、范围等]&lt;/strong>&lt;/p>
&lt;p>随着前浪微博业务的不断发展，业务上拆分的子系统越来越多，目前系统间的调用都是同步调用，由此带来几个明显的系统问题：&lt;/p>
&lt;p>1）性能问题：当用户发布了一条微博后，微博发布子系统需要同步调用“统计子系统”“审核子系统”“奖励子系统”等共 8 个子系统，性能很低。&lt;/p>
&lt;p>2）耦合问题：当新增一个子系统时，例如如果要增加“广告子系统”，那么广告子系统需要开发新的接口给微博发布子系统调用。&lt;/p>
&lt;p>3）效率问题：每个子系统提供的接口参数和实现都有一些细微的差别，导致每次都需要重新设计接口和联调接口，开发团队和测试团队花费了许多重复工作量。&lt;/p>
&lt;p>基于以上背景，需要引入消息队列进行系统解耦，将目前的同步调用改为异步通知。&lt;/p>
&lt;h4 id="需求分析">需求分析&lt;/h4>
&lt;p>&lt;strong>[需求分析主要全方位地描述需求相关的信息]&lt;/strong>&lt;/p>
&lt;p>&lt;strong>5W&lt;/strong>&lt;/p>
&lt;p>[5W 指 Who、When、What、Why、Where]&lt;/p>
&lt;p>Who：需求利益干系人，包括开发者、使用者、购买者、决策者等。&lt;/p>
&lt;p>When：需求使用时间，包括季节、时间、里程碑等。&lt;/p>
&lt;p>What：需求的产出是什么，包括系统、数据、文件、开发库、平台等。&lt;/p>
&lt;p>Where：需求的应用场景，包括国家、地点、环境等，例如测试平台只会在测试环境使用。&lt;/p>
&lt;p>Why：需求需要解决的问题，通常和需求背景相关&lt;/p>
&lt;p>消息队列的 5W 分析如下：&lt;/p>
&lt;p>Who：消息队列系统主要是业务子系统来使用，子系统发送消息或者接收消息。&lt;/p>
&lt;p>When：当子系统需要发送异步通知的时候，需要使用消息队列系统。&lt;/p>
&lt;p>What：需要开发消息队列系统。&lt;/p>
&lt;p>Where：开发环境、测试环境、生产环境都需要部署。&lt;/p>
&lt;p>Why：消息队列系统将子系统解耦，将同步调用改为异步通知。&lt;/p>
&lt;p>1H&lt;/p>
&lt;p>[这里的 How 不是设计方案也不是架构方案，而是关键业务流程。消息队列系统这部分内容很简单，但有的业务系统 1H 就是具体的用例了，有兴趣的同学可以尝试写写 ATM 机取款的业务流程。如果是复杂的业务系统，这部分也可以独立成“用例文档”]&lt;/p>
&lt;p>消息队列有两大核心功能：&lt;/p>
&lt;p>1）业务子系统发送消息给消息队列。&lt;/p>
&lt;p>2）业务子系统从消息队列获取消息。&lt;/p>
&lt;p>8C&lt;/p>
&lt;p>[8C 指的是 8 个约束和限制，即 Constraints，包括性能 Performance、成本 Cost、时间 Time、可靠性 Reliability、安全性 Security、合规性 Compliance、技术性 Technology、兼容性 Compatibility]&lt;/p>
&lt;p>注：需求中涉及的性能、成本、可靠性等仅仅是利益关联方提出的诉求，不一定准确；如果经过分析有的约束没有必要，或成本太高、难度太大，这些约束是可以调整的。&lt;/p>
&lt;p>性能：需要达到 Kafka 的性能水平。&lt;/p>
&lt;p>成本：参考 XX 公司的设计方案，不超过 10 台服务器。&lt;/p>
&lt;p>时间：期望 3 个月内上线第一个版本，在两个业务尝试使用。&lt;/p>
&lt;p>可靠性：按照业务的要求，消息队列系统的可靠性需要达到 99.99%。&lt;/p>
&lt;p>安全性：消息队列系统仅在生产环境内网使用，无需考虑网络安全；如消息中有敏感信息，消息发送方需要自行进行加密，消息队列系统本身不考虑通用的加密。&lt;/p>
&lt;p>合规性：消息队列系统需要按照公司目前的 DevOps 规范进行开发。&lt;/p>
&lt;p>技术性：目前团队主要研发人员是 Java，最好用 Java 开发。&lt;/p>
&lt;p>兼容性：之前没有类似系统，无需考虑兼容性。&lt;/p>
&lt;h4 id="复杂度分析">复杂度分析&lt;/h4>
&lt;p>[分析需求的复杂度，复杂度常见的有高可用、高性能、可扩展等，具体分析方法请参考专栏前面的内容]&lt;/p>
&lt;p>&lt;strong>高可用&lt;/strong>&lt;/p>
&lt;p>对于微博子系统来说，如果消息丢了，导致没有审核，然后触犯了国家法律法规，则是非常严重的事情；对于等级子系统来说，如果用户达到相应等级后，系统没有给他奖品和专属服务，则 VIP 用户会很不满意，导致用户流失从而损失收入，虽然也比较关键，但没有审核子系统丢消息那么严重。&lt;/p>
&lt;p>综合来看，消息队列需要高可用性，包括消息写入、消息存储、消息读取都需要保证高可用性。&lt;/p>
&lt;p>&lt;strong>高性能&lt;/strong>&lt;/p>
&lt;p>前浪微博系统用户每天发送 1000 万条微博，那么微博子系统一天会产生 1000 万条消息，平均一条消息有 10 个子系统读取，那么其他子系统读取的消息大约是 1 亿次。将数据按照秒来计算，一天内平均每秒写入消息数为 115 条，每秒读取的消息数是 1150 条；再考虑系统的读写并不是完全平均的，设计的目标应该以峰值来计算。峰值一般取平均值的 3 倍，那么消息队列系统的 TPS 是 345，QPS 是 3450，考虑一定的性能余量。由于现在的基数较低，为了预留一定的系统容量应对后续业务的发展，将设计目标设定为峰值的 4 倍，因此最终的性能要求是：TPS 为 1380，QPS 为 13800。TPS 为 1380 并不高，但 QPS 为 13800 已经比较高了，因此高性能读取是复杂度之一。&lt;/p>
&lt;p>&lt;strong>可扩展&lt;/strong>&lt;/p>
&lt;p>消息队列的功能很明确，基本无须扩展，因此可扩展性不是这个消息队列的关键复杂度。&lt;/p>
&lt;h4 id="备选方案">备选方案&lt;/h4>
&lt;p>[备选方案设计，至少 3 个备选方案，每个备选方案需要描述关键的实现，无须描述具体的实现细节。此处省略具体方案描述，详细请参考之前的文章]&lt;/p>
&lt;h4 id="备选方案评估">备选方案评估&lt;/h4>
&lt;h3 id="架构设计模板">架构设计模板&lt;/h3>
&lt;p>[备选方案评估后会选择一个方案落地实施，架构设计文档就是用来详细描述细化方案的]&lt;/p>
&lt;h4 id="1-总体方案">1、总体方案&lt;/h4>
&lt;p>[总体方案需要从整体上描述方案的结构，其核心内容就是架构图，以及针对架构图的描述，包括模块或者子系统的职责描述、核心流程]&lt;/p>
&lt;h4 id="2-架构总览">2、架构总览&lt;/h4>
&lt;p>[架构总览给出架构图以及架构的描述]&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-action_28.png" alt="architecture-action_28.png">&lt;/p>
&lt;p>架构关键设计点：&lt;/p>
&lt;p>1）采用数据分散集群的架构，集群中的服务器进行分组，每个分组存储一部分消息数据。&lt;/p>
&lt;p>2）每个分组包含一台主 MySQL 和一台备 MySQL，分组内主备数据复制，分组间数据不同步。&lt;/p>
&lt;p>3）正常情况下，分组内的主服务器对外提供消息写入和消息读取服务，备服务器不对外提供服务；主服务器宕机的情况下，备服务器对外提供消息读取的服务。&lt;/p>
&lt;p>4）客户端采取轮询的策略写入和读取消息。&lt;/p>
&lt;h4 id="3-核心流程">3、核心流程&lt;/h4>
&lt;p>消息发送流程&lt;/p>
&lt;p>消息读取流程&lt;/p>
&lt;h4 id="4-详细设计">4、详细设计&lt;/h4>
&lt;p>&lt;strong>高可用设计&lt;/strong>&lt;/p>
&lt;p>1）消息发送可靠性&lt;/p>
&lt;p>业务服务器中嵌入消息队列系统提供的 SDK，SDK 支持轮询发送消息，当某个分组的主服务器无法发送消息时，SDK 挑选下一个分组主服务器重发消息，依次尝试所有主服务器直到发送成功；如果全部主服务器都无法发送，SDK 可以缓存消息，也可以直接丢弃消息，具体策略可以在启动 SDK 的时候通过配置指定。&lt;/p>
&lt;p>如果 SDK 缓存了一些消息未发送，此时恰好业务服务器又重启，则所有缓存的消息将永久丢失，这种情况 SDK 不做处理，业务方需要针对某些非常关键的消息自己实现永久存储的功能。&lt;/p>
&lt;p>2）消息存储可靠性&lt;/p>
&lt;p>消息存储在 MySQL 中，每个分组有一主一备两台 MySQL 服务器，MySQL 服务器之间复制消息以保证消息存储高可用。如果主备间出现复制延迟，恰好此时 MySQL 主服务器宕机导致数据无法恢复，则部分消息会永久丢失，这种情况不做针对性设计，DBA 需要对主备间的复制延迟进行监控，当复制延迟超过 30 秒的时候需要及时告警并进行处理。&lt;/p>
&lt;p>3）消息读取可靠性&lt;/p>
&lt;p>每个分组有一主一备两台服务器，主服务器支持发送和读取消息，备服务器只支持读取消息，当主服务器正常的时候备服务器不对外提供服务，只有备服务器判断主服务器故障的时候才对外提供消息读取服务。&lt;/p>
&lt;p>主备服务器的角色和分组信息通过配置指定，通过 ZooKeeper 进行状态判断和决策。主备服务器启动的时候分别连接到 ZooKeeper，在 /MQ/Server/[group]目录下建立 EPHEMERAL 节点，假设分组名称为 group1，则主服务器节点为 /MQ/Server/group1/master，备服务器的节点为 /MQ/Server/group1/slave。节点的超时时间可以配置，默认为 10 秒。&lt;/p>
&lt;p>&lt;strong>高性能设计&lt;/strong>&lt;/p>
&lt;p>[此处省略具体设计]&lt;/p>
&lt;p>&lt;strong>可扩展设计&lt;/strong>&lt;/p>
&lt;p>[此处省略具体设计。如果方案不涉及，可以简单写上“无”，表示设计者有考虑但不需要设计；否则如果完全不写的话，方案评审的时候可能会被认为是遗漏了设计点]&lt;/p>
&lt;p>&lt;strong>安全设计&lt;/strong>&lt;/p>
&lt;p>消息队列系统需要提供权限控制功能，权限控制包括两部分：身份识别和队列权限控制。&lt;/p>
&lt;p>1）身份识别&lt;/p>
&lt;p>消息队列系统给业务子系统分配身份标识和接入 key，SDK 首先需要建立连接并进行身份校验，消息队列服务器会中断校验不通过的连接。因此，任何业务子系统如果想接入消息队列系统，都必须首先申请身份标识和接入 key，通过这种方式来防止恶意系统任意接入。&lt;/p>
&lt;p>2）队列权限&lt;/p>
&lt;p>某些队列信息可能比较敏感，只允许部分子系统发送或者读取，消息队列系统将队列权限保存在配置文件中，当收到发送或者读取消息的请求时，首先需要根据业务子系统的身份标识以及配置的权限信息来判断业务子系统是否有权限，如果没有权限则拒绝服务。&lt;/p>
&lt;p>&lt;strong>其他设计&lt;/strong>&lt;/p>
&lt;p>[其他设计包括上述以外的其他设计考虑点，例如指定开发语言、符合公司的某些标准等，如果篇幅较长，也可以独立进行描述]&lt;/p>
&lt;p>1）消息队列系统需要接入公司已有的运维平台，通过运维平台发布和部署。&lt;/p>
&lt;p>2）消息队列系统需要输出日志给公司已有的监控平台，通过监控平台监控消息队列系统的健康状态，包括发送消息的数量、发送消息的大小、积压消息的数量等，详细监控指标在后续设计方案中列出。&lt;/p>
&lt;p>&lt;strong>部署方案&lt;/strong>&lt;/p>
&lt;p>[部署方案主要包括硬件要求、服务器部署方式、组网方式等]&lt;/p>
&lt;p>消息队列系统的服务器和数据库服务器采取混布的方式部署，即：一台服务器上，部署同一分组的主服务器和主 MySQL，或者备服务器和备 MySQL。因为消息队列服务器主要是 CPU 密集型，而 MySQL 是磁盘密集型的，所以两者混布互相影响的几率不大。&lt;/p>
&lt;p>硬件的基本要求：32 核 48G 内存 512G SSD 硬盘，考虑到消息队列系统动态扩容的需求不高，且对性能要求较高，因此需要使用物理服务器，不采用虚拟机。&lt;/p>
&lt;h4 id="5-架构演进规划">5、架构演进规划&lt;/h4>
&lt;p>[通常情况下，规划和设计的需求比较完善，但如果一次性全部做完，项目周期可能会很长，因此可以采取分阶段实施，即：第一期做什么、第二期做什么，以此类推]整个消息队列系统分三期实现：&lt;/p>
&lt;p>第一期：实现消息发送、权限控制功能，预计时间 3 个月。&lt;/p>
&lt;p>第二期：实现消息读取功能，预计时间 1 个月。&lt;/p>
&lt;p>第三期：实现主备基于 ZooKeeper 切换的功能，预计时间 2 周。&lt;/p></description></item><item><title>Docs: 架构设计06-实践</title><link>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A106-%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/71.%E9%80%9A%E7%94%A8/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A106-%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;h2 id="系统架构图">系统架构图&lt;/h2>
&lt;p>很多同学技术能力很强，架构设计也做得很好，但是在给别人讲解的时候，总感觉像是“茶壶里煮饺子，有货倒不出”。其实，在为新员工培训系统架构、给领导汇报技术规划、上技术大会做演讲或者向晋升评委介绍工作贡献的时候，如果能画出一张优秀的软件系统架构图，就可以大大提升自己的讲解效果，让对方轻松地理解你想表达的关键点。&lt;/p>
&lt;h3 id="4-1-视图">4+1 视图&lt;/h3>
&lt;p>1995 年，Philippe Kruchten 在 &lt;a href="https://www.researchgate.net/publication/220018231_The_41_View_Model_of_Architecture">论文&lt;/a> 中指出了过去用单一视图描述软件系统架构的问题，并提出了 4+1 视图作为解决方案。&lt;/p>
&lt;p>有时，软件架构的问题来源于系统设计者过早地划分软件或者过分地强调软件开发的某一个方面，比如数据工程、运行时效率、开发策略或团队组织。此外，软件架构往往不能解决它的所有“用户”的问题。……作为补救措施，我们建议使用几个并发视图来组织对软件架构的描述，其中每个视图分别解决一组特定的问题。&lt;/p>
&lt;p>不同视图之间的关系如下图所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_1.png" alt="architecture-06_1.png">&lt;/p>
&lt;p>4+1 视图的核心理念是从不同的角度去剖析系统，看看系统的结构是什么样的，具体每个视图的含义是：&lt;/p>
&lt;p>1）&lt;strong>逻辑视图&lt;/strong>：从终端用户角度看系统提供给用户的功能，对应 UML 的 class 和 state diagrams。&lt;/p>
&lt;p>2）&lt;strong>处理视图&lt;/strong>：从动态的角度看系统的处理过程，对应 UML 的 sequence 和 activity diagrams。&lt;/p>
&lt;p>3）&lt;strong>开发视图&lt;/strong>：从程序员角度看系统的逻辑组成，对应 UML 的 package diagrams。&lt;/p>
&lt;p>4）&lt;strong>物理视图&lt;/strong>：从系统工程师角度看系统的物理组成，对应 UML 的 deployment diagrams。&lt;/p>
&lt;p>5）&lt;strong>场景视图&lt;/strong>：从用户角度看系统需要实现的需求，对应 UML 的 use case diagrams。&lt;/p>
&lt;p>（备注：逻辑视图看到的“功能”和场景视图看到的“需求”不是一回事。一个需求可能涉及多个功能，例如“取款”这个场景涉及“插卡”“密码验证”“出钞”等功能；而多个需求可能涉及同一个功能，例如“取款”和“转账”是两个不同的需求，但是都涉及“密码验证”这个功能。）&lt;/p>
&lt;p>可以看到，4+1 视图本身很全面也很规范，但是为什么在实际工作中，真正按照这个标准来画架构图的公司和团队并不多。&lt;/p>
&lt;p>原因主要有三点：&lt;/p>
&lt;p>1）架构复杂度增加：1995 年的时候，系统大部分还是单体系统，而现在分布式系统越来越多。如果我们用 4+1 视图来表示分布式系统的话，就会遇到困难，比如微服务架构下有那么多的微服务，Development view 就不好表示。&lt;/p>
&lt;p>2）绑定 UML 图：UML 图画架构图存在问题，主要问题是不美观，表达能力弱。&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_2.png" alt="architecture-06_2.png">&lt;/p>
&lt;p>（备注：左图是用 UML 工具画的，右图是用 Visio 画的，对比之下，UML 图的缺点十分明显。）&lt;/p>
&lt;p>3）&lt;strong>理解困难&lt;/strong>：逻辑视图、开发视图和处理视图比较容易混淆。比如说，有人把逻辑视图理解为软件开发的类结构图，也有人把处理视图和开发视图等同，还有人认为逻辑视图就是开发视图。&lt;/p>
&lt;p>这些原因导致 4+1 视图在目前的实际工作中并不是很实用。下面介绍怎么画软件系统架构图。&lt;/p>
&lt;h3 id="核心指导思想-4r-架构定义">核心指导思想：4R 架构定义&lt;/h3>
&lt;p>其实，很多人之所以画不好架构图，最大的痛点就是不好把握到底要画哪些内容，画得太少担心没有展现关键信息，画得太多又觉得把握不住重点。所以现在的问题变成了：应该按照什么样的标准来明确架构图要展现的内容呢？&lt;/p>
&lt;p>前面提到的 4R 架构定义：软件架构指软件系统的顶层（Rank）结构，它定义了系统由哪些角色（Role）组成，角色之间的关系（Relation）和运作规则（Rule）。&lt;/p>
&lt;p>4R 是指 4 个关键词：Rank，Role，Relation 和 Rule。既然可以通过 4R 来定义软件系统的架构，那么按照 4R 架构定义的思路来画架构图也是很合情合理的，具体步骤如下：&lt;/p>
&lt;p>1）明确 Rank：也就是说，不要事无巨细地把一个大系统的方方面面都在一张架构图中展现出来，而应该明确你要阐述的系统所属的级别（L0～L4），然后只描述这个级别的架构信息。&lt;/p>
&lt;p>2）画出 Role：从不同的角度来分解系统，看看系统包含哪些角色，角色对应架构图中的区块、图标和节点等。&lt;/p>
&lt;p>3）画出 Relation：有了角色后，画出角色之间的关系，对应架构图中角色之间的连接线，不同的连接线可以代表不同的关系。&lt;/p>
&lt;p>4）最后画出 Rule：挑选核心场景，画出系统角色之间如何协作来完成某项具体的业务功能，对应系统序列图。&lt;/p>
&lt;p>描述 Role 和 Relation 的架构图称为静态架构图，描述 Rule 的系统序列图称为动态架构图。&lt;/p>
&lt;p>从某一个角度去看，静态架构图的数量跟系统复杂度有关，一般是 1～2 张，如果比较简单，用一张图就够了，如果比较复杂，就要分别用两张图来展现；而动态架构图是一般是多张，因为核心场景数量不止一个，对应的系统序列图有多张。&lt;/p>
&lt;h3 id="常见架构图">常见架构图&lt;/h3>
&lt;p>从不同的角度去剖析系统，就会得到不同的视图。其实按照 4R 架构定义来画架构图也是这样，用不同的方式去划分系统，就会得到不同类型的架构，分别对应不同类型的架构图。常见的类型整理如下：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_3.png" alt="architecture-06_3.png">&lt;/p>
&lt;p>接下来讲解每一类架构图的特点。&lt;/p>
&lt;h4 id="业务架构图">业务架构图&lt;/h4>
&lt;p>【定义】描述系统对用户提供了什么业务功能，类似于 4+1 视图的场景视图。&lt;/p>
&lt;p>【使用场景】产品人员规划业务：比如说我们经常在产品规划和汇报会议上看到产品人员会用业务架构图来展现业务全局状态。给高 P 汇报业务：对于 P7+ 以上级别的技术人员，在汇报的时候不能光讲技术，也要讲业务的发展情况，用业务架构图就比较容易的展现业务整体情况。给新员工培训业务。&lt;/p>
&lt;p>【画图技巧】&lt;/p>
&lt;p>1）通过不同颜色来标识业务状态：比如说哪些业务发展状态好，哪些问题比较多，哪些比较稳定，哪些竞争比较激烈等。&lt;/p>
&lt;p>2）业务分组管理：将类似的业务放在一个分组里面展现，用虚线框或者相同背景将其标识出来。&lt;/p>
&lt;p>3）区块对齐：为了美观，可以改变不同区块的长短大小进行对齐，让整体看起来更美观。&lt;/p>
&lt;p>【参考案例】AlipayHK 的一个业务架构图如下所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_4.png" alt="architecture-06_4.png">&lt;/p>
&lt;p>这张业务架构图有三点关键信息：&lt;/p>
&lt;p>1）“MTR”区块是浅红色的，“人传人”区块是绿色的，浅红色代表正在进行的，绿色代表明年规划的。&lt;/p>
&lt;p>2）分了 4 组：钱包业务、第三方业务、商家服务和用户管理。&lt;/p>
&lt;p>3）“转账”和“社交红包”等区块比较长，只是为了对齐后更美观，不代表业务本身的量级或者重要程度，如果要表示这样的信息，那么可以用颜色来表示。&lt;/p>
&lt;p>注意，千万不要画得五颜六色，一般一张图的颜色数量控制在 3 种以内是比较好的。所以在画图的时候你要想清楚，到底哪些信息是要放在业务架构图中重点展示的关键信息，哪些信息顺带讲一下就可以了。&lt;/p>
&lt;h4 id="客户端和前端架构图">客户端和前端架构图&lt;/h4>
&lt;p>【定义】描述客户端和前端的领域逻辑架构，关注的是从逻辑的角度如何分解客户端或者前端应用。&lt;/p>
&lt;p>【使用场景】&lt;/p>
&lt;p>1）整体架构设计：由客户端或者前端架构师完成本领域的架构设计。&lt;/p>
&lt;p>2）架构培训。&lt;/p>
&lt;p>【画图技巧】&lt;/p>
&lt;p>1）通过不同颜色来标识不同角色。&lt;/p>
&lt;p>2）通过连接线来表示关系，如果有多种关系，例如有的是直接调用，有的是事件通知，那么可以用不同形状的线条来表示。&lt;/p>
&lt;p>3）分层或分组：将类似的角色分层或者分组管理。&lt;/p>
&lt;p>【参考案例】微信客户端架构 3.x 的架构图如下所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_5.png" alt="architecture-06_5.png">&lt;/p>
&lt;p>这张客户端架构图有三点关键信息：&lt;/p>
&lt;p>1）图中用了灰色（app:UI 等）、蓝色（Net Scene 等）、深灰色（Storage）、浅蓝色（Network）来表示不同类型的模块。&lt;/p>
&lt;p>2）图中有两类连接线：双向的（WebViewUI 和 app:UI），单向的（app:UI 和 Net Scene 等）。&lt;/p>
&lt;p>3）整体上分为 4 组，对应图中背景色不同的四个大的区块。&lt;/p>
&lt;h4 id="系统架构图-1">系统架构图&lt;/h4>
&lt;p>【定义】描述后端的逻辑架构，又叫“后端架构”或“技术架构”，不管是业务系统、中间件系统，还是基础的操作系统、数据库系统等，系统架构都是软件系统架构的核心。&lt;/p>
&lt;p>【使用场景】整体架构设计。架构培训。&lt;/p>
&lt;p>【画图技巧】通过不同颜色来标识不同角色。通过连接线来表示关系。逻辑分组。&lt;/p>
&lt;p>【参考案例】如果系统比较简单，可以参考 MongoDB Sharding 的系统架构图，如下所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_6.png" alt="architecture-06_6.png">&lt;/p>
&lt;p>如果系统相对复杂，建议首先用一张图来展示系统架构里面的角色（Role）以及每个角色的核心功能；然后再用一张图来展示角色之间的关系（Relation），可以参考一个支付中台的系统架构图，如下所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_7.png" alt="architecture-06_7.png">&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_8.png" alt="architecture-06_8.png">&lt;/p>
&lt;p>（备注：完整的支付中台关系图太大了，这张关系图只是摘取其中一部分作为示意图，供你参考。）&lt;/p>
&lt;h4 id="应用架构图">应用架构图&lt;/h4>
&lt;p>【定义】描述后端系统由哪些应用组成，一个应用就是一个可部署发布运行的程序，它是项目开发过程中，开发测试运维团队协作的基础。&lt;/p>
&lt;p>【使用场景】项目开发、测试。运维部署发布。子域架构设计。&lt;/p>
&lt;p>【画图技巧】通过不同颜色来标识不同角色。通过连接线来表示关系。复杂系统分域来画。&lt;/p>
&lt;p>【参考案例】如果系统比较简单，那么基本上应用架构和系统架构是等价的，可以参考 MongoDB Sharding 的应用架构图，如下所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_9.png" alt="architecture-06_9.png">&lt;/p>
&lt;p>可以看到，这张图中的 Router（mongos）、Config Servers 和 Shard（replica set），既包含了系统架构的角色信息（Router、Config Servers 和 Shard），又包含了应用信息（mongos、Config Servers 和 Shard）。&lt;/p>
&lt;p>如果系统比较复杂，按照架构分层的角度来看，应用架构已经到了可执行程序这一层，例如支付中台这一类的系统，包含的应用可能有几百上千个，如果把整个支付中台所有的应用都在一张图里面展示出来，信息太多太密，可能会导致架构图都看不清。&lt;/p>
&lt;p>这种情况下，应用架构一般都是按照子域来画应用架构图，可以参考支付中台的会员域的应用架构图，如下所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_10.png" alt="architecture-06_10.png">&lt;/p>
&lt;h4 id="部署架构图">部署架构图&lt;/h4>
&lt;p>【定义】描述后端系统具体是如何部署的，主要包含机房信息、网络信息和硬件信息等。&lt;/p>
&lt;p>【使用场景】总体架构设计。运维规划和优化。&lt;/p>
&lt;p>【画图技巧】用图标代替区块，这样看起来更加美观和容易理解。&lt;/p>
&lt;p>【参考案例】一个简单的支付系统的部署架构图如下所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_11.png" alt="architecture-06_11.png">&lt;/p>
&lt;h4 id="系统序列图">系统序列图&lt;/h4>
&lt;p>【定义】描述某个业务场景下，系统各个角色如何配合起来完成业务功能。&lt;/p>
&lt;p>【使用场景】结合“系统架构、应用架构和部署架构”来使用。&lt;/p>
&lt;p>【画图技巧】使用 UML 的序列图来画。&lt;/p>
&lt;p>【参考案例】“扫码支付”这个支付核心场景的系统序列图如下所示：&lt;/p>
&lt;p>&lt;img src="../imgs/architecture-06_12.png" alt="architecture-06_12.png">&lt;/p>
&lt;p>（备注：这张序列图的角色对应前面“系统架构”这一小节的支付中台系统的关系图。）&lt;/p>
&lt;h3 id="补充说明">补充说明&lt;/h3>
&lt;p>如果你曾经研究过架构图的标准，那么除了 4+1 视图以外，你可能还看到过 TOGAF 的“业务架构（跟这一讲的业务架构名字相同，但是意义不同）、数据架构（不是指大数据平台架构，而是指数据资产的架构）、应用架构和技术架构”这种说法，或者还看到过 C4 架构模型（Context、Container、Component 和 Code）等等。&lt;/p>
&lt;p>但其实目前业界并没有就架构图标准达成共识，刚才提到的 TOGAF 是企业级的架构，基本上要到 CTO 这个级别才能接触的，而 C4 模型的表达能力又不够。这里并没有直接套用这些内容，而是根据个人经验，将认为最有效果的架构图整理出来。这些架构图，都是在不同类型不同规模不同业务的公司（华为、UC、阿里和蚂蚁等）里面验证过的，可以放心地使用。&lt;/p></description></item></channel></rss>