<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Herbdocs – bytecode</title><link>/tags/bytecode/</link><description>Recent content in bytecode on Herbdocs</description><generator>Hugo -- gohugo.io</generator><atom:link href="/tags/bytecode/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 字节码增强技术-概念</title><link>/docs/45.APM/%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF-%E6%A6%82%E5%BF%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/45.APM/%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF-%E6%A6%82%E5%BF%B5/</guid><description>
&lt;h1 id="asm">ASM&lt;/h1>
&lt;p>Cglib就是基于ASM&lt;/p>
&lt;p>IDEA插件 ASM Bytecode Outline：&lt;a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline/">https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline/&lt;/a>&lt;/p>
&lt;p>ASM和Javassist对比及应用&lt;/p>
&lt;ul>
&lt;li>javassist是基于源码级别的API比基于字节码的ASM简单;&lt;/li>
&lt;li>基于javassist开发,不需要了解字节码的知识,而且其封装的一些工具类可以简单实现一些高级功能, 比如HotSwaper&lt;/li>
&lt;li>ASM比javassist性能更快, 灵活性也较高&lt;/li>
&lt;li>javassist提供的动态代理接口最慢, 比JDK自带的还慢&lt;/li>
&lt;li>监控方法, 采集方法运行时的入参, 出参和异常信息.&lt;/li>
&lt;/ul>
&lt;h1 id="javaassist">JavaAssist&lt;/h1>
&lt;p>ASM虽然可以达到修改字节码的效果，但是代码实现上更偏底层，是一个个虚拟机指令的组合，不好理解、记忆，和Java语言的编程习惯有较大差距。&lt;/p>
&lt;p>利用Javassist实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。&lt;/p>
&lt;ul>
&lt;li>ClassPool：保存CtClass的池子，通过classPool.get(类全路径名)来获取CtClass&lt;/li>
&lt;li>CtClass：编译时类信息，它是一个class文件在代码中的抽象表现形式&lt;/li>
&lt;li>CtMethod：对应类中的方法&lt;/li>
&lt;li>CtField：对应类中的属性、变量&lt;/li>
&lt;/ul>
&lt;p>上面ASM和JavaAssist的Demo，都有一个共同点：&lt;strong>两者例子中的目标类都没有被提前加载到JVM中&lt;/strong>，如果只能在类加载前对类中字节码进行修改，那将失去其存在意义，毕竟大部分运行的Java系统，都是在运行状态的线上系统。&lt;/p>
&lt;p>&lt;strong>JVM是不允许在运行时动态重载一个类的&lt;/strong>&lt;/p>
&lt;h1 id="instrumentation">Instrumentation&lt;/h1>
&lt;p>instrument是JVM提供的一个可以修改已加载类的类库。它需要依赖JVMTI的Attach API机制实现，在JDK 1.6之后，instrument支持了在运行时对类定义的修改。要使用instrument的类修改功能，我们需要实现它提供的ClassFileTransformer接口，定义一个类文件转换器。接口中的transform()方法会在类文件被加载时调用&lt;/p>
&lt;p>先看下其关键方法&lt;/p>
&lt;style>
.td-content .highlight {
margin-top: 0.5rem;
margin-bottom: 0.5rem;
}
.code-collapse1 {
overflow-y: auto;
max-height: 500px;
overflow-x: auto;
max-width: 100%;
}
&lt;/style>
&lt;div class="code-collapse1">
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a90d91">public&lt;/span> &lt;span style="color:#a90d91">interface&lt;/span> &lt;span style="color:#3f6e75">Instrumentation&lt;/span> &lt;span style="color:#000">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500">//添加一个类文件转换器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">addTransformer&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">ClassFileTransformer&lt;/span> &lt;span style="color:#000">transformer&lt;/span>&lt;span style="color:#000">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#177500">//重新加载一个类，加载时触发ClassFileTransformer接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#177500">&lt;/span> &lt;span style="color:#a90d91">void&lt;/span> &lt;span style="color:#000">retransformClasses&lt;/span>&lt;span style="color:#000">(&lt;/span>&lt;span style="color:#000">Class&lt;/span>&lt;span style="color:#000">&amp;lt;?&amp;gt;...&lt;/span> &lt;span style="color:#000">classes&lt;/span>&lt;span style="color:#000">)&lt;/span> &lt;span style="color:#a90d91">throws&lt;/span> &lt;span style="color:#000">UnmodifiableClassException&lt;/span>&lt;span style="color:#000">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;h1 id="agent">Agent&lt;/h1>
&lt;p>光有Instrumentation接口还不够，如何将其注入到一个正在运行JVM的进程中去呢？我们还需要自定义一个Agent，借助Agent的能力将Instrumentation注入到运行的JVM中。&lt;/p>
&lt;p>Agent是JVMTI的一种实现，Agent有两种启动方式&lt;/p>
&lt;ul>
&lt;li>一是随Java进程启动而启动，经常见到的java -agentlib就是这种方式；&lt;/li>
&lt;li>二是运行时载入，通过attach API，将模块（jar包）动态地Attach到指定进程id的Java进程内&lt;/li>
&lt;/ul>
&lt;h3 id="premainclass随jvm进程启动">PremainClass随JVM进程启动&lt;/h3>
&lt;p>-javaagent方式&lt;/p>
&lt;p>以Agent+JavaAssist的方式实现了零侵入方式的AOP，其原理就是JVM会优先调用PreMain方法(即Agent中的方法)，后面才会调用Main方法。&lt;/p>
&lt;p>但是缺点也是显而易见的，Agent必须随着JVM进程启动而加载的方式，不够灵活&lt;/p>
&lt;h3 id="agentclass以attach方法注入agent">AgentClass以Attach方法注入Agent&lt;/h3>
&lt;p>随着进程启动的Premain方式的Agent更偏向是一种初始化加载时的修改方式，而Attach API的loadAgent()方法，能够将打包好的Agent jar包动态Attach到目标JVM上，是一种运行时注入Agent、修改字节码的方式&lt;/p>
&lt;p>市面上诸如Arthas、Btrace这种JVM监控工具即是基于这种思路实现&lt;/p>
&lt;h1 id="bytebuddy">ByteBuddy&lt;/h1>
&lt;p>ByteBuddy是一个可以在运行时动态生成java class的类库。&lt;/p>
&lt;ul>
&lt;li>基于ASM的代码修改和生成工具&lt;/li>
&lt;li>runtime期动态生成和修改&lt;/li>
&lt;li>easy use无需理解字节码，简洁的代码风格&lt;/li>
&lt;/ul>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">美团技术-字节码增强技术探索&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/hosaos/article/details/102931887">Java字节码技术(二)字节码增强之ASM、JavaAssist、Agent、Instrumentation&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/151843984">ByteBuddy入门教程&lt;/a>&lt;/p></description></item></channel></rss>